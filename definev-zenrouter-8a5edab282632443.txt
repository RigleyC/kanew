Directory structure:
└── definev-zenrouter/
    ├── README.md
    ├── LICENSE
    ├── pubspec.yaml
    ├── packages/
    │   ├── zenrouter/
    │   │   ├── README.md
    │   │   ├── analysis_options.yaml
    │   │   ├── CHANGELOG.md
    │   │   ├── LICENSE
    │   │   ├── MIGRATION_GUIDE.md
    │   │   ├── pubspec.yaml
    │   │   ├── .metadata
    │   │   ├── .pubignore
    │   │   ├── doc/
    │   │   │   ├── DOCUMENTATION_ROADMAP.md
    │   │   │   ├── api/
    │   │   │   │   ├── coordinator.md
    │   │   │   │   ├── mixins.md
    │   │   │   │   └── navigation-paths.md
    │   │   │   ├── guides/
    │   │   │   │   ├── coordinator-as-module.md
    │   │   │   │   ├── coordinator-modular.md
    │   │   │   │   ├── getting-started.md
    │   │   │   │   ├── navigator-observers.md
    │   │   │   │   ├── query-parameters.md
    │   │   │   │   ├── route-layout.md
    │   │   │   │   └── state-restoration.md
    │   │   │   ├── migration/
    │   │   │   │   ├── README.md
    │   │   │   │   ├── from-auto-route.md
    │   │   │   │   ├── from-go-router.md
    │   │   │   │   └── from-navigator.md
    │   │   │   ├── paradigms/
    │   │   │   │   ├── declarative.md
    │   │   │   │   ├── imperative.md
    │   │   │   │   └── coordinator/
    │   │   │   │       ├── coordinator-vi.md
    │   │   │   │       ├── coordinator.md
    │   │   │   │       └── example/
    │   │   │   │           ├── analysis_options.yaml
    │   │   │   │           ├── pubspec.yaml
    │   │   │   │           ├── .metadata
    │   │   │   │           ├── android/
    │   │   │   │           │   ├── build.gradle.kts
    │   │   │   │           │   ├── gradle.properties
    │   │   │   │           │   ├── settings.gradle.kts
    │   │   │   │           │   ├── app/
    │   │   │   │           │   │   ├── build.gradle.kts
    │   │   │   │           │   │   └── src/
    │   │   │   │           │   │       ├── debug/
    │   │   │   │           │   │       │   └── AndroidManifest.xml
    │   │   │   │           │   │       ├── main/
    │   │   │   │           │   │       │   ├── AndroidManifest.xml
    │   │   │   │           │   │       │   ├── kotlin/
    │   │   │   │           │   │       │   │   └── com/
    │   │   │   │           │   │       │   │       └── example/
    │   │   │   │           │   │       │   │           └── coordinator_example/
    │   │   │   │           │   │       │   │               └── MainActivity.kt
    │   │   │   │           │   │       │   └── res/
    │   │   │   │           │   │       │       ├── drawable/
    │   │   │   │           │   │       │       │   └── launch_background.xml
    │   │   │   │           │   │       │       ├── drawable-v21/
    │   │   │   │           │   │       │       │   └── launch_background.xml
    │   │   │   │           │   │       │       ├── values/
    │   │   │   │           │   │       │       │   └── styles.xml
    │   │   │   │           │   │       │       └── values-night/
    │   │   │   │           │   │       │           └── styles.xml
    │   │   │   │           │   │       └── profile/
    │   │   │   │           │   │           └── AndroidManifest.xml
    │   │   │   │           │   └── gradle/
    │   │   │   │           │       └── wrapper/
    │   │   │   │           │           └── gradle-wrapper.properties
    │   │   │   │           ├── ios/
    │   │   │   │           │   ├── Flutter/
    │   │   │   │           │   │   ├── AppFrameworkInfo.plist
    │   │   │   │           │   │   ├── Debug.xcconfig
    │   │   │   │           │   │   └── Release.xcconfig
    │   │   │   │           │   ├── Runner/
    │   │   │   │           │   │   ├── AppDelegate.swift
    │   │   │   │           │   │   ├── Info.plist
    │   │   │   │           │   │   ├── Runner-Bridging-Header.h
    │   │   │   │           │   │   ├── Assets.xcassets/
    │   │   │   │           │   │   │   ├── AppIcon.appiconset/
    │   │   │   │           │   │   │   │   └── Contents.json
    │   │   │   │           │   │   │   └── LaunchImage.imageset/
    │   │   │   │           │   │   │       ├── README.md
    │   │   │   │           │   │   │       └── Contents.json
    │   │   │   │           │   │   └── Base.lproj/
    │   │   │   │           │   │       ├── LaunchScreen.storyboard
    │   │   │   │           │   │       └── Main.storyboard
    │   │   │   │           │   └── RunnerTests/
    │   │   │   │           │       └── RunnerTests.swift
    │   │   │   │           ├── lib/
    │   │   │   │           │   ├── main.dart
    │   │   │   │           │   └── routes/
    │   │   │   │           │       ├── app_route.dart
    │   │   │   │           │       └── coordinator.dart
    │   │   │   │           ├── linux/
    │   │   │   │           │   ├── CMakeLists.txt
    │   │   │   │           │   ├── flutter/
    │   │   │   │           │   │   ├── CMakeLists.txt
    │   │   │   │           │   │   ├── generated_plugin_registrant.cc
    │   │   │   │           │   │   ├── generated_plugin_registrant.h
    │   │   │   │           │   │   └── generated_plugins.cmake
    │   │   │   │           │   └── runner/
    │   │   │   │           │       ├── CMakeLists.txt
    │   │   │   │           │       ├── main.cc
    │   │   │   │           │       ├── my_application.cc
    │   │   │   │           │       └── my_application.h
    │   │   │   │           ├── macos/
    │   │   │   │           │   ├── Flutter/
    │   │   │   │           │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │           │   │   ├── Flutter-Release.xcconfig
    │   │   │   │           │   │   └── GeneratedPluginRegistrant.swift
    │   │   │   │           │   ├── Runner/
    │   │   │   │           │   │   ├── AppDelegate.swift
    │   │   │   │           │   │   ├── DebugProfile.entitlements
    │   │   │   │           │   │   ├── Info.plist
    │   │   │   │           │   │   ├── MainFlutterWindow.swift
    │   │   │   │           │   │   ├── Release.entitlements
    │   │   │   │           │   │   ├── Assets.xcassets/
    │   │   │   │           │   │   │   └── AppIcon.appiconset/
    │   │   │   │           │   │   │       └── Contents.json
    │   │   │   │           │   │   ├── Base.lproj/
    │   │   │   │           │   │   │   └── MainMenu.xib
    │   │   │   │           │   │   └── Configs/
    │   │   │   │           │   │       ├── AppInfo.xcconfig
    │   │   │   │           │   │       ├── Debug.xcconfig
    │   │   │   │           │   │       ├── Release.xcconfig
    │   │   │   │           │   │       └── Warnings.xcconfig
    │   │   │   │           │   └── RunnerTests/
    │   │   │   │           │       └── RunnerTests.swift
    │   │   │   │           ├── web/
    │   │   │   │           │   ├── index.html
    │   │   │   │           │   └── manifest.json
    │   │   │   │           └── windows/
    │   │   │   │               ├── CMakeLists.txt
    │   │   │   │               ├── flutter/
    │   │   │   │               │   ├── CMakeLists.txt
    │   │   │   │               │   ├── generated_plugin_registrant.cc
    │   │   │   │               │   ├── generated_plugin_registrant.h
    │   │   │   │               │   └── generated_plugins.cmake
    │   │   │   │               └── runner/
    │   │   │   │                   ├── CMakeLists.txt
    │   │   │   │                   ├── flutter_window.cpp
    │   │   │   │                   ├── flutter_window.h
    │   │   │   │                   ├── main.cpp
    │   │   │   │                   ├── resource.h
    │   │   │   │                   ├── runner.exe.manifest
    │   │   │   │                   ├── Runner.rc
    │   │   │   │                   ├── utils.cpp
    │   │   │   │                   ├── utils.h
    │   │   │   │                   ├── win32_window.cpp
    │   │   │   │                   └── win32_window.h
    │   │   │   └── recipes/
    │   │   │       ├── README.md
    │   │   │       ├── 404-handling.md
    │   │   │       ├── authentication-flow.md
    │   │   │       ├── bottom-navigation.md
    │   │   │       ├── route-transitions.md
    │   │   │       ├── route-versioning.md
    │   │   │       ├── state-management.md
    │   │   │       └── url-strategies.md
    │   │   ├── example/
    │   │   │   ├── analysis_options.yaml
    │   │   │   ├── pubspec.yaml
    │   │   │   ├── .metadata
    │   │   │   ├── android/
    │   │   │   │   ├── build.gradle.kts
    │   │   │   │   ├── gradle.properties
    │   │   │   │   ├── settings.gradle.kts
    │   │   │   │   ├── app/
    │   │   │   │   │   ├── build.gradle.kts
    │   │   │   │   │   └── src/
    │   │   │   │   │       ├── debug/
    │   │   │   │   │       │   └── AndroidManifest.xml
    │   │   │   │   │       ├── main/
    │   │   │   │   │       │   ├── AndroidManifest.xml
    │   │   │   │   │       │   ├── kotlin/
    │   │   │   │   │       │   │   └── dev/
    │   │   │   │   │       │   │       └── zennn/
    │   │   │   │   │       │   │           └── router/
    │   │   │   │   │       │   │               └── example/
    │   │   │   │   │       │   │                   └── example/
    │   │   │   │   │       │   │                       └── MainActivity.kt
    │   │   │   │   │       │   └── res/
    │   │   │   │   │       │       ├── drawable/
    │   │   │   │   │       │       │   └── launch_background.xml
    │   │   │   │   │       │       ├── drawable-v21/
    │   │   │   │   │       │       │   └── launch_background.xml
    │   │   │   │   │       │       ├── values/
    │   │   │   │   │       │       │   └── styles.xml
    │   │   │   │   │       │       └── values-night/
    │   │   │   │   │       │           └── styles.xml
    │   │   │   │   │       └── profile/
    │   │   │   │   │           └── AndroidManifest.xml
    │   │   │   │   └── gradle/
    │   │   │   │       └── wrapper/
    │   │   │   │           └── gradle-wrapper.properties
    │   │   │   ├── ios/
    │   │   │   │   ├── Flutter/
    │   │   │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   │   │   ├── Debug.xcconfig
    │   │   │   │   │   └── Release.xcconfig
    │   │   │   │   ├── Runner/
    │   │   │   │   │   ├── AppDelegate.swift
    │   │   │   │   │   ├── Info.plist
    │   │   │   │   │   ├── Runner-Bridging-Header.h
    │   │   │   │   │   ├── Assets.xcassets/
    │   │   │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   │   │   │   └── Contents.json
    │   │   │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │   │   │       ├── README.md
    │   │   │   │   │   │       └── Contents.json
    │   │   │   │   │   └── Base.lproj/
    │   │   │   │   │       ├── LaunchScreen.storyboard
    │   │   │   │   │       └── Main.storyboard
    │   │   │   │   └── RunnerTests/
    │   │   │   │       └── RunnerTests.swift
    │   │   │   ├── lib/
    │   │   │   │   ├── main.dart
    │   │   │   │   ├── main_coordinator.dart
    │   │   │   │   ├── main_coordinator_module.dart
    │   │   │   │   ├── main_declrative.dart
    │   │   │   │   ├── main_imperative.dart
    │   │   │   │   ├── main_modular.dart
    │   │   │   │   ├── main_observer.dart
    │   │   │   │   ├── main_restoration.dart
    │   │   │   │   └── file_based_routing/
    │   │   │   │       └── README.md
    │   │   │   ├── linux/
    │   │   │   │   ├── CMakeLists.txt
    │   │   │   │   ├── flutter/
    │   │   │   │   │   ├── CMakeLists.txt
    │   │   │   │   │   ├── generated_plugin_registrant.cc
    │   │   │   │   │   ├── generated_plugin_registrant.h
    │   │   │   │   │   └── generated_plugins.cmake
    │   │   │   │   └── runner/
    │   │   │   │       ├── CMakeLists.txt
    │   │   │   │       ├── main.cc
    │   │   │   │       ├── my_application.cc
    │   │   │   │       └── my_application.h
    │   │   │   ├── macos/
    │   │   │   │   ├── Flutter/
    │   │   │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │   │   ├── Flutter-Release.xcconfig
    │   │   │   │   │   └── GeneratedPluginRegistrant.swift
    │   │   │   │   ├── Runner/
    │   │   │   │   │   ├── AppDelegate.swift
    │   │   │   │   │   ├── DebugProfile.entitlements
    │   │   │   │   │   ├── Info.plist
    │   │   │   │   │   ├── MainFlutterWindow.swift
    │   │   │   │   │   ├── Release.entitlements
    │   │   │   │   │   ├── Assets.xcassets/
    │   │   │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │   │   │       └── Contents.json
    │   │   │   │   │   ├── Base.lproj/
    │   │   │   │   │   │   └── MainMenu.xib
    │   │   │   │   │   └── Configs/
    │   │   │   │   │       ├── AppInfo.xcconfig
    │   │   │   │   │       ├── Debug.xcconfig
    │   │   │   │   │       ├── Release.xcconfig
    │   │   │   │   │       └── Warnings.xcconfig
    │   │   │   │   └── RunnerTests/
    │   │   │   │       └── RunnerTests.swift
    │   │   │   ├── web/
    │   │   │   │   ├── index.html
    │   │   │   │   └── manifest.json
    │   │   │   └── windows/
    │   │   │       ├── CMakeLists.txt
    │   │   │       ├── flutter/
    │   │   │       │   ├── CMakeLists.txt
    │   │   │       │   ├── generated_plugin_registrant.cc
    │   │   │       │   ├── generated_plugin_registrant.h
    │   │   │       │   └── generated_plugins.cmake
    │   │   │       └── runner/
    │   │   │           ├── CMakeLists.txt
    │   │   │           ├── flutter_window.cpp
    │   │   │           ├── flutter_window.h
    │   │   │           ├── main.cpp
    │   │   │           ├── resource.h
    │   │   │           ├── runner.exe.manifest
    │   │   │           ├── Runner.rc
    │   │   │           ├── utils.cpp
    │   │   │           ├── utils.h
    │   │   │           ├── win32_window.cpp
    │   │   │           └── win32_window.h
    │   │   ├── lib/
    │   │   │   ├── zenrouter.dart
    │   │   │   └── src/
    │   │   │       ├── coordinator/
    │   │   │       │   ├── base.dart
    │   │   │       │   ├── modular.dart
    │   │   │       │   ├── observer.dart
    │   │   │       │   ├── restoration.dart
    │   │   │       │   └── router.dart
    │   │   │       ├── internal/
    │   │   │       │   ├── diff.dart
    │   │   │       │   ├── equatable.dart
    │   │   │       │   └── type.dart
    │   │   │       ├── mixin/
    │   │   │       │   ├── deeplink.dart
    │   │   │       │   ├── guard.dart
    │   │   │       │   ├── layout.dart
    │   │   │       │   ├── query_parameters.dart
    │   │   │       │   ├── redirect.dart
    │   │   │       │   ├── redirect_rule.dart
    │   │   │       │   ├── restoration.dart
    │   │   │       │   ├── target.dart
    │   │   │       │   ├── transition.dart
    │   │   │       │   └── unique.dart
    │   │   │       └── path/
    │   │   │           ├── base.dart
    │   │   │           ├── indexed.dart
    │   │   │           ├── mutatable.dart
    │   │   │           ├── navigatable.dart
    │   │   │           ├── navigation.dart
    │   │   │           ├── restoration.dart
    │   │   │           ├── stack.dart
    │   │   │           └── transition.dart
    │   │   └── test/
    │   │       ├── coordinator/
    │   │       │   ├── coordinator_route_module_test.dart
    │   │       │   ├── error_test.dart
    │   │       │   ├── modular_test.dart
    │   │       │   ├── navigation_test.dart
    │   │       │   ├── observer_test.dart
    │   │       │   ├── restoration_test.dart
    │   │       │   ├── router_assert_test.dart
    │   │       │   ├── router_delegate_test.dart
    │   │       │   └── transition_strategy_test.dart
    │   │       ├── internal/
    │   │       │   ├── diff_test.dart
    │   │       │   └── equaltable_utils_test.dart
    │   │       ├── mixin/
    │   │       │   ├── combined_mixin_test.dart
    │   │       │   ├── deep_link_test.dart
    │   │       │   ├── guard_test.dart
    │   │       │   ├── layout_test.dart
    │   │       │   ├── mixin_test_utils.dart
    │   │       │   ├── query_parameters_test.dart
    │   │       │   ├── redirect_rule_test.dart
    │   │       │   ├── redirect_test.dart
    │   │       │   ├── restoration_test.dart
    │   │       │   └── transition_test.dart
    │   │       ├── path/
    │   │       │   ├── indexed_test.dart
    │   │       │   ├── mutatable_test.dart
    │   │       │   ├── navigatable_test.dart
    │   │       │   └── restoration_test.dart
    │   │       └── stack/
    │   │           ├── layout_creation_test.dart
    │   │           ├── navigation_stack_test.dart
    │   │           └── route_completion_test.dart
    │   ├── zenrouter_devtools/
    │   │   ├── README.md
    │   │   ├── analysis_options.yaml
    │   │   ├── CHANGELOG.md
    │   │   ├── LICENSE
    │   │   ├── pubspec.yaml
    │   │   ├── .metadata
    │   │   ├── example/
    │   │   │   ├── analysis_options.yaml
    │   │   │   ├── pubspec.lock
    │   │   │   ├── pubspec.yaml
    │   │   │   ├── .metadata
    │   │   │   ├── android/
    │   │   │   │   ├── build.gradle.kts
    │   │   │   │   ├── gradle.properties
    │   │   │   │   ├── settings.gradle.kts
    │   │   │   │   ├── app/
    │   │   │   │   │   ├── build.gradle.kts
    │   │   │   │   │   └── src/
    │   │   │   │   │       ├── debug/
    │   │   │   │   │       │   └── AndroidManifest.xml
    │   │   │   │   │       ├── main/
    │   │   │   │   │       │   ├── AndroidManifest.xml
    │   │   │   │   │       │   ├── kotlin/
    │   │   │   │   │       │   │   └── dev/
    │   │   │   │   │       │   │       └── zennn/
    │   │   │   │   │       │   │           └── router/
    │   │   │   │   │       │   │               └── example/
    │   │   │   │   │       │   │                   └── example/
    │   │   │   │   │       │   │                       └── MainActivity.kt
    │   │   │   │   │       │   └── res/
    │   │   │   │   │       │       ├── drawable/
    │   │   │   │   │       │       │   └── launch_background.xml
    │   │   │   │   │       │       ├── drawable-v21/
    │   │   │   │   │       │       │   └── launch_background.xml
    │   │   │   │   │       │       ├── values/
    │   │   │   │   │       │       │   └── styles.xml
    │   │   │   │   │       │       └── values-night/
    │   │   │   │   │       │           └── styles.xml
    │   │   │   │   │       └── profile/
    │   │   │   │   │           └── AndroidManifest.xml
    │   │   │   │   └── gradle/
    │   │   │   │       └── wrapper/
    │   │   │   │           └── gradle-wrapper.properties
    │   │   │   ├── ios/
    │   │   │   │   ├── Flutter/
    │   │   │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   │   │   ├── Debug.xcconfig
    │   │   │   │   │   └── Release.xcconfig
    │   │   │   │   ├── Runner/
    │   │   │   │   │   ├── AppDelegate.swift
    │   │   │   │   │   ├── Info.plist
    │   │   │   │   │   ├── Runner-Bridging-Header.h
    │   │   │   │   │   ├── Assets.xcassets/
    │   │   │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   │   │   │   └── Contents.json
    │   │   │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │   │   │       ├── README.md
    │   │   │   │   │   │       └── Contents.json
    │   │   │   │   │   └── Base.lproj/
    │   │   │   │   │       ├── LaunchScreen.storyboard
    │   │   │   │   │       └── Main.storyboard
    │   │   │   │   └── RunnerTests/
    │   │   │   │       └── RunnerTests.swift
    │   │   │   ├── lib/
    │   │   │   │   └── main.dart
    │   │   │   ├── linux/
    │   │   │   │   ├── CMakeLists.txt
    │   │   │   │   ├── flutter/
    │   │   │   │   │   ├── CMakeLists.txt
    │   │   │   │   │   ├── generated_plugin_registrant.cc
    │   │   │   │   │   ├── generated_plugin_registrant.h
    │   │   │   │   │   └── generated_plugins.cmake
    │   │   │   │   └── runner/
    │   │   │   │       ├── CMakeLists.txt
    │   │   │   │       ├── main.cc
    │   │   │   │       ├── my_application.cc
    │   │   │   │       └── my_application.h
    │   │   │   ├── macos/
    │   │   │   │   ├── Flutter/
    │   │   │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │   │   ├── Flutter-Release.xcconfig
    │   │   │   │   │   └── GeneratedPluginRegistrant.swift
    │   │   │   │   ├── Runner/
    │   │   │   │   │   ├── AppDelegate.swift
    │   │   │   │   │   ├── DebugProfile.entitlements
    │   │   │   │   │   ├── Info.plist
    │   │   │   │   │   ├── MainFlutterWindow.swift
    │   │   │   │   │   ├── Release.entitlements
    │   │   │   │   │   ├── Assets.xcassets/
    │   │   │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │   │   │       └── Contents.json
    │   │   │   │   │   ├── Base.lproj/
    │   │   │   │   │   │   └── MainMenu.xib
    │   │   │   │   │   └── Configs/
    │   │   │   │   │       ├── AppInfo.xcconfig
    │   │   │   │   │       ├── Debug.xcconfig
    │   │   │   │   │       ├── Release.xcconfig
    │   │   │   │   │       └── Warnings.xcconfig
    │   │   │   │   └── RunnerTests/
    │   │   │   │       └── RunnerTests.swift
    │   │   │   ├── web/
    │   │   │   │   ├── index.html
    │   │   │   │   └── manifest.json
    │   │   │   └── windows/
    │   │   │       ├── CMakeLists.txt
    │   │   │       ├── flutter/
    │   │   │       │   ├── CMakeLists.txt
    │   │   │       │   ├── generated_plugin_registrant.cc
    │   │   │       │   ├── generated_plugin_registrant.h
    │   │   │       │   └── generated_plugins.cmake
    │   │   │       └── runner/
    │   │   │           ├── CMakeLists.txt
    │   │   │           ├── flutter_window.cpp
    │   │   │           ├── flutter_window.h
    │   │   │           ├── main.cpp
    │   │   │           ├── resource.h
    │   │   │           ├── runner.exe.manifest
    │   │   │           ├── Runner.rc
    │   │   │           ├── utils.cpp
    │   │   │           ├── utils.h
    │   │   │           ├── win32_window.cpp
    │   │   │           └── win32_window.h
    │   │   └── lib/
    │   │       ├── zenrouter_devtools.dart
    │   │       └── src/
    │   │           ├── coordinator_debug.dart
    │   │           ├── debug_overlay.dart
    │   │           ├── tabs/
    │   │           │   ├── active_tab.dart
    │   │           │   ├── inspect_tab.dart
    │   │           │   ├── problems_tab.dart
    │   │           │   ├── routes_tab.dart
    │   │           │   └── tabs.dart
    │   │           └── widgets/
    │   │               ├── badges.dart
    │   │               ├── buttons.dart
    │   │               ├── debug_theme.dart
    │   │               └── widgets.dart
    │   ├── zenrouter_docs/
    │   │   ├── README.md
    │   │   ├── analysis_options.yaml
    │   │   ├── build.yaml
    │   │   ├── pubspec.yaml
    │   │   ├── .metadata
    │   │   ├── android/
    │   │   │   ├── build.gradle.kts
    │   │   │   ├── gradle.properties
    │   │   │   ├── settings.gradle.kts
    │   │   │   ├── app/
    │   │   │   │   ├── build.gradle.kts
    │   │   │   │   └── src/
    │   │   │   │       ├── debug/
    │   │   │   │       │   └── AndroidManifest.xml
    │   │   │   │       ├── main/
    │   │   │   │       │   ├── AndroidManifest.xml
    │   │   │   │       │   ├── kotlin/
    │   │   │   │       │   │   └── com/
    │   │   │   │       │   │       └── example/
    │   │   │   │       │   │           └── zenrouter_docs/
    │   │   │   │       │   │               └── MainActivity.kt
    │   │   │   │       │   └── res/
    │   │   │   │       │       ├── drawable/
    │   │   │   │       │       │   └── launch_background.xml
    │   │   │   │       │       ├── drawable-v21/
    │   │   │   │       │       │   └── launch_background.xml
    │   │   │   │       │       ├── values/
    │   │   │   │       │       │   └── styles.xml
    │   │   │   │       │       └── values-night/
    │   │   │   │       │           └── styles.xml
    │   │   │   │       └── profile/
    │   │   │   │           └── AndroidManifest.xml
    │   │   │   └── gradle/
    │   │   │       └── wrapper/
    │   │   │           └── gradle-wrapper.properties
    │   │   ├── ios/
    │   │   │   ├── Podfile
    │   │   │   ├── Flutter/
    │   │   │   │   ├── AppFrameworkInfo.plist
    │   │   │   │   ├── Debug.xcconfig
    │   │   │   │   └── Release.xcconfig
    │   │   │   ├── Runner/
    │   │   │   │   ├── AppDelegate.swift
    │   │   │   │   ├── Info.plist
    │   │   │   │   ├── Runner-Bridging-Header.h
    │   │   │   │   ├── SceneDelegate.swift
    │   │   │   │   ├── Assets.xcassets/
    │   │   │   │   │   ├── AppIcon.appiconset/
    │   │   │   │   │   │   └── Contents.json
    │   │   │   │   │   └── LaunchImage.imageset/
    │   │   │   │   │       ├── README.md
    │   │   │   │   │       └── Contents.json
    │   │   │   │   └── Base.lproj/
    │   │   │   │       ├── LaunchScreen.storyboard
    │   │   │   │       └── Main.storyboard
    │   │   │   └── RunnerTests/
    │   │   │       └── RunnerTests.swift
    │   │   ├── lib/
    │   │   │   ├── main.dart
    │   │   │   ├── constants/
    │   │   │   │   └── app_constants.dart
    │   │   │   ├── routes/
    │   │   │   │   ├── _coordinator.dart
    │   │   │   │   ├── _layout.dart
    │   │   │   │   ├── _layout.g.dart
    │   │   │   │   ├── _route.dart
    │   │   │   │   ├── index.dart
    │   │   │   │   ├── index.g.dart
    │   │   │   │   ├── not_found.dart
    │   │   │   │   ├── routes.zen.dart
    │   │   │   │   └── docs/
    │   │   │   │       ├── _layout.dart
    │   │   │   │       ├── _layout.g.dart
    │   │   │   │       ├── index.dart
    │   │   │   │       ├── index.g.dart
    │   │   │   │       ├── _configuration/
    │   │   │   │       │   ├── seo_title.dart
    │   │   │   │       │   ├── seo_title.io.dart
    │   │   │   │       │   └── seo_title.web.dart
    │   │   │   │       ├── concepts/
    │   │   │   │       │   ├── routes-and-paths.dart
    │   │   │   │       │   ├── routes-and-paths.g.dart
    │   │   │   │       │   ├── stack-management.dart
    │   │   │   │       │   ├── stack-management.g.dart
    │   │   │   │       │   ├── uri-parsing.dart
    │   │   │   │       │   └── uri-parsing.g.dart
    │   │   │   │       ├── examples/
    │   │   │   │       │   ├── _layout.dart
    │   │   │   │       │   ├── _layout.g.dart
    │   │   │   │       │   └── [slug]/
    │   │   │   │       │       ├── index.dart
    │   │   │   │       │       └── index.g.dart
    │   │   │   │       ├── file-routing/
    │   │   │   │       │   ├── conventions.dart
    │   │   │   │       │   ├── conventions.g.dart
    │   │   │   │       │   ├── deferred-imports.dart
    │   │   │   │       │   ├── deferred-imports.g.dart
    │   │   │   │       │   ├── dynamic-routes.dart
    │   │   │   │       │   ├── dynamic-routes.g.dart
    │   │   │   │       │   ├── getting-started.dart
    │   │   │   │       │   └── getting-started.g.dart
    │   │   │   │       ├── paradigms/
    │   │   │   │       │   ├── choosing.dart
    │   │   │   │       │   ├── choosing.g.dart
    │   │   │   │       │   ├── coordinator.dart
    │   │   │   │       │   ├── coordinator.g.dart
    │   │   │   │       │   ├── declarative.dart
    │   │   │   │       │   ├── declarative.g.dart
    │   │   │   │       │   ├── imperative.dart
    │   │   │   │       │   └── imperative.g.dart
    │   │   │   │       └── patterns/
    │   │   │   │           ├── deep-linking.dart
    │   │   │   │           ├── deep-linking.g.dart
    │   │   │   │           ├── guards-redirects.dart
    │   │   │   │           ├── guards-redirects.g.dart
    │   │   │   │           ├── layouts.dart
    │   │   │   │           ├── layouts.g.dart
    │   │   │   │           ├── query-parameters.dart
    │   │   │   │           └── query-parameters.g.dart
    │   │   │   ├── theme/
    │   │   │   │   └── app_theme.dart
    │   │   │   └── widgets/
    │   │   │       ├── breadcrumb.dart
    │   │   │       ├── code_block.dart
    │   │   │       ├── doc_page.dart
    │   │   │       ├── docs_layout.dart
    │   │   │       ├── mardown_section.dart
    │   │   │       └── section_layout.dart
    │   │   ├── linux/
    │   │   │   ├── CMakeLists.txt
    │   │   │   ├── flutter/
    │   │   │   │   ├── CMakeLists.txt
    │   │   │   │   ├── generated_plugin_registrant.cc
    │   │   │   │   ├── generated_plugin_registrant.h
    │   │   │   │   └── generated_plugins.cmake
    │   │   │   └── runner/
    │   │   │       ├── CMakeLists.txt
    │   │   │       ├── main.cc
    │   │   │       ├── my_application.cc
    │   │   │       └── my_application.h
    │   │   ├── macos/
    │   │   │   ├── Podfile
    │   │   │   ├── Podfile.lock
    │   │   │   ├── Flutter/
    │   │   │   │   ├── Flutter-Debug.xcconfig
    │   │   │   │   ├── Flutter-Release.xcconfig
    │   │   │   │   └── GeneratedPluginRegistrant.swift
    │   │   │   ├── Runner/
    │   │   │   │   ├── AppDelegate.swift
    │   │   │   │   ├── DebugProfile.entitlements
    │   │   │   │   ├── Info.plist
    │   │   │   │   ├── MainFlutterWindow.swift
    │   │   │   │   ├── Release.entitlements
    │   │   │   │   ├── Assets.xcassets/
    │   │   │   │   │   └── AppIcon.appiconset/
    │   │   │   │   │       └── Contents.json
    │   │   │   │   ├── Base.lproj/
    │   │   │   │   │   └── MainMenu.xib
    │   │   │   │   └── Configs/
    │   │   │   │       ├── AppInfo.xcconfig
    │   │   │   │       ├── Debug.xcconfig
    │   │   │   │       ├── Release.xcconfig
    │   │   │   │       └── Warnings.xcconfig
    │   │   │   └── RunnerTests/
    │   │   │       └── RunnerTests.swift
    │   │   ├── web/
    │   │   │   ├── index.html
    │   │   │   └── manifest.json
    │   │   └── windows/
    │   │       ├── CMakeLists.txt
    │   │       ├── flutter/
    │   │       │   ├── CMakeLists.txt
    │   │       │   ├── generated_plugin_registrant.cc
    │   │       │   ├── generated_plugin_registrant.h
    │   │       │   └── generated_plugins.cmake
    │   │       └── runner/
    │   │           ├── CMakeLists.txt
    │   │           ├── flutter_window.cpp
    │   │           ├── flutter_window.h
    │   │           ├── main.cpp
    │   │           ├── resource.h
    │   │           ├── runner.exe.manifest
    │   │           ├── Runner.rc
    │   │           ├── utils.cpp
    │   │           ├── utils.h
    │   │           ├── win32_window.cpp
    │   │           └── win32_window.h
    │   ├── zenrouter_file_annotation/
    │   │   ├── README.md
    │   │   ├── CHANGELOG.md
    │   │   ├── LICENSE
    │   │   ├── pubspec.yaml
    │   │   ├── example/
    │   │   │   └── README.md
    │   │   └── lib/
    │   │       ├── zenrouter_file_annotation.dart
    │   │       └── src/
    │   │           ├── annotations.dart
    │   │           ├── analyzer/
    │   │           │   ├── layout_element.dart
    │   │           │   ├── path_parser.dart
    │   │           │   └── route_element.dart
    │   │           └── codegen/
    │   │               ├── layout_code_generator.dart
    │   │               └── route_code_generator.dart
    │   └── zenrouter_file_generator/
    │       ├── README.md
    │       ├── analysis_options.yaml
    │       ├── build.yaml
    │       ├── CHANGELOG.md
    │       ├── devtools_options.yaml
    │       ├── LICENSE
    │       ├── pubspec.yaml
    │       ├── .metadata
    │       ├── .pubignore
    │       ├── example/
    │       │   ├── analysis_options.yaml
    │       │   ├── benchmark.sh
    │       │   ├── BENCHMARK_ANALYSIS.md
    │       │   ├── benchmark_results.txt
    │       │   ├── build.yaml
    │       │   ├── devtools_options.yaml
    │       │   ├── pubspec.yaml
    │       │   ├── .metadata
    │       │   ├── android/
    │       │   │   ├── build.gradle.kts
    │       │   │   ├── gradle.properties
    │       │   │   ├── settings.gradle.kts
    │       │   │   ├── app/
    │       │   │   │   ├── build.gradle.kts
    │       │   │   │   └── src/
    │       │   │   │       ├── debug/
    │       │   │   │       │   └── AndroidManifest.xml
    │       │   │   │       ├── main/
    │       │   │   │       │   ├── AndroidManifest.xml
    │       │   │   │       │   ├── kotlin/
    │       │   │   │       │   │   └── com/
    │       │   │   │       │   │       └── example/
    │       │   │   │       │   │           └── example/
    │       │   │   │       │   │               └── MainActivity.kt
    │       │   │   │       │   └── res/
    │       │   │   │       │       ├── drawable/
    │       │   │   │       │       │   └── launch_background.xml
    │       │   │   │       │       ├── drawable-v21/
    │       │   │   │       │       │   └── launch_background.xml
    │       │   │   │       │       ├── values/
    │       │   │   │       │       │   └── styles.xml
    │       │   │   │       │       └── values-night/
    │       │   │   │       │           └── styles.xml
    │       │   │   │       └── profile/
    │       │   │   │           └── AndroidManifest.xml
    │       │   │   └── gradle/
    │       │   │       └── wrapper/
    │       │   │           └── gradle-wrapper.properties
    │       │   ├── ios/
    │       │   │   ├── Flutter/
    │       │   │   │   ├── AppFrameworkInfo.plist
    │       │   │   │   ├── Debug.xcconfig
    │       │   │   │   └── Release.xcconfig
    │       │   │   ├── Runner/
    │       │   │   │   ├── AppDelegate.swift
    │       │   │   │   ├── Info.plist
    │       │   │   │   ├── Runner-Bridging-Header.h
    │       │   │   │   ├── Assets.xcassets/
    │       │   │   │   │   ├── AppIcon.appiconset/
    │       │   │   │   │   │   └── Contents.json
    │       │   │   │   │   └── LaunchImage.imageset/
    │       │   │   │   │       ├── README.md
    │       │   │   │   │       └── Contents.json
    │       │   │   │   └── Base.lproj/
    │       │   │   │       ├── LaunchScreen.storyboard
    │       │   │   │       └── Main.storyboard
    │       │   │   └── RunnerTests/
    │       │   │       └── RunnerTests.swift
    │       │   ├── lib/
    │       │   │   ├── flutter_scan.dart
    │       │   │   ├── main_deferred.dart
    │       │   │   ├── main_no_deferred.dart
    │       │   │   └── routes/
    │       │   │       ├── (auth).forgot-password.dart
    │       │   │       ├── (auth).forgot-password.g.dart
    │       │   │       ├── _coordinator.dart
    │       │   │       ├── _route.dart
    │       │   │       ├── about.dart
    │       │   │       ├── about.g.dart
    │       │   │       ├── blog.[...slugs].dart
    │       │   │       ├── blog.[...slugs].g.dart
    │       │   │       ├── collection.list.dart
    │       │   │       ├── collection.list.g.dart
    │       │   │       ├── index.dart
    │       │   │       ├── index.g.dart
    │       │   │       ├── not_found.dart
    │       │   │       ├── routes.zen.dart
    │       │   │       ├── settings.account.index.dart
    │       │   │       ├── settings.account.index.g.dart
    │       │   │       ├── shop.products.[productId].reviews.dart
    │       │   │       ├── shop.products.[productId].reviews.g.dart
    │       │   │       ├── (auth)/
    │       │   │       │   ├── _layout.dart
    │       │   │       │   ├── _layout.g.dart
    │       │   │       │   ├── login.dart
    │       │   │       │   ├── login.g.dart
    │       │   │       │   ├── register.dart
    │       │   │       │   └── register.g.dart
    │       │   │       ├── profile/
    │       │   │       │   ├── general.dart
    │       │   │       │   ├── general.g.dart
    │       │   │       │   └── [profileId]/
    │       │   │       │       ├── index.dart
    │       │   │       │       └── index.g.dart
    │       │   │       └── tabs/
    │       │   │           ├── _layout.dart
    │       │   │           ├── _layout.g.dart
    │       │   │           ├── profile.dart
    │       │   │           ├── profile.g.dart
    │       │   │           ├── settings.dart
    │       │   │           ├── settings.g.dart
    │       │   │           └── feed/
    │       │   │               ├── _layout.dart
    │       │   │               ├── _layout.g.dart
    │       │   │               ├── following/
    │       │   │               │   ├── [postId].dart
    │       │   │               │   ├── [postId].g.dart
    │       │   │               │   ├── _layout.dart
    │       │   │               │   ├── _layout.g.dart
    │       │   │               │   ├── index.dart
    │       │   │               │   ├── index.g.dart
    │       │   │               │   └── [...slugs]/
    │       │   │               │       ├── [id].dart
    │       │   │               │       ├── [id].g.dart
    │       │   │               │       ├── about.dart
    │       │   │               │       ├── about.g.dart
    │       │   │               │       ├── index.dart
    │       │   │               │       └── index.g.dart
    │       │   │               └── for-you/
    │       │   │                   ├── _layout.dart
    │       │   │                   ├── _layout.g.dart
    │       │   │                   ├── index.dart
    │       │   │                   ├── index.g.dart
    │       │   │                   ├── sheet.dart
    │       │   │                   └── sheet.g.dart
    │       │   ├── linux/
    │       │   │   ├── CMakeLists.txt
    │       │   │   ├── flutter/
    │       │   │   │   ├── CMakeLists.txt
    │       │   │   │   ├── generated_plugin_registrant.cc
    │       │   │   │   ├── generated_plugin_registrant.h
    │       │   │   │   └── generated_plugins.cmake
    │       │   │   └── runner/
    │       │   │       ├── CMakeLists.txt
    │       │   │       ├── main.cc
    │       │   │       ├── my_application.cc
    │       │   │       └── my_application.h
    │       │   ├── macos/
    │       │   │   ├── Flutter/
    │       │   │   │   ├── Flutter-Debug.xcconfig
    │       │   │   │   ├── Flutter-Release.xcconfig
    │       │   │   │   └── GeneratedPluginRegistrant.swift
    │       │   │   ├── Runner/
    │       │   │   │   ├── AppDelegate.swift
    │       │   │   │   ├── DebugProfile.entitlements
    │       │   │   │   ├── Info.plist
    │       │   │   │   ├── MainFlutterWindow.swift
    │       │   │   │   ├── Release.entitlements
    │       │   │   │   ├── Assets.xcassets/
    │       │   │   │   │   └── AppIcon.appiconset/
    │       │   │   │   │       └── Contents.json
    │       │   │   │   ├── Base.lproj/
    │       │   │   │   │   └── MainMenu.xib
    │       │   │   │   └── Configs/
    │       │   │   │       ├── AppInfo.xcconfig
    │       │   │   │       ├── Debug.xcconfig
    │       │   │   │       ├── Release.xcconfig
    │       │   │   │       └── Warnings.xcconfig
    │       │   │   └── RunnerTests/
    │       │   │       └── RunnerTests.swift
    │       │   ├── web/
    │       │   │   ├── index.html
    │       │   │   └── manifest.json
    │       │   └── windows/
    │       │       ├── CMakeLists.txt
    │       │       ├── flutter/
    │       │       │   ├── CMakeLists.txt
    │       │       │   ├── generated_plugin_registrant.cc
    │       │       │   ├── generated_plugin_registrant.h
    │       │       │   └── generated_plugins.cmake
    │       │       └── runner/
    │       │           ├── CMakeLists.txt
    │       │           ├── flutter_window.cpp
    │       │           ├── flutter_window.h
    │       │           ├── main.cpp
    │       │           ├── resource.h
    │       │           ├── runner.exe.manifest
    │       │           ├── Runner.rc
    │       │           ├── utils.cpp
    │       │           ├── utils.h
    │       │           ├── win32_window.cpp
    │       │           └── win32_window.h
    │       ├── lib/
    │       │   ├── builder.dart
    │       │   ├── zenrouter_file_generator.dart
    │       │   └── src/
    │       │       ├── builder.dart
    │       │       ├── analyzers/
    │       │       │   ├── layout_element.dart
    │       │       │   └── route_element.dart
    │       │       └── generators/
    │       │           ├── coordinator_generator.dart
    │       │           ├── layout_generator.dart
    │       │           └── route_generator.dart
    │       └── test/
    │           ├── annotations_test.dart
    │           ├── coordinator_generator_test.dart
    │           ├── layout_element_test.dart
    │           ├── path_parser_test.dart
    │           └── route_element_test.dart
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            └── test.yml

================================================
FILE: README.md
================================================
<div align="center">

<picture>
  <source media="(prefers-color-scheme: dark)" srcset="https://github.com/definev/zenrouter/blob/main/assets/zenrouter_dark.png?raw=true">
  <source media="(prefers-color-scheme: light)" srcset="https://github.com/definev/zenrouter/blob/main/assets/zenrouter_light.png?raw=true">
  <img alt="ZenRouter Logo" src="https://github.com/definev/zenrouter/blob/main/assets/zenrouter_light.png?raw=true">
</picture>

**The Ultimate Flutter Router for Every Navigation Pattern**

[![pub package](https://img.shields.io/pub/v/zenrouter.svg)](https://pub.dev/packages/zenrouter)
[![Test](https://github.com/definev/zenrouter/actions/workflows/test.yml/badge.svg)](https://github.com/definev/zenrouter/actions/workflows/test.yml)
[![Codecov - zenrouter](https://codecov.io/gh/definev/zenrouter/branch/main/graph/badge.svg?flag=zenrouter)](https://app.codecov.io/gh/definev/zenrouter?branch=main&flags=zenrouter)

</div>

ZenRouter is the only router you'll ever need - supporting three distinct paradigms to handle any routing scenario, from simple mobile apps to complex web applications with deep linking.

## Three Paradigms. One Router.

🎮 **Imperative** - Direct control for mobile apps and event-driven navigation  
📊 **Declarative** - State-driven routing for tab bars and dynamic UIs  
🗺️ **Coordinator** - Deep linking and web support for complex applications  

## Why ZenRouter?

✨ **One Router, Three Paradigms** - Choose the approach that fits your needs  
🚀 **Progressive** - Start simple, add complexity only when needed  
🌐 **Full Web Support** - Built-in deep linking and URL synchronization  
⚡ **Blazing Fast** - Efficient Myers diff for optimal performance  
🔒 **Type-Safe** - Catch routing errors at compile-time  
🛡️ **Powerful** - Guards, redirects, and custom transitions built-in  
📝 **No Codegen Needed (for core)** - Pure Dart, no build_runner or generated files required. *(Optional file-based routing via `zenrouter_file_generator` is available when you want codegen.)*  

---

## 📚 Full Documentation

For complete documentation, API reference, examples, and getting started guides:

### **👉 [View Full ZenRouter Documentation](packages/zenrouter/README.md)**

---

## Repository Structure

This monorepo contains:

- **[zenrouter](packages/zenrouter/)** - The core routing library
- **[zenrouter_file_generator](packages/zenrouter_file_generator/)** - File-based routing code generator for ZenRouter's Coordinator paradigm
- **[zenrouter_devtools](packages/zenrouter_devtools/)** - DevTools for debugging navigation

---

## Quick Example

```dart
// Imperative: Direct control
final path = NavigationPath<AppRoute>.create();
path.push(ProfileRoute());

// Declarative: State-driven
NavigationStack.declarative(
  routes: [
    for (final page in pages) PageRoute(page),
  ],
  resolver: (route) => StackTransition.material(...),
)

// Coordinator: Web & deep linking
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) => ...;
}
```

---

## Platform Support

✅ iOS • ✅ Android • ✅ Web • ✅ macOS • ✅ Windows • ✅ Linux

---

## License

Apache 2.0 License - see [LICENSE](LICENSE)

## Author

Created by [definev](https://github.com/definev)

---

<div align="center">

**[Get Started →](packages/zenrouter/README.md)**

</div>


================================================
FILE: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Bui Dai Duong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: pubspec.yaml
================================================
name: _
publish_to: none
environment:
  sdk: ^3.6.0
workspace:
  - packages/zenrouter
  - packages/zenrouter/example
  - packages/zenrouter_devtools
  - packages/zenrouter_file_generator
  - packages/zenrouter_file_generator/example
  - packages/zenrouter_file_annotation
  - packages/zenrouter/doc/paradigms/coordinator/example
  - packages/zenrouter_docs


================================================
FILE: packages/zenrouter/README.md
================================================
<div align="center">

<img alt="ZenRouter Logo" src="https://raw.githubusercontent.com/definev/zenrouter/main/assets/zenrouter_light_solid.png">

**The Ultimate Flutter Router for Every Navigation Pattern**

[![pub package](https://img.shields.io/pub/v/zenrouter.svg)](https://pub.dev/packages/zenrouter)
[![Test](https://github.com/definev/zenrouter/actions/workflows/test.yml/badge.svg)](https://github.com/definev/zenrouter/actions/workflows/test.yml)
[![Codecov - zenrouter](https://codecov.io/gh/definev/zenrouter/branch/main/graph/badge.svg?flag=zenrouter)](https://app.codecov.io/gh/definev/zenrouter?branch=main&flags=zenrouter)

</div>

ZenRouter is the only router you'll ever need - supporting three distinct paradigms to handle any routing scenario. From simple mobile apps to complex web applications with deep linking, ZenRouter adapts to your needs.


---

## Installation

Add ZenRouter to your `pubspec.yaml`:

```bash
flutter pub add zenrouter
```

---

## Features

- 🎭 **Flexible Paradigms**: Choose between Imperative (simple), Declarative (state-driven), or Coordinator (complex) patterns.
- 💾 **State Restoration**: Built-in support for restoring app state after process death (essential for Android).
- 🔗 **Deep Linking**: Full support for deep links and web URLs with strict typing.
- 🛡️ **Guards & Redirects**: Robust security and navigation flow control.
- ⚡ **Performance**: Optimized diff algorithms for minimal widget rebuilds.
- 🛠️ **DevTools**: Inspect your navigation stack and test deep links in real-time.
- 🚫 **No CodeGen Required**: Works out of the box with standard Dart code.

---

## Quick Links

- 🧭 [Documentation Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/DOCUMENTATION_ROADMAP.md) - A roadmap for documentation
- 📚 [Getting Started Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/getting-started.md) - Choose your paradigm
- 🍳 [Recipes & Cookbook](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/) - Practical solutions for common scenarios
- 🔄 [Migration Guides](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/migration/) - Switch from go_router, auto_route, or Navigator
- 📖 [API Reference](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/) - Complete API documentation
- 🎓 [Paradigm Guides](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/) - Deep dives into each pattern

---

## Three Paradigms, Infinite Flexibility


### Choose Your Path

```
Need web support, deep linking, and router devtools to handle complex scalable navigation?
│
├─ YES → Use Coordinator
│        ✓ Deep linking & URL sync
│        ✓ Devtools ready!
│        ✓ Back button gesture (Web back, predictive back, etc)
│        ✓ Perfect for web, complex mobile apps
│
└─ NO → Is navigation driven by state?
       │
       ├─ YES → Use Declarative
       │        ✓ Efficient Myers diff
       │        ✓ React-like patterns
       │        ✓ Perfect for tab bars
       │
       └─ NO → Use Imperative
                ✓ Simple & direct
                ✓ Full control
                ✓ Perfect for mobile
```

---

## 🔄 Migrating from Another Router?

Switching to ZenRouter is straightforward. We have comprehensive guides for:

- **[From go_router](doc/migration/from-go-router.md)** - Most popular Flutter router
- **[From auto_route](doc/migration/from-auto-route.md)** - Code generation alternative  
- **[From Navigator 1.0/2.0](doc/migration/from-navigator.md)** - Flutter's built-in APIs

Each guide includes side-by-side code comparisons and step-by-step instructions.

---

### 🗺️ **Coordinator** - Deep Linking & Web
*Perfect for web apps and complex navigation hierarchies*

#### Quick Start

Ready to level up? When your app needs to support deep linking, web URLs, or browser navigation, it's time to graduate to the **Coordinator** pattern. This is the final and most powerful routing paradigm in ZenRouter—built for production apps that need to handle complex navigation scenarios across multiple platforms.

The Coordinator pattern gives you:
- 🔗 **Deep linking** - Open specific screens from external sources (`myapp://profile/123`)
- 🌐 **URL synchronization** - Keep browser URLs in sync with navigation state
- 💾 **State Restoration** - Automatically save and restore state when the app is killed by the OS
- ⬅️ **Browser back button** - Native web navigation that just works
- 🛠️ **DevTools** - Built-in debugging and route inspection

Let's build a Coordinator-powered app. First, define your routes with URI support:

First, create a base route class for your app. The `RouteUnique` mixin is **required** for Coordinator—it enforces that every route must define a unique URI, which is essential for deep linking and URL synchronization:

```dart
abstract class AppRoute extends RouteTarget with RouteUnique {}
```

Now define your concrete routes by extending `AppRoute`:

```dart
class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return HomePage(coordinator: coordinator);
  }
}

class ProfileRoute extends AppRoute {
  ProfileRoute(this.userId);
  final String userId;

  @override
  List<Object?> get props => [userId];
  
  @override
  Uri toUri() => Uri.parse('/profile/$userId');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ProfilePage(userId: userId, coordinator: coordinator);
  }
}
```

> [!IMPORTANT]
> Notice that the `build()` method uses `AppCoordinator` (not `Coordinator`) as the parameter type. This is because `Coordinator` is **covariant**—when you create your `AppCoordinator extends Coordinator<AppRoute>`, all your routes will receive that specific coordinator type, giving you type-safe access to any custom methods or properties you add to `AppCoordinator`.

Next, create your Coordinator by extending the `Coordinator` class and implementing URI parsing:

```dart
class AppCoordinator extends Coordinator<RouteTarget> {
  @override
  RouteTarget parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile', String userId] => ProfileRoute(userId),
      _ => NotFoundRoute(),
    };
  }
}
```

Finally, wire it up with `MaterialApp.router` to enable full platform navigation:

```dart
class MyApp extends StatelessWidget {
  final coordinator = AppCoordinator();
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}
```

If you want `state restoration` support, just add `restorationScopeId` to `MaterialApp.router`:

```dart
return MaterialApp.router(
  restorationScopeId: 'app',
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
);
```

> [!IMPORTANT]
> State restoration is supported on Android and iOS. It requires routes to be parsed synchronously during startup.
>
> If your `parseRouteFromUri` is asynchronous, you **must** override `parseRouteFromUriSync` to provide a synchronous parser. If `parseRouteFromUri` is already synchronous, it works out of the box.

That's it! Your app now supports:
- ✅ Deep links: `myapp://profile/joe` automatically navigates to Joe's profile
- ✅ Web URLs: Users can bookmark and share `https://myapp.com/profile/joe`
- ✅ Browser navigation: Back/forward buttons work seamlessly
- ✅ Dev tools: Debug routes and navigation flows in real-time

The Coordinator handles all the complexity of URI parsing, route restoration, and platform integration—you just focus on building your app.

[→ Learn Coordinator Pattern](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator/coordinator.md)

---

### 🎮 **Imperative** - Direct Control

*Perfect for mobile apps and event-driven navigation*

#### Quick Start

First, define a navigation path and all possible routes. For example, let's say you have `Home` and `Profile` routes:

```dart
class Home extends RouteTarget {}

class Profile extends RouteTarget {
  Profile(this.id);
  final String id;

  /// Make sure to add `id` in `props` to prevent unwanted behavior when pushing the same route
  List<Object?> get props => [id];
}

final appPath = NavigationPath.create();
```

Now that the setup is complete, let's wire up the navigation. The `NavigationStack` widget expects two main parameters:
- `path`: The route stack to display
- `resolver`: A function for resolving which transition type each route will use

```dart
class AppRouter extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return NavigationStack(
      path: appPath,
      resolver: (route) => switch (route) {
        Home() => StackTransition.material(HomePage()),
        Profile() => StackTransition.material(ProfilePage()),
      },
    );
  }
}
```

That's it! You've successfully set up imperative routing for your app. To navigate, simply call `push()` to open a new route (you can `await` the result when it's popped), and `pop()` to go back. The `NavigationPath` class offers many handy operations—see more in the [NavigationPath API documentation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md#navigationpath).

```dart
// Open Profile route
ElevatedButton(
  onPressed: () => appPath.push(Profile('Joe')),
  child: Text('Open "Joe" profile'),
),

// Pop back
appPath.pop();
```

**When to use:**
- Mobile-only applications
- Button clicks and gesture-driven navigation
- Migrating from Navigator 1.0
- You want simple, direct control

[→ Learn Imperative Routing](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md)

---

### 📊 **Declarative** - State-Driven
*Perfect for tab bars, filtered lists, and React-like UIs*

#### Quick Start

In declarative navigation, your UI is a function of your state. When your state changes, the navigation stack automatically updates to reflect it. ZenRouter uses the **Myers diff algorithm** to efficiently compute the minimal changes needed, ensuring optimal performance even with complex navigation stacks.

Let's build a simple tab navigation example. First, define your routes and state:

```dart
class HomeTab extends RouteTarget {}
class SearchTab extends RouteTarget {}
class ProfileTab extends RouteTarget {}

class TabNavigator extends StatefulWidget {
  @override
  State<TabNavigator> createState() => _TabNavigatorState();
}

class _TabNavigatorState extends State<TabNavigator> {
  int currentTab = 0;
  
  @override
  Widget build(BuildContext context) {
    return NavigationStack.declarative(
      routes: [
        HomeTab(),
        switch (currentTab) {
          0 => SearchTab(),
          1 => ProfileTab(),
          _ => SearchTab(),
        },
      ],
      resolver: (route) => switch (route) {
        HomeTab() => StackTransition.material(HomePage()),
        SearchTab() => StackTransition.material(SearchPage()),
        ProfileTab() => StackTransition.material(ProfilePage()),
      },
    );
  }
}
```

When you update the state, the navigation stack automatically reflects the changes. ZenRouter intelligently diffs the old and new route lists to determine the minimal set of push/pop operations needed:

```dart
// Switch tabs
setState(() => currentTab = 1); // Automatically pushes ProfileTab
```

That's it! The navigation stack stays perfectly in sync with your state—no manual `push()` or `pop()` calls needed. This pattern is ideal for tab bars, filtered lists, or any UI where navigation is derived from application state.

**When to use:**
- Tab navigation
- Filtered or dynamic lists
- State-driven UIs
- React-like declarative patterns

[→ Learn Declarative Routing](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md)

---

## Quick Comparison

|  | **Imperative** | **Declarative** | **Coordinator** |
|---|:---:|:---:|:---:|
| **Simplicity** | ⭐⭐⭐ | ⭐⭐ | ⭐ |
| **Web Support** | ❌ | ❌ | ✅ |
| **Deep Linking** | ❌ | ❌ | ✅ |
| **State-Driven** | Compatible | ✅ Native | Compatible |
| **Best For** | Mobile apps | Tab bars, lists | Web, large apps |
| **Route Ability** | `Guard`, `Redirect`, `Transition` | `Guard`, `Redirect`, `Transition` | `Guard`, `Redirect`, `Transition`, **`DeepLink`** |

---


## Documentation

### **📚 Guides**
- [Getting Started](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/getting-started.md) - Choose your paradigm and get started
- [Imperative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md) - Direct stack control
- [Declarative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md) - State-driven routing
- [Coordinator Pattern](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator/coordinator.md) - Deep linking & web support

### **🔧 API Reference**
- [Route Mixins](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/mixins.md) - Guards, redirects, transitions, and more
- [Navigation Paths](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md) - Stack containers and navigation
- [Coordinator API](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/coordinator.md) - Full coordinator reference
- [Core Classes](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/core-classes.md) - RouteTarget and fundamentals

### **🍳 Recipes & Cookbook**
- [404 Handling](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/404-handling.md) - Custom error pages
- [Authentication Flow](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/authentication-flow.md) - Guards and protected routes
- [Bottom Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/bottom-navigation.md) - Persistent tab navigation
- [Route Transitions](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/route-transitions.md) - Custom animations
- [State Management](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/state-management.md) - Integration with Riverpod, Bloc, Provider
- [URL Strategies](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/url-strategies.md) - Web deployment
- [→ All Recipes](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/recipes/)

### **🔄 Migration Guides**
- [From go_router](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/migration/from-go-router.md) - Migrate from go_router
- [From auto_route](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/migration/from-auto-route.md) - Migrate from auto_route
- [From Navigator 1.0/2.0](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/migration/from-navigator.md) - Migrate from Navigator APIs

### **💡 Examples**
- [Imperative Example](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/main_imperative.dart) - Multi-step form
- [Declarative Example](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/main_declrative.dart) - State-driven navigation
- [Coordinator Example](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/main_coordinator.dart) - Deep linking & nested navigation
- [File-based Routing Example (Coordinator + generator)](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/file_based_routing/README.md) - Next.js-style file-based routing using `zenrouter_file_generator`

To get Next.js / Nuxt.js–style file-based routing on top of the Coordinator paradigm, use the optional [`zenrouter_file_generator`](https://pub.dev/packages/zenrouter_file_generator) package, which provides annotations and a `build_runner`-based code generator.

---

## Contributing

We welcome contributions! See [CONTRIBUTING.md](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/CONTRIBUTING.md) for guidelines.

## License

Apache 2.0 License - see [LICENSE](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/LICENSE) for details.

## Created With Love By

[definev](https://github.com/definev)

---

<div align="center">

**The Ultimate Router for Flutter**

[Documentation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/getting-started.md) • [Examples](https://github.com/definev/zenrouter/tree/main/packages/zenrouter/example) • [Issues](https://github.com/definev/zenrouter/issues)

**Happy Routing! 🧘**

</div>



================================================
FILE: packages/zenrouter/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options



================================================
FILE: packages/zenrouter/CHANGELOG.md
================================================
## 1.2.0

### 🐞 Fixes
- **Fix**: Regression error when using `RouteRedirectRule` inside `IndexedStackPath` (Thanks to @obenkucuk)

### 🚀 New Features

#### Coordinator as RouteModule — Nested Coordinators
- `Coordinator` now implements `RouteModule<T>`, enabling any coordinator to be nested inside a `CoordinatorModular` by overriding the `coordinator` getter.
- Unlocks **route versioning** (V1/V2 side by side), multi-team modular architectures, and deeply nested coordinator hierarchies.
- Auto-detected `isRouteModule` flag controls root path creation vs parent inheritance.
- See [Guide](doc/guides/coordinator-as-module.md) & `example/lib/main_coordinator_module.dart`

### ⚠️ Breaking Changes

- **`Coordinator.parseRouteFromUri`** signature changed from `FutureOr<T>` to `FutureOr<T?>`. Child coordinators return `null` for unrecognized URIs; standalone coordinators are guarded by assertions.
- **`CoordinatorModular.parseRouteFromUri`** returns `null` instead of `notFoundRoute` when the coordinator is itself a nested module.

### 📖 Documentation

- **New Guide**: [Coordinator as RouteModule](doc/guides/coordinator-as-module.md)
- **New Recipe**: [Route Versioning](doc/recipes/route-versioning.md)

---

## 1.1.0

- BREAKING CHANGE: Remove `coordinator` from `defineModules`, use `this` getter instead.
- Feat: Enforce `getModule` method return exact type.

## 1.0.0

🎉 **Major Release - Production Ready**

### 🚀 New Features

#### CoordinatorModular - Modular Route Management
- Split route management across independent modules by domain/feature
- `CoordinatorModular` mixin + `RouteModule` base class
- Perfect for large apps with team collaboration
- See [Guide](doc/guides/coordinator-modular.md) & `example/lib/main_modular.dart`

```dart
class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    AuthModule(this),
    ShopModule(this),
  };
}
```

#### RouteRedirectRule - Composable Redirect Logic
- Reusable, chainable redirect rules (auth → feature flags → logging)
- `RedirectResult` sealed class with `Stop`/`Continue`/`RedirectTo` variants
- Async support for API calls, database queries

```dart
class ProtectedRoute extends AppRoute
    with RouteRedirect, RouteRedirectRule {
  @override
  List<RedirectRule> get redirectRules => [
    AuthenticationRule(),
    PermissionRule(permission: 'admin'),
  ];
}
```

### ⚠️ Breaking Changes

**Removed deprecated APIs:**
- `RouteLayout.buildPrimitivePath` → Use `RouteLayout.buildPath`
- `RouteLayout.layoutBuilderTable` → Use `RouteLayout.buildPath`
- `RouteLayout.navigationPath`/`indexedStackPath` → Use `NavigationPath.key`/`IndexedStackPath.key`
- `routerDelegateWithInitialRoute` → Use `RouteRedirect` in `IndexRoute`

See [Migration Guide](MIGRATION_GUIDE.md) for details.

### 📦 What's Included

- ✅ Stable API surface
- ✅ Full test coverage (48 new tests: 33 modular + 15 redirect rule)
- ✅ Comprehensive documentation with guides

---

## 0.4.20

* **Fix**: back gesture failed in android

## 0.4.19

* **Fix**: Blank screen when using `Coordinator` as `routerConfig` (due to unset `routerInformationProvider`).
* **Feat**: Added `initialRoutePath` property to `Coordinator`.
* **Feat**: Added `NavigatorObserverListGetter` typedef for passing external observers. ([View Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/navigator-observers.md#passing-observers-from-outside))

## 0.4.18
- **Feat**: Add `pushReplacement` method in `StackMutatable`.
- **Feat**: `Coordinator` now implements `RouterConfig` so you can use it with `MaterialApp.router` more easily.
  - ```dart
    MaterialApp.router(
      // New way
      routerConfig: coordinator,
      // Old way
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
    ```
- **Deprecate**: `routerDelegateWithInitialRoute` is deprecated, you can simulate the same behavior by using `RouteRedirect` in `IndexRoute`.

## 0.4.17
- ZenRouter officially achieved 100% test coverage 🚀
- **Docs**: Added migration guides from other packages (go_router, auto_route, and Navigator 1.0/2.0)
- **Docs**: Added recipes for common use cases
- **Docs**: Added quick links section to make the docs easier to navigate

## 0.4.16
- **Fix**: Future already completed bug when pushing the same route with `pushOrMoveToTop`.

## 0.4.15
- **Feat**: Add `onUpdate` method to `RouteTarget` for handling in-place route updates when navigating to the same route with different state.
- **Feat**: Add `bindLayout` method to `StackPath` as a convenient alternative for layout registration. (See [RouteLayout Guide](doc/guides/route-layout.md))

## 0.4.14
- **Breaking Change**: Don't allow `redirect` to return null anymore since it doesn't do anything.
- **Feat**: Add `mustCallSuper` to `paths` getter (Thanks @mrgnhnt96)
- **Feat**: Add `discard` parameter to `remove` method for controlling discarding behavior.
- **Fix**: Memory leak when pushing `RouteQueryParameters` in `IndexedStackPath`.
- **Fix**: Memory leak when discard route in `RouteRedirect`.

## 0.4.13
- **Fix**: Ensure `navigate` method is compatible with `RouteRedirect`.

## 0.4.12
- **Feat**: Introduce new `StackNavigatable` mixin for `StackPath` to handle custom logic when receiving a `navigate` command. (Back/Forward button on the browser)
- **Fix**: `navigate` clear all history that occurred when pushing a custom layout.

## 0.4.11
- **Feat**: Expose `stackPath` in `RouteTarget` and expose `protected` method for developer create custom `stackPath`.
- **Feat**: Add `onDiscard` to handle discarding phase in `RouteTarget`.

## 0.4.10
- **Chore**: Fix analyzer warnings

## 0.4.9
- **Chore**: Standardize `serialize` and `deserialize` for supported `RouteTarget` type

## 0.4.8
- **Feat**: Introduce new state restoration with `RouteRestoration` mixin. Support state restoration by default if `restorationScopeId` is provided in `MaterialApp.router` and using `Coordinator` pattern.
- **Fix**: Resolve bug in `recover` method where `RouteRedirect` was ignored.

## 0.4.7
- **Docs**: Update README

## 0.4.6
- **Docs**: Update README and add screenshots

## 0.4.5
- **Feat**: Add `RouteQueryParameters` mixin for targeted query parameter updates using `ValueNotifier`.
- **Fix**: Ensure `path` is set for `RouteTarget` when initial `IndexedStackPath`.
- **Fix**: Ensure `layout` is resolve correct if they under deeper stack.
- **Refactor**: Refactor folder structure and test folder structure to be more organized.

## 0.4.4
- **Feat**: New ZenRoute Logo!
- **Docs**: Improve document and update outdate example

## 0.4.3
- **Feat**: Add `CoordinatorNavigatorObserver` mixin to provide a list of observers for the coordinator's navigator.
- **Breaking Change**: Complete redesign [RouteLayout] builder to be more flexible and powerful.
  - Deprecate static method `RouteLayout.buildPrimitivePath` and use `buildPath` function instead.
  - Add ability to define new [StackPath] using `RouteLayout.definePath`. You can create custom behavior path builder. (Eg: RecoverableHistoryStack like unrouter)

## 0.4.2
- **Feat**: Add `transitionStrategy` to `Coordinator` for default stack transition setup
- **Fix**: Ensure when [Navigator.pop] called sync new stack with [NavigationPath]

## 0.4.1
- **Fix**: Ensure [Coordinator.routeDelegate] initialize once
- **Improvement**: Add [IndexedStackPathBuilder] for improve performance for rendering [IndexedStackPath]

## 0.4.0
- **Breaking Change**: Deprecated default constructors for `NavigationPath` and `IndexedStackPath`. Use `NavigationPath.create`/`createWith` and `IndexedStackPath.create`/`createWith` instead.
- **Breaking Change**: Introduced `internalProps` to `RouteTarget` for better deep equality and hash code generation.
- **Feat**: Added `popGuardWith` to `RouteGuard` and `redirectWith` to `RouteRedirect` for coordinator-aware mixin logic.
- **Feat**: Added strict path-coordinator binding support via `createWith` factories.
- **Docs**: Added comprehensive [Migration Guide](MIGRATION_GUIDE.md).
- **Feat**: Added `routerDelegateWithInitalRoute` to `Coordinator`.
- **Feat**: Enhanced `setInitialRoutePath` to correctly handle initial routes vs deep links.

## 0.3.2
- Add `navigate` function: A smarter alternative to `push` that handles browser history restoration by popping to existing routes instead of duplicating them.

## 0.3.1
- Allow `parseRouteFromUri` to return `Future` for implementing deferred import/async route parsing

## 0.3.0
- Breaking change: Change return of `Coordinator.push()` from `Future<dynamic>` to `Future<T?>`
- Fix `NavigationStack` rerender page everytime `path` updated. Resolve [#10](https://github.com/definev/zenrouter/issues/10).
- Feat: Add `recover` function

## 0.2.3
- Update `activePathIndex` to `activeIndex` in `IndexedStackPath`
- Update document for detailed, hand-written example of Coordinator pattern

## 0.2.2
- Expose pop result in Coordinator
- **Fix memory leak**: Complete route result futures when routes are removed via `pushOrMoveToTop`
- **Fix memory leak**: Complete intermediate route futures during `RouteRedirect.resolve` chain

## 0.2.1
- Standardize how to access primitive path layout builder
    - Define using `definePrimitivePath`
    - Build using `buildPrimitivePath`

## 0.2.0
- BREAKING: Rename `activeHostPaths` to `activeLayoutPaths` to reflect correct concept.

## 0.1.2
- Update homepage link

## 0.1.1
- Fix broken document link by update it to github link

## 0.1.1
- Fix broken document link

## 0.1.0

- Initial release of ZenRouter.
- Unified Navigator 1.0 and 2.0 support.
- Coordinator pattern for centralized navigation logic.
- Support for both Declarative and Imperative navigation paradigms.
- Route mixins: `RouteGuard`, `RouteRedirect`, `RouteDeepLink`.
- Optimized Myers diff algorithm for efficient stack updates.
- Type-safe routing with `RouteUnique`.



================================================
FILE: packages/zenrouter/LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Bui Dai Duong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: packages/zenrouter/MIGRATION_GUIDE.md
================================================
# Migration Guide

This guide outlines the changes and steps required to migrate to the latest version of `zenrouter`.

## Path Constructors

The constructors for `NavigationPath` and `IndexedStackPath` have been updated to provide better clarity and type safety, especially when binding to a `Coordinator`.

### Changes

- **Deprecated**: The default unnamed constructors `NavigationPath(...)` and `IndexedStackPath(...)`.
- **New**: `create` factory constructor for creating paths with optional arguments.
- **New**: `createWith` factory constructor for creating paths that are explicitly bound to a `Coordinator`.

### Migration

Replace direct constructor calls with `create` or `createWith`:

**Before:**
```dart
final path = NavigationPath(
  'root',
  [],
  coordinator,
);
```

**After (Standard):**
```dart
final path = NavigationPath.create(
  label: 'root',
  stack: [],
  coordinator: coordinator,
);
```

**After (With explicit Coordinator):**
```dart
late final path = NavigationPath.createWith(
  coordinator: this,
  label: 'root',
  stack: [],
);
```

Same applies to `IndexedStackPath`.

### Rationale

Deeply integrating paths with their coordinator using `createWith` provides several benefits:

1.  **Coordinator Awareness**: The path explicitly knows which coordinator it belongs to, enabling features like `popGuardWith` to verify that operations are happening in the correct context.
2.  **Safety**: Prevents a path from being used detached from its coordinator, which could lead to silent failures or incorrect state management.
3.  **Strict Binding**: The `late final ... = ... .createWith(coordinator: this, ...)` pattern ensures that the path and coordinator are 1:1 linked from the moment of creation, avoiding race conditions or initialization order issues.

### Trade-offs

*   **Coupling**: This approach tightly couples instances of `StackPath` to a specific `Coordinator`. While this is by design, it means paths are less "standalone".
*   **Testing**: Unit testing individual paths in isolation now requires providing a mock or dummy `Coordinator` if you use `createWith`, whereas previously they could be tested as simple data containers.
*   **Initialization**: Requires using `late final` variables in the `Coordinator` to handle the circular reference (Coordinator needs Path, Path needs Coordinator). Exceptions during initialization might be harder to debug if not careful.

**Why it is worth it:**
When using `createWith`, you are explicitly creating a path intended to work *with* a Coordinator. Therefore, this coupling is intentional and necessary. It guarantees that the path always has access to the correct context for advanced features like guards and redirects, making the system more robust and preventing common configuration errors.

## RouteGuard API

The `RouteGuard` mixin has been enhanced to support coordinator validation during pop operations.

### Changes

- **New**: `popGuardWith(Coordinator coordinator)` method.
  - This method is called by the framework when a pop is attempted.
  - It asserts that the route's path is associated with the correct coordinator.
  - It internally calls `popGuard()`.

- **Existing**: `popGuard()` remains the place to implement your custom guard logic.

### Migration

If you are manually calling `popGuard` in your custom logic or tests, consider using `popGuardWith` if you have access to the coordinator to benefit from the additional checks.

No changes are needed for existing `popGuard` implementations unless you are overriding the default behavior significantly.

## RouteRedirect API

The `RouteRedirect` mixin has been updated similarly to `RouteGuard`.

### Changes

- **New**: `redirectWith(Coordinator coordinator)` method.
  - Called by the framework during route resolution.
  - Helps ensuring the path belongs to the correct coordinator context.
  - Internally calls `redirect()`.

- **Existing**: `redirect()` remains the place to implement your redirect logic.

## Internal Properties (`internalProps`)

A new property `internalProps` has been introduced to the `Equatable` base class (and consequently `RouteTarget`) to handling deep comparison and hashing of internal state.

### Changes

- **`internalProps`**: A list of properties used for calculating `hashCode` and ensuring object identity, separate from the public `props`.
- `RouteTarget` now includes `runtimeType`, `_path`, and the internal result completer in `internalProps`.

### Impact

This ensures that `RouteTarget` instances are correctly distinguished even if they have identical configuration `props`, especially when they belong to different paths or have different lifecycle states. This improves the reliability of deep comparisons and sets containing routes.



================================================
FILE: packages/zenrouter/pubspec.yaml
================================================
name: zenrouter
description: >-
  A powerful Flutter router with deep linking, web support, type-safe routing,
  guards, redirects, and zero boilerplate.
version: 1.2.0

repository: https://github.com/definev/zenrouter
homepage: https://github.com/definev/zenrouter/tree/main/packages/zenrouter
issue_tracker: https://github.com/definev/zenrouter/issues
documentation: https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/getting-started.md

topics:
  - router
  - navigation
  - zenrouter
  - state-restoration
  - deep-linking

screenshots:
  - description: "Zen Logo for ZenRouter"
    path: screenshots/logo_light.png

environment:
  sdk: ^3.8.0
  flutter: ">=3.0.0"

resolution: workspace

dependencies:
  flutter:
    sdk: flutter
  collection: ^1.19.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0



================================================
FILE: packages/zenrouter/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: package



================================================
FILE: packages/zenrouter/.pubignore
================================================
doc/api
doc/paradigms
doc/guides
example/android
example/ios
example/linux
example/macos
example/web
example/windows
build


================================================
FILE: packages/zenrouter/doc/DOCUMENTATION_ROADMAP.md
================================================
# ZenRouter Documentation Roadmap

Welcome to the ZenRouter documentation! This roadmap helps you navigate our comprehensive guides based on your needs.

## 🎯 For New Users

### Start Here
1. **[README.md](../README.md)** - Overview and quick paradigm selection
2. **[Getting Started Guide](guides/getting-started.md)** - Installation and paradigm quick starts

### Learn Your Paradigm
Choose based on your needs:
- **Simple mobile app?** → [Imperative Pattern](paradigms/imperative.md)
- **State-driven UI?** → [Declarative Pattern](paradigms/declarative.md)
- **Web/deep linking?** → [Coordinator Pattern](paradigms/coordinator/coordinator.md)

### Build Common Features
Explore our [Recipes & Cookbook](recipes/):
- [404 Handling](recipes/404-handling.md) - Custom error pages
- [Bottom Navigation](recipes/bottom-navigation.md) - Tab bars with persistent state
- [Authentication Flow](recipes/authentication-flow.md) - Guards and protected routes

---

## 🔄 For Migrating Users

Coming from another router? We have dedicated migration guides:

| Your Current Router | Migration Guide | Key Topics |
|---------------------|-----------------|------------|
| go_router | [from-go-router.md](migration/from-go-router.md) | GoRoute → RouteTarget, ShellRoute → RouteLayout |
| auto_route | [from-auto-route.md](migration/from-auto-route.md) | Removing build_runner, AutoTabsRouter → IndexedStackPath |
| Navigator 1.0/2.0 | [from-navigator.md](migration/from-navigator.md) | Named routes → Type-safe classes |

---

## 🍳 By Use Case

### Basic Navigation
1. [Getting Started - Imperative](guides/getting-started.md#imperative-quick-start)
2. [Navigation Paths API](api/navigation-paths.md)

### Tab Navigation  
1. [Getting Started - Declarative](guides/getting-started.md#declarative-quick-start)
2. [Bottom Navigation Recipe](recipes/bottom-navigation.md)

### Web & Deep Linking
1. [Getting Started - Coordinator](guides/getting-started.md#coordinator-quick-start)
2. [Coordinator Pattern Guide](paradigms/coordinator/coordinator.md)
3. [Coordinator Modular Guide](guides/coordinator-modular.md)
4. [Coordinator as RouteModule Guide](guides/coordinator-as-module.md)
5. [URL Strategies Recipe](recipes/url-strategies.md)
6. [Route Versioning Recipe](recipes/route-versioning.md)

### Authentication & Guards
1. [Authentication Flow Recipe](recipes/authentication-flow.md)
2. [Route Mixins - RouteRedirect](api/mixins.md#routeredirect)

### Custom Transitions
1. [Route Transitions Recipe](recipes/route-transitions.md)
2. [Route Mixins - RouteTransition](api/mixins.md#routetransition)

### State Management
1. [State Management Recipe](recipes/state-management.md)
2. [State Restoration Guide](guides/state-restoration.md)

---

## 📖 By Document Type

### 📚 Guides (Learning-Oriented)
Step-by-step tutorials for getting started:
- [Getting Started](guides/getting-started.md) - Choose and learn your paradigm
- [Route Layout](guides/route-layout.md) - Create custom layouts
- [Coordinator Modular](guides/coordinator-modular.md) - Split coordinator into modules
- [Coordinator as RouteModule](guides/coordinator-as-module.md) - Nest coordinators as modules
- [Query Parameters](guides/query-parameters.md) - Handle URL query parameters  
- [State Restoration](guides/state-restoration.md) - Android state preservation
- [Navigator Observers](guides/navigator-observers.md) - Track navigation events

### 🍳 Recipes (Problem-Oriented)
Practical solutions for specific scenarios:
- [404 Handling](recipes/404-handling.md)
- [Authentication Flow](recipes/authentication-flow.md)
- [Bottom Navigation](recipes/bottom-navigation.md)
- [Route Transitions](recipes/route-transitions.md)
- [Route Versioning](recipes/route-versioning.md)
- [State Management](recipes/state-management.md)
- [URL Strategies](recipes/url-strategies.md)

### 🔧 API Reference (Information-Oriented)
Complete technical documentation:
- [Core Classes](api/core-classes.md) - RouteTarget fundamentals
- [Navigation Paths](api/navigation-paths.md) - NavigationPath, IndexedStackPath
- [Route Mixins](api/mixins.md) - Guards, redirects, transitions
- [Coordinator API](api/coordinator.md) - Deep linking reference

### 🎓 Paradigm Guides (Understanding-Oriented)
Deep dives into each pattern:
- [Imperative Pattern](paradigms/imperative.md)
- [Declarative Pattern](paradigms/declarative.md)
- [Coordinator Pattern](paradigms/coordinator/coordinator.md)

### 🔄 Migration Guides (Task-Oriented)
Switching from other routers:
- [From go_router](migration/from-go-router.md)
- [From auto_route](migration/from-auto-route.md)
- [From Navigator 1.0/2.0](migration/from-navigator.md)

---

## 📊 Documentation Structure

```
zenrouter/
├── README.md                    # Quick overview & links
├── doc/
    ├── guides/                # Step-by-step learning
    │   ├── getting-started.md
    │   ├── route-layout.md
    │   ├── coordinator-modular.md
    │   ├── coordinator-as-module.md
    │   ├── query-parameters.md
    │   ├── state-restoration.md
    │   └── navigator-observers.md
    │
    ├── recipes/               # Practical solutions
    │   ├── README.md            # Recipe index
    │   ├── 404-handling.md
    │   ├── authentication-flow.md
    │   ├── bottom-navigation.md
    │   ├── route-transitions.md
    │   ├── route-versioning.md
    │   ├── state-management.md
    │   └── url-strategies.md
    │
    ├── migration/             # Switching routers
    │   ├── README.md            # Migration index
    │   ├── from-go-router.md
    │   ├── from-auto-route.md
    │   └── from-navigator.md
    │
    ├── api/                   # Technical reference
    │   ├── core-classes.md
    │   ├── navigation-paths.md
    │   ├── mixins.md
    │   └── coordinator.md
    │
    └── paradigms/             # Pattern deep dives
        ├── imperative.md
        ├── declarative.md
        └── coordinator/
            └── coordinator.md
```

---

## ✨ Quick Reference

### Core Concepts
- **RouteTarget** - Base class for all routes ([Core Classes](api/core-classes.md))
- **NavigationPath** - Stack container ([Navigation Paths](api/navigation-paths.md))
- **Coordinator** - Deep linking coordinator ([Coordinator API](api/coordinator.md))
- **CoordinatorModular** - Modular route delegation ([Modular Guide](guides/coordinator-modular.md))
- **Coordinator as RouteModule** - Nested coordinator modules ([Guide](guides/coordinator-as-module.md))

### Route Mixins
- **RouteUnique** - URI-based equality ([Mixins](api/mixins.md#routeunique))
- **RouteRedirect** - Guards and redirects ([Mixins](api/mixins.md#routeredirect))
- **RouteGuard** - Pop prevention ([Mixins](api/mixins.md#routeguard))
- **RouteLayout** - Custom layouts ([Route Layout Guide](guides/route-layout.md))
- **RouteQueryParameters** - Reactive query params ([Query Parameters Guide](guides/query-parameters.md))

### Navigation Paths
- **NavigationPath** - Standard stack ([Navigation Paths](api/navigation-paths.md#navigationpath))
- **IndexedStackPath** - Tab navigation ([Navigation Paths](api/navigation-paths.md#indexedstackpath))

---

## 🎯 Learning Paths

### Path 1: Mobile-First Developer
1. [Imperative Quick Start](guides/getting-started.md#imperative-quick-start)
2. [Route Transitions Recipe](recipes/route-transitions.md)
3. [Authentication Flow Recipe](recipes/authentication-flow.md)
4. [State Management Recipe](recipes/state-management.md)

### Path 2: Web Developer
1. [Coordinator Quick Start](guides/getting-started.md#coordinator-quick-start)
2. [URL Strategies Recipe](recipes/url-strategies.md)
3. [404 Handling Recipe](recipes/404-handling.md)
4. [Coordinator Pattern Guide](paradigms/coordinator/coordinator.md)

### Path 3: Flutter Veteran (migrating)
1. Choose migration guide:
   - [From go_router](migration/from-go-router.md)
   - [From auto_route](migration/from-auto-route.md)  
   - [From Navigator](migration/from-navigator.md)
2. [Getting Started](guides/getting-started.md) - Map to ZenRouter concepts
3. [Recipes](recipes/) - See advanced patterns
4. [API Reference](api/) - Complete technical details

---

## 📝 Documentation Principles

### 1. **Calm and In Control**
Documentation should make you feel confident, not overwhelmed.

### 2. **Progressive Disclosure**
Start simple, reveal complexity as needed.

### 3. **Practical Examples**
Every concept has runnable code.

### 4. **Multiple Entry Points**
Find what you need from any starting point.

---

## 🔗 External Resources

- **GitHub Repository**: [definev/zenrouter](https://github.com/definev/zenrouter)
- **Pub.dev Package**: [pub.dev/packages/zenrouter](https://pub.dev/packages/zenrouter)
- **Example Apps**: [GitHub Examples](https://github.com/definev/zenrouter/tree/main/packages/zenrouter/example)
- **Issue Tracker**: [GitHub Issues](https://github.com/definev/zenrouter/issues)
- **Discussions**: [GitHub Discussions](https://github.com/definev/zenrouter/discussions)

---

**Last Updated**: 2026-01-06  
**Version**: 0.4.14

---

🧘 **Happy routing with ZenRouter!**



================================================
FILE: packages/zenrouter/doc/api/coordinator.md
================================================
# Coordinator API

Complete API reference for the `Coordinator` class and related types.

## Overview

The `Coordinator` class manages multiple navigation paths, handles deep linking, and synchronizes navigation with URLs. It's the central router for the coordinator paradigm.

---

## Coordinator<T>

Base class for creating coordinators.

### Class Definition

```dart
abstract class Coordinator<T extends RouteUnique> {
  // Main navigation path (always present)
  final NavigationPath<T> root;
  
  // Additional paths for nested navigation
  List<StackPath> get paths;

  // Active state properties
  RouteLayout? get activeLayout;
  List<RouteLayout> get activeLayouts;
  List<StackPath> get activeLayoutPaths;
  StackPath<T> get activePath;
  Uri get currentUri;
  NavigatorState get navigator;
  
  // Parse URLs into routes
  T parseRouteFromUri(Uri uri);
  
  // Navigation methods
  Future<dynamic> push(T route);
  void pop();
  void replace(T route);
  void pushOrMoveToTop(T route);
  Future<bool?> tryPop();
  
  // Router integration
  CoordinatorRouterDelegate get routerDelegate;
  CoordinatorRouteParser get routeInformationParser;
}
```

### Creating a Coordinator

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  // Define navigation paths
  late final homeStack = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'home',
  );
  
  late final tabPath = IndexedStackPath<AppRoute>.createWith(
    [
      FeedTab(),
      ProfileTab(),
      SettingsTab(),
    ],
    coordinator: this,
    label: 'tab',
  );
  
  @override
  List<StackPath> get paths => [root, homeStack, tabPath];
  
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile', final id] => ProfileRoute(id),
      ['settings'] => SettingsRoute(),
      _ => NotFoundRoute(uri),
    };
  }
}

// Use with MaterialApp.router
final coordinator = AppCoordinator();

MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
)
```

---

## Properties

### `root` → `NavigationPath<T>`

The main navigation path. Always present and managed by the coordinator.

```dart
// Access the root stack
coordinator.root.stack;

// Get current root route
final currentRoute = coordinator.root.stack.last;

// Check stack depth
if (coordinator.root.stack.length > 1) {
  print('Can go back');
}
```

**Note:** You typically don't manipulate `root` directly - use coordinator methods like `push()`, `pop()`, etc.

### `paths` → `List<StackPath>`

All navigation paths managed by this coordinator.

**Must include:** The `root` path plus any additional paths for nested navigation.

```dart
@override
List<StackPath> get paths => [
  root,              // Main path (required!)
  homeStack,         // Home navigation
  settingsStack,     // Settings navigation
  tabPath,           // Tab bar (fixed)
  feedStack,         // Feed nested navigation
];
```

**Important:** Always include `root` in the list!

### `activeLayout` → `RouteLayout?`

Returns the deepest active `RouteLayout` in the navigation hierarchy.

Returns `null` if the root is the active layout.

### `activeLayouts` → `List<RouteLayout>`

Returns all active `RouteLayout` instances in the navigation hierarchy, from root to deepest.

### `activeLayoutPaths` → `List<StackPath>`

Returns the list of active layout paths in the navigation hierarchy, starting from `root`.

### `activePath` → `StackPath<T>`

Returns the currently active `StackPath`. This is the path that contains the currently active route.

### `currentUri` → `Uri`

Returns the current URI based on the active route.

### `navigator` → `NavigatorState`

Access to the `NavigatorState`.

### `routerDelegate` → `CoordinatorRouterDelegate`

Router delegate for `MaterialApp.router`.

Manages the navigator stack and handles system navigation events (back button, etc.).

```dart
MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
)
```

**Access Navigator:**
```dart
// Get the navigator context
final context = coordinator.routerDelegate.navigatorKey.currentContext;

// Get the navigator state
final navigator = coordinator.routerDelegate.navigatorKey.currentState;
```

### `routeInformationParser` → `CoordinatorRouteParser`

Route information parser for URL handling.

Converts between `RouteInformation` and `Uri`.

```dart
MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
)
```

Also available as `routeInformationParser` for convenience:
```dart
coordinator.routeInformationParser; // Same as coordinator.routeInformationParser
```

---

## Methods

### `parseRouteFromUri(Uri uri)` → `T`

**Abstract method** - You must implement this to parse URLs into routes.

Called when:
- App opens with a deep link
- User navigates to a URL in browser
- `recoverRouteFromUri()` is called manually

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    [] => HomeRoute(),
    ['profile', final id] => ProfileRoute(id),
    ['settings'] => SettingsRoute(),
    ['product', final id] => ProductRoute(id),
    _ => NotFoundRoute(uri),
  };
}
```

**With query parameters:**
```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  final filter = uri.queryParameters['filter'];
  final sort = uri.queryParameters['sort'];
  
  return switch (uri.pathSegments) {
    ['products'] => ProductListRoute(filter: filter, sort: sort),
    _ => NotFoundRoute(uri),
  };
}
```

**Tips:**
- Use pattern matching for clean URL parsing
- Handle query parameters when needed
- Always return a route (use NotFound for unmatched URLs)
- Consider using named parameters: `['user', final userId]`

**Best practice:** Use sealed classes for exhaustive matching!
```dart
sealed class AppRoute extends RouteTarget with RouteUnique {}

@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    [] => HomeRoute(),
    ['profile'] => ProfileRoute(),
    // Compiler ensures all routes are handled!
  };
}
```

### `push(T route)` → `Future<dynamic>`

Pushes a route onto its appropriate navigation path.

The coordinator automatically:
1. Resolves which path the route belongs to (via `route.layout`)
2. Ensures all parent layouts are in place
3. Pushes the route to the correct path
4. Updates the browser URL

```dart
// Simple push
await coordinator.push(ProfileRoute('user123'));

// The coordinator figures out:
// 1. Which path ProfileRoute belongs to
// 2. What parent layouts need to be created
// 3. Pushes route to correct path
// 4. Updates URL to /profile/user123
```

**With nested navigation:**
```dart
class FeedDetailRoute extends AppRoute {
  @override
  Type? get layout => FeedTabLayout;
}

// Pushing FeedDetailRoute
coordinator.push(FeedDetailRoute('123'));

// Coordinator automatically:
// 1. Creates/resolves FeedTabLayout
// 2. Pushes FeedDetailRoute to feedStack
// 3. Updates URL
```

**With redirects:**
```dart
class ProtectedRoute extends AppRoute with RouteRedirect {
  @override
  Future<AppRoute> redirect() async {
    return await auth.check() ? this : LoginRoute();
  }
}

// If not authenticated, redirects to LoginRoute
coordinator.push(ProtectedRoute());
```

**Returns:** Future that completes when route resolution is done.

### `pop()` → `void`

Pops the last route from the nearest dynamic path.

The coordinator:
1. Finds the deepest active dynamic path
2. Consults route guards (if present)
3. Pops the route if guard allows
4. Cleans up empty paths
5. Updates the browser URL

```dart
await coordinator.pop();
```

**With guards:**
```dart
class GuardedRoute extends AppRoute with RouteGuard {
  @override
  Future<bool> popGuard() async {
    return await confirmExit();
  }
}

// If current route is GuardedRoute
await coordinator.pop(); // Guard is consulted first
```

**Behavior:**
- If stack becomes empty after pop, the coordinator handles cleanup
- Browser back button automatically calls `pop()`
- Returns `void`

### `replace(T route)` → `void`

Wipes the current navigation stack and replaces it with the new route.

All paths are cleared and the route is pushed to the appropriate path.

```dart
// Replace entire navigation with login
await coordinator.replace(LoginRoute());
// All previous routes are cleared
// Stack is now just [LoginRoute]

// After logout
coordinator.replace(WelcomeRoute());

// After completing a flow
coordinator.replace(DashboardRoute());
```

**Use cases:**
- Logging out (clear authenticated routes, show login)
- Completing wizards (clear wizard routes, show result)
- Resetting navigation state

**Note:** Unlike `push()`, this **does not** consult guards. It's a forced reset.

### `pushOrMoveToTop(T route)` → `void`

Pushes a route or moves it to the top if already present in its path.

Useful for tab navigation where you don't want duplicates.

```dart
// Switch tabs without duplicating routes
onTap: (index) => switch (index) {
  0 => coordinator.pushOrMoveToTop(FeedTab()),
  1 => coordinator.pushOrMoveToTop(ProfileTab()),
  2 => coordinator.pushOrMoveToTop(SettingsTab()),
  _ => null,
}
```

**Behavior:**
- If route is already in its path, it's moved to the top
- If not present, it's pushed normally
- Follows redirects (like `push()`)
- Updates URL

### `pushReplacement<R, RO>(T route, {RO? result})` → `Future<R?>`

Pops the current route and pushes a new route in its place.

**Parameters:**
- `route`: The new route to push after popping
- `result`: Optional value to pass to the popped route's `push()` Future

**Returns:** A `Future` that completes when the new route is popped. Returns `null` if redirect resolution fails or guard blocks the pop.

```dart
// Replace current screen without adding to history
await coordinator.pushReplacement(HomeRoute());

// Replace with result for the popped route
await coordinator.pushReplacement<void, String>(
  HomeRoute(),
  result: 'completed',
);
```

**Result handling:**
```dart
// Screen A pushes B and waits for result
final result = await coordinator.push<String>(ScreenBRoute());
print('Got: $result'); // Prints: Got: from_c

// Screen B replaces itself with C, passing result to A
coordinator.pushReplacement<void, String>(
  ScreenCRoute(),
  result: 'from_c',
);
```

**Behavior:**
1. Resolves any `RouteRedirect`s
2. Ensures required `RouteLayout` hierarchy is active
3. Delegates to `StackMutatable.pushReplacement`:
   - On single-element stack: completes the route and pushes new one
   - On multi-element stack: pops (respecting guards), then pushes
4. Updates the browser URL

**Use cases:**
- Login → Home transition (back should not return to login)
- Splash/Loading → Main content transition
- Wizard flows where previous steps shouldn't be revisited
- Replacing temporary screens with actual content

**With guards:**
```dart
// If current route has RouteGuard that returns false
final result = await coordinator.pushReplacement(HomeRoute());
// Returns null if guard blocks the pop
```

### `recoverRouteFromUri(Uri uri)` → `Future<void>`

Handles navigation from a deep link URI.

Called automatically when:
- App opens with a deep link
- Browser URL changes
- System navigation event occurs

Can also be called manually:

```dart
// Handle a custom deep link
await coordinator.recoverRouteFromUri(
  Uri.parse('myapp://product/123?ref=email'),
);

// Parse and navigate
final uri = Uri.parse('/profile/settings');
await coordinator.recoverRouteFromUri(uri);
```

**Process:**
1. Calls `parseRouteFromUri(uri)` to get the route
2. Checks if route has `RouteDeepLink` mixin
3. If yes and strategy is `custom`: Calls `route.deeplinkHandler()`
4. If yes and strategy is `push`: Calls `push(route)`
5. If no or strategy is `replace`: Calls `replace(route)` (default)

**Deep link strategies:**
```dart
class MyRoute extends AppRoute with RouteDeepLink {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(Coordinator coordinator, Uri uri) async {
    // Custom setup logic
    coordinator.replace(HomeTab());
    coordinator.push(this);
    analytics.logDeepLink(uri);
  }
}
```

### `defineLayout()` → `void`

Registers layout constructors for Type-based layout creation.

**Override** to register your layout types:

```dart
@override
void defineLayout() {
  RouteLayout.defineLayout(TabBarLayout, () => TabBarLayout());
  RouteLayout.defineLayout(SettingsLayout, () => SettingsLayout());
  RouteLayout.defineLayout(ProductsLayout, () => ProductsLayout());
}
```

**Required when:**
- Using `RouteLayout` with nested navigation
- Routes specify a `layout` Type

**Important:** Call this in your Coordinator constructor (happens automatically).

### `layoutBuilder(BuildContext context)` → `Widget`

Builds the root widget (the primary navigator).

**Override** to customize the root navigation structure:

```dart
@override
Widget layoutBuilder(BuildContext context) {
  return Scaffold(
    body: RouteLayout.buildRoot(this),
    drawer: Drawer(
      child: DrawerContent(),
    ),
  );
}
```

**Default implementation:**
```dart
@override
Widget layoutBuilder(BuildContext context) {
  return RouteLayout.buildRoot(this);
}
```

### `tryPop()` → `Future<bool?>`

Attempts to pop the nearest dynamic path.

**Returns:**
- `true` if the route was popped
- `false` if the route prevented the pop (via guard)
- `null` if the guard wants manual control

```dart
final didPop = await coordinator.tryPop();
if (didPop == true) {
  print('Successfully popped');
} else if (didPop == false) {
  print('Pop was blocked by guard');
} else {
  print('Guard is handling it manually');
}
```

**With guards:**
```dart
class EditorRoute extends AppRoute with RouteGuard {
  @override
  Future<bool> popGuard() async {
    // Return false to prevent pop
    if (hasUnsavedChanges) return false;
    return true;
  }
}
```

**Note:** Called automatically by system back button. You rarely need to call this manually.

---

## Mixins

### CoordinatorNavigatorObserver

Mixin that provides a list of observers for the coordinator's navigator.

When applied to a `Coordinator`, this mixin allows you to define global `NavigatorObserver`s that will be automatically applied to all `NavigationStack` widgets that use this coordinator.

#### Mixin Definition

```dart
mixin CoordinatorNavigatorObserver on Coordinator {
  /// A list of observers that apply for every NavigationPath in the coordinator.
  List<NavigatorObserver> get observers;
}
```

#### Usage

```dart
class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  
  // Define global observers
  @override
  List<NavigatorObserver> get observers => [
    MyAnalyticsObserver(),
    MyLoggingObserver(),
  ];
  
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    // ... route parsing
  }
}
```

#### How It Works

When a `NavigationStack` is created with a coordinator that has this mixin:

1. The `NavigationStack` checks if the coordinator implements `CoordinatorNavigatorObserver`
2. If yes, it combines the coordinator's observers with any local observers
3. All observers are passed to the underlying `Navigator` widget

```dart
// In NavigationStack
Navigator(
  observers: [
    ...coordinator.observers,  // From CoordinatorNavigatorObserver
    ...widget.observers,        // Local observers
  ],
)
```

#### Example: Analytics Observer

```dart
class AnalyticsObserver extends NavigatorObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    analytics.logScreenView(route.settings.name);
  }
  
  @override
  void didPop(Route route, Route? previousRoute) {
    analytics.logScreenView(previousRoute?.settings.name);
  }
}

class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  
  @override
  List<NavigatorObserver> get observers => [
    AnalyticsObserver(),
  ];
  
  // ... rest of coordinator
}
```

#### Example: Combining Global and Local Observers

```dart
// Global observers in coordinator
class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  
  @override
  List<NavigatorObserver> get observers => [
    AnalyticsObserver(),      // Track all navigation
    PerformanceObserver(),    // Monitor performance
  ];
}

// Local observers in NavigationStack
NavigationStack<AppRoute>(
  path: coordinator.root,
  coordinator: coordinator,
  observers: [
    DebugObserver(),  // Only for this stack
  ],
  resolver: (route) => route.transition,
)

// Result: Navigator gets all three observers:
// [AnalyticsObserver, PerformanceObserver, DebugObserver]
```

#### Example: Logging Observer

```dart
class LoggingObserver extends NavigatorObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    print('📍 Pushed: ${route.settings.name}');
  }
  
  @override
  void didPop(Route route, Route? previousRoute) {
    print('📍 Popped: ${route.settings.name}');
  }
  
  @override
  void didRemove(Route route, Route? previousRoute) {
    print('📍 Removed: ${route.settings.name}');
  }
  
  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    print('📍 Replaced: ${oldRoute?.settings.name} → ${newRoute?.settings.name}');
  }
}

class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  
  @override
  List<NavigatorObserver> get observers => [
    if (kDebugMode) LoggingObserver(),
  ];
}
```

#### Benefits

- **Centralized Monitoring**: Define observers once in the coordinator instead of repeating them for each `NavigationStack`
- **Consistent Tracking**: Ensures all navigation paths use the same observers
- **Easy Testing**: Mock or replace observers at the coordinator level
- **Clean Separation**: Keep navigation logic separate from observation logic

#### When to Use

Use `CoordinatorNavigatorObserver` when you need to:
- Track all navigation events for analytics
- Log navigation for debugging
- Monitor performance across all routes
- Implement global navigation behaviors
- Test navigation flows

Use local observers (on `NavigationStack`) when you need:
- Stack-specific tracking
- Different observers for different navigation contexts
- Temporary debugging observers

---

## Related Classes

### CoordinatorRouterDelegate<T>

Router delegate that connects the coordinator to Flutter's Router.

**Properties:**
- `navigatorKey` → Key for accessing navigator state
- `currentConfiguration` → Current URI

**Methods:**
- `build(BuildContext)` → Builds the navigator widget
- `setNewRoutePath(Uri)` → Handles URL changes
- `popRoute()` → Handles system back button

**Usage:**
```dart
// Access navigator
final context = coordinator.routerDelegate.navigatorKey.currentContext;
final navigator = coordinator.routerDelegate.navigatorKey.currentState;

// Get current URL
final uri = coordinator.routerDelegate.currentConfiguration;
```

### CoordinatorRouteParser<T>

Parses `RouteInformation` to and from `Uri`.

**Methods:**
- `parseRouteInformation(RouteInformation)` → Parses to URI
- `restoreRouteInformation(Uri)` → Converts back to RouteInformation

**Usage:**
```dart
// Typically used automatically by MaterialApp.router
MaterialApp.router(
  routeInformationParser: coordinator.routeInformationParser,
  routerDelegate: coordinator.routerDelegate,
)
```

---

## Extension Types

### CoordinatorUtils<T>

Utility methods for `NavigationPath`.

```dart
extension type CoordinatorUtils<T extends RouteTarget>(
  NavigationPath<T> path
) {
  // Clears the path and sets a single route
  void setRoute(T route);
}
```

**Usage:**
```dart
// Clear and set a single route
CoordinatorUtils(coordinator.homeStack).setRoute(HomeRoute());

// Or directly if imported
coordinator.homeStack.setRoute(HomeRoute());
```

---

## Complete Example

```dart
// Define routes
sealed class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => coordinator.push(ProfileRoute()),
          child: const Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: const Center(child: Text('Profile Page')),
    );
  }
}

// Create coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile'] => ProfileRoute(),
      _ => HomeRoute(),
    };
  }
}

// Use in app
void main() {
  runApp(const MyApp());
}

final coordinator = AppCoordinator();

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}
```

---

## See Also

- [Coordinator Pattern Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) - Complete usage guide
- [Route Mixins](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/mixins.md) - RouteUnique, RouteLayout, RouteDeepLink
- [Navigation Paths](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md) - NavigationPath, IndexedStackPath
- [Deep Linking Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/deep-linking.md) - Deep linking setup (if exists)



================================================
FILE: packages/zenrouter/doc/api/mixins.md
================================================
# Route Mixin System

> **Compose route behavior with mixins**

ZenRouter uses a mixin-based architecture that lets you add specific behaviors to your routes. Instead of a deep inheritance hierarchy, you compose functionality by mixing in exactly what you need.

## Overview

```dart
class MyRoute extends RouteTarget    // Base class (required)
    with RouteUnique                 // For coordinator (optional)
    with RouteGuard                  // Prevent navigation (optional)
    with RouteRedirect               // Conditional routing (optional)
    with RouteRedirect               // Conditional routing (optional)
    with RouteDeepLink               // Custom deep link handling (optional)
    with RouteQueryParameters {      // Efficient query handling (optional)
  // Your route implementation
}
```

Each mixin adds specific capabilities:
- **RouteUnique** - Makes route work with Coordinator
- **RouteLayout** - Creates navigation layout for nested routes
- **RouteTransition** - Custom page transitions
- **RouteGuard** - Prevents unwanted navigation
- **RouteRedirect** - Redirects to different routes
- **RouteRedirectRule** - Composable redirect rules (works with RouteRedirect)
- **RouteDeepLink** - Custom deep link handling
- **RouteQueryParameters** - Efficiently handle query parameters

### Decision Tree

```
Which mixins do I need?
│
├─ Need custom page transitions?
│  ├─ Yes → Add RouteTransition ✓
│  └─ No → Continue
│
├─ Prevent navigation (unsaved changes)?
│  ├─ Yes → Add RouteGuard ✓
│  └─ No → Continue
│
├─ Conditional routing (auth, permissions)?
│  ├─ Need reusable/composable rules?
│  │  ├─ Yes → Add RouteRedirect + RouteRedirectRule ✓
│  │  └─ No → Add RouteRedirect ✓
│  └─ No → Continue
│
├─ Using Coordinator?
│  ├─ Yes → Add RouteUnique ✓
│  └─ No → Just extend RouteTarget
│
├─ Creating a navigation layout (tabs, navigation-stack)?
│  ├─ Yes → Add RouteLayout ✓
│  └─ No → Continue
│
└─ Custom deep link handling?
   ├─ Yes → Add RouteDeepLink ✓
   └─ No → Continue
│
└─ Need query parameters with granular updates?
   ├─ Yes → Add RouteQueryParameters ✓
   └─ Done!
```


## Mixin Reference

### RouteUnique

Makes a route identifiable by `Coordinator` and provides URI mapping. This mixin is **required** when using the Coordinator pattern for deep linking and URL synchronization.

**Required when:**
- Using the Coordinator pattern
- You need deep linking support
- You want URL synchronization

**Not needed when:**
- Using pure imperative navigation
- Using pure declarative navigation without Coordinator

#### Recommended Pattern

When using `RouteUnique`, **create a base abstract class first** that extends `RouteTarget` with the `RouteUnique` mixin. Then have all your app routes extend this base class:

```dart
abstract class AppRoute extends RouteTarget with RouteUnique {}
```

**Why this pattern?**
1. **Narrows Coordinator scope** - Your `Coordinator<AppRoute>` only works with `AppRoute` types, providing strong type safety
2. **Better library context** - The internal library can accurately infer types and handle routing logic more efficiently
3. **Cleaner architecture** - Single source of truth for your app's route contract
4. **Covariant coordinator** - Routes receive your specific `AppCoordinator` type in `build()` methods, giving access to custom methods

> [!IMPORTANT]
> The `Coordinator` class is **covariant**. When you create `AppCoordinator extends Coordinator<AppRoute>`, the `build()` method in your routes will receive `AppCoordinator` (not generic `Coordinator`), providing type-safe access to any custom methods or properties you add.

#### API

```dart
mixin RouteUnique on RouteTarget {
  // Convert route to URI
  Uri toUri();
  
  // Build the UI for this route
  Widget build(covariant Coordinator coordinator, BuildContext context);
  
  // Optional: Parent layout Type
  Type? get layout => null;
  
  // Create a new layout instance (called automatically)
  RouteLayout? createLayout(covariant Coordinator coordinator);
  
  // Resolve or create layout from active layouts (called automatically)
  RouteLayout? resolveLayout(covariant Coordinator coordinator);
}
```

#### Example: Basic Setup

```dart
// 1. Create base route class
abstract class AppRoute extends RouteTarget with RouteUnique {}

// 2. Define concrete routes
class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => coordinator.push(ProfileRoute()),
          child: const Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: const Center(child: Text('Profile Page')),
    );
  }
}

// 3. Create coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile'] => ProfileRoute(),
      _ => NotFoundRoute(),
    };
  }
}
```

#### Example: With Parameters

```dart
class UserRoute extends AppRoute {
  final String userId;
  
  UserRoute(this.userId);
  
  @override
  Uri toUri() => Uri.parse('/user/$userId');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('User: $userId')),
      body: UserProfile(userId: userId),
    );
  }
  
  @override
  List<Object?> get props => [userId];
}
```

---

### RouteLayout<T>

Creates a navigation layout that contains and manages other routes, essential for building nested navigation hierarchies like tab bars, drawers, and shell routes.

`RouteLayout` acts as a layout for `StackPath` instances. Each type of stack path requires its own corresponding layout widget. ZenRouter provides two built-in path types: `NavigationPath` (for stack-based push/pop navigation) uses `NavigationStack` as its layout, while `IndexedStackPath` (for tab bars and indexed navigation) uses `IndexedStack` as its layout.

**Custom Layouts**: You can create your own layout types by implementing the `RouteLayout` mixin, registering the constructor in `layoutConstructorTable`, and providing the default widget builder in `layoutBuilderTable`. For more details, check out the advanced tutorial.

#### API

```dart
mixin RouteLayout<T extends RouteUnique> on RouteUnique {
  // Which navigation path does this layout manage?
  StackPath<RouteUnique> resolvePath(covariant Coordinator coordinator);
  
  // Builds the layout UI (automatically delegates to layoutBuilderTable)
  @override
  Widget build(covariant Coordinator coordinator, BuildContext context);
  
  // Optional: Parent layout Type (for nested layouts)
  @override
  Type? get layout => null;
  
  // Static tables for layout construction and building
  static Map<Type, RouteLayoutConstructor> layoutConstructorTable = {};
  static Map<String, RouteLayoutBuilder> layoutBuilderTable = {...};
  
  // Register a layout constructor
  static void defineLayout<T extends RouteLayout>(
    Type layoutType,
    T Function() constructor,
  );
}
```

#### Example: Tab Bar Layout (Indexed Navigation)

```dart
class TabBarLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.tabPath;
  
  @override
  Uri toUri() => Uri.parse('/tabs');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = coordinator.tabPath;
    
    return Scaffold(
      body: buildPath(coordinator),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: path.activePathIndex,
        onTap: (index) => switch (index) {
          0 => coordinator.push(FeedTab()),
          1 => coordinator.push(ProfileTab()),
          2 => coordinator.push(SettingsTab()),
          _ => null,
        },
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Feed'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: 'Settings'),
        ],
      ),
    );
  }
}

// Tab routes point to the tab layout using Type reference
class FeedTab extends AppRoute {
  @override
  Type? get layout => TabBarLayout;
  
  @override
  Uri toUri() => Uri.parse('/tabs/feed');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const Center(child: Text('Feed Tab'));
  }
}

// Register layout in Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineLayout() {
    RouteLayout.defineLayout(TabBarLayout, () => TabBarLayout());
  }
}
```

#### Example: Stack Navigation Layout (NavigationStack style)

```dart
class SettingsLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.settingsStack;
  
  @override
  Uri toUri() => Uri.parse('/settings');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: buildPath(coordinator),
    );
  }
  
}

// Settings routes point to settings layout using Type reference
class GeneralSettings extends AppRoute {
  @override
  Type? get layout => SettingsLayout;
  
  @override
  Uri toUri() => Uri.parse('/settings/general');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      children: [
        ListTile(
          title: const Text('Account'),
          onTap: () => coordinator.push(AccountSettings()),
        ),
        ListTile(
          title: const Text('Privacy'),
          onTap: () => coordinator.push(PrivacySettings()),
        ),
      ],
    );
  }
}

// Register layout in Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineLayout() {
    RouteLayout.defineLayout(SettingsLayout, () => SettingsLayout());
  }
}
```

#### Example: Nested Layouts

```dart
// Level 1: Main app layout
class AppLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.mainStack;
  
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: buildPath(coordinator),
    );
  }
}

// Level 2: Tab bar layout (nested inside AppLayout)
class TabBarLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  Type? get layout => AppLayout; // Parent layout Type
  
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.tabPath;
  
  @override
  Uri toUri() => Uri.parse('/tabs');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: buildPath(coordinator),
      bottomNavigationBar: BottomNavigationBar(/* ... */),
    );
  }
}

// Level 3: Feed stack layout (nested inside TabBarLayout)
class FeedLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  Type? get layout => TabBarLayout; // Parent layout Type
  
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.feedStack;
  
  @override
  Uri toUri() => Uri.parse('/tabs/feed');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return buildPath(coordinator);
  }
}

// Register all layouts in Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineLayout() {
    RouteLayout.defineLayout(AppLayout, () => AppLayout());
    RouteLayout.defineLayout(TabBarLayout, () => TabBarLayout());
    RouteLayout.defineLayout(FeedLayout, () => FeedLayout());
  }
}
```

---

### RouteGuard

Prevents navigation away from a route unless specific conditions are met, ideal for protecting unsaved work or confirmation prompts. When a user attempts to navigate away (via back button, swipe gesture, or programmatic `pop()`), the `popGuard()` method is automatically called to determine whether navigation should proceed.

Use this mixin when you need to protect forms with unsaved changes, prevent interruption of ongoing processes, or require user confirmation before leaving a screen.

#### API

```dart
mixin RouteGuard on RouteTarget {
  // Return true to allow pop, false to prevent
  FutureOr<bool> popGuard();

  // Called by system with coordinator context
  // Asserts path/coordinator consistency then calls popGuard()
  FutureOr<bool> popGuardWith(covariant Coordinator coordinator);
}
```

#### Example: Unsaved Changes Warning

```dart
class EditFormRoute extends RouteTarget with RouteUnique, RouteGuard {
  bool hasUnsavedChanges = false;
  
  @override
  Future<bool> popGuard() async {
    if (!hasUnsavedChanges) return true; // No unsaved changes, allow navigation
    
    // Ask user to confirm discarding changes
    final shouldPop = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Unsaved Changes'),
        content: const Text(
          'You have unsaved changes. Discard them?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Discard'),
          ),
        ],
      ),
    );
    
    return shouldPop ?? false;
  }
  
  @override
  Uri toUri() => Uri.parse('/edit');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Edit'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () async {
            // popGuard() is automatically checked before navigation
            coordinator.pop();
          },
        ),
      ),
      body: TextField(
        onChanged: (value) => hasUnsavedChanges = true,
        decoration: const InputDecoration(
          hintText: 'Start typing...',
        ),
      ),
    );
  }
}
```

#### Example: Process Confirmation

```dart
class UploadRoute extends RouteTarget with RouteGuard {
  bool isUploading = false;
  
  @override
  Future<bool> popGuard() async {
    if (!isUploading) return true;
    
    final shouldCancel = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Upload in Progress'),
        content: const Text('Cancel upload and go back?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Continue Upload'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Cancel Upload'),
          ),
        ],
      ),
    );
    
    if (shouldCancel == true) {
      // Cancel the upload
      uploadTask.cancel();
    }
    
    return shouldCancel ?? false;
  }
}
```

---

### RouteRedirect<T>

Redirects navigation to a different route based on runtime conditions, essential for authentication flows, permission checks, and conditional routing. The `redirect()` method is called automatically when navigating to a route, allowing you to intercept and redirect to a different destination.

Use this mixin for authentication state checks, permission enforcement, data-driven conditional routing, or A/B testing different navigation flows.

#### API

```dart
mixin RouteRedirect<T extends RouteTarget> on RouteTarget {
  // Return the target route (can be async)
  // Return `this` to proceed to the current route
  // Return null to cancel navigation
  FutureOr<T?> redirect();

  // Called by system with coordinator context
  // Intercepts and allows coordinator-aware redirect logic
  FutureOr<T?> redirectWith(covariant Coordinator coordinator);
}
```

#### Example: Authentication Check

```dart
class DashboardRoute extends RouteTarget 
    with RouteUnique, RouteRedirect<AppRoute> {
  @override
  Future<AppRoute?> redirect() async {
    final isLoggedIn = await authService.checkAuth();
    
    if (!isLoggedIn) {
      // User not authenticated, redirect to login with return URL
      return LoginRoute(redirectTo: '/dashboard');
    }
    
    // User is authenticated, proceed to dashboard
    return this;
  }
  
  @override
  Uri toUri() => Uri.parse('/dashboard');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Dashboard')),
      body: const Center(child: Text('Welcome to Dashboard!')),
    );
  }
}

class LoginRoute extends RouteTarget with RouteUnique {
  final String? redirectTo;
  
  LoginRoute({this.redirectTo});
  
  @override
  Uri toUri() => Uri.parse('/login');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Center(
        child: ElevatedButton(
          onPressed: () async {
            await authService.login();
            if (redirectTo != null) {
              coordinator.recoverRouteFromUri(Uri.parse(redirectTo!));
            } else {
              coordinator.replace(DashboardRoute());
            }
          },
          child: const Text('Login'),
        ),
      ),
    );
  }
}
```

#### Example: Permission Check

```dart
class AdminRoute extends RouteTarget with RouteRedirect<AppRoute> {
  @override
  Future<AppRoute?> redirect() async {
    final user = await authService.getCurrentUser();
    
    if (user == null) {
      return LoginRoute(redirectTo: '/admin');
    }
    
    if (!user.isAdmin) {
      return UnauthorizedRoute();
    }
    
    return this; // User has admin privileges, allow access
  }
}
```

#### Example: Data-Driven Redirect

```dart
class PostRoute extends RouteTarget with RouteRedirect<AppRoute> {
  final String postId;
  
  PostRoute(this.postId);
  
  @override
  Future<AppRoute?> redirect() async {
    final post = await postService.getPost(postId);
    
    if (post == null) {
      return NotFoundRoute();
    }
    
    if (post.isDeleted) {
      return DeletedPostRoute(postId);
    }
    
    if (post.requiresSubscription && !user.hasSubscription) {
      return SubscriptionRequiredRoute();
    }
    
    return this;
  }
}
```

#### Redirect Chains

Redirects can chain together automatically. ZenRouter follows each redirect until reaching a route that doesn't redirect:

```dart
// RouteA redirects to RouteB
class RouteA extends RouteTarget with RouteRedirect<AppRoute> {
  @override
  Future<AppRoute> redirect() async => RouteB();
}

// RouteB redirects to RouteC
class RouteB extends RouteTarget with RouteRedirect<AppRoute> {
  @override
  Future<AppRoute> redirect() async => RouteC();
}

// RouteC has no redirect, this is the final destination
class RouteC extends RouteTarget {}

// Pushing RouteA ends up at RouteC!
coordinator.push(RouteA());
// Internal flow: RouteA → RouteB → RouteC
```

---

### RouteRedirectRule

Enables composable, reusable redirect logic by chaining multiple `RedirectRule` instances together. This mixin works with `RouteRedirect` to provide a rule-based approach to redirects, making it easy to create reusable authentication, authorization, feature flag, and logging rules.

**Benefits over direct `RouteRedirect` implementation:**
- **Reusable**: One rule can be used for multiple routes
- **Composable**: Chain multiple rules together (auth → feature flag → logging)
- **Testable**: Test each rule independently
- **Maintainable**: Centralized redirect logic, easy to modify

**Use when:**
- You need the same redirect logic across multiple routes
- You want to combine multiple checks (auth + permissions + feature flags)
- You prefer a rule-based architecture
- You want to test redirect logic independently

**Not needed when:**
- You have simple, route-specific redirect logic
- You only need a single redirect check

#### API

```dart
// Base class for creating redirect rules
abstract class RedirectRule<T extends RouteTarget> {
  FutureOr<RedirectResult<T>> redirectResult(
    covariant Coordinator coordinator,
    covariant T route,
  );
}

// Result types
sealed class RedirectResult<T extends RouteTarget> {
  const RedirectResult.stop();              // Stop navigation
  const RedirectResult.continueRedirect();  // Continue to next rule
  const RedirectResult.redirectTo(T route); // Redirect to route
}

// Mixin for routes
mixin RouteRedirectRule<T extends RouteTarget> on RouteRedirect<T> {
  List<RedirectRule> get redirectRules;
  
  // Automatically implements RouteRedirect.redirectWith()
}
```

#### Example: Authentication Rule

```dart
class AuthenticationRule extends RedirectRule<AppRoute> {
  @override
  FutureOr<RedirectResult<AppRoute>> redirectResult(
    Coordinator coordinator,
    AppRoute route,
  ) {
    if (!AuthService.isAuthenticated) {
      // Not logged in → redirect to login page
      return RedirectResult.redirectTo(LoginRoute());
    }
    // Logged in → continue to next rule
    return const RedirectResult.continueRedirect();
  }
}

class ProtectedRoute extends AppRoute
    with RouteRedirect, RouteRedirectRule {
  @override
  List<RedirectRule> get redirectRules => [
    AuthenticationRule(), // Check authentication first
  ];
  
  @override
  Uri toUri() => Uri.parse('/protected');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Protected')),
      body: const Center(child: Text('Protected Content')),
    );
  }
}
```

#### Example: Chaining Multiple Rules

```dart
class FeatureFlagRule extends RedirectRule<AppRoute> {
  final String feature;
  FeatureFlagRule({required this.feature});

  @override
  FutureOr<RedirectResult<AppRoute>> redirectResult(
    Coordinator coordinator,
    AppRoute route,
  ) async {
    final isEnabled = await FeatureService.isEnabled(feature);
    if (!isEnabled) {
      return RedirectResult.stop(); // Stop navigation
    }
    return const RedirectResult.continueRedirect();
  }
}

class PermissionRule extends RedirectRule<AppRoute> {
  final String permission;
  PermissionRule({required this.permission});

  @override
  FutureOr<RedirectResult<AppRoute>> redirectResult(
    Coordinator coordinator,
    AppRoute route,
  ) async {
    final user = await AuthService.getCurrentUser();
    if (user == null) {
      return RedirectResult.redirectTo(LoginRoute());
    }
    if (!user.hasPermission(permission)) {
      return RedirectResult.redirectTo(UnauthorizedRoute());
    }
    return const RedirectResult.continueRedirect();
  }
}

class LoggingRule extends RedirectRule<AppRoute> {
  @override
  FutureOr<RedirectResult<AppRoute>> redirectResult(
    Coordinator coordinator,
    AppRoute route,
  ) async {
    // Log navigation event (side effect)
    Analytics.logNavigation(route.toUri());
    return const RedirectResult.continueRedirect(); // Always continue
  }
}

// Use all rules together
class AdminDashboardRoute extends AppRoute
    with RouteRedirect, RouteRedirectRule {
  @override
  List<RedirectRule> get redirectRules => [
    AuthenticationRule(),                    // 1. Check login
    PermissionRule(permission: 'admin'),     // 2. Check admin permission
    FeatureFlagRule(feature: 'admin-panel'), // 3. Check feature flag
    LoggingRule(),                           // 4. Log navigation
  ];
  
  @override
  Uri toUri() => Uri.parse('/admin/dashboard');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Admin Dashboard')),
      body: const Center(child: Text('Admin Content')),
    );
  }
}
```

#### Rule Execution Flow

Rules are executed in the order they appear in the `redirectRules` list:

```
Rule 1: AuthenticationRule
  ├─ Not authenticated → RedirectResult.redirectTo(LoginRoute) → STOP ✅
  └─ Authenticated → RedirectResult.continueRedirect() → Continue

Rule 2: PermissionRule
  ├─ No permission → RedirectResult.redirectTo(UnauthorizedRoute) → STOP ✅
  └─ Has permission → RedirectResult.continueRedirect() → Continue

Rule 3: FeatureFlagRule
  ├─ Feature disabled → RedirectResult.stop() → STOP ❌ (cancel navigation)
  └─ Feature enabled → RedirectResult.continueRedirect() → Continue

Rule 4: LoggingRule
  └─ Always → RedirectResult.continueRedirect() → Continue

All rules passed → Display original route ✅
```

**Important:** Once a rule returns `StopRedirect` or `RedirectTo`, subsequent rules are **not executed**.

#### Example: Reusing Rules Across Routes

```dart
// Define rules once
final authRule = AuthenticationRule();
final adminPermissionRule = PermissionRule(permission: 'admin');
final userPermissionRule = PermissionRule(permission: 'user');

// Use in multiple routes
class AdminSettingsRoute extends AppRoute
    with RouteRedirect, RouteRedirectRule {
  @override
  List<RedirectRule> get redirectRules => [
    authRule,
    adminPermissionRule,
  ];
}

class UserProfileRoute extends AppRoute
    with RouteRedirect, RouteRedirectRule {
  @override
  List<RedirectRule> get redirectRules => [
    authRule,
    userPermissionRule,
  ];
}
```

#### Example: Async Rules

Rules can be async to fetch data, call APIs, or read from databases:

```dart
class SubscriptionRule extends RedirectRule<AppRoute> {
  @override
  Future<RedirectResult<AppRoute>> redirectResult(
    Coordinator coordinator,
    AppRoute route,
  ) async {
    // Fetch subscription status from API
    final subscription = await SubscriptionService.getCurrent();
    
    if (subscription == null) {
      return RedirectResult.redirectTo(SubscribeRoute());
    }
    
    if (subscription.isExpired) {
      return RedirectResult.redirectTo(RenewSubscriptionRoute());
    }
    
    return const RedirectResult.continueRedirect();
  }
}
```

#### Example: Route-Specific Rule Logic

Rules can inspect the route being navigated to:

```dart
class RateLimitRule extends RedirectRule<AppRoute> {
  @override
  FutureOr<RedirectResult<AppRoute>> redirectResult(
    Coordinator coordinator,
    AppRoute route,
  ) async {
    // Check if route requires premium subscription
    if (route is PremiumRoute) {
      final user = await AuthService.getCurrentUser();
      if (user?.isPremium != true) {
        return RedirectResult.redirectTo(UpgradeRoute());
      }
    }
    
    return const RedirectResult.continueRedirect();
  }
}
```

#### When to Use RouteRedirectRule vs RouteRedirect

| Use Case | Use RouteRedirect | Use RouteRedirectRule |
|----------|------------------|----------------------|
| Simple, route-specific logic | ✅ Yes | ❌ No |
| Reusable across multiple routes | ❌ No | ✅ Yes |
| Single check (auth only) | ✅ Yes | ✅ Yes (if reusable) |
| Multiple checks (auth + permissions + flags) | ❌ No | ✅ Yes |
| Testable, isolated logic | ❌ No | ✅ Yes |
| Side effects (logging, analytics) | ❌ No | ✅ Yes |

#### Best Practices

**✅ DO:**
- Put critical rules first (auth, permissions)
- Put side-effect rules last (logging, analytics)
- Make rules reusable across routes
- Test rules independently
- Use `StopRedirect` to cancel navigation when appropriate

**❌ DON'T:**
- Put side-effect rules before critical checks
- Create rules that depend on execution order unnecessarily
- Mix route-specific logic with reusable rules
- Return `null` from rules (use `StopRedirect` instead)

---

### RouteDeepLink

Provides custom handling for deep links with advanced control over navigation behavior. While ZenRouter handles basic deep linking automatically through `RouteUnique`, this mixin allows you to customize how your app responds to deep links—whether by replacing the entire stack, pushing onto the current stack, or executing completely custom logic.

Use this mixin when deep links require multi-step navigation setup, analytics tracking, data preloading, or custom navigation flows that go beyond simple route replacement.

#### API

```dart
mixin RouteDeepLink on RouteUnique {
  // Strategy for handling deep links
  DeeplinkStrategy get deeplinkStrategy;
  
  // Custom deep link handler (only called if strategy is custom)
  FutureOr<void> deeplinkHandler(
    covariant Coordinator coordinator,
    Uri uri,
  );
}

enum DeeplinkStrategy {
  replace,  // Replace entire navigation stack with this route (default)
  push,     // Push this route onto the existing stack
  custom,   // Use deeplinkHandler()
}
```

#### Example: Multi-Step Deep Link Setup

```dart
class ProductDetailRoute extends RouteTarget 
    with RouteUnique, RouteDeepLink {
  final String productId;
  
  ProductDetailRoute(this.productId);
  
  @override
  Uri toUri() => Uri.parse('/product/$productId');
  
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(
    AppCoordinator coordinator,
    Uri uri,
  ) async {
    // Step 1: Navigate to the correct tab
    coordinator.replace(ShopTab());
    
    // Step 2: Load product data asynchronously
    final product = await productService.loadProduct(productId);
    
    // Step 3: Navigate to category if available
    if (product.category != null) {
      coordinator.push(CategoryRoute(product.category!));
    }
    
    // Step 4: Finally navigate to the product detail
    coordinator.push(this);
    
    // Step 5: Track deep link analytics
    analytics.logDeepLink(uri, {
      'product_id': productId,
      'source': uri.queryParameters['source'],
    });
  }
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Product $productId')),
      body: ProductDetailView(productId: productId),
    );
  }
}
```

#### Example: Push Strategy

```dart
class ModalRoute extends RouteTarget with RouteUnique, RouteDeepLink {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.push;
  
  @override
  Uri toUri() => Uri.parse('/modal');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Dialog(
      child: Container(
        padding: const EdgeInsets.all(24),
        child: const Text('Modal from deep link'),
      ),
    );
  }
}

// Example: myapp://modal opens as a modal on top of current navigation
// The existing stack is preserved
```

#### Example: Analytics Tracking

```dart
class CampaignRoute extends RouteTarget with RouteDeepLink {
  final String campaignId;
  
  CampaignRoute(this.campaignId);
  
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(
    AppCoordinator coordinator,
    Uri uri,
  ) async {
    // Track campaign parameters
    final source = uri.queryParameters['utm_source'];
    final medium = uri.queryParameters['utm_medium'];
    final campaign = uri.queryParameters['utm_campaign'];
    
    analytics.logEvent('campaign_opened', {
      'campaign_id': campaignId,
      'source': source,
      'medium': medium,
      'campaign': campaign,
    });
    
    // Load campaign data
    final data = await campaignService.load(campaignId);
    
    // Navigate to appropriate screen
    if (data.type == 'product') {
      coordinator.replace(ProductRoute(data.productId));
    } else {
      coordinator.replace(CampaignDetailRoute(campaignId));
    }
  }
}
```

---

### RouteTransition

Customizes page transition animations for a route.

**Use when:**
- You want custom page transitions
- Different routes need different transitions
- Platform-specific transitions

#### API

```dart
mixin RouteTransition on RouteUnique {
  StackTransition<T> transition<T extends RouteUnique>(
    covariant Coordinator coordinator,
  );
}
```

#### Example: Custom Transition

```dart
class FadeRoute extends RouteTarget with RouteUnique, RouteTransition {
  @override
  Uri toUri() => Uri.parse('/fade');
  
  @override
  StackTransition<T> transition<T extends RouteUnique>(
    Coordinator coordinator,
  ) {
    return StackTransition.custom(
      builder: (context) => build(coordinator, context),
      pageBuilder: (context, key, child) => PageRouteBuilder(
        settings: RouteSettings(name: key.toString()),
        pageBuilder: (context, animation, secondaryAnimation) => child,
        transitionsBuilder: (context, animation, secondaryAnimation, child) {
          return FadeTransition(
            opacity: animation,
            child: child,
          );
        },
      ),
    );
  }
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Fade Transition')),
      body: const Center(child: Text('Faded in!')),
    );
  }
}
```

#### Example: Platform-Specific Transitions

```dart
class AdaptiveRoute extends RouteTarget with RouteTransition {
  @override
  StackTransition<T> transition<T extends RouteUnique>(
    Coordinator coordinator,
  ) {
    if (Platform.isIOS) {
      return StackTransition.cupertino(
        build(coordinator, coordinator.navigator.context),
      );
    } else {
      return StackTransition.material(
        build(coordinator, coordinator.navigator.context),
      );
    }
  }
}
```

---


### Full Example
```dart
class ComplexRoute extends AppRoute
    with RouteUnique, RouteGuard, RouteRedirect, RouteDeepLink {
  bool isDirty = false;
  
  @override
  Future<bool> popGuard() async => !isDirty || await confirmExit();
  
  @override
  Future<AppRoute?> redirect() async {
    if (!await auth.check()) return LoginRoute();
    return this;
  }
  
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(Coordinator coordinator, Uri uri) async {
    analytics.log(uri);
    coordinator.push(this);
  }
  
  @override
  Uri toUri() => Uri.parse('/complex');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return ComplexScreen(onChanged: () => isDirty = true);
  }
}
```

## Best Practices

### ✅ DO: Use Minimal Mixins

Only add mixins you actually need:

```dart
// ✅ GOOD: Only what's needed
class SimpleRoute extends RouteTarget with RouteUnique {
  // Just basic coordinator support
}

// ❌ BAD: Unnecessary mixins
class SimpleRoute extends RouteTarget 
    with RouteUnique, RouteGuard, RouteRedirect {
  @override
  Future<bool> popGuard() => true; // Always true = useless
  
  @override
  Future<AppRoute> redirect() => this; // Always this = useless
}
```

### ✅ DO: Combine Related Mixins

Guards and redirects work well together:

```dart
class SecureFormRoute extends AppRoute 
    with RouteUnique, RouteGuard, RouteRedirect {
  bool hasChanges = false;
  
  // Redirect: Check auth first
  @override
  Future<AppRoute> redirect() async {
    return await auth.check() ? this : LoginRoute();
  }
  
  // Guard: Prevent accidental exit
  @override
  Future<bool> popGuard() async {
    return !hasChanges || await confirmDiscard();
  }
}
```

### ❌ DON'T: Create Deep Inheritance Hierarchies

Use composition, not inheritance:

```dart
// ❌ BAD: Deep hierarchy
abstract class AuthenticatedRoute extends AppRoute with RouteRedirect {...}
abstract class GuardedRoute extends AuthenticatedRoute with RouteGuard {...}
class MyRoute extends GuardedRoute {...}

// ✅ GOOD: Flat composition
class MyRoute extends AppRoute 
    with RouteUnique, RouteRedirect, RouteGuard {
  // All mixins at once, clear and explicit
}
```

### ❌ DON'T: Use RouteLayout Without Coordinator

`RouteLayout` requires `Coordinator`:

```dart
// ❌ BAD: RouteLayout without coordinator
class TabLayout extends RouteTarget with RouteLayout {...}
// Won't work with pure imperative/declarative navigation

// ✅ GOOD: Use RouteUnique with RouteLayout
class TabLayout extends RouteTarget with RouteUnique, RouteLayout {...}
// Works with Coordinator
```

---

### RouteQueryParameters

Efficiently handles query parameters by allowing granular UI rebuilds. This mixin provides a `ValueNotifier` for query parameters, enabling parts of your UI to rebuild when specific queries change without rebuilding the entire route or triggering navigation transitions.

**Required when:**
- You have complex routes with filters, sorting, or pagination
- You want to update the URL without navigation
- You need high performance for frequent parameter updates

#### API

```dart
mixin RouteQueryParameters on RouteUnique {
  // The notifier for query parameters
  ValueNotifier<Map<String, String>> get queryNotifier;

  // Current query parameters
  Map<String, String> get queries;

  // Get a specific query
  String? query(String name);

  // Update queries and sync URL
  void updateQueries(
    covariant Coordinator coordinator, {
    required Map<String, String> queries,
  });

  // Build widgets that rebuild only when specific queries change
  Widget selectorBuilder<T>({
    required T Function(Map<String, String> queries) selector,
    required Widget Function(BuildContext context, T value) builder,
  });
}
```

#### Example: Pagination and Filtering

```dart
class CollectionListRoute extends AppRoute with RouteQueryParameters {
  @override
  late final ValueNotifier<Map<String, String>> queryNotifier;

  CollectionListRoute({Map<String, String> queries = const {}})
    : queryNotifier = ValueNotifier(queries);

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Only rebuilds when 'filter' changes
          selectorBuilder(
            selector: (q) => q['filter'] ?? 'all',
            builder: (context, filter) => Text('Filter: $filter'),
          ),
          
          // Only rebuilds when 'page' changes
          selectorBuilder(
            selector: (q) => int.tryParse(q['page'] ?? '1') ?? 1,
            builder: (context, page) => Text('Page: $page'),
          ),

          ElevatedButton(
            onPressed: () {
              updateQueries(
                coordinator,
                queries: {...queries, 'page': '2'},
              );
            },
            child: const Text('Go to Page 2'),
          ),
        ],
      ),
    );
  }
}
```

---

## See Also

- [Imperative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md) - Using mixins with imperative navigation
- [Coordinator Pattern](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) - Using mixins with coordinator
- [API Reference](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/core-classes.md) - Detailed API documentation



================================================
FILE: packages/zenrouter/doc/api/navigation-paths.md
================================================
# Navigation Paths API

Complete API reference for navigation path types in ZenRouter.

## Overview

Navigation paths are stack-based containers that hold routes. ZenRouter provides:

- **`StackPath`** - Base class for all navigation paths
- **`NavigationPath`** - Mutable stack with push/pop operations (created via `StackPath.navigationStack()`)
- **`IndexedStackPath`** - Immutable stack with index-based navigation (created via `StackPath.indexedStack()`)
- **`NavigationStack`** - Widget that renders a navigation path
- **`DeclarativeNavigationStack`** - Widget for state-driven navigation

---

## StackPath<T>

Base class for all navigation paths. Provides common functionality for managing route stacks.


### Factory Constructors

#### `NavigationPath.create()`

Creates a mutable navigation path with push/pop operations.

```dart
factory NavigationPath.create({
  String? label,
  List<T>? stack,
  Coordinator? coordinator,
})
```

**Example:**
```dart
final path = NavigationPath.create(
  label: 'main-nav',
  stack: [HomeRoute()], // Start with home route
);
```

#### `IndexedStackPath.create()`

Creates an indexed navigation path with index-based navigation.

```dart
factory IndexedStackPath.create(
  List<T> stack, {
  String? label,
  Coordinator? coordinator,
})
```

**Example:**
```dart
final tabPath = IndexedStackPath.create(
  [
    FeedTab(),
    ProfileTab(),
    SettingsTab(),
  ], 
  label: 'main-tabs',
);
```

#### `createWith()`

Both `NavigationPath` and `IndexedStackPath` also provide a `createWith` factory to strictly bind a path to a `Coordinator`.

```dart
factory NavigationPath.createWith({
  required Coordinator coordinator,
  required String label,
  List<T>? stack,
})
```

### Common Properties

#### `stack` → `List<T>`

Returns an unmodifiable view of the current navigation stack.

```dart
final currentStack = path.stack;
print('Stack depth: ${currentStack.length}');
print('Top route: ${currentStack.last}');
```

#### `debugLabel` → `String?`

Optional label for debugging purposes.

```dart
print(path.debugLabel); // 'main-nav'
```

#### `activeRoute` → `T?`

The currently active route in the stack.

```dart
final current = path.activeRoute;
print('Active route: ${current?.runtimeType}');
```

### Common Methods

#### `reset()` → `void`

Force clears the entire navigation history.

```dart
path.reset();
// Stack is now empty
```

#### `activateRoute(T route)` → `Future<void>`

Navigates to a specific route.

```dart
await path.activateRoute(ProfileRoute());
```

---

## NavigationPath<T>

A mutable navigation path with push/pop operations. Extends `StackPath` with `StackMutatable` mixin.

### Constructor

Use the factory constructors:

```dart
// Standard creation
final path = NavigationPath.create(
  label: 'main-nav',
  stack: [HomeRoute()],
);

// With explicit coordinator binding (inside Coordinator)
late final path = NavigationPath.createWith(
  coordinator: this,
  label: 'main-nav',
  stack: [HomeRoute()],
);
```

### Methods

#### `push(T element)` → `Future<dynamic>`

Pushes a route onto the navigation stack.

**Returns:** A `Future` that completes when the route is popped, with the pop result value.

**Handles redirects:** If the route has `RouteRedirect`, the redirect chain is followed until a non-redirecting route is reached.

**Example:**
```dart
// Push and wait for result
final result = await path.push(EditProfileRoute());
if (result?['saved'] == true) {
  showSnackBar('Profile saved!');
}

// Push without waiting for result
path.push(SettingsRoute());

// Push returns the result when popped
final formData = await path.push(FormRoute());
print('User submitted: $formData');
```

**With redirects:**
```dart
// If EditRoute has RouteRedirect that checks auth
await path.push(EditRoute());
// If not authenticated, automatically redirects to LoginRoute
```

#### `pop([Object? result])` → `Future<void>`

Removes the top route from the navigation stack.

**Parameters:**
- `result`: Optional value returned to the `Future` from `push()`

**Guards:** If the route has `RouteGuard`, the guard is consulted first. The pop is cancelled if the guard returns `false`.

**Example:**
```dart
// Pop with a result
path.pop({'saved': true, 'name': 'John'});

// Pop without a result
path.pop();

// The result is received by the Future from push()
final result = await path.push(EditorRoute());
// When EditorRoute calls: path.pop({'content': 'Hello'})
print(result['content']); // 'Hello'
```

**With guards:**
```dart
// If current route has RouteGuard
await path.pop(); // Guard is consulted, pop only happens if guard returns true
```

#### `pushOrMoveToTop(T element)` → `Future<void>`

Pushes a route to the top of the stack, or moves it if already present.

If the route is already in the stack, it's removed from its current position and moved to the top. If not present, it's added to the top.

**Use for:** Tab navigation where you don't want duplicates.

**Example:**
```dart
// Switch between tabs without duplicating
path.pushOrMoveToTop(FeedTab());
// Stack: [FeedTab]

path.pushOrMoveToTop(ProfileTab());
// Stack: [FeedTab, ProfileTab]

path.pushOrMoveToTop(FeedTab());
// Stack: [ProfileTab, FeedTab] - FeedTab moved to top!
```

**Follows redirects:** Just like `push()`, redirect chains are followed.

#### `pushReplacement(T element, {Object? result})` → `Future<dynamic>`

Pops the current route and pushes a new route in its place.

**Parameters:**
- `element`: The new route to push after popping
- `result`: Optional value to pass to the popped route's `push()` Future

**Returns:** A `Future` that completes when the new route is popped, with the pop result value. Returns `null` if redirect resolution fails or guard blocks the pop.

**Behavior based on stack state:**
- **Empty stack:** Pushes the new route normally
- **Single element:** Completes the active route with `result`, resets the stack, then pushes the new route
- **Multiple elements:** Pops the top route (respecting `RouteGuard`), waits for the animation, then pushes

**Example:**
```dart
// Replace current screen without adding to history
await path.pushReplacement(HomeRoute());

// Replace with result for the popped route
await path.pushReplacement(HomeRoute(), result: 'completed');

// Common flow: Screen A waits for result, Screen B replaces with C
// In Screen A:
final result = await path.push(ScreenBRoute());
print('Got: $result'); // Prints: Got: from_c

// In Screen B:
path.pushReplacement(ScreenCRoute(), result: 'from_c');
```

**With guards:**
```dart
// If current route has RouteGuard that returns false
final newRoute = await path.pushReplacement(HomeRoute());
// Returns null if guard blocks the pop
```

**Use cases:**
- Login → Home transition (back should not return to login)
- Splash screen → Main content
- Wizard flows where previous steps shouldn't be revisited

#### `remove(T element)` → `void`

Removes a specific route from the stack at any position.

**⚠️ Warning:** Guards are NOT consulted. This is a forced removal. Use with caution.

**Example:**
```dart
// Remove a specific route
final routeToRemove = path.stack.firstWhere((r) => r is LoginRoute);
path.remove(routeToRemove);

// Remove all routes of a certain type
path.stack.whereType<SplashRoute>().forEach(path.remove);

// Remove by index (via stack list)
final oldRoute = path.stack[2];
path.remove(oldRoute);
```

**Common use cases:**
- Cleaning up intermediate routes after a flow completes
- Removing login/splash screens from history
- Manual stack management

#### `reset()` → `void`

Force clears the entire navigation history.

**⚠️ Warning:** Guards are NOT consulted. This is a hard reset that clears everything.

**Example:**
```dart
// Clear everything
path.reset();
// Stack is now empty

// After reset, you typically push a new initial route
path.reset();
path.push(WelcomeRoute());
```

**Use cases:**
- Logging out
- Resetting app state
- Clearing navigation before a new flow

---

## IndexedStackPath<T>

An immutable navigation path with index-based navigation. Perfect for tab bars and drawer navigation.

### Constructor

Use the factory constructors:

```dart
// Standard creation
final tabPath = IndexedStackPath.create(
  [
    FeedTab(),
    ProfileTab(),
    SettingsTab(),
  ], 
  debugLabel: 'main-tabs',
);

// With explicit coordinator binding (inside Coordinator)
late final tabPath = IndexedStackPath.createWith(
  [
    FeedTab(),
    ProfileTab(),
    SettingsTab(),
  ], 
  coordinator: this, 
  label: 'main-tabs',
);
```

**Important:** The stack is immutable - you cannot add or remove routes after creation.

### Properties

#### `stack` → `List<T>`

Returns the complete list of routes (unmodifiable).

```dart
final tabs = tabPath.stack;
print('Total tabs: ${tabs.length}');
```

#### `activePathIndex` → `int`

The index of the currently active route.

```dart
print('Current tab: ${tabPath.activePathIndex}');
// 0 = first tab, 1 = second tab, etc.
```

#### `activeRoute` → `T`

The currently active route.

```dart
final current = tabPath.activeRoute;
print('Active: ${current.runtimeType}');
```

### Methods

#### `goToIndexed(int index)` → `Future<void>`

Navigates to the route at the specified index.

**Consults guards:** If the current route has `RouteGuard`, it's consulted before switching.

**Follows redirects:** If the target route has `RouteRedirect`, the redirect is followed.

**Example:**
```dart
// Switch to second tab
await tabPath.goToIndexed(1);

// Switch to first tab
await tabPath.goToIndexed(0);

// With guard
class GuardedTab extends RouteTarget with RouteGuard {
  @override
  Future<bool> popGuard() async {
    return await confirmLeave();
  }
}
// If current tab is GuardedTab:
await tabPath.goToIndexed(2); // Guard is consulted first
```

**Throws:** `StateError` if index is out of bounds.

#### `activateRoute(T route)` → `Future<void>`

Navigates to a specific route by reference.

**Example:**
```dart
final profileTab = ProfileTab();
final tabPath = IndexedStackPath.create([
  FeedTab(),
  profileTab,
  SettingsTab(),
]);

// Navigate to profile tab
await tabPath.activateRoute(profileTab);
```

**Throws:** `StateError` if route is not found in the stack.

**Note:** Route equality is used for matching. Make sure your routes implement `==` correctly if they have parameters.

#### `reset()` → `void`

Resets all route state but keeps the active index.

```dart
tabPath.reset();
// All routes have their internal state reset
// Active index remains the same
```

---

## NavigationStack Widget

Widget that renders a navigation path. Works with both `DynamicNavigationPath` and `FixedNavigationPath`.

### Constructor

```dart
NavigationStack<T extends RouteTarget>({
  Key? key,
  required NavigationPath<T> path,
  required StackTransitionResolver<T> resolver,
  T? defaultRoute,
  Coordinator? coordinator,
  GlobalKey<NavigatorState>? navigatorKey,
})
```

**Parameters:**

- **`path`** (required): The navigation path to render
  ```dart
  NavigationStack(
    path: myPath,
    resolver: resolver,
  )
  ```

- **`resolver`** (required): Function that converts routes to `StackTransition`
  ```dart
  resolver: (route) => switch (route) {
    HomeRoute() => StackTransition.material(HomeScreen()),
    ProfileRoute() => StackTransition.cupertino(ProfileScreen()),
    _ => StackTransition.material(NotFoundScreen()),
  }
  ```

- **`defaultRoute`** (optional): Initial route to push when stack initializes
  ```dart
  NavigationStack(
    path: path,
    defaultRoute: HomeRoute(), // Pushed on first build
    resolver: resolver,
  )
  ```

- **`coordinator`** (optional): Associated coordinator for this stack
  ```dart
  NavigationStack(
    path: path,
    coordinator: myCoordinator,
    resolver: resolver,
  )
  ```

- **`navigatorKey`** (optional): Key for accessing navigator state
  ```dart
  final navKey = GlobalKey<NavigatorState>();
  NavigationStack(
    path: path,
    navigatorKey: navKey,
    resolver: resolver,
  )
  // Later: navKey.currentState?.maybePop()
  ```

### Example

```dart
class MyApp extends StatelessWidget {
  final path = NavigationPath.create();
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: NavigationStack(
        path: path,
        defaultRoute: HomeRoute(),
        resolver: (route) => StackTransition.material(
          route.build(context),
        ),
      ),
    );
  }
}
```

---

## NavigationStack.declarative

Factory constructor for creating a declarative, state-driven navigation stack.

### Constructor

```dart
static DeclarativeNavigationStack<T> declarative<T extends RouteTarget>({
  required List<T> routes,
  required StackTransitionResolver<T> resolver,
  GlobalKey<NavigatorState>? navigatorKey,
  String? debugLabel,
})
```

**Parameters:**

- **`routes`** (required): List of routes derived from your state
  ```dart
  routes: [
    HomePage(),
    if (showProfile) ProfileRoute(),
    for (final item in items) ItemRoute(item.id),
  ]
  ```

- **`resolver`** (required): Function that converts routes to `StackTransition`
  ```dart
  resolver: (route) => switch (route) {
    HomeRoute() => StackTransition.material(HomeScreen()),
    ProfileRoute() => StackTransition.cupertino(ProfileScreen()),
    _ => StackTransition.material(NotFoundScreen()),
  }
  ```

- **`navigatorKey`** (optional): Key for accessing navigator state
  ```dart
  final navigatorKey = GlobalKey<NavigatorState>();
  NavigationStack.declarative(
    navigatorKey: navigatorKey,
    routes: routes,
    resolver: resolver,
  )
  // Later: navigatorKey.currentState?.pop()
  ```

- **`debugLabel`** (optional): Label for debugging
  ```dart
  debugLabel: 'main-navigation'
  ```

### Example

```dart
class MyApp extends StatefulWidget {
  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  List<int> pages = [1, 2, 3];
  bool showSpecial = false;
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: NavigationStack.declarative(
          routes: [
            for (final page in pages) PageRoute(page),
            if (showSpecial) SpecialRoute(),
          ],
          resolver: (route) => StackTransition.material(
            route.build(context),
          ),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: () => setState(() => pages.add(pages.length + 1)),
          child: const Icon(Icons.add),
        ),
      ),
    );
  }
}
```

**How it works:**
- When `setState` is called and routes change, Myers diff calculates the minimal set of operations
- Only changed routes are added/removed
- Existing routes are preserved with their state intact

---

## StackTransition

Defines page transition types for routes. Used by `NavigationStack` resolver.

### StackTransition.material

Standard Material page transition.

**Behavior:**
- Android: Slide from bottom
- iOS: Slide from right

```dart
StackTransition.material(
  Scaffold(
    appBar: AppBar(title: const Text('Material Page')),
    body: const Center(child: Text('Hello')),
  ),
)
```

### StackTransition.cupertino

iOS-style page transition (slide from right on all platforms).

```dart
StackTransition.cupertino(
  CupertinoPageScaffold(
    navigationBar: const CupertinoNavigationBar(
      middle: Text('Cupertino Page'),
    ),
    child: const Center(child: Text('Hello')),
  ),
)
```

### StackTransition.sheet

Bottom sheet presentation.

```dart
StackTransition.sheet(
  Container(
    height: 400,
    decoration: BoxDecoration(
      color: Colors.white,
      borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
    ),
    child: const Center(child: Text('Bottom Sheet')),
  ),
)
```

### StackTransition.dialog

Dialog presentation (centered, with barrier).

```dart
StackTransition.dialog(
  AlertDialog(
    title: const Text('Dialog'),
    content: const Text('This is a dialog'),
    actions: [
      TextButton(
        onPressed: () => Navigator.pop(context),
        child: const Text('Close'),
      ),
    ],
  ),
)
```

### StackTransition.custom

Custom transition with full control.

```dart
StackTransition.custom(
  builder: (context) => MyWidget(),
  pageBuilder: (context, key, child) => PageRouteBuilder(
    settings: RouteSettings(name: key.toString()),
    pageBuilder: (context, animation, secondaryAnimation) => child,
    transitionsBuilder: (context, animation, secondaryAnimation, child) {
      return FadeTransition(
        opacity: animation,
        child: SlideTransition(
          position: Tween<Offset>(
            begin: const Offset(1, 0),
            end: Offset.zero,
          ).animate(animation),
          child: child,
        ),
      );
    },
  ),
)
```

---

## Type Definitions

### StackTransitionResolver<T>

Function type for resolving routes to transitions.

```dart
typedef StackTransitionResolver<T extends RouteTarget> = 
    StackTransition Function(T route);
```

**Example:**
```dart
StackTransition resolver(AppRoute route) {
  return switch (route) {
    HomeRoute() => StackTransition.material(HomeScreen()),
    ProfileRoute() => StackTransition.cupertino(ProfileScreen()),
    ModalRoute() => StackTransition.sheet(ModalSheet()),
    _ => StackTransition.material(NotFoundScreen()),
  };
}
```

---

## See Also

- [Imperative Navigation Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md) - Using DynamicNavigationPath
- [Declarative Navigation Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md) - Using NavigationStack.declarative
- [Coordinator Pattern Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) - Using paths with Coordinator
- [Route Mixins](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/mixins.md) - Adding behavior to routes



================================================
FILE: packages/zenrouter/doc/guides/coordinator-as-module.md
================================================
# Coordinator as RouteModule Guide

> **Unlock Powerful Versioning & Parallel Development Workflows**

Since `Coordinator<T>` implements `RouteModule<T>`, you can nest entire coordinators as modules within a parent. This architecture treats each child coordinator as a self-contained application, managing its own navigation history, deep linking logic, and state.

This capability is particularly powerful for **scalable feature development**. It allows teams to build major features in parallel—such as developing a "Shop V2" alongside a "Shop V1"—without code conflicts or regression risks. By isolating features into their own coordinators, you gain the ability to run safe A/B tests, incrementally migrate legacy apps, and let different teams own their entire vertical stack.

## Why Use Coordinators as Modules?

When you nest a `Coordinator` inside another, it behaves exactly like a standard `RouteModule`. It doesn't create a separate history stack or navigation context; instead, its routes are merged seamlessly into the parent's routing tree.

The true power of this pattern lies in **reusability and modularity**:

*   **Reuse Existing Code**: You can take a standalone `Coordinator` from an older project (or a different part of your app) and plug it directly into a modern `CoordinatorModular` setup without rewriting it.
*   **Seamless Versioning**: Because both V1 and V2 coordinators share the same parent history, users can navigate between them effortlessly. Pushing a V2 route from V1 feels just like a normal navigation event.
*   **Parallel Development**: Different teams can work on different `Coordinator` classes (e.g., `ShopCoordinatorV1` vs. `ShopCoordinatorV2`) simultaneously. Each coordinator is a self-contained unit of code, but at runtime, they act as one cohesive application.

### When to Use

This pattern is ideal when you want to **integrate an existing Coordinator** into a modular app, or when you are **rewriting a feature** and want to keep the old logic (V1) available while building the new one (V2). It allows you to maintain two complete, improved versions of a feature side-by-side in the same codebase.

If you are starting a new feature from scratch and don't need this specific kind of separation, a standard `RouteModule` is usually simpler and sufficient.



---

## Technical Implementation

The correct way to use a Coordinator as a Module is to verify the **Wrapper Pattern**. This allows you to keep your feature coordinator completely unaware of its parent or version prefix, maximizing reusability.

### 1. The Feature Coordinator

First, write your feature coordinator as a standard, standalone class. It doesn't need to know about parents or versioning.

```dart
class ShopCoordinator extends Coordinator<AppRoute> {
  // Define paths owned by this coordinator
  late final NavigationPath<AppRoute> shopStack = NavigationPath.createWith(
    label: 'shop',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, shopStack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    // Standard route parsing logic
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeRoute(),
      ['shop', 'products', final id] => ProductRoute(id: id),
      _ => null,
    };
  }
}
```

### 2. The Module Wrapper

Next, create a wrapper class that extends your feature coordinator. This wrapper connects the feature to the parent and handles any route prefixing (e.g., `/v1/shop` vs `/shop`).

```dart
class ShopCoordinatorModule extends ShopCoordinator {
  ShopCoordinatorModule(this.coordinator);

  @override
  final CoordinatorModular<AppRoute> coordinator;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    // Intercept routes starting with 'v1'
    return switch (uri.pathSegments) {
      ['v1', ...final rest] => super.parseRouteFromUri(
        uri.replace(pathSegments: rest), // Strip 'v1' and delegate
      ),
      _ => null, 
    };
  }
}
```

By overriding the `coordinator` field, you link the child to the parent. By modifying `parseRouteFromUri`, you handle the versioning externally, keeping `ShopCoordinator` clean.

### 3. Register in the Parent

Finally, register the *wrapper* in the parent's `defineModules` method.

```dart
class MainCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    // Register the wrapper, passing 'this' as the parent
    ShopCoordinatorModule(this), 
    SettingsModule(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}
```

---

## Parallel Feature Development (Versioning)

The Wrapper Pattern naturally supports **Parallel Feature Development**. You can have multiple versions of the same feature coordinator running side-by-side by creating different wrappers for them.

### Example: V1 and V2 Coexistence

You might have a legacy `ShopCoordinatorV1` and a new `ShopCoordinatorV2`. You simply wrap them with different prefixes:

```dart
// Legacy Wrapper
class ShopCoordinatorV1Module extends ShopCoordinatorV1 {
  ShopCoordinatorV1Module(this.coordinator);
  @override
  final CoordinatorModular<AppRoute> coordinator;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['v1', ...final rest] => super.parseRouteFromUri(
        uri.replace(pathSegments: rest),
      ),
      _ => null,
    };
  }
}

// New Wrapper
class ShopCoordinatorV2Module extends ShopCoordinatorV2 {
  ShopCoordinatorV2Module(this.coordinator);
  @override
  final CoordinatorModular<AppRoute> coordinator;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['v2', ...final rest] => super.parseRouteFromUri(
        uri.replace(pathSegments: rest),
      ),
      _ => null,
    };
  }
}
```

Then register both in `MainCoordinator`:

```dart
@override
Set<RouteModule<AppRoute>> defineModules() => {
  ShopCoordinatorV1Module(this),
  ShopCoordinatorV2Module(this),
};
```

### Benefits of this Approach

1.  **Zero Regression Risk**: The legacy `ShopCoordinatorV1` remains untouched.
2.  **Clean Code**: Coordinators focus on logic, Wrappers focus on mounting and versioning.
3.  **Experiment Freedom**: V2 can use a completely different architecture or state management library.
4.  **Instant Rollback**: If V2 has bugs, you can restrict access to it in the wrapper or parent without redeploying valid code.



### Best Practices for Parallel Development

*   **Namespace Everything**: Prefix V2 classes with `V2` (e.g., `ShopCoordinatorV2`, `ShopHomeV2`) to prevent naming collisions and make the code self-documenting.
*   **Isolate Dependencies**: Avoid sharing complex ViewModels or Controllers between V1 and V2. Sharing only simple Data Transfer Objects (DTOs) ensures that changes in the new version don't accidentally break the old one.
*   **Visible Deprecation**: In the legacy V1 layouts, consider adding UI indicators like banners or badges to inform users of the new version and encourage them to migrate.

---

## Troubleshooting

### UnimplementedError: "This coordinator is standalone"

you will encounter this error if you use a Coordinator as a RouteModule but forget to override the `coordinator` getter. The base `Coordinator` class throws this error to prevent misuse. Ensure your child coordinator implements:

```dart
@override
CoordinatorModular<AppRoute> get coordinator => _parent;
```

### AssertionError: "you must return route from parseRouteFromUri"

If you are using a standalone coordinator (one that isn't nested) as your main `RouterConfig`, it *must* return a route from `parseRouteFromUri`. If it returns `null`, the app doesn't know what to show. Always ensure your top-level coordinator has a fallback, typically a `NotFoundRoute`.

---

**Need help?** File an issue at [github.com/definev/zenrouter/issues](https://github.com/definev/zenrouter/issues)



================================================
FILE: packages/zenrouter/doc/guides/coordinator-modular.md
================================================
# Modular Coordinator Guide

> **Split your coordinator into independent, reusable modules**

The Modular Coordinator pattern enables you to organize routes by domain or feature, making large applications more maintainable and allowing teams to work independently on different parts of your app.

## What is Modular Coordinator?

`CoordinatorModular` is a mixin that extends `Coordinator` with the ability to delegate route management to multiple `RouteModule` instances. Each module handles a specific subset of routes, paths, layouts, and converters.

**Key concepts:**
- **RouteModule**: A self-contained unit that handles routes for a specific domain
- **CoordinatorModular**: Aggregates modules and delegates route parsing
- **Module Isolation**: Each module manages its own paths and layouts independently

### When to Use Modular Coordinator

✅ **Use when:**
- Building large applications with many routes
- Working with multiple teams on different features
- You want to organize routes by domain (auth, shop, settings, etc.)
- You need to reuse route modules across applications
- Your `parseRouteFromUri` method is becoming too large

❌ **Don't use when:**
- Your app has fewer than ~10 routes
- All routes belong to a single domain
- You prefer a single, centralized route parser

---

## Quick Start

### Step 1: Create Your Route Modules

Each module extends `RouteModule` and handles routes for a specific domain:

```dart
// lib/modules/auth_module.dart
class AuthModule extends RouteModule<AppRoute> {
  AuthModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['auth', 'login'] => LoginRoute(),
      ['auth', 'register'] => RegisterRoute(),
      _ => null, // Not handled by this module
    };
  }

  @override
  void defineLayout() {
    // Register auth-specific layouts
    RouteLayout.defineLayout(AuthLayout, AuthLayout.new);
  }
}

// lib/modules/shop_module.dart
class ShopModule extends RouteModule<AppRoute> {
  ShopModule(super.coordinator);

  // Module can define its own navigation paths
  late final NavigationPath<AppRoute> shopPath = NavigationPath.createWith(
    label: 'shop',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [shopPath];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeRoute(),
      ['shop', 'products', final id] => ProductRoute(id: id),
      ['shop', 'cart'] => CartRoute(),
      _ => null,
    };
  }

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  }
}
```

### Step 2: Create Your Modular Coordinator

Use the `CoordinatorModular` mixin and implement `defineModules`:

```dart
// lib/coordinator.dart
class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  
  @override
  Set<RouteModule<AppRoute>> defineModules() {
    return {
      AuthModule(this),
      ShopModule(this),
      SettingsModule(this),
    };
  }

  @override
  AppRoute notFoundRoute(Uri uri) {
    return NotFoundRoute(uri: uri);
  }
}
```

### Step 3: Use in Your App

The coordinator works exactly like a regular coordinator:

```dart
final coordinator = AppCoordinator();

MaterialApp.router(
  routerConfig: coordinator,
)
```

**That's it!** Routes are now parsed by modules in order until one matches.

---

## How Route Parsing Works

When `parseRouteFromUri` is called, the coordinator:

1. **Iterates through modules** in the order they appear in `defineModules`
2. **Calls each module's `parseRouteFromUri`** until one returns a non-null route
3. **Returns the first match** found
4. **Calls `notFoundRoute`** if all modules return null

**Example flow:**

```dart
// URI: /shop/products/123
coordinator.parseRouteFromUri(Uri.parse('/shop/products/123'));

// 1. AuthModule.parseRouteFromUri() → returns null (not handled)
// 2. ShopModule.parseRouteFromUri() → returns ProductRoute(id: '123') ✅
// 3. Returns ProductRoute immediately (doesn't check SettingsModule)
```

**Important:** Module order matters! The first module that returns a non-null route wins.

---

## Complete Example

Here's a full example showing multiple modules with layouts and paths:

```dart
// ============================================================================
// Route Base
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

// ============================================================================
// Auth Module
// ============================================================================

class AuthModule extends RouteModule<AppRoute> {
  AuthModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['login'] => LoginRoute(),
      ['register'] => RegisterRoute(),
      _ => null,
    };
  }
}

class LoginRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/login');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => coordinator.replace(ShopHomeRoute()),
          child: const Text('Login'),
        ),
      ),
    );
  }
}

class RegisterRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/register');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Register')),
      body: const Center(child: Text('Register Page')),
    );
  }
}

// ============================================================================
// Shop Module
// ============================================================================

class ShopModule extends RouteModule<AppRoute> {
  ShopModule(super.coordinator);

  late final NavigationPath<AppRoute> shopPath = NavigationPath.createWith(
    label: 'shop',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [shopPath];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeRoute(),
      ['shop', 'products', final id] => ProductRoute(id: id),
      _ => null,
    };
  }

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  }
}

class ShopLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) {
    final shopModule = coordinator.getModule<ShopModule>() as ShopModule;
    return shopModule.shopPath;
  }

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Shop')),
      body: buildPath(coordinator),
    );
  }
}

class ShopHomeRoute extends AppRoute {
  @override
  Type get layout => ShopLayout;

  @override
  Uri toUri() => Uri.parse('/shop');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      children: [
        ListTile(
          title: const Text('Product 1'),
          onTap: () => coordinator.push(ProductRoute(id: '1')),
        ),
      ],
    );
  }
}

class ProductRoute extends AppRoute {
  ProductRoute({required this.id});
  final String id;

  @override
  Type get layout => ShopLayout;

  @override
  Uri toUri() => Uri.parse('/shop/products/$id');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Product $id')),
      body: Center(child: Text('Product Detail: $id')),
    );
  }

  @override
  List<Object?> get props => [id];
}

// ============================================================================
// Coordinator
// ============================================================================

class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  
  @override
  Set<RouteModule<AppRoute>> defineModules() {
    return {
      AuthModule(this),
      ShopModule(this),
    };
  }

  @override
  AppRoute notFoundRoute(Uri uri) {
    return NotFoundRoute(uri: uri);
  }
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});
  final Uri uri;

  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Not Found')),
      body: Center(child: Text('Route not found: ${uri.path}')),
    );
  }
}
```

---

## Accessing Modules

Use `getModule()` to access module-specific functionality:

```dart
final coordinator = AppCoordinator();

// Access a specific module
final shopModule = coordinator.getModule<ShopModule>();

// Use module-specific paths
shopModule.shopPath.push(ProductRoute(id: '123'));

// Access module properties
final shopPath = shopModule.shopPath;
```

**Use case:** When you need to navigate within a specific module's path or access module-specific functionality.

---

## Module Responsibilities

Each module can handle:

### 1. Route Parsing

Override `parseRouteFromUri` to handle specific URI patterns:

```dart
@override
FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    ['my', 'route'] => MyRoute(),
    _ => null, // Let other modules handle it
  };
}
```

**Best practice:** Return `null` for routes you don't handle. This allows other modules to process them.

### 2. Navigation Paths

Override `paths` to provide paths for nested navigation:

```dart
late final NavigationPath<AppRoute> myPath = NavigationPath.createWith(
  label: 'my-module',
  coordinator: coordinator,
);

@override
List<StackPath> get paths => [myPath];
```

**Important:** Always use `.createWith()` to bind paths to the coordinator.

### 3. Layout Registration

Override `defineLayout` to register layouts:

```dart
@override
void defineLayout() {
  RouteLayout.defineLayout(MyLayout, MyLayout.new);
}
```

### 4. Converter Registration

Override `defineConverter` to register restorable converters:

```dart
@override
void defineConverter() {
  RestorableConverter.defineConverter(
    MyRoute,
    (json) => MyRoute.fromJson(json),
    (route) => route.toJson(),
  );
}
```

---

## Module Order Matters

Modules are checked in the order they appear in the `Set` returned by `defineModules`. This allows you to:

- **Prioritize certain modules** (e.g., admin routes checked before public routes)
- **Handle route conflicts** (first module wins)
- **Create fallback chains** (specific modules before general ones)

**Example: Admin routes take precedence**

```dart
@override
Set<RouteModule<AppRoute>> defineModules() {
  return {
    AdminModule(this),    // Checked first
    PublicModule(this),   // Checked second
  };
}
```

If both modules could handle `/users`, AdminModule wins because it's checked first.

---

## Path Aggregation

All module paths are automatically aggregated into the coordinator's `paths`:

```dart
class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  // ... defineModules ...

  // Paths automatically include:
  // - coordinator.root (from super.paths)
  // - shopModule.shopPath (from ShopModule)
  // - settingsModule.settingsPath (from SettingsModule)
}
```

You can access all paths through `coordinator.paths`, and they're all available for state restoration.

---

## Best Practices

### ✅ Do

- **Return null** when a module doesn't handle a route
- **Use descriptive module names** (AuthModule, ShopModule, not Module1, Module2)
- **Keep modules focused** on a single domain or feature
- **Use `.createWith()`** for all paths to ensure proper binding
- **Provide unique labels** for paths (required for state restoration)
- **Order modules logically** (specific before general, admin before public)

### ❌ Don't

- **Don't handle routes outside your domain** (return null instead)
- **Don't create circular dependencies** between modules
- **Don't access other modules directly** (use `getModule()` instead)
- **Don't forget to return null** for unhandled routes
- **Don't create paths without binding** to the coordinator

---

## Advanced Patterns

### Module with Multiple Paths

A module can manage multiple paths:

```dart
class ShopModule extends RouteModule<AppRoute> {
  ShopModule(super.coordinator);

  late final NavigationPath<AppRoute> productsPath = NavigationPath.createWith(
    label: 'products',
    coordinator: coordinator,
  );

  late final NavigationPath<AppRoute> cartPath = NavigationPath.createWith(
    label: 'cart',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [productsPath, cartPath];
}
```

### Module with Async Parsing

Modules can use async parsing for dynamic route resolution:

```dart
@override
Future<AppRoute?> parseRouteFromUri(Uri uri) async {
  if (uri.pathSegments.first == 'dynamic') {
    // Fetch data from API
    final data = await fetchRouteData(uri);
    return DynamicRoute(data: data);
  }
  return null;
}
```

### Module with Conditional Registration

Register modules conditionally:

```dart
@override
Set<RouteModule<AppRoute>> defineModules() {
  final modules = <RouteModule<AppRoute>>{
    AuthModule(this),
    ShopModule(this),
  };

  // Add admin module only if user is admin
  if (userService.isAdmin) {
    modules.add(AdminModule(coordinator));
  }

  return modules;
}
```

---

## Troubleshooting

### Error: "TypeError: type 'X' is not a subtype of type 'Y'"

**Problem:** Trying to access a module that wasn't registered.

**Solution:** Ensure the module is included in `defineModules`:

```dart
@override
Set<RouteModule<AppRoute>> defineModules() {
  return {
    MyModule(this), // ✅ Must be included
  };
}
```

### Routes Not Being Parsed

**Check:**
1. Module is included in `defineModules`
2. Module's `parseRouteFromUri` returns non-null for the route
3. Module appears before other modules that might handle the same route
4. Route URI matches the pattern in the module

**Debug tip:** Add logging to see which modules are checked:

```dart
@override
FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
  print('AuthModule checking: ${uri.path}');
  return switch (uri.pathSegments) {
    ['auth', 'login'] => LoginRoute(),
    _ => null,
  };
}
```

### Path Not Found

**Problem:** Module path not accessible or not aggregated.

**Solution:**
1. Ensure path is returned in module's `paths` getter
2. Use `.createWith()` to bind path to coordinator
3. Check that module is registered in `defineModules`

### Layout Not Registered

**Problem:** Layout constructor not found.

**Solution:** Register layout in module's `defineLayout`:

```dart
@override
void defineLayout() {
  RouteLayout.defineLayout(MyLayout, MyLayout.new); // ✅ Required
}
```

---

## Comparison: Regular vs Modular Coordinator

| Aspect | Regular Coordinator | Modular Coordinator |
|--------|-------------------|---------------------|
| **Route Parsing** | Single `parseRouteFromUri` method | Delegated to modules |
| **Code Organization** | All routes in one place | Routes organized by module |
| **Team Collaboration** | Requires coordination | Teams work independently |
| **Scalability** | Becomes unwieldy with many routes | Scales well with many routes |
| **Reusability** | Routes tied to coordinator | Modules can be reused |
| **Complexity** | Simpler for small apps | Better for large apps |

**Migration:** You can migrate from regular to modular coordinator incrementally by extracting routes into modules one at a time.

---

## Next Steps

- **See [route-layout.md](./route-layout.md)** for creating nested navigation layouts
- **See [state-restoration.md](./state-restoration.md)** for persisting navigation state
- **See [query-parameters.md](./query-parameters.md)** for handling URL parameters
- **Check example code** in `packages/zenrouter/example/lib/main_modular.dart`
- **Read API docs** for [RouteModule](../api/coordinator.md#routemodule) and [CoordinatorModular](../api/coordinator.md#coordinatormodular)

---

**Need help?** File an issue at [github.com/definev/zenrouter/issues](https://github.com/definev/zenrouter/issues)



================================================
FILE: packages/zenrouter/doc/guides/getting-started.md
================================================
# Getting Started with ZenRouter

Welcome to ZenRouter! This guide will help you choose the right paradigm and get started quickly.

## Quick Navigation

- [Installation](#installation)
- [Choose Your Paradigm](#choose-your-paradigm)
- [Imperative Quick Start](#imperative-quick-start)
- [Declarative Quick Start](#declarative-quick-start)
- [Coordinator Quick Start](#coordinator-quick-start)
- [Common Recipes](#common-recipes)
- [Migrating?](#migrating-from-another-router)
- [Next Steps](#next-steps)

---

## Installation

Add zenrouter to your `pubspec.yaml`:

```yaml
dependencies:
  zenrouter: ^0.1.0  # Check pub.dev for latest version
```

Then run:

```bash
flutter pub get
```

## Choose Your Paradigm

ZenRouter offers three paradigms. Choose based on your needs:

```
┌─────────────────────────────────────────────────────────────┐
│                     DECISION FLOWCHART                      │
└─────────────────────────────────────────────────────────────┘

Do you need web support or deep linking?
│
├─ YES → Use COORDINATOR
│        ✓ Deep linking
│        ✓ URL synchronization  
│        ✓ Browser back button
│        ✓ Centralized routing
│        → See: Coordinator Quick Start
│
└─ NO → Is your navigation driven by state?
       │
       ├─ YES → Use DECLARATIVE
       │        ✓ State-driven routing
       │        ✓ React-like declarative UI
       │        ✓ Efficient updates with Myers diff
       │        → See: Declarative Quick Start
       │
       └─ NO → Use IMPERATIVE
                ✓ Simple and straightforward
                ✓ Direct control over stack
                ✓ Event-driven navigation
                → See: Imperative Quick Start
```

## Comparison Table

| Feature | Imperative | Declarative | Coordinator |
|---------|-----------|-------------|-------------|
| **Complexity** | ⭐ Simple | ⭐⭐ Moderate | ⭐⭐⭐ Advanced |
| **Control** | Full | State-driven | Centralized |
| **Deep Linking** | ❌ No | ❌ No | ✅ Yes |
| **Web Support** | ❌ No | ❌ No | ✅ Yes |
| **URL Sync** | ❌ No | ❌ No | ✅ Yes |
| **State-Driven** | Compatible | ✅ Native | Compatible |
| **Best For** | Mobile apps | Tab bars, lists | Web, large apps |
| **Learning Curve** | Easy | Easy | Moderate |

---

## Imperative Quick Start

**Best for:** Mobile-only apps, event-driven navigation, Navigator 1.0 migration

### 1. Define Routes

```dart
import 'package:zenrouter/zenrouter.dart';

// Base class
sealed class AppRoute extends RouteTarget {
  Widget build(BuildContext context);
}

class HomeRoute extends AppRoute {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => path.push(ProfileRoute()),
          child: const Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileRoute extends AppRoute {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: const Center(child: Text('Profile Page')),
    );
  }
}
```

### 2. Create Navigation Path

```dart
final path = NavigationPath<AppRoute>.create();
```

### 3. Render with NavigationStack

```dart
void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: NavigationStack(
        path: path,
        defaultRoute: HomeRoute(),
        resolver: (route) => StackTransition.material(
          route.build(context),
        ),
      ),
    );
  }
}
```

### 4. Navigate!

```dart
// Navigate to a specific route (Pop to the route if it's already in the stack or push it otherwise)
path.navigate(ProfileRoute());

// Push a route
path.push(ProfileRoute());

// Pop back
path.pop();

// Replace entire stack
path.replace([HomeRoute()]);
```

**Next steps:** [Imperative Navigation Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md)

---

## Declarative Quick Start

**Best for:** State-driven navigation, tab bars, filtered lists, React-like UI

### 1. Define Routes with Equality

```dart
import 'package:zenrouter/zenrouter.dart';

class PageRoute extends RouteTarget {
  final int pageNumber;
  
  PageRoute(this.pageNumber);
  
  // IMPORTANT: Implement equality for Myers diff!
  @override
  List<Object?> get props => [pageNumber];
}
```

### 2. Create Stateful Widget

```dart
class MyApp extends StatefulWidget {
  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final List<int> _pages = [1]; // State
  
  void _addPage() {
    setState(() {
      _pages.add(_pages.length + 1);
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: NavigationStack.declarative(
          // Derive routes from state
          routes: [
            for (final page in _pages) PageRoute(page),
          ],
          resolver: (route) => StackTransition.material(
            PageScreen(pageNumber: (route as PageRoute).pageNumber),
          ),
        ),
        floatingActionButton: FloatingActionButton(
          onPressed: _addPage,
          child: const Icon(Icons.add),
        ),
      ),
    );
  }
}

class PageScreen extends StatelessWidget {
  final int pageNumber;
  
  const PageScreen({super.key, required this.pageNumber});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Page $pageNumber')),
      body: Center(child: Text('Page $pageNumber')),
    );
  }
}
```

**Next steps:** [Declarative Navigation Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md)

---

## Coordinator Quick Start

**Best for:** Web apps, deep linking, complex nested navigation, large apps

### 1. Define Routes with RouteUnique

```dart
import 'package:zenrouter/zenrouter.dart';

abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => coordinator.push(ProfileRoute()),
          child: const Text('Go to Profile'),
        ),
      ),
    );
  }
}

class ProfileRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: const Center(child: Text('Profile Page')),
    );
  }
}
```

### 2. Create Coordinator

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile'] => ProfileRoute(),
      _ => NotFoundRoute(),
    };
  }
}

final coordinator = AppCoordinator();
```

### 3. Use MaterialApp.router

```dart
void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}
```

### 4. Navigate!

```dart
// Push a route
coordinator.push(ProfileRoute());

// Pop back
coordinator.pop();

// Replace stack
coordinator.replace(HomeRoute());
```

Now you have:
- ✅ Deep linking: Open `myapp://profile` to go directly to profile
- ✅ Web URLs: Navigate to `/profile` in browser
- ✅ Browser back button support

**Next steps:** [Coordinator Pattern Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md)

---

## Mixing Paradigms

You can combine paradigms in the same app:

```dart
// Use coordinator for main navigation (deep linking)
class AppCoordinator extends Coordinator<AppRoute> { ... }

// Use declarative for a tab bar (state-driven)
NavigationStack.declarative(
  routes: [
    for (final tab in tabs) TabRoute(tab),
  ],
  resolver: resolver,
)

// Use imperative for a modal flow (event-driven)
final modalPath = NavigationPath<ModalRoute>.create();
modalPath.push(Step1Route());
```

## Common Recipes

### Recipe: Tab Bar Navigation

**Use:** Declarative or Coordinator with `IndexedStackPath`

```dart
// Declarative approach
int selectedTab = 0;

NavigationStack.declarative(
  routes: [
    HomeRoute(),
    switch (selectedTab) {
      0 => FeedRoute(),
      1 => ProfileRoute(),
      2 => SettingsRoute(),
      _ => FeedRoute(),
    },
  ],
  resolver: resolver,
)
```

### Recipe: Multi-Step Form

**Use:** Imperative with state passing

```dart
// Step 1
path.push(PersonalInfoStep(data: FormData()));

// Step 2 (in PersonalInfoStep)
path.push(PreferencesStep(data: updatedData));

// Step 3 (in PreferencesStep)
path.push(ReviewStep(data: updatedData));
```

### Recipe: Authentication Flow

**Use:** Coordinator with `RouteRedirect`

```dart
class ProtectedRoute extends AppRoute with RouteRedirect {
  @override
  Future<AppRoute> redirect() async {
    final isAuthed = await auth.check();
    return isAuthed ? ProtectedRoute() : LoginRoute();
  }
}
```

### Recipe: Deep Linking

**Use:** Coordinator with `RouteDeepLink`

```dart
class ProductRoute extends AppRoute with RouteDeepLink {
  // Use custom deeplink strategy
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(Coordinator coordinator, Uri uri) async {
    // Track analytics
    analytics.logDeepLink(uri);

    // Set up navigation stack
    coordinator.replace(ShopTab());
    coordinator.push(this);
  }
}
```

---

## Common Recipes

Once you've chosen your paradigm, explore these cookbooks for common scenarios:

### Navigation Patterns
- [404 Handling](../recipes/404-handling.md) - Custom error pages and fallback routes
- [Bottom Navigation](../recipes/bottom-navigation.md) - Persistent tab navigation with independent stacks
- [Route Transitions](../recipes/route-transitions.md) - Custom animations and page transitions

### Advanced Features
- [Authentication Flow](../recipes/authentication-flow.md) - Guards, protected routes, and role-based access
- [State Management Integration](../recipes/state-management.md) - Riverpod, Bloc, Provider patterns
- [URL Strategies](../recipes/url-strategies.md) - Web deployment and SEO

**[🔗 Browse All Recipes](../recipes/)**

---

## Migrating from Another Router?

Already using a different router? We have step-by-step migration guides:

- **[From go_router](../migration/from-go-router.md)** - Most popular Flutter router
- **[From auto_route](../migration/from-auto-route.md)** - Code generation alternative
- **[From Navigator 1.0/2.0](../migration/from-navigator.md)** - Flutter's built-in APIs

Each guide includes:
- Feature comparison tables
- Side-by-side code examples
- Migration checklists
- Common gotchas

---

## Next Steps

1. **Read the paradigm guide** for your chosen approach
2. **Explore the examples** in the `example/` directory
3. **Check the API reference** for detailed documentation
4. **Join the community** for support and discussions

## Documentation

- **Paradigm Guides**
  - [Imperative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md)
  - [Declarative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md)
  - [Coordinator Pattern](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md)

- **API Reference**
  - [Core Classes](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/core-classes.md)
  - [Navigation Paths](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md)
  - [Route Mixins](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/mixins.md)
  - [Coordinator API](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/coordinator.md)

- **Examples**
  - [Imperative Example](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/main_imperative.dart)
  - [Declarative Example](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/main_declrative.dart)
  - [Coordinator Example](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/example/lib/main_coordinator.dart)

## Need Help?

- **Issues**: [GitHub Issues](https://github.com/definev/zenrouter/issues)
- **Discussions**: [GitHub Discussions](https://github.com/definev/zenrouter/discussions)
- **Examples**: Check the `example/` directory

Happy routing! 🧘



================================================
FILE: packages/zenrouter/doc/guides/navigator-observers.md
================================================
# Navigator Observers Guide

Learn how to monitor navigation events in `zenrouter` using `NavigatorObserver`s at both the global (Coordinator) and local (NavigationStack) levels.

## Background

In Flutter, `NavigatorObserver` is used to listen to changes in the navigation stack (push, pop, replace, remove). `zenrouter` provides two ways to integrate these observers into your application structure.

## Global Observers: `CoordinatorNavigatorObserver`

Use this for observers that should track events across **all** navigation stacks in your coordinator. This is ideal for:
- App-wide analytics
- Global navigation logging
- Performance monitoring

### Implementation

Apply the `CoordinatorNavigatorObserver` mixin to your `Coordinator` and implement the `observers` getter:

```dart
class AppCoordinator extends Coordinator<AppRoute> 
    with CoordinatorNavigatorObserver<AppRoute> {
  
  @override
  List<NavigatorObserver> get observers => [
    MyAnalyticsObserver(),
    MyLoggingObserver(),
  ];
  
  @override
  AppRoute parseRouteFromUri(Uri uri) => ...;
}
```

### Passing Observers from Outside

Sometimes you may want to inject observers from outside the coordinator (e.g., for testing or when using dependency injection). You can key off the `NavigatorObserverListGetter` typedef to achieve this.

```dart
class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  AppCoordinator({
    NavigatorObserverListGetter observers = kEmptyNavigatorObserverList,
  }) : _observersGetter = observers;

  final NavigatorObserverListGetter _observersGetter;

  @override
  List<NavigatorObserver> get observers => _observersGetter();

  // ...
}
```

Then you can pass the observers when creating the coordinator:

```dart
final coordinator = AppCoordinator(
  observers: () => [
    FirebaseAnalyticsObserver(...),
    SentryNavigatorObserver(),
  ],
);
```

> [!CAUTION]
> **Important:** The `observers` getter is called whenever a new `NavigationPath` is attached to the Coordinator. Since a `NavigatorObserver` can only be attached to a single `Navigator` at a time, you **must return new instances** of your observers each time this getter is called. Reusing the same observer instance across multiple navigators will cause errors.


## Local Observers: `NavigationStack`

Use this for observers that are specific to a single navigation stack. This is useful for:
- Tracking events within a specific tab or nested flow
- Debugging a particular part of the UI

### Implementation

Pass the observers to the `NavigationStack` widget:

```dart
NavigationStack<AppRoute>(
  path: coordinator.root,
  coordinator: coordinator,
  observers: [
    LocalDebugObserver(),
  ],
  resolver: (route) => route.transition,
)
```

## Observer Combination Order

When both coordinator and stack observers are defined, they are combined automatically. The final list passed to the underlying `Navigator` is:

1. **Coordinator Observers** (Global)
2. **NavigationStack Observers** (Local)

This ensures that global observers always receive events before local ones.

## Example: Tracking Screen Views

```dart
class AnalyticsObserver extends NavigatorObserver {
  @override
  void didPush(Route route, Route? previousRoute) {
    print('Analytics: User navigated to ${route.settings.name}');
  }
}

class AppCoordinator extends Coordinator<AppRoute> 
    with CoordinatorNavigatorObserver<AppRoute> {
  
  @override
  List<NavigatorObserver> get observers => [AnalyticsObserver()];
  
  // ...
}
```

## Best Practices

- **Keep it Light**: Observers run on every navigation event. Avoid heavy operations.
- **Prefer Global for Analytics**: Use the coordinator mixin for feature-wide or app-wide analytics to ensure consistent tracking.
- **Use Local for Debugging**: Keep temporary or specific debugging observers local to the `NavigationStack` to avoid noise.
- **Mix and Match**: Don't be afraid to use both! Use global for "what" (analytics) and local for "how" (flow-specific logic).



================================================
FILE: packages/zenrouter/doc/guides/query-parameters.md
================================================
# Query Parameters Guide

The `RouteQueryParameters` mixin provides a powerful way to handle query parameters in your routes efficiently. It allows for fine-grained updates to the UI without rebuilding the entire route or triggering unnecessary navigation transitions.

> [!IMPORTANT]
> The `RouteQueryParameters` mixin requires your route to also use the `RouteUnique` mixin.

## Key Benefits

1.  **Granular Rebuilds**: Listen to specific query parameters and rebuild only the parts of the UI that depend on them.
2.  **Performance**: Avoid rebuilding the entire page when only a small part of the state (like a page number or filter) changes.
3.  **URL Sync**: Update the browser URL to reflect the current state without triggering a full navigation cycle.
4.  **State Preservation**: Keep the same route instance alive while updating its parameters.

## Usage Guide

### Setup

To use query parameters, mix `RouteQueryParameters` into your `RouteTarget`.

> [!TIP]
> This mixin is designed to be used with a base abstract class (e.g. `AppRoute`) that already implements `RouteTarget` and `RouteUnique`.

```dart
import 'package:zenrouter/zenrouter.dart';

// Example implementation
class CollectionListRoute extends AppRoute with RouteQueryParameters {
  @override
  late final ValueNotifier<Map<String, String>> queryNotifier;

  CollectionListRoute({Map<String, String> queries = const {}})
    : queryNotifier = ValueNotifier(queries);

  // ... other route implementation
}
```

### Listening to Changes

You can listen to changes in query parameters in two ways:

#### 1. Using `selectorBuilder` (Recommended)

The `selectorBuilder` method allows you to select a specific value derived from the query parameters and rebuild only when that value changes.

```dart
@override
Widget build(AppCoordinator coordinator, BuildContext context) {
  return Scaffold(
    body: Column(
      children: [
        // Rebuilds ONLY when 'page' query changes
        selectorBuilder(
          selector: (queries) => int.tryParse(queries['page'] ?? '1') ?? 1,
          builder: (context, page) {
            return Text('Current Page: $page');
          },
        ),
        // Rebuilds ONLY when 'sort' query changes
        selectorBuilder(
          selector: (queries) => queries['sort'] ?? 'asc',
          builder: (context, sortOrder) {
            return Text('Sort Order: $sortOrder');
          },
        ),
      ],
    ),
  );
}
```

#### 2. Using `queryNotifier` directly

You can also use the `queryNotifier` directly with a `ValueListenableBuilder`.

```dart
ValueListenableBuilder(
  valueListenable: queryNotifier,
  builder: (context, queries, child) {
    return Text('All Active Queries: ${queries.keys.join(', ')}');
  },
)
```

### Updating Queries

To update query parameters programmatically, use the `updateQueries` method. This will update the `queryNotifier` (triggering UI rebuilds) and sync the URL.

```dart
// Update 'page' to 2, keeping other existing queries
updateQueries(
  coordinator,
  queries: {...queries, 'page': '2'},
);

// clear all and set 'filter' to 'active'
updateQueries(
  coordinator,
  queries: {'filter': 'active'},
);
```

### Reading Queries

You can strictly access the current query parameters using the `queries` getter or the `query(name)` helper.

```dart
final currentFilter = query('filter'); // Returns String? or null
final allQueries = queries; // Returns Map<String, String>
```

## Complete Example

Here is a complete example of a route that handles pagination and filtering using `RouteQueryParameters`.

```dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// Assumes AppRoute extends RouteTarget and mixes in RouteUnique
class CollectionListRoute extends AppRoute with RouteQueryParameters {
  
  @override
  late final ValueNotifier<Map<String, String>> queryNotifier;

  CollectionListRoute({Map<String, String> queries = const {}})
      : queryNotifier = ValueNotifier(queries);

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Collection')),
      body: Column(
        children: [
          // Filter Selector
          selectorBuilder(
            selector: (q) => q['filter'] ?? 'all',
            builder: (context, filter) => DropdownButton<String>(
              value: filter,
              items: const [
                DropdownMenuItem(value: 'all', child: Text('All')),
                DropdownMenuItem(value: 'active', child: Text('Active')),
              ],
              onChanged: (newValue) {
                if (newValue != null) {
                  updateQueries(
                    coordinator, 
                    queries: {...queries, 'filter': newValue}
                  );
                }
              },
            ),
          ),
          
          // Page Display
          selectorBuilder(
            selector: (q) => int.tryParse(q['page'] ?? '1') ?? 1,
            builder: (context, page) => Text('Page $page'),
          ),

          // Pagination Controls
          Row(
            children: [
              ElevatedButton(
                onPressed: () {
                   final currentPage = int.tryParse(query('page') ?? '1') ?? 1;
                   if (currentPage > 1) {
                     updateQueries(
                       coordinator,
                       queries: {...queries, 'page': '${currentPage - 1}'}
                     );
                   }
                },
                child: const Text('Prev'),
              ),
              ElevatedButton(
                onPressed: () {
                   final currentPage = int.tryParse(query('page') ?? '1') ?? 1;
                   updateQueries(
                     coordinator,
                     queries: {...queries, 'page': '${currentPage + 1}'}
                   );
                },
                child: const Text('Next'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}
```



================================================
FILE: packages/zenrouter/doc/guides/route-layout.md
================================================
# RouteLayout Guide

RouteLayout is a powerful mixin that enables you to create nested navigation structures like shells, tab bars, and custom layouts. This guide covers how to create custom layouts and register them with your Coordinator.

## What is RouteLayout?

`RouteLayout` is a mixin that transforms a route into a container that manages a `StackPath` (navigation container). Think of it as a "shell" or "wrapper" that can display multiple child routes within its own stack path.

**Common use cases:**
- **Tab bars**: Show multiple tabs with their own navigation stacks
- **Shell routes**: Wrap routes with a persistent UI (e.g., sidebar, navigation bar)
- **Modal flows**: Create custom navigation containers for modals or sheets
- **Master-detail layouts**: Side-by-side navigation for tablets and desktops

## Built-in Stack Paths

ZenRouter provides two built-in `StackPath` implementations:

| Type | Purpose | Behavior |
|------|---------|----------|
| **NavigationPath** | Standard navigation | Mutable stack with push/pop operations |
| **IndexedStackPath** | Tab navigation | Fixed stack with indexed switching |

Both are automatically registered and ready to use. Custom layouts typically use one of these paths.

---

## Creating a RouteLayout

### Step 1: Define Your Layout Route

A layout route must:
1. Use the `RouteLayout` mixin
2. Implement `resolvePath()` to return its `StackPath`
3. Build its UI using `buildPath()`

**Example: Simple Shell Layout**

```dart
class ShellLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.shellPath;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('My App')),
      drawer: MyDrawer(),
      // buildPath() renders the current route in the shell's path
      body: buildPath(coordinator),
    );
  }
}
```

### Step 2: Create the StackPath in Your Coordinator

Add a `StackPath` property to your coordinator. This holds the navigation stack for the layout.

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  // Create a dedicated path for the shell layout
  late final NavigationPath<AppRoute> shellPath = NavigationPath.createWith(
    label: 'shell',        // Unique label for restoration
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [
    ...super.paths,
    shellPath,  // Register the path
  ];
}
```

> **Important:** Always use the `.createWith()` factory to bind paths to coordinators. This ensures proper lifecycle management and state restoration.

### Step 3: Register the Layout Constructor

Use `defineLayout()` in your coordinator to register how the layout should be instantiated:

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShellLayout, ShellLayout.new);
  }
}
```

> **Why is this needed?**
> ZenRouter needs to create layout instances during navigation and state restoration. By registering the constructor, you enable ZenRouter to instantiate layouts without reflection (important for web and minification compatibility).

### Step 4: Assign Routes to the Layout

Routes specify which layout they belong to using the `layout` getter:

```dart
class HomeRoute extends AppRoute {
  @override
  Type get layout => ShellLayout;

  @override
  Uri toUri() => Uri.parse('/home');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Center(child: Text('Home Page'));
  }
}
```

When you push `HomeRoute`, the coordinator will:
1. Check if `ShellLayout` is active
2. If not, activate/push the layout first
3. Then push `HomeRoute` to the shell's `NavigationPath`

---

## Using bindLayout (Recommended Pattern)

For a more concise approach, use the `bindLayout` extension method to register layouts inline:

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  late final NavigationPath<AppRoute> shellPath = NavigationPath.createWith(
    label: 'shell',
    coordinator: this,
  )..bindLayout(ShellLayout.new);  // ✅ Register layout inline

  @override
  List<StackPath> get paths => [...super.paths, shellPath];

  // No need to override defineLayout() when using bindLayout
}
```

**Benefits of `bindLayout`:**
- ✅ More concise (no separate `defineLayout()` method)
- ✅ Collocates path and layout registration
- ✅ Reduces boilerplate

**When to use each approach:**
| Approach | When to Use |
|----------|-------------|
| `bindLayout` | Modern code, single layout per path |
| `defineLayout()` | Multiple layouts, legacy code migration |

---

## Using definePath for Custom StackPaths

If you extend `StackPath` to create custom navigation behavior (e.g., modal sheets, custom transitions), you must register a builder using `definePath`.

### Creating a Custom StackPath

```dart
class ModalPath<T extends RouteTarget> extends StackPath<T>
    with StackMutatable<T> {
  // 1. Define a unique PathKey
  static const key = PathKey('ModalPath');

  ModalPath._(super.stack, {super.debugLabel, super.coordinator});

  factory ModalPath.createWith({
    required Coordinator coordinator,
    required String label,
  }) => ModalPath._([], debugLabel: label, coordinator: coordinator);

  // 2. Return the key
  @override
  PathKey get pathKey => key;

  @override
  T? get activeRoute => _stack.lastOrNull;

  @override
  void reset() {
    for (final route in _stack) {
      route.completeOnResult(null, null, true);
    }
    _stack.clear();
  }

  @override
  Future<void> activateRoute(T route) async {
    reset();
    push(route);
  }
}
```

### Registering the Custom Path Builder

Use `definePath` to tell ZenRouter how to render your custom path:

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  late final ModalPath<AppRoute> modalPath = ModalPath.createWith(
    label: 'modal',
    coordinator: this,
  );

  @override
  void defineLayout() {
    // Register custom path builder
    RouteLayout.definePath(
      ModalPath.key,
      (coordinator, path, layout) {
        return ModalStack(
          path: path as ModalPath<AppRoute>,
          coordinator: coordinator,
        );
      },
    );
  }
}
```

The builder receives:
- `coordinator`: Your app's coordinator
- `path`: The StackPath instance
- `layout`: The parent RouteLayout (if nested)

---

## Complete Example: Tab Bar with Nested Navigation

Here's a real-world example showing tabs with independent navigation stacks.

```dart
// ============================================================================
// Routes
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

class TabBarLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.tabIndexed;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = coordinator.tabIndexed;
    return Scaffold(
      body: Column(
        children: [
          Expanded(child: buildPath(coordinator)),  // Tab content
          _buildTabBar(coordinator, path),          // Tab buttons
        ],
      ),
    );
  }

  Widget _buildTabBar(AppCoordinator coordinator, IndexedStackPath path) {
    return ListenableBuilder(
      listenable: path,
      builder: (context, _) => Row(
        children: [
          _TabButton(
            label: 'Home',
            isActive: path.activeIndex == 0,
            onTap: () => coordinator.push(HomeTab()),
          ),
          _TabButton(
            label: 'Profile',
            isActive: path.activeIndex == 1,
            onTap: () => coordinator.push(ProfileTab()),
          ),
        ],
      ),
    );
  }
}

// Each tab can have its own nested navigation
class HomeTabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  Type get layout => TabBarLayout;  // Nested inside TabBarLayout

  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.homeTabPath;
}

class HomeTab extends AppRoute {
  @override
  Type get layout => HomeTabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/home');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      children: [
        ListTile(
          title: Text('Item 1'),
          onTap: () => coordinator.push(DetailRoute(id: '1')),
        ),
      ],
    );
  }
}

class DetailRoute extends AppRoute {
  DetailRoute({required this.id});
  final String id;

  @override
  Type get layout => HomeTabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/home/detail/$id');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Detail $id')),
      body: Center(child: Text('Detail for $id')),
    );
  }

  @override
  List<Object?> get props => [id];
}

// ============================================================================
// Coordinator
// ============================================================================

class AppCoordinator extends Coordinator<AppRoute> {
  // Tab container with indexed navigation
  late final IndexedStackPath<AppRoute> tabIndexed =
      IndexedStackPath.createWith(
    coordinator: this,
    label: 'tabs',
    [HomeTabLayout(), ProfileTab()],
  )..bindLayout(TabBarLayout.new);

  // Each tab gets its own navigation stack
  late final NavigationPath<AppRoute> homeTabPath =
      NavigationPath.createWith(
    label: 'home-tab',
    coordinator: this,
  )..bindLayout(HomeTabLayout.new);

  @override
  List<StackPath> get paths => [
    ...super.paths,
    tabIndexed,
    homeTabPath,
  ];

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['tabs', 'home'] => HomeTab(),
      ['tabs', 'home', 'detail', final id] => DetailRoute(id: id),
      ['tabs', 'profile'] => ProfileTab(),
      _ => HomeTab(),
    };
  }
}
```

---

## Layout Hierarchies

Layouts can be nested arbitrarily. The coordinator resolves the full hierarchy when navigating.

**Example hierarchy:**
```
RootLayout (NavigationPath)
  └─ TabBarLayout (IndexedStackPath)
       ├─ HomeTabLayout (NavigationPath)
       │    └─ DetailRoute
       └─ ProfileTab
```

When you push `DetailRoute`:
1. Coordinator activates `RootLayout` (if needed)
2. Then activates `TabBarLayout` inside root
3. Then activates `HomeTabLayout` inside tabs
4. Finally pushes `DetailRoute` to home tab's path

**Navigation path resolution:**
- Each route's `layout` getter points to its parent
- The coordinator walks up the chain to build the full hierarchy
- All required layouts are activated/pushed automatically

---

## Key Concepts Reference

### RouteLayout Methods

| Method | Purpose |
|--------|---------|
| `resolvePath()` | Returns the StackPath this layout manages |
| `buildPath()` | Renders the current route in the path |
| `build()` | Builds the layout's UI (wrap with shell, etc.) |

### Registration Functions

| Function | Purpose | When to Use |
|----------|---------|-------------|
| `bindLayout()` | Register layout constructor inline | Modern code, recommended |
| `defineLayout()` | Register layout in coordinator | Multiple layouts, legacy code |
| `definePath()` | Register custom StackPath builder | Custom navigation containers |

### Best Practices

✅ **Do:**
- Use `bindLayout` for cleaner code
- Always use `.createWith()` to bind paths to coordinators
- Provide unique `label` for each path (required for state restoration)
- Keep layout hierarchies simple and logical

❌ **Don't:**
- Create paths without binding to a coordinator
- Forget to register layouts with `bindLayout` or `defineLayout`
- Create circular layout dependencies
- Use the same label for multiple paths

---

## Troubleshooting

### Error: "Missing RouteLayout constructor"

```
Missing RouteLayout constructor for [MyLayout] must define by calling 
[RouteLayout.defineLayout] in [defineLayout] function
```

**Solution:** Register the layout constructor:
```dart
// Option 1: Using bindLayout (recommended)
late final path = NavigationPath.createWith(...)
  ..bindLayout(MyLayout.new);

// Option 2: Using defineLayout
@override
void defineLayout() {
  RouteLayout.defineLayout(MyLayout, MyLayout.new);
}
```

### Error: "No layout builder provided"

```
No layout builder provided for [CustomPath]. If you extend the [StackPath] 
class, you must register it via [RouteLayout.definePath]
```

**Solution:** Register your custom path's builder:
```dart
@override
void defineLayout() {
  RouteLayout.definePath(
    CustomPath.key,
    (coordinator, path, layout) => CustomPathWidget(path: path),
  );
}
```

### Layout Not Appearing

**Check:**
1. Path is added to `coordinator.paths` list
2. Layout is registered with `bindLayout` or `defineLayout`
3. Route's `layout` getter returns the correct Type
4. Path is bound to coordinator with `.createWith()`

---

## Next Steps

- **See [getting-started.md](./getting-started.md)** for basic navigation patterns
- **See [query-parameters.md](./query-parameters.md)** for handling URL parameters
- **See [state-restoration.md](./state-restoration.md)** for persisting navigation state
- **Check example code** in `packages/zenrouter/example/lib/main_coordinator.dart`

---

**Need help?** File an issue at [github.com/definev/zenrouter/issues](https://github.com/definev/zenrouter/issues)



================================================
FILE: packages/zenrouter/doc/guides/state-restoration.md
================================================
# State Restoration Guide

State restoration allows your Flutter app to save its state before the operating system kills the process (to free up resources) and restore it when the user returns. This is crucial for a seamless user experience, especially on Android.

ZenRouter makes state restoration simple and type-safe, handling deeply nested navigation stacks and complex route parameters automatically.

---

## 🚀 Basic Setup

To enable state restoration, you need to configure two things:

### 1. Enable Restoration in MaterialApp

Add a `restorationScopeId` to your `MaterialApp.router`. This ID tells Flutter to enable the restoration subsystem.

```dart
MaterialApp.router(
  restorationScopeId: 'app_state', // Required to enable restoration
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
)
```

### 2. Ensure Synchronous Parsing

When the app restarts, the restoration system needs to modify the route stack *synchronously* before the first frame. Therefore, your URI parsing logic must be synchronous.

If your standard `parseRouteFromUri` is already synchronous, you're good to go. If it's asynchronous (e.g., waiting for async loading), you **must** override `parseRouteFromUriSync`:

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  // ...
  
  @override
  AppRoute parseRouteFromUriSync(Uri uri) {
    // Must return an AppRoute synchronously
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      _ => NotFoundRoute(),
    };
  }
}
```

---

## 🧩 Strategy 1: URI-Based Restoration

This is the default and simplest strategy. It works for any route that implements `RouteUnique`. ZenRouter simply saves the route's URI and restores it by re-parsing that URI.

**Best for:** Routes where all state is contained in the URL (e.g., `/product/123`).

```dart
class ProductRoute extends AppRoute {
  ProductRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/product/$id');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ProductPage(id: id);
  }
}
```

Nothing else is needed! When the app is restored, ZenRouter calls `parseRouteFromUri` with `/product/123` and recreates the route.

---

## 🛠️ Strategy 2: Custom Restoration

Sometimes your route contains complex state that can't (or shouldn't) be put into the URL—like a large form object, a specific filter configuration, or private data.

For these cases, use `RouteRestorable` and a `RestorableConverter`.

### 1. Implement `RouteRestorable`

Mixin `RouteRestorable` and override the restoration properties.

```dart
class FilterRoute extends AppRoute with RouteRestorable<FilterRoute> {
  FilterRoute({required this.filters});
  
  final FilterData filters; // Complex object not in URL

  @override
  String get restorationId => 'filter_route';

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.converter;

  @override
  RestorableConverter<FilterRoute> get converter => const FilterConverter();

  @override
  Uri toUri() => Uri.parse('/filters'); // URL doesn't contain the data
  
  // ... build method
}
```

### 2. Create the Converter

The converter handles serializing your route to a Map and back.

```dart
class FilterConverter extends RestorableConverter<FilterRoute> {
  const FilterConverter();
  
  // Unique key for this converter
  @override
  String get key => 'filter_converter';

  @override
  Map<String, dynamic> serialize(FilterRoute route) {
    return {
      'categories': route.filters.categories,
      'minPrice': route.filters.minPrice,
      'maxPrice': route.filters.maxPrice,
    };
  }

  @override
  FilterRoute deserialize(Map<String, dynamic> data) {
    return FilterRoute(
      filters: FilterData(
        categories: List<String>.from(data['categories']),
        minPrice: data['minPrice'],
        maxPrice: data['maxPrice'],
      ),
    );
  }
}
```

### 3. Register the Converter

Finally, register your converter in your Coordinator. This is required so ZenRouter knows how to find it during startup.

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineConverter() {
    RestorableConverter.defineConverter(
      'filter_converter', 
      () => const FilterConverter(),
    );
  }
  
  // ... rest of coordinator
}
```

---

## 🧪 How to Test

You can simulate process death to verify your restoration logic.

### Android
1. Run your app on an emulator or device.
2. Navigate deep into your app.
3. Press the **Home** button to background the app.
4. Run this command in your terminal:
   ```bash
   adb shell am kill <your.package.name>
   ```
5. Tap the app icon to relaunch it. It should open exactly where you left off.

### iOS
1. Run your app on the Simulator.
2. Navigate deep into your app.
3. Press **Home** (Cmd+Shift+H) to background the app.
4. In Xcode (or Simulator menu), go to **Debug > Simulate Memory Warning**.
5. Relaunch the app.

> [!NOTE]
> On iOS, "Simulate Memory Warning" doesn't always kill the app immediately. For a more reliable test, you can use **Device > Restart** on the simulator while the state is saved, but Android is generally easier for testing this specific behavior.



================================================
FILE: packages/zenrouter/doc/migration/README.md
================================================
[Binary file]


================================================
FILE: packages/zenrouter/doc/migration/from-auto-route.md
================================================
# Migrating from auto_route to ZenRouter

## Why Migrate?

`auto_route` provides excellent code generation for routing, but ZenRouter offers similar power without requiring build_runner on every change. If you want faster iteration, more control, or prefer writing routes as classes over annotations, this guide will help.

**What you'll gain:**
- ✅ **No build_runner delays** - Routes are plain Dart classes
- ✅ **Faster development** - No waiting for code generation
- ✅ **More control** - Direct access to routing logic
- ✅ **Optional code gen** - Use file-based routing generator if you prefer
- ✅ **Paradigm choice** - Not locked into one routing style

---

## Quick Comparison

| Feature | auto_route | ZenRouter |
|---------|-----------|-----------|
| **Route Definition** | `@RoutePage()` annotations | `RouteTarget` classes |
| **Code Generation** | Required (`build_runner`) | Optional (file-based) |
| **Navigation** | `context.router.push()` | `coordinator.push()` |
| **Guards** | `AutoRouteGuard` classes | `RouteRedirect` mixin |
| **Nested Routing** | `AutoRoute.new()` with children | `RouteLayout` + multiple paths |
| **Type Safety** | Generated routes | Native Dart classes |
| **Tab Navigation** | `AutoTabsRouter` | `IndexedStackPath` |
| **Deep Linking** | Built-in | Built-in (Coordinator) |

---

## Step-by-Step Migration

### 1. Update Dependencies

**Before (auto_route):**
```yaml
dependencies:
  auto_route: ^9.0.0

dev_dependencies:
  auto_route_generator: ^9.0.0
  build_runner: ^2.4.0
```

**After (ZenRouter):**
```yaml
dependencies:
  zenrouter: ^0.4.14

# Optional: if you want file-based generation
dev_dependencies:
  zenrouter_generator: ^0.4.14
  build_runner: ^2.4.0
```

### 2. Remove Build Configuration

Delete or rename `build.yaml` if it was only used for auto_route.

---

## Basic Routing Migration

### auto_route Example

```dart
// Route definition with annotation
@RoutePage()
class HomePage extends StatelessWidget {
  const HomePage({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            context.router.push(ProductRoute(id: '123'));
          },
          child: const Text('Go to Product'),
        ),
      ),
    );
  }
}

@RoutePage()
class ProductPage extends StatelessWidget {
  final String id;
  
  const ProductPage({
    super.key,
    @PathParam('id') required this.id,
  });
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Product $id')),
      body: Center(child: Text('Viewing product: $id')),
    );
  }
}

// Router configuration
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [
    AutoRoute(page: HomeRoute.page, initial: true),
    AutoRoute(page: ProductRoute.page, path: '/products/:id'),
  ];
}

// In main.dart
final _appRouter = AppRouter();

MaterialApp.router(
  routerConfig: _appRouter.config(),
);
```

### ZenRouter Equivalent

```dart
// Route definitions (no annotations needed!)
abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

class ProductRoute extends AppRoute {
  final String id;
  
  ProductRoute(this.id);
  
  @override
  List<Object?> get props => [id];
  
  @override
  Uri toUri() => Uri.parse('/products/$id');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ProductPage(id: id);
  }
}

// Pages (unchanged)
class HomePage extends StatelessWidget {
  const HomePage({super.key});
  
  @override
  Widget build(BuildContext context) {
    final coordinator = context.coordinator<AppCoordinator>();
    
    return Scaffold(
      body: Center(
        child: ElevatedButton(
          onPressed: () {
            coordinator.push(ProductRoute('123'));
          },
          child: const Text('Go to Product'),
        ),
      ),
    );
  }
}

class ProductPage extends StatelessWidget {
  final String id;
  
  const ProductPage({super.key, required this.id});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Product $id')),
      body: Center(child: Text('Viewing product: $id')),
    );
  }
}

// Coordinator
class AppCoordinator extends Coordinator<AppRoute> {  
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['products', String id] => ProductRoute(id),
      _ => NotFoundRoute(),
    };
  }
}

// In main.dart
final coordinator = AppCoordinator();

MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
);
```

**Key Differences:**
- **No annotations** - Routes are just classes
- **No `build_runner`** - Changes take effect immediately
- **Parameters** - Constructor arguments instead of `@PathParam`
- **Navigation** - `coordinator.push()` instead of `context.router.push()`

---

## Guards & Auth

### auto_route Guards

```dart
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    if (AuthService.instance.isAuthenticated) {
      resolver.next(true);
    } else {
      resolver.redirect(LoginRoute(onResult: (success) {
        resolver.next(success);
      }));
    }
  }
}

// In router config
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [
    AutoRoute(page: ProfileRoute.page, guards: [AuthGuard()]),
    AutoRoute(page: LoginRoute.page),
  ];
}
```

### ZenRouter RouteRedirect

```dart
mixin AuthGuard on RouteRedirect {
  AppRoute get intendedRoute;

  @override
  Future<AppRoute> redirect() async {
    if (!AuthService.instance.isAuthenticated) {
      return LoginRoute(intendedRoute: intendedRoute);
    }
    return this;
  }
}

class ProfileRoute extends AppRoute with AuthGuard {
  @override
  AppRoute get intendedRoute => ProfileRoute();
  
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const ProfilePage();
  }
}

class LoginRoute extends AppRoute {
  final AppRoute? intendedRoute;
  
  LoginRoute({this.intendedRoute});
  
  @override
  List<Object?> get props => [intendedRoute];
  
  @override
  Uri toUri() => Uri.parse('/login');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return LoginPage(
      onSuccess: () {
        if (intendedRoute != null) {
          coordinator.replace(intendedRoute!);
        } else {
          coordinator.replace(HomeRoute());
        }
      },
    );
  }
}
```

**Advantages:**
- Guard logic is reusable but still local to the route
- Automatic intended route preservation

See [Authentication Flow Recipe](../recipes/authentication-flow.md) for more patterns.

---

## Tab Navigation

### auto_route AutoTabsRouter

```dart
@RoutePage()
class DashboardPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AutoTabsRouter(
      routes: [
        HomeRoute(),
        SearchRoute(),
        ProfileRoute(),
      ],
      builder: (context, child) {
        final tabsRouter = AutoTabsRouter.of(context);
        return Scaffold(
          body: child,
          bottomNavigationBar: BottomNavigationBar(
            currentIndex: tabsRouter.activeIndex,
            onTap: tabsRouter.setActiveIndex,
            items: const [
              BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
              BottomNavigationBarItem(icon: Icon(Icons.search), label: 'Search'),
              BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
            ],
          ),
        );
      },
    );
  }
}
```

### ZenRouter IndexedStackPath

```dart
class TabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) => 
      coordinator.tabPath;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return RootLayout(
      coordinator: coordinator,
      child: buildPath(coordinator),
    );
  }
}

class HomeRoute extends AppRoute {
  @override
  Type get layout => TabLayout;
  
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

// Similar for SearchRoute, ProfileRoute...

class AppCoordinator extends Coordinator<AppRoute> {
  late final tabPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'tab',
    [
      HomeRoute(),
      SearchRoute(),
      ProfileRoute(),
    ],
  )..bindLayout(TabLayout.new);
  
  @override
  List<StackPath<AppRoute>> get paths => [...super.paths, tabPath];
  
  void switchToTab(int index) => tabPath.activeIndex = index;
  int get currentTab => tabPath.activeIndex;
}

class RootLayout extends StatelessWidget {
  final AppCoordinator coordinator;
  final Widget child;
  
  const RootLayout({super.key, required this.coordinator, required this.child});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: child,
      bottomNavigationBar: ListenableBuilder(
        listenable: coordinator.tabPath,
        builder: (context, _) {
          return BottomNavigationBar(
            currentIndex: coordinator.currentTab,
            onTap: coordinator.switchToTab,
            items: const [
              BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
              BottomNavigationBarItem(icon: Icon(Icons.search), label: 'Search'),
              BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
            ],
          );
        },
      ),
    );
  }
}
```

**Advantages:**
- No magic method in `Coordinator` to call
- All tab switching logic own by `IndexedStackPath`
- Deep linking & State Restoration works out of the box

See [Bottom Navigation Recipe](../recipes/bottom-navigation.md) for advanced patterns.

---

## Nested Routes

### auto_route Children

```dart
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [
    AutoRoute(
      page: DashboardRoute.page,
      children: [
        AutoRoute(page: OverviewRoute.page, initial: true),
        AutoRoute(page: DetailsRoute.page),
        AutoRoute(page: SettingsRoute.page),
      ],
    ),
  ];
}

@RoutePage()
class DashboardPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AutoRouter(); // Renders child routes
  }
}
```

### ZenRouter RouteLayout

```dart
class DashboardLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) => 
      coordinator.dashboardPath;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return DashboardScaffold(
      child: buildPath(coordinator), // Renders child routes
    );
  }
}

class OverviewRoute extends AppRoute {
  @override
  Type get layout => DashboardLayout;
  
  @override
  Uri toUri() => Uri.parse('/dashboard');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const OverviewPage();
  }
}

class DetailsRoute extends AppRoute {
  @override
  Type get layout => DashboardLayout;
  
  @override
  Uri toUri() => Uri.parse('/dashboard/details');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const DetailsPage();
  }
}

class AppCoordinator extends Coordinator<AppRoute> {
  late final dashboardPath = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'dashboard',
  )..bindLayout(DashboardLayout.new);
  
  @override
  List<StackPath<AppRoute>> get paths => [...super.paths, dashboardPath];
}
```

---

## Query Parameters

### auto_route

```dart
@RoutePage()
class SearchPage extends StatelessWidget {
  final String? query;
  
  const SearchPage({super.key, @QueryParam() this.query});
  
  @override
  Widget build(BuildContext context) {
    return Text('Searching: $query');
  }
}

// Navigate
context.router.push(SearchRoute(query: 'flutter'));
```

### ZenRouter

```dart
class SearchRoute extends AppRoute with RouteQueryParameters {
  SearchRoute({String? query}) {
    if (query != null) {
      queries({'q': query});
    }
  }
  
  @override
  Uri toUri() => Uri.parse('/search').replace(queryParameters: queries);
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return SearchPage(searchRoute: this);
  }
}

class SearchPage extends StatelessWidget {
  final SearchRoute searchRoute;
  
  const SearchPage({super.key, required this.searchRoute});
  
  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder(
      valueListenable: searchRoute.queryNotifier,
      builder: (context, queries, _) {
        final q = queries['q'];
        return Text('Searching: $q');
      },
    );
  }
}

// Navigate
coordinator.push(SearchRoute(query: 'flutter'));
```

**Advantage:** 
- Query parameters are **reactive** - changing the value updates the URL automatically.
- You can listen separately on each query parameter and achieve fine-grained control over the UI.

---

## Common Gotchas

> [!CAUTION]
> **Context extensions**
> auto_route adds `context.router`. ZenRouter doesn't have it build-in. You can create your own `InheritedWidget` to provide the `coordinator` to the widget tree.

> [!TIP]
> **No more build_runner**
> After migration, you can remove `flutter packages pub run build_runner build` from your workflow. Changes to routes take effect immediately!

> [!NOTE]
> **Route parameters**
> auto_route uses `@PathParam` and `@QueryParam`. ZenRouter uses constructor arguments and `RouteQueryParameters` mixin.

> [!WARNING]
> **Navigation API**
> Replace all `context.router.push()` / `context.router.pop()` / `context.router.replace()` with `coordinator.push()` / `coordinator.pop()` / `coordinator.replace()`.

---

## Migration Checklist

- [ ] Replace `auto_route` dependencies with `zenrouter`
- [ ] Remove `build_runner` configuration (or keep for other packages)
- [ ] Convert `@RoutePage()` classes to `RouteTarget` classes
- [ ] Remove `@PathParam`, `@QueryParam` annotations
- [ ] Create a `Coordinator` with `parseRouteFromUri`
- [ ] Replace `context.router.*` with `coordinator.*`
- [ ] Convert`AutoRouteGuard` to `RouteRedirect` mixins
- [ ] Migrate `AutoTabsRouter` to `IndexedStackPath`
- [ ] Update nested routes to use `RouteLayout`
- [ ] Test deep linking and navigation flows
- [ ] Remove generated `*.gr.dart` files

---

## What You Gain

### Faster Iteration

```bash
# auto_route
# Edit route → run build_runner → wait → see changes
flutter pub run build_runner build

# ZenRouter
# Edit route → hot reload → see changes immediately!
```

### No Code Generation Complexity

No more dealing with:
- `part 'file.gr.dart';` statements
- Build cache issues
- Generated file conflicts in version control
- Build runner configuration

### More Direct Control

```dart
// Custom route resolution logic
@override
AppRoute parseRouteFromUri(Uri uri) {
  // Add custom logic here
  if (uri.host == 'legacy.example.com') {
    return LegacyRedirectRoute(uri);
  }
  
  return switch (uri.pathSegments) {
    ['products', String id] => ProductRoute(id),
    _ => NotFoundRoute(),
  };
}
```

---

## Optional: File-Based Routing Generator

If you prefer code generation, ZenRouter has an optional generator:

```yaml
dev_dependencies:
  zenrouter_generator: ^0.4.14
  build_runner: ^2.4.0
```

Create route files in a special directory structure, and the generator creates the coordinator for you. Best of both worlds!

---

## Need Help?

- [ZenRouter Getting Started](../guides/getting-started.md)
- [Coordinator Pattern Guide](../paradigms/coordinator.md)
- [Bottom Navigation Recipe](../recipes/bottom-navigation.md)
- [Authentication Recipe](../recipes/authentication-flow.md)
- [GitHub Issues](https://github.com/definev/zenrouter/issues)

---

**Happy migrating! 🧘**



================================================
FILE: packages/zenrouter/doc/migration/from-go-router.md
================================================
# Migrating from go_router to ZenRouter

## Why Migrate?

`go_router` is a powerful declarative router, but ZenRouter offers additional paradigm choices and a more Flutter-idiomatic API. If you're finding go_router's declarative-only approach limiting, or you want better type safety and less boilerplate, this guide will help you transition smoothly.

**What you'll gain:**
- ✅ **Paradigm flexibility** - Choose Imperative, Declarative, or Coordinator patterns
- ✅ **Better type safety** - Routes are classes, not string paths
- ✅ **Less boilerplate** - No need for path templates and parameter extraction
- ✅ **Simpler guards** - Mixin-based redirects instead of redirect callbacks
- ✅ **Cleaner layouts** - RouteLayout instead of ShellRoute nesting

---

## Quick Comparison

| Feature | go_router | ZenRouter |
|---------|-----------|-----------|
| **Routing Style** | Declarative only | Imperative, Declarative, Coordinator |
| **Route Definition** | `GoRoute` with path strings | `RouteTarget` classes |
| **Navigation** | `context.go('/path')` | `coordinator.push(Route())` |
| **Type Safety** | Require code generation | Class-based routes |
| **Guards/Redirects** | `redirect` callback | `RouteRedirect` mixin |
| **Nested Routes** | `ShellRoute` | `RouteLayout` |
| **Deep Linking** | Built-in | Built-in (Coordinator) |
| **Web Support** | Built-in | Built-in (Coordinator) |
| **Code Generation** | Not required | Optional (file-based) |

---

## Step-by-Step Migration

### 1. Update Dependencies

**Before (go_router):**
```yaml
dependencies:
  go_router: ^14.0.0
```

**After (ZenRouter):**
```yaml
dependencies:
  zenrouter: ^0.4.14
```

### 2. Choose Your Paradigm

go_router uses a declarative approach. ZenRouter offers three options:

- **Coordinator** - Most similar to go_router, recommended for web/deep linking
- **Declarative** - Pure state-driven routing
- **Imperative** - Simple push/pop navigation

For this guide, we'll use **Coordinator** as it maps most closely to go_router's capabilities.

---

## Basic Routing Migration

### go_router Example

```dart
final router = GoRouter(
  routes: [
    GoRoute(
      path: '/',
      builder: (context, state) => const HomePage(),
    ),
    GoRoute(
      path: '/products/:id',
      builder: (context, state) {
        final id = state.pathParameters['id']!;
        return ProductPage(id: id);
      },
    ),
    GoRoute(
      path: '/profile',
      builder: (context, state) => const ProfilePage(),
    ),
  ],
);

// In MaterialApp
MaterialApp.router(
  routerConfig: router,
);

// Navigation
context.go('/products/123');
context.push('/profile');
```

### ZenRouter Equivalent

```dart
// Define routes as classes
abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

class ProductRoute extends AppRoute {
  final String id;
  ProductRoute(this.id);
  
  @override
  List<Object?> get props => [id];
  
  @override
  Uri toUri() => Uri.parse('/products/$id');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return ProductPage(id: id);
  }
}

class ProfileRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const ProfilePage();
  }
}

// Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['products', String id] => ProductRoute(id),
      ['profile'] => ProfileRoute(),
      _ => NotFoundRoute(),
    };
  }
}

// In MaterialApp
final coordinator = AppCoordinator();

MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
);

// Navigation
coordinator.push(ProductRoute('123'));
coordinator.push(ProfileRoute());
```

**Key Differences:**
- Routes are **type-safe classes** instead of path strings
- Parameters are **constructor arguments** instead of extracted from path
- Navigation uses **route objects** instead of string paths
- URI parsing is **pattern matching** instead of template matching

---

## Nested Routes & Layouts

### go_router ShellRoute

```dart
GoRouter(
  routes: [
    ShellRoute(
      builder: (context, state, child) {
        return ScaffoldWithNav(child: child);
      },
      routes: [
        GoRoute(
          path: '/home',
          builder: (context, state) => const HomePage(),
        ),
        GoRoute(
          path: '/search',
          builder: (context, state) => const SearchPage(),
        ),
      ],
    ),
  ],
);
```

### ZenRouter RouteLayout

```dart
class MainLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) => 
      coordinator.mainPath;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ScaffoldWithNav(
      child: buildPath(coordinator),
    );
  }
}

class HomeRoute extends AppRoute {
  @override
  Type get layout => MainLayout;
  
  @override
  Uri toUri() => Uri.parse('/home');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

class SearchRoute extends AppRoute {
  @override
  Type get layout => MainLayout;
  
  @override
  Uri toUri() => Uri.parse('/search');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const SearchPage();
  }
}

// Bind layout to path
class AppCoordinator extends Coordinator<AppRoute> {
  late final mainPath = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'main',
  )..bindLayout(MainLayout.new);
  
  // ...
}
```

**Advantages:**
- Layouts are **reusable classes**
- Child routes declare their layout via `Type get layout`
- More explicit and type-safe

---

## Authentication & Guards

### go_router Redirect

```dart
GoRouter(
  redirect: (context, state) {
    final isLoggedIn = AuthService.instance.isLoggedIn;
    final isGoingToLogin = state.matchedLocation == '/login';
    
    if (!isLoggedIn && !isGoingToLogin) {
      return '/login';
    }
    
    if (isLoggedIn && isGoingToLogin) {
      return '/';
    }
    
    return null;
  },
  routes: [
    GoRoute(
      path: '/profile',
      builder: (context, state) => const ProfilePage(),
    ),
    GoRoute(
      path: '/login',
      builder: (context, state) => const LoginPage(),
    ),
  ],
);
```

### ZenRouter RouteRedirect

```dart
class ProfileRoute extends AppRoute with RouteRedirect {
  @override
  Future<AppRoute> redirect() async {
    if (!AuthService.instance.isLoggedIn) {
      return LoginRoute(intendedRoute: this);
    }
    return this;
  }
  
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const ProfilePage();
  }
}

class LoginRoute extends AppRoute {
  final AppRoute? intendedRoute;
  
  LoginRoute({this.intendedRoute});
  
  @override
  List<Object?> get props => [intendedRoute];
  
  @override
  Uri toUri() => Uri.parse('/login');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return LoginPage(
      onSuccess: () {
        if (intendedRoute != null) {
          coordinator.replace(intendedRoute!);
        } else {
          coordinator.replace(HomeRoute());
        }
      },
    );
  }
}
```

**Advantages:**
- Guard logic is **attached to the route** that needs protection
- Automatic **intended route preservation**
- Per-route redirects instead of global redirect logic

---

## Push Replacement

### go_router pushReplacement

```dart
// Replace current screen without adding to history
context.pushReplacement('/home');

// With path parameters
context.pushReplacementNamed(
  'product',
  pathParameters: {'id': '123'},
);
```

### ZenRouter pushReplacement

```dart
// Replace current screen without adding to history
coordinator.pushReplacement(HomeRoute());

// With typed parameters
coordinator.pushReplacement(ProductRoute('123'));

// With result for the replaced route
coordinator.pushReplacement<void, String>(
  HomeRoute(),
  result: 'completed',
);
```

**Common use cases:**
- Login → Home transition (back should not return to login)
- Splash/Loading → Main screen transition
- Wizard flows where previous steps shouldn't be revisited
- Replacing a temporary screen with actual content

**Result handling example:**
```dart
// Screen A pushes B and waits for result
final result = await coordinator.push<String>(ScreenBRoute());
print('Got: $result'); // Prints: Got: from_c

// Screen B replaces itself with C, passing result to A
coordinator.pushReplacement<void, String>(
  ScreenCRoute(),
  result: 'from_c',
);
```

**Advantages:**
- Type-safe route objects instead of string paths
- Result passing to the replaced route's push future
- Respects `RouteGuard` when popping the current route

---

## Restorations

### go_router

You needs to specify `restorationId` for each `GoRoute`.

### zenrouter

ZenRouter support `restoration` by default. You just need to enable it in `MaterialApp.router`.

```dart
MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
  restorationScopeId: 'app',
);
```

---

## Query Parameters

### go_router

```dart
GoRoute(
  path: '/search',
  builder: (context, state) {
    final query = state.uri.queryParameters['q'] ?? '';
    return SearchPage(query: query);
  },
);

// Navigate
context.go('/search?q=flutter');
```

### ZenRouter

```dart
class SearchRoute extends AppRoute with RouteQueryParameters {
  SearchRoute({String? initialQuery}) {
    if (initialQuery != null) {
      queries({'q': initialQuery});
    }
  }
  
  @override
  Uri toUri() => Uri.parse('/search').replace(queryParameters: queries);
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return SearchPage(queryRoute: this);
  }
}

// In SearchPage
class SearchPage extends StatelessWidget {
  final SearchRoute queryRoute;
  
  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder(
      valueListenable: queryRoute.queryNotifier,
      builder: (context, queries, _) {
        final query = queries['q'];
        return Text('Searching for: $query');
      },
    );
  }
}

// Navigate
coordinator.push(SearchRoute(initialQuery: 'flutter'));
```

**Advantages:**
- Query parameters are **reactive** (ValueNotifier)
- Type-safe access via `queryParameters` map
- URL updates automatically when values change

---

## 404 Handling

### go_router

```dart
GoRouter(
  errorBuilder: (context, state) => const NotFoundPage(),
  routes: [...],
);
```

### ZenRouter

```dart
class NotFoundRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/404');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const NotFoundPage();
  }
}

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['products', String id] => ProductRoute(id),
      _ => NotFoundRoute(), // Catch-all
    };
  }
}
```

See [404 Handling Recipe](../recipes/404-handling.md) for advanced patterns.

---

## Deep Linking & Web URLs

Both go_router and ZenRouter support deep linking out of the box when using `MaterialApp.router`.

### URL Strategies

**go_router:**
```dart
import 'package:flutter_web_plugins/url_strategy.dart';

void main() {
  usePathUrlStrategy(); // Remove # from URLs
  runApp(MyApp());
}
```

**ZenRouter:**
```dart
import 'package:flutter_web_plugins/url_strategy.dart';

void main() {
  usePathUrlStrategy(); // Same as go_router
  runApp(MyApp());
}
```

See [URL Strategies Recipe](../recipes/url-strategies.md) for deployment configuration.

---

## Common Gotchas

> [!CAUTION]
> **String paths vs route objects**
> go_router uses string paths everywhere. ZenRouter uses route objects. Don't try to call `coordinator.push('/path')`—use `coordinator.push(RouteClass())`.

> [!TIP]
> **Preserve intended destinations**
> In go_router, you manually preserve `state.matchedLocation`. In ZenRouter, pass `intendedRoute` to your LoginRoute and it's automatically handled.

> [!NOTE]
> **No global redirect**
> go_router has a global `redirect` callback. ZenRouter uses per-route `RouteRedirect` mixins. This is more modular but requires adding the mixin to each protected route.

> [!WARNING]
> **Path parameter extraction**
> go_router extracts parameters from the path. ZenRouter expects you to **parse** them in `parseRouteFromUri` and **pass** them as constructor arguments.

---

## Migration Checklist

- [ ] Replace `go_router` dependency with `zenrouter`
- [ ] Convert `GoRoute` definitions to `RouteTarget` classes
- [ ] Create a `Coordinator` with `parseRouteFromUri` implementation
- [ ] Update `MaterialApp` to use `coordinator.routerDelegate` and `routeInformationParser`
- [ ] Replace `context.go()`, `context.push()` with `coordinator.push()`, `coordinator.replace()`
- [ ] Replace `context.pushReplacement()` with `coordinator.pushReplacement()`
- [ ] Migrate `redirect` callbacks to `RouteRedirect` mixins
- [ ] Convert `ShellRoute` to `RouteLayout` classes
- [ ] Update query parameter handling to use `RouteQueryParameters`
- [ ] Test deep linking and web URLs
- [ ] Add 404 handling with catch-all pattern

---

## What You Gain

### Type Safety
```dart
// go_router - runtime error if typo
context.go('/prodcuts/123'); // No compile error!

// ZenRouter - compile-time safety
coordinator.push(ProductRoute('123')); // Type-checked!
```

### Paradigm Flexibility

If Coordinator feels heavy for your use case, switch to Imperative:

```dart
final path = NavigationPath<AppRoute>.create();

// Direct push/pop
path.push(HomeRoute());
path.push(ProductRoute('123'));
path.pop();
```

### Better Refactoring

Routes are classes, so renaming and refactoring is safer. Your IDE can find all references.

### Cleaner Deep Link Handling

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    ['products', String id] when id.length == 36 => ProductRoute(id),
    ['products', String id] => ProductRoute(id, legacy: true),
    _ => NotFoundRoute(),
  };
}
```

Pattern matching gives you powerful URI parsing logic.

---

## Need Help?

- [ZenRouter Getting Started](../guides/getting-started.md)
- [Coordinator Pattern Guide](../paradigms/coordinator.md)
- [Authentication Recipe](../recipes/authentication-flow.md)
- [GitHub Issues](https://github.com/definev/zenrouter/issues)

---

**Happy migrating! 🧘**



================================================
FILE: packages/zenrouter/doc/migration/from-navigator.md
================================================
# Migrating from Navigator 1.0 / 2.0 to ZenRouter

## Why Migrate?

Flutter's Navigator APIs are powerful but low-level. Navigator 1.0 requires manual route management, and Navigator 2.0 (Router API) has a steep learning curve. ZenRouter simplifies both approaches while adding type safety, better IDE support, and modern patterns.

**What you'll gain:**
- ✅ **Type-safe routes** - No more string-based route names
- ✅ **Better DX** - Less boilerplate than Navigator 2.0
- ✅ **Paradigm choice** - Use Imperative (like Navigator 1.0) or Coordinator (like Navigator 2.0)
- ✅ **Deep linking** - Built-in support without complex setup
- ✅ **State restoration** - Automatic with Coordinator pattern

---

## Quick Comparison

| Feature | Navigator 1.0 | Navigator 2.0 | ZenRouter |
|---------|---------------|---------------|-----------|
| **API Style** | Imperative | Declarative | Both + Coordinator |
| **Type Safety** | String routes | Manual | Built-in |
| **Deep Linking** | Complex | Built-in | Built-in (Coordinator) |
| **State Restoration** | Manual | Manual | Automatic (Coordinator) |
| **Learning Curve** | Low | High | Medium |
| **Boilerplate** | Low | High | Low-Medium |

---

## From Navigator 1.0

### Navigator 1.0 Example

```dart
// Route names
class Routes {
  static const home = '/';
  static const product = '/product';
  static const profile = '/profile';
}

// MaterialApp with routes
MaterialApp(
  initialRoute: Routes.home,
  routes: {
    Routes.home: (context) => const HomePage(),
    Routes.profile: (context) => const ProfilePage(),
  },
  onGenerateRoute: (settings) {
    if (settings.name?.startsWith(Routes.product) ?? false) {
      final id = settings.name!.split('/').last;
      return MaterialPageRoute(
        builder: (context) => ProductPage(id: id),
        settings: settings,
      );
    }
    return null;
  },
);

// Navigation
Navigator.pushNamed(context, Routes.profile);
Navigator.pushNamed(context, '${Routes.product}/123');
Navigator.pop(context);
```

### ZenRouter Imperative (Similar Feel)

```dart
// Define routes as classes
abstract class AppRoute extends RouteTarget {
  Widget build(BuildContext context);
}

class HomeRoute extends AppRoute {
  @override
  Widget build(BuildContext context) => const HomePage();
}

class ProfileRoute extends AppRoute {
  @override
  Widget build(BuildContext context) => const ProfilePage();
}

class ProductRoute extends AppRoute {
  final String id;
  ProductRoute(this.id);
  
  @override
  List<Object?> get props => [id];
  
  @override
  Widget build(BuildContext context) => ProductPage(id: id);
}

// Create a navigation path
final appPath = NavigationPath<AppRoute>.create();

// MaterialApp
MaterialApp(
  home: NavigationStack(
    path: appPath,
    defaultRoute: HomeRoute(),
    resolver: (route) => StackTransition.material(
      route.build(context),
    ),
  ),
);

// Navigation (type-safe!)
appPath.push(ProfileRoute());
appPath.push(ProductRoute('123'));
appPath.pop();
```

**Advantages:**
- **Type safety** - `ProductRoute('123')` instead of string concatenation
- **Parameter safety** - Constructor arguments instead of parsing strings
- **No route name constants** - Routes are classes
- **IDE support** - Autocomplete, refactoring, find usages

---

## From Navigator 2.0

Navigator 2.0 requires implementing `RouterDelegate`, `RouteInformationParser`, and managing page stacks manually. ZenRouter's Coordinator pattern provides the same capabilities with much less code.

### Navigator 2.0 Example

```dart
class AppRouterDelegate extends RouterDelegate<RoutePath>
    with ChangeNotifier, PopNavigatorRouterDelegateMixin {
  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();
  
  final List<Page> _pages = [];
  
  @override
  Widget build(BuildContext context) {
    return Navigator(
      key: navigatorKey,
      pages: List.unmodifiable(_pages),
      onPopPage: (route, result) {
        if (!route.didPop(result)) return false;
        _pages.removeLast();
        notifyListeners();
        return true;
      },
    );
  }
  
  @override
  Future<void> setNewRoutePath(RoutePath path) async {
    // Update _pages based on path
    // ... complex logic ...
    notifyListeners();
  }
}

class AppRouteInformationParser extends RouteInformationParser<RoutePath> {
  @override
  Future<RoutePath> parseRouteInformation(RouteInformation info) async {
    final uri = Uri.parse(info.uri.toString());
    // Parse URI to RoutePath
    // ... manual parsing logic ...
    return RoutePath(/* ... */);
  }
  
  @override
  RouteInformation? restoreRouteInformation(RoutePath path) {
    // Convert RoutePath back to URI
    // ... manual conversion ...
    return RouteInformation(uri: Uri.parse(/* ... */));
  }
}

// In MaterialApp
final routerDelegate = AppRouterDelegate();
final routeInformationParser = AppRouteInformationParser();

MaterialApp.router(
  routerDelegate: routerDelegate,
  routeInformationParser: routeInformationParser,
);
```

### ZenRouter Coordinator (Much Simpler)

```dart
// Define routes
abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

class ProductRoute extends AppRoute {
  final String id;
  ProductRoute(this.id);
  
  @override
  List<Object?> get props => [id];
  
  @override
  Uri toUri() => Uri.parse('/products/$id');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ProductPage(id: id);
  }
}

// Coordinator (replaces RouterDelegate + RouteInformationParser)
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['products', String id] => ProductRoute(id),
      _ => NotFoundRoute(),
    };
  }
}

// In MaterialApp
final coordinator = AppCoordinator();

MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
);
```

**Advantages:**
- **10x less boilerplate** - No manual page stack management
- **Automatic URL generation** - Each route knows its URI via `toUri()`
- **Built-in state restoration** - Works automatically
- **Type-safe parsing** - Pattern matching instead of string manipulation

---

## Named Routes Migration

### Navigator 1.0 Named Routes

```dart
// Define routes
class Routes {
  static const home = '/';
  static const settings = '/settings';
  static const about = '/about';
}

// In MaterialApp
routes: {
  Routes.home: (context) => const HomePage(),
  Routes.settings: (context) => const SettingsPage(),
  Routes.about: (context) => const AboutPage(),
}

// Navigate
Navigator.pushNamed(context, Routes.settings);
Navigator.pushNamed(context, Routes.about);
```

### ZenRouter Equivalent

```dart
// Define route classes
class HomeRoute extends AppRoute {
  @override
  Widget build(BuildContext context) => const HomePage();
}

class SettingsRoute extends AppRoute {
  @override
  Widget build(BuildContext context) => const SettingsPage();
}

class AboutRoute extends AppRoute {
  @override
  Widget build(BuildContext context) => const AboutPage();
}

// Navigate (type-safe)
appPath.push(SettingsRoute());
appPath.push(AboutRoute());
```

No route name constants needed - the route class IS the identifier.

---

## Route Arguments

### Navigator 1.0 Arguments

```dart
// Pass arguments
Navigator.pushNamed(
  context,
  '/product',
  arguments: {'id': '123', 'name': 'Widget'},
);

// Receive arguments
class ProductPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final args = ModalRoute.of(context)!.settings.arguments as Map<String, dynamic>;
    final id = args['id'] as String;
    final name = args['name'] as String;
    
    return Text('Product: $id - $name');
  }
}
```

### ZenRouter Type-Safe Arguments

```dart
// Route with parameters
class ProductRoute extends AppRoute {
  final String id;
  final String name;
  
  ProductRoute({required this.id, required this.name});
  
  @override
  List<Object?> get props => [id, name];
  
  @override
  Widget build(BuildContext context) {
    return ProductPage(id: id, name: name);
  }
}

// Navigate (compile-time type checking!)
appPath.push(ProductRoute(id: '123', name: 'Widget'));

// Receive arguments
class ProductPage extends StatelessWidget {
  final String id;
  final String name;
  
  const ProductPage({required this.id, required this.name});
  
  @override
  Widget build(BuildContext context) {
    return Text('Product: $id - $name');
  }
}
```

**No runtime casting, no null checks, no errors!**

---

## Custom Transitions

### Navigator 1.0 PageRoute

```dart
class FadePageRoute extends PageRouteBuilder {
  final Widget page;
  
  FadePageRoute({required this.page})
      : super(
          pageBuilder: (context, animation, secondaryAnimation) => page,
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(opacity: animation, child: child);
          },
        );
}

// Navigate
Navigator.push(context, FadePageRoute(page: const ProfilePage()));
```

### ZenRouter StackTransition

```dart
class FadePage<T> extends Page<T> {
  const FadePage({super.key, required this.child});
  final Widget child;

  @override
  Route<T> createRoute(BuildContext context) {
    return PageRouteBuilder<T>(
      settings: this,
      pageBuilder: (context, animation, _) {
        return FadeTransition(
          opacity: animation,
          child: child,
        );
      },
    );
  }
}

// In resolver
resolver: (route) {
  if (route is ProfileRoute) {
    return StackTransition.custom<ProfileRoute>(
      builder: (context) => const ProfilePage(),
      pageBuilder: (context, routeKey, child) => FadePage(
        key: routeKey,
        child: child,
      ),
    );
  }
  return StackTransition.material(route.build(context));
}
```

See [Route Transitions Recipe](../recipes/route-transitions.md) for more patterns.

---

## WillPopScope / PopScope Migration

### Navigator 1.0/2.0 WillPopScope

```dart
class EditPage extends StatefulWidget {
  @override
  State<EditPage> createState() => _EditPageState();
}

class _EditPageState extends State<EditPage> {
  bool _hasUnsavedChanges = false;
  
  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: () async {
        if (!_hasUnsavedChanges) return true;
        
        return await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('Discard changes?'),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: const Text('Cancel'),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context, true),
                child: const Text('Discard'),
              ),
            ],
          ),
        ) ?? false;
      },
      child: Scaffold(/* ... */),
    );
  }
}
```

### ZenRouter RouteGuard

```dart
class EditRoute extends AppRoute with RouteGuard {
  final bool hasUnsavedChanges;
  
  EditRoute({this.hasUnsavedChanges = false});
  
  @override
  List<Object?> get props => [hasUnsavedChanges];
  
  @override
  Future<bool> canPop() async {
    if (!hasUnsavedChanges) return true;
    
    final result = await showDialog<bool>(
      context: navigatorKey.currentContext!,
      builder: (context) => AlertDialog(
        title: const Text('Discard changes?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Discard'),
          ),
        ],
      ),
    );
    
    return result ?? false;
  }
  
  @override
  Widget build(BuildContext context) {
    return EditPage(onChanged: () {
      // Update route with new state
      coordinator.replace(EditRoute(hasUnsavedChanges: true));
    });
  }
}
```

---

## Deep Linking

### Navigator 2.0 Deep Linking

Requires significant boilerplate with `RouteInformationParser` and `RouterDelegate`.

### ZenRouter Deep Linking

**Automatic** with Coordinator pattern! Just define `toUri()` and `parseRouteFromUri()`:

```dart
class ProductRoute extends AppRoute {
  final String id;
  ProductRoute(this.id);
  
  @override
  Uri toUri() => Uri.parse('/products/$id');
}

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['products', String id] => ProductRoute(id),
      _ => NotFoundRoute(),
    };
  }
}
```

Now links like `myapp://products/123` automatically work!

---

## Common Gotchas

> [!CAUTION]
> **Context.pushNamed is gone**
> Navigator 1.0's `context.pushNamed()` becomes `path.push(Route())` or `coordinator.push(Route())`.

> [!TIP]
> **Choose your paradigm**
> If you loved Navigator 1.0's simplicity, use ZenRouter **Imperative**. If you need Navigator 2.0's power, use **Coordinator**.

> [!NOTE]
> **Arguments are constructor parameters**
> No more `ModalRoute.of(context)!.settings.arguments`. Pass data through route constructors.

> [!WARNING]
> **onGenerateRoute is parseRouteFromUri**
> The pattern matching in `parseRouteFromUri` replaces `onGenerateRoute` logic.

---

## Migration Checklist

### From Navigator 1.0

- [ ] Convert route name constants to `RouteTarget` classes
- [ ] Create a `NavigationPath` or `Coordinator`
- [ ] Replace `MaterialApp.routes` with `NavigationStack` or `MaterialApp.router`
- [ ] Update all `Navigator.pushNamed()` to `path.push(Route())`
- [ ] Convert route arguments to constructor parameters
- [ ] Replace `onGenerateRoute` with `parseRouteFromUri` (if using Coordinator)
- [ ] Migrate `WillPopScope` to `RouteGuard` mixin

### From Navigator 2.0

- [ ] Delete custom `RouterDelegate` and `RouteInformationParser`
- [ ] Convert page classes to `RouteTarget` classes
- [ ] Create `Coordinator` with `parseRouteFromUri`
- [ ] Implement `toUri()` on each route
- [ ] Update `MaterialApp.router` to use `coordinator.routerDelegate` and `routeInformationParser`
- [ ] Test deep linking and state restoration

---

## What You Gain

### Type Safety

```dart
// Navigator 1.0 - runtime error
Navigator.pushNamed(context, '/prodcut/123'); // Typo!

// ZenRouter - compile error
coordinator.push(Prodcut Route('123')); // Won't compile!
```

### Less Boilerplate

Navigator 2.0 requires ~200 lines for basic routing. ZenRouter Coordinator: ~50 lines.

### Better IDE Support

- Autocomplete for routes
- Find all usages
- Rename refactoring
- Type hints

---

## Need Help?

- [ZenRouter Getting Started](../guides/getting-started.md)
- [Imperative Paradigm Guide](../paradigms/imperative.md)
- [Coordinator Pattern Guide](../paradigms/coordinator.md)
- [Route Transitions Recipe](../recipes/route-transitions.md)
- [GitHub Issues](https://github.com/definev/zenrouter/issues)

---

**Happy migrating! 🧘**



================================================
FILE: packages/zenrouter/doc/paradigms/declarative.md
================================================
# Declarative Navigation

> **Define what the stack should look like, not how to build it**

The declarative paradigm lets you define your navigation stack as a function of your app's state. Instead of imperatively calling `push()` and `pop()`, you declare what routes should be present and let ZenRouter efficiently update the stack using Myers diff algorithm.

## When to Use Declarative Navigation

✅ **Use declarative navigation when:**
- Your navigation is driven by state changes (selected tab, list items, filters)
- You want React-like declarative UI for navigation
- You need efficient stack updates with minimal operations
- Your navigation stack mirrors your app state
- You're building tabbed interfaces or filtered lists

❌ **Don't use declarative navigation when:**
- Navigation is primarily event-driven (use [Imperative](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md) instead)
- You need deep linking or web URLs (use [Coordinator](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) instead)
- You need fine-grained control over push/pop operations

## Core Concept

In declarative navigation, you define the desired navigation stack based on your state, and ZenRouter automatically calculates the minimal set of operations needed to update the actual stack.

```dart
// Your state
int selectedPage = 1;
bool showSpecial = false;

// Your navigation stack is derived from state
NavigationStack.declarative(
  routes: [
    HomePage(),
    if (selectedPage > 0) PageRoute(selectedPage),
    if (showSpecial) SpecialRoute(),
  ],
  resolver: (route) => StackTransition.material(
    route.build(context),
  ),
)
```

When state changes, only the **changed routes** are added or removed - existing routes are preserved! This is powered by the **Myers diff algorithm**.

## How Myers Diff Works

Myers diff is an efficient algorithm that finds the minimal set of operations to transform one list into another.

### Example: Adding a Page

```dart
// Before (state: pages = [1, 2])
Stack: [Page1, Page2]

// After (state: pages = [1, 2, 3])
Stack: [Page1, Page2, Page3]

// Myers diff operation: INSERT Page3 at end
// ✅ Page1 and Page2 are preserved (not recreated!)
```

### Example: Removing a Page

```dart
// Before (state: pages = [1, 2, 3])
Stack: [Page1, Page2, Page3]

// After (state: pages = [1, 3])
Stack: [Page1, Page3]

// Myers diff operation: DELETE Page2
// ✅ Page1 and Page3 are preserved!
```

### Why This Matters

Without diff, changing the stack would destroy and recreate all routes, losing:
- Widget state (scroll position, form inputs, etc.)
- Animation continuity
- Performance

With Myers diff, only the minimal changes are applied, preserving everything else!

## Complete Example: Dynamic Page List

This example shows a list of pages that can be added or removed. Watch how the counter state is preserved when you add/remove other pages!

### Step 1: Define Your Routes

```dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// Route with a parameter
class PageRoute extends RouteTarget {
  final int pageNumber;
  
  PageRoute(this.pageNumber);
  
  // IMPORTANT: Must implement equality for diff to work!
  @override
  List<Object?> get props => [pageNumber];
}

class SpecialRoute extends RouteTarget {}
```

> **⚠️ Critical:** Routes **must** implement `==` and `hashCode` correctly for Myers diff to identify which routes changed!

### Step 2: Create Stateful Widget with State

```dart
class DemoScreen extends StatefulWidget {
  const DemoScreen({super.key});
  
  @override
  State<DemoScreen> createState() => _DemoScreenState();
}

class _DemoScreenState extends State<DemoScreen> {
  // State: list of page numbers to show
  final List<int> _pageNumbers = [1];
  int _nextPageNumber = 2;
  bool _showSpecial = false;
  
  void _addPage() {
    setState(() {
      _pageNumbers.add(_nextPageNumber);
      _nextPageNumber++;
    });
  }
  
  void _removePage(int pageNumber) {
    setState(() {
      _pageNumbers.remove(pageNumber);
    });
  }
  
  void _toggleSpecial() {
    setState(() {
      _showSpecial = !_showSpecial;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Declarative navigation stack
          Expanded(
            child: NavigationStack.declarative(
              routes: [
                // Derive routes from state
                for (final pageNumber in _pageNumbers) 
                  PageRoute(pageNumber),
                if (_showSpecial) 
                  SpecialRoute(),
              ],
              resolver: (route) => switch (route) {
                SpecialRoute() => StackTransition.sheet(
                  _buildSpecialPage(),
                ),
                PageRoute(:final pageNumber) => StackTransition.material(
                  PageView(pageNumber: pageNumber),
                ),
                _ => throw UnimplementedError(),
              },
            ),
          ),
          
          // Controls
          Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              children: [
                Row(
                  children: [
                    Checkbox(
                      value: _showSpecial,
                      onChanged: (_) => _toggleSpecial(),
                    ),
                    const Text('Show special page'),
                    const Spacer(),
                    ElevatedButton.icon(
                      onPressed: _addPage,
                      icon: const Icon(Icons.add),
                      label: const Text('Add Page'),
                    ),
                  ],
                ),
                Wrap(
                  spacing: 8,
                  children: _pageNumbers.map((pageNum) {
                    return Chip(
                      label: Text('Page $pageNum'),
                      onDeleted: _pageNumbers.length > 1
                          ? () => _removePage(pageNum)
                          : null,
                    );
                  }).toList(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildSpecialPage() {
    return Scaffold(
      appBar: AppBar(title: const Text('Special Route')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => setState(() => _showSpecial = false),
          child: const Text('Close'),
        ),
      ),
    );
  }
}
```

### Step 3: Build Stateful Page Widget

This widget demonstrates **state preservation** - the counter is preserved when other pages are added/removed:

```dart
class PageView extends StatefulWidget {
  final int pageNumber;
  
  const PageView({super.key, required this.pageNumber});
  
  @override
  State<PageView> createState() => _PageViewState();
}

class _PageViewState extends State<PageView> {
  int _counter = 0; // Widget state
  
  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Page ${widget.pageNumber}'),
        automaticallyImplyLeading: false,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('State Preservation Demo'),
            const SizedBox(height: 16),
            Text(
              'Counter: $_counter',
              style: const TextStyle(fontSize: 36, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              onPressed: _incrementCounter,
              icon: const Icon(Icons.add),
              label: const Text('Increment'),
            ),
            const SizedBox(height: 32),
            Text(
              'Try adding/removing other pages.\\n'
              'This counter stays preserved!',
              textAlign: TextAlign.center,
              style: TextStyle(color: Colors.grey[600]),
            ),
          ],
        ),
      ),
    );
  }
}
```

## API Reference

For complete API documentation including all methods and parameters, see:

**[→ Navigation Paths API Reference](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md#navigationstackdeclarative)**

Quick reference for `NavigationStack.declarative`:

| Parameter | Required | Description |
|-----------|----------|-------------|
| `routes` | ✅ Yes | List of routes derived from state |
| `resolver` | ✅ Yes | Function converting routes to `StackTransition` |
| `navigatorKey` | ❌ No | Key for accessing navigator state |
| `debugLabel` | ❌ No | Label for debugging |

**StackTransition types:**

| Type | Behavior |
|------|----------|
| `.material(child)` | Material page transition (platform adaptive) |
| `.cupertino(child)` | iOS-style slide from right |
| `.sheet(child)` | Bottom sheet presentation |
| `.dialog(child)` | Dialog presentation |
| `.custom(...)` | Custom transition with full control |

See [StackTransition API](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md#stacktransition) for detailed examples.


## State Patterns

### Pattern: Tab Navigation

Derive navigation from selected tab index:

```dart
class TabNavigation extends StatefulWidget {
  @override
  State<TabNavigation> createState() => _TabNavigationState();
}

class _TabNavigationState extends State<TabNavigation> {
  int _selectedTab = 0;
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: NavigationStack.declarative(
        routes: [
          // Base route always present
          HomeRoute(),
          // Active tab route
          switch (_selectedTab) {
            0 => FeedRoute(),
            1 => ProfileRoute(),
            2 => SettingsRoute(),
            _ => FeedRoute(),
          },
        ],
        resolver: (route) => StackTransition.material(
          route.build(context),
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedTab,
        onTap: (index) => setState(() => _selectedTab = index),
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Feed'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: 'Settings'),
        ],
      ),
    );
  }
}
```

### Pattern: Filtered List

Derive navigation from list filters:

```dart
class FilteredListNavigation extends StatefulWidget {
  @override
  State<FilteredListNavigation> createState() => _FilteredListNavigationState();
}

class _FilteredListNavigationState extends State<FilteredListNavigation> {
  String _searchQuery = '';
  String _category = 'all';
  
  List<Item> get _filteredItems {
    return allItems.where((item) {
      final matchesSearch = item.name.toLowerCase().contains(
        _searchQuery.toLowerCase(),
      );
      final matchesCategory = _category == 'all' || item.category == _category;
      return matchesSearch && matchesCategory;
    }).toList();
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Filter controls
          TextField(
            onChanged: (value) => setState(() => _searchQuery = value),
            decoration: const InputDecoration(hintText: 'Search...'),
          ),
          DropdownButton<String>(
            value: _category,
            onChanged: (value) => setState(() => _category = value!),
            items: const [
              DropdownMenuItem(value: 'all', child: Text('All')),
              DropdownMenuItem(value: 'tech', child: Text('Tech')),
              DropdownMenuItem(value: 'food', child: Text('Food')),
            ],
          ),
          
          // Declarative navigation based on filters
          Expanded(
            child: NavigationStack.declarative(
              routes: [
                ListRoute(),
                for (final item in _filteredItems)
                  ItemRoute(item.id),
              ],
              resolver: (route) => switch (route) {
                ListRoute() => StackTransition.material(
                  ListScreen(items: _filteredItems),
                ),
                ItemRoute(:final id) => StackTransition.material(
                  ItemDetailScreen(id: id),
                ),
                _ => throw UnimplementedError(),
              },
            ),
          ),
        ],
      ),
    );
  }
}
```

### Pattern: Wizard Flow with Steps

Derive navigation from current step:

```dart
class WizardNavigation extends StatefulWidget {
  @override
  State<WizardNavigation> createState() => _WizardNavigationState();
}

class _WizardNavigationState extends State<WizardNavigation> {
  int _currentStep = 0;
  WizardData _data = const WizardData();
  
  void _nextStep() {
    if (_currentStep < 2) {
      setState(() => _currentStep++);
    }
  }
  
  void _prevStep() {
    if (_currentStep > 0) {
      setState(() => _currentStep--);
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return NavigationStack.declarative(
      routes: [
        WelcomeRoute(),
        if (_currentStep >= 0) Step1Route(data: _data),
        if (_currentStep >= 1) Step2Route(data: _data),
        if (_currentStep >= 2) Step3Route(data: _data),
      ],
      resolver: (route) => StackTransition.material(
        route.build(context, onNext: _nextStep, onPrev: _prevStep),
      ),
    );
  }
}
```

## Best Practices

### ✅ DO: Implement Equality Correctly

Routes **must** implement `==` and `hashCode` for Myers diff to work, make sure you call `compareWith` to align with underline `RouteTarget` comparing logic.

```dart
class ItemRoute extends RouteTarget {
  final String itemId;
  
  ItemRoute(this.itemId);
  
  @override
  List<Object?> get props => [itemId];
}
```

Without proper equality, Myers diff can't identify unchanged routes and will recreate them unnecessarily!

### ✅ DO: Derive Routes from Single Source of Truth

Keep your state in one place and derive everything from it:

```dart
class AppState {
  final List<Item> selectedItems;
  final bool showDetails;
  final String? activeItemId;
}

// Derive routes from AppState
List<RouteTarget> buildRoutes(AppState state) {
  return [
    HomeRoute(),
    for (final item in state.selectedItems)
      ItemRoute(item.id),
    if (state.showDetails && state.activeItemId != null)
      DetailRoute(state.activeItemId!),
  ];
}
```

### ❌ DON'T: Mutate the Routes List

Don't modify the routes list after passing it - create a new list:

```dart
// ❌ BAD
final routes = [HomeRoute()];
routes.add(ProfileRoute()); // Mutation
NavigationStack.declarative(routes: routes, ...)

// ✅ GOOD
NavigationStack.declarative(
  routes: [
    HomeRoute(),
    ProfileRoute(),
  ],
  ...
)
```

### ❌ DON'T: Forget to Call setState

The stack only updates when you rebuild with new routes:

```dart
// ❌ BAD
void addPage() {
  _pages.add(PageRoute(2)); // Stack won't update!
}

// ✅ GOOD
void addPage() {
  setState(() {
    _pages.add(PageRoute(2)); // Triggers rebuild
  });
}
```

## Performance Characteristics

### Myers Diff Complexity

- **Time complexity:** O((N+M)D) where N and M are list lengths, D is the edit distance
- **Space complexity:** O((N+M)D)

For most navigation scenarios (small lists, few changes), this is very fast!

### Optimization Tips

1. **Implement equality correctly** - This lets Myers diff skip unchanged routes
2. **Use const constructors** - Flutter can skip widget rebuilds
3. **Avoid large route lists** - Keep navigation depth reasonable (< 10 routes typically)
4. **Batch state changes** - Update state once instead of multiple times

```dart
// ❌ BAD: Multiple setState calls
void updateFilters() {
  setState(() => _category = 'tech');    // Rebuild+diff
  setState(() => _searchQuery = 'phone'); // Rebuild+diff
}

// ✅ GOOD: Single setState call
void updateFilters() {
  setState(() {
    _category = 'tech';
    _searchQuery = 'phone';
  }); // Single rebuild+diff
}
```

## Transition to Other Paradigms

### Moving to Imperative

If you need more direct control over navigation timing:

```dart
// Instead of deriving stack from state...
NavigationStack.declarative(
  routes: [if (showDetail) DetailRoute()],
  resolver: resolver,
)

// ...use imperative push/pop at the right moment
onTap: () => path.push(DetailRoute())
```

### Moving to Coordinator

If you need deep linking or web support:

```dart
// Create new abstract route for your Coordinator
abstract class AppRoute extends RouteTarget with RouteUnique {}

class MyRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/my-route');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return MyScreen();
  }
}

// Still use declarative style with Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  void updateNavigation(AppState state) {
    root.replace([
      HomeRoute(),
      for (final item in state.items) ItemRoute(item.id),
    ]);
  }
}
```

## See Also

- [Imperative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md) - Direct stack control
- [Coordinator Pattern](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) - Deep linking and web support
- [Myers Diff Implementation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/diff.md) - Algorithm details
- [DeclarativeNavigationStack API](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md#declarativenavigationstack) - Complete API reference



================================================
FILE: packages/zenrouter/doc/paradigms/imperative.md
================================================
# Imperative Navigation

> **You control the navigation stack directly**

The imperative paradigm gives you full, explicit control over the navigation stack. You manually call methods like `push()`, `pop()`, and `replace()` to manipulate routes - just like Navigator 1.0, but with better type safety and features.

## When to Use Imperative Navigation

✅ **Use imperative navigation when:**
- Building mobile-only apps without web support
- You want simple, straightforward navigation control
- Navigation logic is event-driven (button clicks, gestures)
- You're migrating from Navigator 1.0
- You need fine-grained control over the stack

❌ **Don't use imperative navigation when:**
- You need deep linking or web URL support (use [Coordinator](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) instead)
- Your navigation is driven by state changes (use [Declarative](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md) instead)
- You want automatic browser back button support

## Core Concept

In imperative navigation, you work directly with a `NavigationPath` - a stack-based container for routes. You push routes onto the stack, pop them off, and replace the entire stack as needed.

```dart
final path = NavigationPath<RouteTarget>.create();
// Or: StackPath.navigationStack<RouteTarget>()

// Push a route
await path.push(ProfileRoute('user123'));

// Pop the current route
path.pop({'saved': true});

// Replace the entire stack
path.replace([HomeRoute(), SettingsRoute()]);
```

## Complete Example: Multi-Step Form

This example demonstrates a complete onboarding flow with multiple screens, state management, and navigation guards.

### Step 1: Define Your Data Model

```dart
import 'package:zenrouter/zenrouter.dart';

class OnboardingFormData {
  final String? fullName;
  final String? email;
  final DateTime? birthDate;
  final List<String> interests;
  
  const OnboardingFormData({
    this.fullName,
    this.email,
    this.birthDate,
    this.interests = const [],
  });
  
  // Immutable updates
  OnboardingFormData copyWith({
    String? fullName,
    String? email,
    DateTime? birthDate,
    List<String>? interests,
  }) {
    return OnboardingFormData(
      fullName: fullName ?? this.fullName,
      email: email ?? this.email,
      birthDate: birthDate ?? this.birthDate,
      interests: interests ?? this.interests,
    );
  }
}
```

### Step 2: Define Routes That Carry State

Each route carries its own state via constructor parameters:

```dart
sealed class OnboardingRoute extends RouteTarget {
  Widget build(BuildContext context);
}

class PersonalInfoStep extends OnboardingRoute with RouteGuard {
  final OnboardingFormData formData;
  final _nameController = TextEditingController();
  final _emailController = TextEditingController();
  
  PersonalInfoStep({required this.formData}) {
    // Initialize controllers from route state
    _nameController.text = formData.fullName ?? '';
    _emailController.text = formData.email ?? '';
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Personal Information')),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          children: [
            TextField(
              controller: _nameController,
              decoration: const InputDecoration(labelText: 'Full Name'),
            ),
            TextField(
              controller: _emailController,
              decoration: const InputDecoration(labelText: 'Email'),
            ),
            ElevatedButton(
              onPressed: () => _onNext(context),
              child: const Text('Continue'),
            ),
          ],
        ),
      ),
    );
  }
  
  void _onNext(BuildContext context) {
    // Create updated state
    final updatedData = formData.copyWith(
      fullName: _nameController.text,
      email: _emailController.text,
    );
    
    // Navigate to next step with updated state
    onboardingPath.push(PreferencesStep(formData: updatedData));
  }
  
  @override
  Future<bool> popGuard() async {
    // Show confirmation dialog before leaving
    final shouldExit = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Exit Onboarding?'),
        content: const Text('Your progress will be lost.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Exit'),
          ),
        ],
      ),
    );
    return shouldExit ?? false;
  }
}

class PreferencesStep extends OnboardingRoute {
  final OnboardingFormData formData;
  
  PreferencesStep({required this.formData});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Preferences'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => onboardingPath.pop(), // Navigate back
        ),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          children: [
            const Text('What interests you?'),
            // Interest selection UI...
            ElevatedButton(
              onPressed: () {
                // Navigate to next step
                onboardingPath.push(ReviewStep(formData: formData));
              },
              child: const Text('Continue'),
            ),
          ],
        ),
      ),
    );
  }
}

class ReviewStep extends OnboardingRoute {
  final OnboardingFormData formData;
  
  ReviewStep({required this.formData});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Review')),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          children: [
            Text('Name: ${formData.fullName}'),
            Text('Email: ${formData.email}'),
            Text('Interests: ${formData.interests.join(", ")}'),
            ElevatedButton(
              onPressed: () async {
                // Submit and navigate to success
                await _submitForm();
                onboardingPath.push(SuccessStep(formData: formData));
              },
              child: const Text('Submit'),
            ),
          ],
        ),
      ),
    );
  }
  
  Future<void> _submitForm() async {
    // Submit to backend
    await Future.delayed(const Duration(seconds: 2));
  }
}

class SuccessStep extends OnboardingRoute {
  final OnboardingFormData formData;
  
  SuccessStep({required this.formData});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.check_circle, color: Colors.green, size: 100),
            const SizedBox(height: 32),
            Text('Welcome ${formData.fullName}!'),
            ElevatedButton(
              onPressed: () {
                // Reset to welcome screen
                onboardingPath.reset();
                onboardingPath.push(WelcomeStep());
              },
              child: const Text('Get Started'),
            ),
          ],
        ),
      ),
    );
  }
}
```

### Step 3: Create Navigation Path

```dart
// Global navigation path for onboarding
final onboardingPath = NavigationPath<OnboardingRoute>.create();
// Or: StackPath.navigationStack<OnboardingRoute>()
```

### Step 4: Render with NavigationStack

```dart
class OnboardingApp extends StatelessWidget {
  const OnboardingApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: NavigationStack(
        path: onboardingPath,
        defaultRoute: WelcomeStep(), // Initial route
        resolver: (route) {
          // Convert routes to page destinations
          return StackTransition.material(
            route.build(context),
          );
        },
      ),
    );
  }
}
```

## API Reference

For complete API documentation including all methods, properties, and advanced usage, see:

**[→ Navigation Paths API Reference](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md#navigationpath)**

Quick reference for `NavigationPath`:

| Method | Description |
|--------|-------------|
| `push(T)` | Push route onto stack, returns `Future` with pop result |
| `pop([result])` | Pop top route, consults guards |
| `replace(List<T>)` | Replace entire stack |
| `pushOrMoveToTop(T)` | Push or move route to top (for tabs) |
| `remove(T)` | Remove specific route (no guards) |
| `reset()` | Clear all routes (no guards) |

| Property | Description |
|----------|-------------|
| `stack` | Unmodifiable view of current stack |
| `debugLabel` | Optional label for debugging |


## Best Practices

### ✅ DO: Use Immutable State

Routes should carry immutable state and return updated state via `copyWith`:

```dart
class MyRoute extends RouteTarget {
  final String userId;
  final bool isEditing;
  
  MyRoute({required this.userId, this.isEditing = false});
  
  MyRoute copyWith({String? userId, bool? isEditing}) {
    return MyRoute(
      userId: userId ?? this.userId,
      isEditing: isEditing ?? this.isEditing,
    );
  }
}
```

### ✅ DO: Implement Equality for Parameterized Routes

Routes with parameters must override `props`:

```dart
class ProfileRoute extends RouteTarget {
  final String userId;
  
  ProfileRoute(this.userId);
  
  @override
  List<Object?> get props => [userId];
}
```

### ✅ DO: Use Guards for Unsaved Changes

Prevent accidental data loss with `RouteGuard`:

```dart
class FormRoute extends RouteTarget with RouteGuard {
  bool hasUnsavedChanges = false;
  
  @override
  Future<bool> popGuard() async {
    if (!hasUnsavedChanges) return true;
    
    final shouldPop = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Unsaved Changes'),
        content: const Text('Discard changes?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Discard'),
          ),
        ],
      ),
    );
    
    return shouldPop ?? false;
  }
}
```

### ❌ DON'T: Use Global Mutable State

Avoid storing form state in global variables:

```dart
// ❌ BAD
var globalFormData = FormData();

class MyRoute extends RouteTarget {
  void onSubmit() {
    globalFormData.name = controller.text; // Mutating global state
  }
}

// ✅ GOOD
class MyRoute extends RouteTarget {
  final FormData formData; // State passed via constructor
  
  MyRoute({required this.formData});
  
  void onSubmit() {
    final updated = formData.copyWith(name: controller.text);
    path.push(NextRoute(formData: updated));
  }
}
```

### ❌ DON'T: Assume Stack Order

Don't rely on specific stack positions - they can change:

```dart
// ❌ BAD
path.stack[0]; // Might not be what you expect

// ✅ GOOD
path.stack.firstWhere((r) => r is HomeRoute);
```

## Common Patterns

### Pattern: Multi-Step Wizard

```dart
// Step 1 → Step 2 → Step 3 → Complete
path.push(Step1(data: data));
// In Step1: path.push(Step2(data: updatedData));
// In Step2: path.push(Step3(data: updatedData));
// In Step3: path.replace([HomeRoute()]); // Reset after completion
```

### Pattern: Modal Flow

```dart
// Show a modal flow that returns a result
final result = await path.push(ModalFlowStart());
if (result != null) {
  // Use the result
  print('User selected: $result');
}
```

### Pattern: Conditional Navigation

```dart
void navigateBasedOnState() {
  if (user.isLoggedIn) {
    path.push(DashboardRoute());
  } else {
    path.push(LoginRoute());
  }
}
```

## Transition to Other Paradigms

### Moving to Declarative

If your navigation becomes state-driven, consider [Declarative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md):

```dart
// Instead of imperatively pushing based on state...
if (selectedTab == 0) path.pushOrMoveToTop(Tab1());
if (selectedTab == 1) path.pushOrMoveToTop(Tab2());

// ...derive the stack from state declaratively
NavigationStack.declarative(
  routes: [
    HomeRoute(),
    if (selectedTab == 0) Tab1(),
    if (selectedTab == 1) Tab2(),
  ],
  resolver: (route) => ...,
)
```

### Moving to Coordinator

If you need deep linking or web support, upgrade to [Coordinator](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md):

```dart
// 1. Add RouteUnique to your routes
class HomeRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return HomeScreen();
  }
}

// 2. Create a Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile'] => ProfileRoute(),
      _ => NotFoundRoute(),
    };
  }
}

// 3. Use MaterialApp.router
MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
)
```

## See Also

- [Declarative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md) - State-driven routing
- [Coordinator Pattern](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/coordinator.md) - Deep linking and web support
- [Route Mixins Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/mixins.md) - RouteGuard, RouteRedirect, and more
- [NavigationPath API](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/navigation-paths.md#navigationpath) - Complete API reference



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/coordinator-vi.md
================================================
[Binary file]


================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/coordinator.md
================================================
# Write your first Coordinator

> **Centralize routing, handle deep links, manage nested navigation**

You are now starting the quick start guide to create your first Coordinator to enable handling routing in your app. In about 15 minutes, you will learn the basics. Now let's start!

## What is a Coordinator?

The Coordinator is a pattern that provides a centralized routing system with deep linking, URL synchronization, and support for complex nested navigation hierarchies. It's the most powerful paradigm in ZenRouter, building on top of the imperative foundation.

### When to Use Coordinator

- You need deep linking or web URL support
- Building for web with browser navigation
- You want centralized route management
- You have complex nested navigation (tabs within tabs, drawer + tabs)
- You need URL-based routing and navigation
- You want debuggable route state
- You're building a large app with many routes

Let's dive into the core concepts of the Coordinator.


## Example app

The code of example app can be found [here](https://github.com/definev/zenrouter/tree/main/packages/zenrouter/doc/paradigms/coordinator/example). You can go to the `example` folder and run `flutter run` to see the final result or follow step by step guide below.

### Create the project

Let's create your project with the `flutter create` command.

```bash
flutter create --empty coordinator_example
cd coordinator_example
```

After that open the project inside your favourite IDE and add the `zenrouter` dependency to your `pubspec.yaml` file.

```yaml
dependencies:
  zenrouter: ^0.2.1
```

Now that the setup is complete, let's create a folder structure for our app.

```bash
lib
|- main.dart
|- routes
| |- coordinator.dart
| |- app_route.dart
```

### Setup Coordinator

A `Coordinator` is the central piece of URI routing.

A `Coordinator` manages multiple `StackPath`s and provides:
1. **URI Parsing** - Converts URLs to routes
2. **Route Resolution** - Finds the correct path for each route
3. **Deep Linking** - Handles incoming deep links
4. **Nested Navigation** - Manages multiple navigation stacks

When using Coordinator you must override `parseRouteFromUri` method to convert **URI** to **Route**.

The AppRoute class represents a route in the application. It extends the RouteTarget class and implements the RouteUnique mixin. This ensures that each route has a unique identifier. See more at [Mixin Section](#routeunique).

```dart
/// file: lib/routes/coordinator.dart

import 'app_route.dart';

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    ...
  }
}
```

And setup the `AppRoute` for `Coordinator`.

```dart
/// file: lib/routes/app_route.dart

abstract class AppRoute extends RouteTarget with RouteUnique {}
```

### How to create a Route?

You will extend the `AppRoute` abstract class above to create a new Route in our app.

For example, here is the `Home` and `PostDetail` route. `Home` has no parameters, while `PostDetail` has an `id` parameter.

> **Important**: When a route has parameters (like `id` in `PostDetail`), you **must** override `props` to include them. ZenRouter uses this for equality checks to prevent duplicate routes and handle updates correctly.

```dart
/// file: lib/routes/app_route.dart

class Home extends AppRoute {
  Uri toUri() => Uri.parse('/');
  
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home'),
      ),
      body: Center(
        child: FilledButton(
          onPressed: () => coordinator.push(PostDetail(id: 1)),
          child: const Text('Go to Post Detail'),
        ),
      ),
    );
  }
}

class PostDetail extends AppRoute {
  PostDetail({
    required this.id,
  });
  
  final String id;
  
  /// If the params has involved in `toUri` function, you must add it to `props`
  List<Object?> get props => [id];
  
  Uri toUri() => Uri.parse('/post/$id');
  
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Post $id Detail'),
      ),
      body: Center(
        child: Text('Post ID: $id'),
      ),
    );
  }
}
```

### Wiring up the Coordinator

So let's go back to your `AppCoordinator`. You will need to implement the `uri` to `AppRoute` mapping in the `parseRouteFromUri` method.

```dart
/// file: lib/routes/coordinator.dart

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => Home(),
      ['post', String id] => PostDetail(id: id),
      /// No matching route found
      _ => NotFoundRoute(uri: uri),
    };
  }
}

/// No matching route found
class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});

  final Uri uri;
  
  @override
  Uri toUri() => uri;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Not Found'),
      ),
      body: Center(
        child: Text('Route not found: $uri'),
      ),
    );
  }
}
```

That's it! You have now created a Coordinator that can handle deep links and nested navigation.

Finally just wire your `Coordinator` inside your `MaterialApp`.

```dart

void main() {
  runApp(const MainApp());
}

/// The entrypoint of your app
/// 
/// It wire up the `Coordinator` inside your `MaterialApp`.
class MainApp extends StatelessWidget {
  const MainApp({super.key});

  final appCoordinator = AppCoordinator();

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: appCoordinator.routerDelegate,
      routeInformationParser: appCoordinator.routeInformationParser,
    );
  }
}
```

Let's run your app in browser with 
```
flutter run -d chrome --web-hostname=0.0.0.0 --web-port=8080
```
Now when you open `http://localhost:8080/#/post/123`, it goes directly to post 123.

### Advanced Usage

Now that you have two basic routes in your app, let's advance! 
Imagine a home view with two tabs: `Feed` and `Profile`.
- The `Feed` tab contains two sub-routes: `PostList` and `PostDetail`.
- The `Profile` tab contains two sub-routes: `ProfileView` and `SettingsView`.

The `Feed` Flow: You have a list of posts, and when you click on a post, it will navigate to the `PostDetail` route.

```bash
 0---------------------0
 |                     |
 | Post 1              |
 |- - - - - - - - - - -|
 | Post 2              |
 |- - - - - - - - - - -|
 | Post 3              |
 |- - - - - - - - - - -|
 | Post 4              |
 |- - - - - - - - - - -|
 |                     |
 |                     |
 |                     |
 |                     |
 0---------------------0
 |  Feed    | Profile  |
 |    *     |          |
 0---------------------0
          |
          | Click "Post 1"
          V
 0---------------------0
 |                     |
 |    Post 1 Detail    |
 |- - - - - - - - - - -|
 |                     |
 |                     |
 |      Post id: 1     |
 |         |           |
 |     Lorem ipsum     |
 |                     |
 |                     |
 |                     |
 |                     |
 |                     |
 0---------------------0
 |  Feed    | Profile  |
 |    *     |          |
 0---------------------0

```

The `Profile` Flow: You have a profile view and a settings view.

```bash
 0---------------------0
 |                     |
 | Hello, User         |
 |- - - - - - - - - - -|
 | Open "Settings"     |
 |                     |
 |                     |
 |                     |
 |                     |
 0---------------------0
 |  Feed    | Profile  |
 |          |    *     |
 0---------------------0
          |
          | Click "Settings"
          V
 0---------------------0
 |                     |
 | <- Settings View    |
 |- - - - - - - - - - -|
 |                     |
 |                     |
 |                     |
 |                     |
 |                     |
 0---------------------0
 |  Feed    | Profile  |
 |          |    *     |
 0---------------------0
```

That represents the whole flow of our new app. To achieve this, I need to introduce you to a new concept: `RouteLayout`. `RouteLayout` implements `RouteUnique` and owns a `StackPath` (which contains a list of `RouteUnique` items).

There are two types of `StackPath`:
- `NavigationPath`: A stack path where you can push, pop, or remove routes dynamically; usually used with `NavigationStack`.
- `IndexedStackPath`: A stack path that has a fixed number of routes. You cannot modify it after initialization and can only select which one is currently active; usually used with `IndexedStack`.

For the layout above, we have 3 `RouteLayout`s to create:
- `FeedLayout`: A `NavigationPath` that can have 2 tabs: `PostList` and `PostDetail`.
- `ProfileLayout`: A `NavigationPath` that can have 2 tabs: `ProfileView` and `SettingsView`.
- `HomeLayout`: An `IndexedStackPath` that contains only 2 tabs: `FeedLayout` and `ProfileLayout`. (Note that `RouteLayout` is still a `RouteUnique`, so it can be used as a route).

You must define the `StackPath` in the `Coordinator`. Let's create it in `lib/routes/coordinator.dart`.

```dart
/// file: lib/routes/coordinator.dart

class AppCoordinator extends Coordinator<AppRoute> {
  late final homeIndexed = IndexedStackPath<AppRoute>.createWith(
    [
      FeedLayout(),
      ProfileLayout(),
    ],
    coordinator: this,
    label: 'home',
  );
  late final feedNavigation = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'feed',
  );
  late final profileNavigation = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'profile',
  );

  /// IMPORTANT: You must register all your stack paths here!
  /// ZenRouter uses this list to manage navigation state and listeners.
  /// Don't forget to include the 'root' path which is provided by the Coordinator.
  @override
  List<StackPath<RouteTarget>> get paths => [
    root, 
    homeIndexed,
    feedNavigation,
    profileNavigation,
  ];

  ...
}
```

And let's wire it up in `lib/routes/app_route.dart` file. The `FeedLayout` and `ProfileLayout` located within `HomeLayout` so we override the `layout` property in them to `HomeLayout`.

```dart
/// file: lib/routes/app_route.dart

class HomeLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) => coordinator.homeIndexed;

  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);

    return Scaffold(
      body: buildPath(coordinator),
      bottomNavigationBar: BottomNavigationBar(
        items: [
          BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Home',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person),
            label: 'Profile',
          ),
        ],
        currentIndex: path.activeIndex,
        onTap: (index) {
          coordinator.push(path.stack[index]);

          /// Ensure the selected tab is not empty
          switch (index) {
            case 0:
              if (coordinator.feedNavigation.stack.isEmpty) {
                coordinator.push(PostList());
              }
            case 1:
              if (coordinator.profileNavigation.stack.isEmpty) {
                coordinator.push(Profile());
              }
          }
        },
      ),
    );
  }
}

class FeedLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) => coordinator.feedNavigation;

  Type? get layout => HomeLayout;

  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);

    return buildPath(coordinator);
  }
}

class ProfileLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) => coordinator.profileNavigation;

  Type? get layout => HomeLayout;

  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);

    return buildPath(coordinator);
  }
}
```

We setting up the `RouteLayout` for our app. Now let's create the `PostList` and `PostDetail`.

```dart
class PostList extends AppRoute {
  Uri toUri() => Uri.parse('/post');

  /// `PostList` will be rendered inside `FeedLayout`
  Type? get layout => FeedLayout;

  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      children: [
        ListTile(
          title: const Text('Post 1'),
          onTap: () => coordinator.push(PostDetail(id: 1)),
        ),
        ListTile(
          title: const Text('Post 2'),
          onTap: () => coordinator.push(PostDetail(id: 2)),
        ),
      ],
    );
  }
}

class PostDetail extends AppRoute {
  ...

  /// `PostDetail` will be rendered inside `FeedLayout`
  /// Add this line in existing `PostDetail` route
  Type? get layout => FeedLayout;

  ...
}
```

Next up, we go to `ProfileLayout` and create `ProfileView` and `SettingsView`.

```dart

class Profile extends AppRoute {
  Uri toUri() => Uri.parse('/profile');

  /// `ProfileView` will be rendered inside `ProfileLayout`
  Type? get layout => ProfileLayout;

  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: ListView(
        children: [
          const ListTile(title: Text('Hello, User')),
          ListTile(
            title: const Text('Open Settings'),
            onTap: () => coordinator.push(Settings()),
            trailing: const Icon(Icons.chevron_right),
          ),
        ],
      ),
    );
  }
}

class Settings extends AppRoute {
  Uri toUri() => Uri.parse('/settings');

  /// `SettingsView` will be rendered inside `ProfileLayout`
  Type? get layout => ProfileLayout;

  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const Center(
      child: Text('Settings View'),
    );
  }
}
```

Great, every route is set up. Now let's wire it up in the `lib/routes/coordinator.dart` file. The final boilerplate code when defining a layout is that you have to define a factory function in the `defineLayout` method.
The `defineLayout` function takes 2 parameters: the `Type` of `RouteLayout` and a factory `Function` that creates the `RouteLayout`.

```dart
/// file: lib/routes/coordinator.dart

class AppCoordinator extends Coordinator<AppRoute> {
  final homeIndexed = IndexedStackPath<AppRoute>(
    routes: [
      FeedLayout(),
      ProfileLayout(),
    ],
  );
  late final feedNavigation = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'feed',
  );
  late final profileNavigation = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'profile',
  );

  @override
  List<StackPath<RouteTarget>> get paths => [
    root,
    homeIndexed,
    feedNavigation,
    profileNavigation,
  ];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(HomeLayout, HomeLayout.new);
    RouteLayout.defineLayout(FeedLayout, FeedLayout.new);
    RouteLayout.defineLayout(ProfileLayout, ProfileLayout.new);
  }

  ...
}

```

The `parseRouteFromUri` method needs to be reworked since we added many new screens.

### Handling Root Path

Sometimes you want to redirect the root path `/` to a specific route, like `PostList`. You can use `RouteRedirect` mixin to achieve this.

```dart
class IndexRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  FutureOr<AppRoute?> redirect() {
    return PostList();
  }

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }
}
```

Now let's update `parseRouteFromUri`:

```dart

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => IndexRoute(),
      ['post'] => PostList(),
      ['post', final id] => PostDetail(id: id),
      ['profile'] => Profile(),
      ['settings'] => Settings(),
      _ => NotFoundRoute(uri: uri),
    };
  }
}
```

All done. Now you can run your app and test it. The final result should be like this:

![Coordinator](https://raw.githubusercontent.com/definev/zenrouter/main/packages/zenrouter/doc/paradigms/coordinator/final.gif)

## API Reference

For complete API documentation including all methods, properties, and advanced usage, see:

**[→ Coordinator API Reference](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/coordinator.md)**

Quick reference for `Coordinator`:

| Method | Description |
|--------|-------------|
| `parseRouteFromUri(Uri)` | Abstract method to parse URLs into routes |
| `push(T)` | Push route onto appropriate path |
| `pop()` | Pop from nearest dynamic path |
| `replace(T)` | Wipe stack and replace with route |
| `pushOrMoveToTop(T)` | Push or move route to top |
| `recoverRouteFromUri(Uri)` | Handle deep link URI |

| Property | Description |
|----------|-------------|
| `root` | Main navigation path (always present) |
| `paths` | All navigation paths managed by coordinator |
| `routerDelegate` | Router delegate for MaterialApp.router |
| `routeInformationParser` | Route information parser |

**Example:**
```dart
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['profile'] => ProfileRoute(),
      _ => NotFoundRoute(),
    };
  }
}

MaterialApp.router(
  routerDelegate: coordinator.routerDelegate,
  routeInformationParser: coordinator.routeInformationParser,
)
```


## Route Mixins for Coordinator

These mixins provide special functionality when using the coordinator pattern:

### RouteUnique

**Required** for all routes used with Coordinator.

```dart
mixin RouteUnique on RouteTarget {
  // Convert route to URL
  Uri toUri();
  
  // Build the UI for this route
  Widget build(Coordinator coordinator, BuildContext context);
  
  // Optional: Layout layout for nested navigation
  Type? get layout => null;
}
```

**Example:**
```dart
class HomeRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: const Center(child: Text('Welcome!')),
    );
  }
}
```

### RouteLayout<T>

Creates a navigation layout that contains other routes.

```dart
mixin RouteLayout<T extends RouteUnique> on RouteUnique {
  // Which path does this layout manage?
  StackPath<RouteUnique> resolvePath(Coordinator coordinator);
  
  // Builds the layout UI (automatically delegates to layoutBuilderTable)
  @override
  Widget build(covariant Coordinator coordinator, BuildContext context);
  
  // Optional: Parent layout Type
  @override
  Type? get layout => null;
}
```

**Example - NavigationStack style navigation layout:**
```dart
class HomeLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.homeStack;
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: buildPath(coordinator),
    );
  }
}

// Routes specify layout using Type reference
class DetailRoute extends AppRoute {
  @override
  Type? get layout => HomeLayout;
}

// Register in Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineLayout() {
    RouteLayout.defineLayout(HomeLayout, () => HomeLayout());
  }
}
```

**Example - Indexed navigation layout (tabs):**
```dart
class TabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.tabPath;
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = coordinator.tabPath;
    return Scaffold(
      body: buildPath(coordinator),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: path.activePathIndex,
        onTap: (index) => coordinator.push(tabs[index]),
        items: [...],
      ),
    );
  }
}

// Tab routes use Type reference
class HomeTab extends AppRoute {
  @override
  Type? get layout => TabLayout;
}
```

### RouteDeepLink

Custom deep link handling with strategies.

```dart
mixin RouteDeepLink on RouteUnique {
  // Strategy for handling deep links
  DeeplinkStrategy get deeplinkStrategy;
  
  // Custom deep link handler
  Future<void> deeplinkHandler(Coordinator coordinator, Uri uri);
}

enum DeeplinkStrategy {
  replace,  // Replace current stack (default)
  push,     // Push onto current stack
  custom,   // Use custom handler
}
```

**Example:**
```dart
class ProductRoute extends AppRoute with RouteDeepLink {
  final String productId;
  
  ProductRoute(this.productId);
  
  @override
  Uri toUri() => Uri.parse('/product/$productId');
  
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(AppCoordinator coordinator, Uri uri) async {
    // Custom logic: ensure we're in the right tab
    coordinator.replace(ShopTab());
    
    // Load product data
    final product = await loadProduct(productId);
    
    // Then navigate to this route
    coordinator.push(this);
    
    // Log analytics
    analytics.logDeepLink(uri);
  }
}
```

## Deep Linking

### How Deep Links Work

1. App opens with URL: `myapp://home/feed/123`
2. Coordinator calls `parseRouteFromUri(Uri.parse('myapp://home/feed/123'))`
3. You return: `FeedDetail(id: '123')`
4. Coordinator checks if route has `RouteDeepLink`
   - If yes and strategy == `custom`: Call `deeplinkHandler()`
   - If yes and strategy == `push`: Push route
   - If no: Replace stack with route

### Deep Link Strategies

#### Replace (Default)

Replaces the entire stack with the deep link route:

```dart
// URL: myapp://profile/123
// Result: Stack = [ProfileRoute('123')]
```

#### Push

Pushes the route onto the existing stack:

```dart
class MyRoute extends AppRoute with RouteDeepLink {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.push;
}

// If stack was [HomeRoute()]
// After deep link: Stack = [HomeRoute(), ProfileRoute('123')]
```

#### Custom

Full control over deep link handling:

```dart
class CheckoutRoute extends AppRoute with RouteDeepLink {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(AppCoordinator coordinator, Uri uri) async {
    // 1. Ensure user is logged in
    if (!await auth.isLoggedIn()) {
      coordinator.replace(LoginRoute(
        redirectTo: uri.toString(),
      ));
      return;
    }
    
    // 2. Set up the navigation stack
    coordinator.replace(HomeRoute());
    coordinator.push(CartRoute());
    coordinator.push(this);
    
    // 3. Track analytics
    analytics.logDeepLink(uri);
  }
}
```

### Testing Deep Links

#### iOS Simulator
```bash
xcrun simctl openurl booted "myapp://home/feed/123"
```

#### Android Emulator
```bash
adb shell am start -W -a android.intent.action.VIEW \\
  -d "myapp://home/feed/123" com.example.myapp
```

#### Flutter
```dart
// In your code
coordinator.recoverRouteFromUri(
  Uri.parse('myapp://home/feed/123'),
);
```

## See Also

- [Imperative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/imperative.md) - Direct stack control
- [Declarative Navigation](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/paradigms/declarative.md) - State-driven routing
- [Route Mixins Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/mixins.md) - All available mixins
- [Coordinator API](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/api/coordinator.md) - Complete API reference
- [Deep Linking Guide](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/doc/guides/deep-linking.md) - Deep linking setup



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/pubspec.yaml
================================================
name: coordinator_example
description: "Write your first coordinator example code"
publish_to: 'none'
version: 0.1.0+1

resolution: workspace

environment:
  sdk: ^3.9.0

dependencies:
  flutter:
    sdk: flutter
  zenrouter:

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

flutter:
  uses-material-design: true



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: android
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: ios
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: linux
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: macos
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: web
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: windows
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/build.gradle.kts
================================================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/settings.gradle.kts
================================================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.11.1" apply false
    id("org.jetbrains.kotlin.android") version "2.2.20" apply false
}

include(":app")



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/build.gradle.kts
================================================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.coordinator_example"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.coordinator_example"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="coordinator_example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/main/kotlin/com/example/coordinator_example/MainActivity.kt
================================================
package com.example.coordinator_example

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-all.zip



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Flutter/Debug.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Flutter/Release.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Coordinator Example</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>coordinator_example</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/lib/main.dart
================================================
import 'package:flutter/material.dart';
import 'routes/coordinator.dart';

void main() {
  runApp(const MainApp());
}

/// The entrypoint of your app
///
/// It wire up the `Coordinator` inside your `MaterialApp`.
class MainApp extends StatelessWidget {
  const MainApp({super.key});

  // We use a singleton access pattern or just a static final for simplicity in this example
  // to avoid recreation. Ideally, use a Provider or InheritedWidget.
  // But strictly following the guide's pattern where it's a field in a StatelessWidget...
  // Since MainApp is const, we can't initialize non-final non-const fields.
  // The guide had: final coordinator = AppCoordinator();
  // We'll stick to making it working.

  static final appCoordinator = AppCoordinator();

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: appCoordinator.routerDelegate,
      routeInformationParser: appCoordinator.routeInformationParser,
      title: 'Coordinator Example',
    );
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/lib/routes/app_route.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'coordinator.dart';

abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.homeIndexed;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);

    return Scaffold(
      body: buildPath(coordinator),
      bottomNavigationBar: BottomNavigationBar(
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
        ],
        currentIndex: path.activeIndex,
        onTap: (index) {
          coordinator.push(path.stack[index]);

          /// Ensure the selected tab is not empty
          switch (index) {
            case 0:
              if (coordinator.feedNavigation.stack.isEmpty) {
                coordinator.push(PostList());
              }
            case 1:
              if (coordinator.profileNavigation.stack.isEmpty) {
                coordinator.push(Profile());
              }
          }
        },
      ),
    );
  }
}

class FeedLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.feedNavigation;

  @override
  Type? get layout => HomeLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return buildPath(coordinator);
  }
}

class ProfileLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.profileNavigation;

  @override
  Type? get layout => HomeLayout;
}

class PostList extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/post');

  /// `PostList` will be rendered inside `FeedLayout`
  @override
  Type? get layout => FeedLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    // Scaffold is important here because NavigationStack doesn't provide one
    return Scaffold(
      appBar: AppBar(title: const Text('Post List')),
      body: ListView(
        children: [
          ListTile(
            title: const Text('Post 1'),
            onTap: () => coordinator.push(PostDetail(id: 1)),
          ),
          ListTile(
            title: const Text('Post 2'),
            onTap: () => coordinator.push(PostDetail(id: 2)),
          ),
        ],
      ),
    );
  }
}

class PostDetail extends AppRoute {
  PostDetail({required this.id});

  final int id;

  /// If the params has involved in `toUri` function, you must add it to `props`
  @override
  List<Object?> get props => [id];

  @override
  Uri toUri() => Uri.parse('/post/$id');

  @override
  Type? get layout => FeedLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Post $id Detail')),
      body: Center(child: Text('Post ID: $id')),
    );
  }
}

class Profile extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');

  /// `ProfileView` will be rendered inside `ProfileLayout`
  @override
  Type? get layout => ProfileLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: ListView(
        children: [
          const ListTile(title: Text('Hello, User')),
          ListTile(
            title: const Text('Open Settings'),
            onTap: () => coordinator.push(Settings()),
            trailing: const Icon(Icons.chevron_right),
          ),
        ],
      ),
    );
  }
}

class Settings extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  /// `SettingsView` will be rendered inside `ProfileLayout`
  @override
  Type? get layout => ProfileLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: const Center(child: Text('Settings View')),
    );
  }
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});

  final Uri uri;

  @override
  Uri toUri() => uri;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Not Found')),
      body: Center(child: Text('Route not found: $uri')),
    );
  }
}

class IndexRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  AppRoute redirect() => PostList();

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/lib/routes/coordinator.dart
================================================
import 'package:zenrouter/zenrouter.dart';
import 'app_route.dart';

class AppCoordinator extends Coordinator<AppRoute> {
  late final homeIndexed = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'home',
    [FeedLayout(), ProfileLayout()],
  );
  late final feedNavigation = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'feed',
  );
  late final profileNavigation = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'profile',
  );

  @override
  List<StackPath<RouteTarget>> get paths => [
    ...super.paths,
    homeIndexed,
    feedNavigation,
    profileNavigation,
  ];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(HomeLayout, HomeLayout.new);
    RouteLayout.defineLayout(FeedLayout, FeedLayout.new);
    RouteLayout.defineLayout(ProfileLayout, ProfileLayout.new);
  }

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => IndexRoute(),
      ['post'] => PostList(),
      ['post', final id] => PostDetail(id: int.parse(id)),
      ['profile'] => Profile(),
      ['settings'] => Settings(),
      _ => NotFoundRoute(uri: uri),
    };
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "coordinator_example")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.example.coordinator_example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void fl_register_plugins(FlPluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/runner/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/runner/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView* view) {
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "coordinator_example");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "coordinator_example");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(
      project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000
  // for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb),
                           self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application,
                                                  gchar*** arguments,
                                                  int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
    g_warning("Failed to register: %s", error->message);
    *exit_status = 1;
    return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line =
      my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID, "flags",
                                     G_APPLICATION_NON_UNIQUE, nullptr));
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/linux/runner/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication,
                     my_application,
                     MY,
                     APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Flutter/Flutter-Release.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation


func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = coordinator_example

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.example.coordinatorExample

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2025 com.example. All rights reserved.



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/macos/RunnerTests/RunnerTests.swift
================================================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="coordinator_example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>coordinator_example</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <!--
    You can customize the "flutter_bootstrap.js" script.
    This is useful to provide a custom configuration to the Flutter loader
    or to give the user feedback during the initialization process.

    For more details:
    * https://docs.flutter.dev/platform-integration/web/initialization
  -->
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/web/manifest.json
================================================
{
    "name": "coordinator_example",
    "short_name": "coordinator_example",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(coordinator_example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "coordinator_example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void RegisterPlugins(flutter::PluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"coordinator_example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "coordinator_example" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "coordinator_example" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "coordinator_example.exe" "\0"
            VALUE "ProductName", "coordinator_example" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
FILE: packages/zenrouter/doc/paradigms/coordinator/example/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_



================================================
FILE: packages/zenrouter/doc/recipes/README.md
================================================
# ZenRouter Recipes

Practical, copy-paste ready solutions for common routing scenarios. Each recipe includes:
- **Problem statement** - The challenge you're facing
- **Solution overview** - Why this approach works
- **Complete code example** - Ready to use
- **Step-by-step explanation** - How it works
- **Advanced variations** - Take it further
- **Common gotchas** - Avoid mistakes

---

## 🎯 Core Patterns

### [404 Not Found Handling](404-handling.md)
Gracefully handle unknown routes and invalid deep links with custom 404 pages.

**Topics**: Error handling, fallback routing, user experience  
**Paradigm**: Coordinator  
**Difficulty**: ⭐ Easy

---

### [Authentication Flow](authentication-flow.md)
Protect routes, redirect unauthenticated users, and preserve intended destinations.

**Topics**: Route guards, redirects, auth state, login flow  
**Paradigm**: All paradigms  
**Difficulty**: ⭐⭐ Moderate

---

### [Bottom Navigation with Persistent State](bottom-navigation.md)
Create tab bars where each tab maintains its own navigation stack independently.

**Topics**: Tab navigation, IndexedStackPath, persistent state  
**Paradigm**: Coordinator, Imperative  
**Difficulty**: ⭐⭐ Moderate

---

## 🎨 UI & Transitions

### [Custom Route Transitions](route-transitions.md)
Customize page animations—slide, fade, scale, or create your own.

**Topics**: Animations, transitions, StackTransition, Hero  
**Paradigm**: All paradigms  
**Difficulty**: ⭐⭐ Moderate

---

## 🔧 Integration

### [State Management Integration](state-management.md)
Integrate routing with Riverpod, Bloc, Provider, and other state solutions.

**Topics**: Riverpod, Bloc, Provider, auth state, data loading  
**Paradigm**: All paradigms  
**Difficulty**: ⭐⭐ Moderate

---

## 🏗️ Architecture

### [Route Versioning](route-versioning.md)
Run multiple versions of a feature side-by-side using Coordinator-as-RouteModule.

**Topics**: Route versioning, Coordinator-as-RouteModule, deprecation flow, cross-version navigation  
**Paradigm**: Coordinator  
**Difficulty**: ⭐⭐⭐ Advanced

---

## 🌐 Web

### [URL Strategies for Web](url-strategies.md)
Configure hash vs. path-based URLs, server setup, and deployment strategies.

**Topics**: URL strategies, hash routing, path routing, deployment  
**Paradigm**: Coordinator (web-only)  
**Difficulty**: ⭐⭐ Moderate

---

## Quick Reference

### By Use Case

| Use Case | Recipe |
|----------|--------|
| Tab bar with persistent tabs | [Bottom Navigation](bottom-navigation.md) |
| Login with protected routes | [Authentication Flow](authentication-flow.md) |
| Invalid URL handling | [404 Handling](404-handling.md) |
| Sidebar + content layout | [Nested Navigation](nested-navigation.md) |
| Custom animations | [Route Transitions](route-transitions.md) |
| Full-screen flows | [Modal Routing](modal-routing.md) |
| API versioning / feature flags | [Route Versioning](route-versioning.md) |
| Riverpod/Bloc integration | [State Management](state-management.md) |
| Deploying to web | [URL Strategies](url-strategies.md) |

### By Paradigm

| Paradigm | Applicable Recipes |
|----------|-------------------|
| **Imperative** | All except URL Strategies |
| **Declarative** | Route Transitions, Authentication Flow, State Management |
| **Coordinator** | All recipes |

### By Difficulty

| Level | Recipes |
|-------|---------|
| ⭐ **Easy** | 404 Handling |
| ⭐⭐ **Moderate** | Authentication Flow, Bottom Navigation, Route Transitions, Modal Routing, State Management, URL Strategies |
| ⭐⭐⭐ **Advanced** | Nested Navigation, Route Versioning |

---

## Need Help?

- **Can't find a recipe?** [Open an issue](https://github.com/definev/zenrouter/issues) requesting a new recipe
- **Found a problem?** [Report it](https://github.com/definev/zenrouter/issues)
- **Have a better solution?** [Contribute](https://github.com/definev/zenrouter/blob/main/CONTRIBUTING.md) your recipe!

---

## Related Documentation

- [Getting Started Guide](../guides/getting-started.md) - Choose your paradigm
- [API Reference](../api/) - Detailed API documentation
- [Paradigm Guides](../paradigms/) - Deep dives into each paradigm
- [Migration Guides](../migration/) - Switching from other routers

---

**Happy Routing! 🧘**



================================================
FILE: packages/zenrouter/doc/recipes/404-handling.md
================================================
# Recipe: 404 Not Found Handling

## Problem

Your app needs to gracefully handle unknown routes and deep links that don't match any defined route, showing users a helpful 404 page instead of crashing or showing a blank screen.

## Solution Overview

ZenRouter makes 404 handling straightforward with the **Coordinator pattern**. When `parseRouteFromUri` encounters an unknown path, simply return a dedicated `NotFoundRoute`. This approach:

- Provides a consistent fallback for all invalid URLs
- Maintains type safety across your routing system
- Allows customization of the 404 experience
- Works seamlessly with deep linking and web URLs

## Complete Code Example

```dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// 1. Define your base route class
abstract class AppRoute extends RouteTarget with RouteUnique {}

// 2. Create a dedicated NotFoundRoute
class NotFoundRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/404');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const NotFoundPage();
  }
}

// 3. Define your 404 page UI
class NotFoundPage extends StatelessWidget {
  const NotFoundPage({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Icon or illustration
            Icon(
              Icons.error_outline,
              size: 120,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 24),
            
            // Title
            Text(
              '404',
              style: Theme.of(context).textTheme.displayLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: Colors.grey[700],
                  ),
            ),
            const SizedBox(height: 8),
            
            // Message
            Text(
              'Page Not Found',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 16),
            
            Text(
              'The page you are looking for doesn\'t exist.',
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                    color: Colors.grey[600],
                  ),
            ),
            const SizedBox(height: 32),
            
            // Action button
            ElevatedButton.icon(
              onPressed: () {
                // Navigate back to home
                context.coordinator<AppCoordinator>().replace(HomeRoute());
              },
              icon: const Icon(Icons.home),
              label: const Text('Go Home'),
            ),
          ],
        ),
      ),
    );
  }
}

// 4. In your Coordinator, return NotFoundRoute for unknown paths
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['about'] => AboutRoute(),
      ['profile', String userId] => ProfileRoute(userId),
      
      // Catch-all for unknown routes
      _ => NotFoundRoute(),
    };
  }
}

// Example routes
class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

class AboutRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/about');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const AboutPage();
  }
}

class ProfileRoute extends AppRoute {
  final String userId;
  ProfileRoute(this.userId);
  
  @override
  List<Object?> get props => [userId];
  
  @override
  Uri toUri() => Uri.parse('/profile/$userId');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return ProfilePage(userId: userId);
  }
}
```

## Step-by-Step Explanation

### 1. Create a Dedicated NotFoundRoute

```dart
class NotFoundRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/404');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const NotFoundPage();
  }
}
```

- The `NotFoundRoute` is a regular route like any other in your app
- It has its own URI (`/404`) for consistency
- The `build` method returns your custom 404 UI

### 2. Use Switch Pattern Matching with Catch-All

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    [] => HomeRoute(),
    ['about'] => AboutRoute(),
    ['profile', String userId] => ProfileRoute(userId),
    
    // Catch-all pattern - matches anything not matched above
    _ => NotFoundRoute(),
  };
}
```

- The `_` pattern is Dart's catch-all wildcard
- Any path not matching the patterns above returns `NotFoundRoute`
- This includes malformed paths, typos, and invalid deep links

### 3. Design a User-Friendly 404 Page

A good 404 page should:
- Clearly communicate the error ("404 Page Not Found")
- Explain what happened in plain language
- Provide a clear action (e.g., "Go Home" button)
- Match your app's design language

## Advanced Variations

### Track 404s for Analytics

```dart
class NotFoundRoute extends AppRoute with RouteDeepLink {
  final String attemptedPath;
  
  NotFoundRoute([this.attemptedPath = '/404']);
  
  @override
  List<Object?> get props => [attemptedPath];
  
  @override
  Uri toUri() => Uri.parse('/404');
  
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(Coordinator coordinator, Uri uri) async {
    // Log to analytics
    analytics.logEvent(
      name: 'page_not_found',
      parameters: {'attempted_path': attemptedPath},
    );
  }
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return NotFoundPage(attemptedPath: attemptedPath);
  }
}

// In coordinator
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    [] => HomeRoute(),
    _ => NotFoundRoute(uri.path), // Pass the attempted path
  };
}
```

### Show Search Suggestions

```dart
class NotFoundPage extends StatelessWidget {
  final String? attemptedPath;
  
  const NotFoundPage({super.key, this.attemptedPath});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // ... 404 message ...
            
            if (attemptedPath != null) ...[
              const SizedBox(height: 24),
              Text(
                'You tried to access: $attemptedPath',
                style: TextStyle(
                  fontFamily: 'monospace',
                  color: Colors.grey[600],
                ),
              ),
              const SizedBox(height: 16),
              
              // Show suggestions
              Text(
                'Did you mean:',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              const SizedBox(height: 8),
              _SuggestionsList(attemptedPath: attemptedPath!),
            ],
          ],
        ),
      ),
    );
  }
}

class _SuggestionsList extends StatelessWidget {
  final String attemptedPath;
  
  const _SuggestionsList({required this.attemptedPath});
  
  @override
  Widget build(BuildContext context) {
    // Simple fuzzy matching (could use a package like string_similarity)
    final suggestions = [
      if (attemptedPath.contains('prof')) '/profile',
      if (attemptedPath.contains('about')) '/about',
      if (attemptedPath.contains('home')) '/',
    ];
    
    return Column(
      children: suggestions.map((suggestion) {
        return TextButton(
          onPressed: () {
            context.coordinator<AppCoordinator>()
                .navigate(Uri.parse(suggestion));
          },
          child: Text(suggestion),
        );
      }).toList(),
    );
  }
}
```

### Custom 404s Based on Section

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    [] => HomeRoute(),
    
    // Blog section
    ['blog', ...] when uri.pathSegments.length >= 2 => BlogPostRoute(uri.pathSegments[1]),
    ['blog'] => BlogListRoute(),
    
    // Shop section
    ['shop', ...] when uri.pathSegments.length >= 2 => ProductRoute(uri.pathSegments[1]),
    ['shop'] => ShopRoute(),
    
    // Section-specific 404s
    ['blog', ...] => NotFoundRoute.blog(),
    ['shop', ...] => NotFoundRoute.shop(),
    
    // Generic 404
    _ => NotFoundRoute(),
  };
}

// Enhanced NotFoundRoute
class NotFoundRoute extends AppRoute {
  final NotFoundSection section;
  
  NotFoundRoute([this.section = NotFoundSection.generic]);
  
  NotFoundRoute.blog() : section = NotFoundSection.blog;
  NotFoundRoute.shop() : section = NotFoundSection.shop;
  
  @override
  List<Object?> get props => [section];
  
  @override
  Uri toUri() => Uri.parse('/404');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return NotFoundPage(section: section);
  }
}

enum NotFoundSection { generic, blog, shop }
```

## Common Gotchas

> [!CAUTION]
> **Don't forget the catch-all pattern!**
> Without `_ => NotFoundRoute()` in your switch, an unknown path will throw an exception.

> [!TIP]
> **Test your 404 handling early**
> Try navigating to random URLs in development to ensure the fallback works correctly.

> [!NOTE]
> **404 pages work in all paradigms**
> While this recipe uses the Coordinator pattern (best for deep linking), you can create custom error screens in Imperative and Declarative paradigms too—just without the automatic URI-driven fallback.

## Related Recipes

- [Authentication Flow](authentication-flow.md) - Redirect to login before showing 404
- [Route Transitions](route-transitions.md) - Custom animations for error pages
- [Nested Navigation](nested-navigation.md) - 404s in nested navigation contexts

## See Also

- [Coordinator Pattern Guide](../paradigms/coordinator/coordinator.md)
- [RouteDeepLink Mixin](../api/mixins.md#routedeeplink)



================================================
FILE: packages/zenrouter/doc/recipes/authentication-flow.md
================================================
# Recipe: Authentication Flow

## Problem

You need to protect certain routes in your app, redirecting unauthenticated users to a login page. After successful login, users should be sent to their originally requested page. This pattern is essential for apps with user accounts, admin panels, or premium content.

## Solution Overview

ZenRouter provides the **RouteRedirect** mixin for implementing authentication guards. This approach:

- Automatically intercepts protected routes
- Redirects unauthenticated users to login
- Preserves the original destination for post-login navigation
- Works seamlessly with deep linking
- Keeps auth logic separate from UI code

## Complete Code Example

```dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// 1. Sample authentication service
class AuthService {
  bool _isAuthenticated = false;
  
  bool get isAuthenticated => _isAuthenticated;
  
  Future<bool> login(String email, String password) async {
    // Simulate API call
    await Future.delayed(const Duration(seconds: 1));
    
    if (email == 'user@example.com' && password == 'password') {
      _isAuthenticated = true;
      return true;
    }
    return false;
  }
  
  void logout() {
    _isAuthenticated = false;
  }
}

// Global auth service (or use dependency injection)
final authService = AuthService();

// 2. Define your base route class
abstract class AppRoute extends RouteTarget with RouteUnique {}

// 3. Create a mixin for protected routes
mixin ProtectedRoute on AppRoute implements RouteRedirect {
  AppRoute get intendedRoute;

  @override
  Future<AppRoute> redirect() async {
    if (!authService.isAuthenticated) {
      // Redirect to login with the intended destination
      return LoginRoute(intendedRoute: intendedRoute);
    }
    return this; // User is authenticated, allow access
  }
}

// 4. Define the login route
class LoginRoute extends AppRoute {
  final AppRoute? intendedRoute;
  
  LoginRoute({this.intendedRoute});
  
  @override
  List<Object?> get props => [intendedRoute];
  
  @override
  Uri toUri() => Uri.parse('/login');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return LoginPage(
      onLoginSuccess: () {
        if (intendedRoute != null) {
          // Navigate to originally intended page
          coordinator.navigate(intendedRoute!);
        } else {
          // No intended route, go to home
          coordinator.navigate(HomeRoute());
        }
      },
    );
  }
}

// 5. Protected routes using the mixin
class ProfileRoute extends AppRoute with ProtectedRoute {
  @override
  Uri toUri() => Uri.parse('/profile');

  @override
  AppRoute get intendedRoute => ProfileRoute();
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const ProfilePage();
  }
}

class SettingsRoute extends AppRoute with ProtectedRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  AppRoute get intendedRoute => SettingsRoute();
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const SettingsPage();
  }
}

class DashboardRoute extends AppRoute with ProtectedRoute {
  @override
  Uri toUri() => Uri.parse('/dashboard');

  @override
  AppRoute get intendedRoute => DashboardRoute();
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const DashboardPage();
  }
}

// Public routes (no mixin needed)
class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  AppRoute get intendedRoute => HomeRoute();
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return HomePage(coordinator: coordinator);
  }
}

// 6. Setup the Coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['login'] => LoginRoute(),
      ['profile'] => ProfileRoute(),
      ['settings'] => SettingsRoute(),
      ['dashboard'] => DashboardRoute(),
      _ => NotFoundRoute(),
    };
  }
}

// 7. Login page UI
class LoginPage extends StatefulWidget {
  final VoidCallback onLoginSuccess;
  
  const LoginPage({super.key, required this.onLoginSuccess});
  
  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> {
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLoading = false;
  String? _errorMessage;
  
  Future<void> _handleLogin() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    
    final success = await authService.login(
      _emailController.text,
      _passwordController.text,
    );
    
    if (success) {
      widget.onLoginSuccess();
    } else {
      setState(() {
        _isLoading = false;
        _errorMessage = 'Invalid email or password';
      });
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              'Welcome Back',
              style: Theme.of(context).textTheme.headlineMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            
            TextField(
              controller: _emailController,
              decoration: const InputDecoration(
                labelText: 'Email',
                border: OutlineInputBorder(),
              ),
              keyboardType: TextInputType.emailAddress,
            ),
            const SizedBox(height: 16),
            
            TextField(
              controller: _passwordController,
              decoration: const InputDecoration(
                labelText: 'Password',
                border: OutlineInputBorder(),
              ),
              obscureText: true,
            ),
            const SizedBox(height: 8),
            
            if (_errorMessage != null)
              Text(
                _errorMessage!,
                style: const TextStyle(color: Colors.red),
                textAlign: TextAlign.center,
              ),
            const SizedBox(height: 24),
            
            ElevatedButton(
              onPressed: _isLoading ? null : _handleLogin,
              child: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Login'),
            ),
            
            const SizedBox(height: 16),
            Text(
              'Demo: user@example.com / password',
              style: Theme.of(context).textTheme.bodySmall,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
  
  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }
}

// Example: Home page with login/logout
class HomePage extends StatelessWidget {
  final AppCoordinator coordinator;
  
  const HomePage({super.key, required this.coordinator});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home'),
        actions: [
          if (authService.isAuthenticated)
            IconButton(
              icon: const Icon(Icons.logout),
              onPressed: () {
                authService.logout();
                coordinator.replace(HomeRoute()); // Refresh to update UI
              },
            ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              authService.isAuthenticated
                  ? 'You are logged in!'
                  : 'You are not logged in',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 24),
            
            if (!authService.isAuthenticated) ...[
              ElevatedButton(
                onPressed: () => coordinator.push(LoginRoute()),
                child: const Text('Login'),
              ),
            ] else ...[
              ElevatedButton(
                onPressed: () => coordinator.push(ProfileRoute()),
                child: const Text('Go to Profile (Protected)'),
              ),
              const SizedBox(height: 8),
              ElevatedButton(
                onPressed: () => coordinator.push(DashboardRoute()),
                child: const Text('Go to Dashboard (Protected)'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
```

## Step-by-Step Explanation

### 1. Create a Reusable Protection Mixin

```dart
mixin ProtectedRoute on AppRoute implements RouteRedirect {
  AppRoute get intendedRoute;

  @override
  Future<AppRoute> redirect() async {
    if (!authService.isAuthenticated) {
      return LoginRoute(intendedRoute: intendedRoute);
    }
    return this;
  }
}
```

- The `ProtectedRoute` mixin implements `RouteRedirect`
- `redirect()` checks authentication status
- If not authenticated, returns `LoginRoute` with the intended route stored
- If authenticated, returns `this` (allowing access)

### 2. Preserve Intended Destination

```dart
class LoginRoute extends AppRoute {
  final AppRoute? intendedRoute;
  
  LoginRoute({this.intendedRoute});
  
  // After successful login:
  onLoginSuccess: () {
    if (intendedRoute != null) {
      coordinator.replace(intendedRoute!);
    } else {
      coordinator.replace(HomeRoute());
    }
  }
}
```

- Store the intended route in `LoginRoute`
- After successful authentication, navigate to the intended route
- Falls back to home if no intended route exists

### 3. Apply Protection to Routes

```dart
class ProfileRoute extends AppRoute with ProtectedRoute {
  @override
  AppRoute get intendedRoute => ProfileRoute();

  // ... route implementation
}
```

Simply add `with ProtectedRoute` to any route that requires authentication.

## Advanced Variations

### Role-Based Access Control

```dart
enum UserRole { user, admin, moderator }

class AuthService {
  UserRole? _currentRole;
  
  bool get isAuthenticated => _currentRole != null;
  UserRole? get currentRole => _currentRole;
  
  bool hasRole(UserRole role) => _currentRole == role;
  bool hasAnyRole(List<UserRole> roles) => 
      _currentRole != null && roles.contains(_currentRole);
}

// Role-specific protection
mixin AdminRoute on AppRoute implements RouteRedirect {
  @override
  AppRoute get intendedRoute;

  @override
  Future<AppRoute> redirect() async {
    if (!authService.isAuthenticated) {
      return LoginRoute(intendedRoute: intendedRoute);
    }
    
    if (!authService.hasRole(UserRole.admin)) {
      return UnauthorizedRoute(); // Or redirect to home
    }
    
    return this;
  }
}

// Usage
class AdminPanelRoute extends AppRoute with AdminRoute {
  @override
  AppRoute get intendedRoute => AdminPanelRoute();

  @override
  Uri toUri() => Uri.parse('/admin');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const AdminPanelPage();
  }
}
```

### Token-Based Authentication

```dart
class AuthService {
  String? _accessToken;
  DateTime? _tokenExpiry;
  
  bool get isAuthenticated {
    if (_accessToken == null || _tokenExpiry == null) return false;
    return DateTime.now().isBefore(_tokenExpiry!);
  }
  
  Future<bool> refreshToken() async {
    // Call refresh endpoint
    try {
      final response = await api.refreshToken();
      _accessToken = response.accessToken;
      _tokenExpiry = DateTime.now().add(Duration(hours: 1));
      return true;
    } catch (e) {
      return false;
    }
  }
}

mixin ProtectedRoute on AppRoute implements RouteRedirect {
  @override
  AppRoute get intendedRoute;

  @override
  Future<AppRoute> redirect() async {
    if (!authService.isAuthenticated) {
      // Try to refresh token first
      final refreshed = await authService.refreshToken();
      if (!refreshed) {
        return LoginRoute(intendedRoute: intendedRoute);
      }
    }
    return this;
  }
}
```

### Deep Link Preservation with Query Parameters

```dart
class LoginRoute extends AppRoute {
  final Uri? intendedUri;
  
  LoginRoute({AppRoute? intendedRoute, this.intendedUri})
      : _intendedRoute = intendedRoute;
  
  final AppRoute? _intendedRoute;
  
  @override
  List<Object?> get props => [_intendedRoute, intendedUri];
  
  @override
  Uri toUri() {
    if (intendedUri != null) {
      return Uri.parse('/login').replace(
        queryParameters: {'redirect': intendedUri?.toUri()?.toString()},
      );
    }
    return Uri.parse('/login');
  }
  
  // After login:
  onLoginSuccess: () {
    if (intendedUri != null) {
      coordinator.navigate(coordinator.parseRouteFromUri(intendedUri!));
    } else if (_intendedRoute != null) {
      coordinator.replace(_intendedRoute!);
    } else {
      coordinator.replace(HomeRoute());
    }
  }
}
```

## Common Gotchas

> [!CAUTION]
> **Remember to implement equals/hashCode**
> If your `LoginRoute` stores an `intendedRoute`, make sure to include it in `props` for proper route comparison.

> [!WARNING]
> **Avoid infinite redirect loops**
> Never add `RouteRedirect` to your `LoginRoute` itself, or it may create a redirect loop.

> [!TIP]
> **Test with deep links**
> Try opening protected deep links when logged out (e.g., `myapp://profile`). Users should land on login, then automatically navigate to the profile after authenticating.

> [!NOTE]
> **State management integration**
> This recipe uses a simple `AuthService` singleton. In production, consider integrating with your state management solution (Riverpod, Bloc, Provider) for reactive auth state.

## Related Recipes

- [404 Handling](404-handling.md) - Handle unauthorized vs not found
- [State Management Integration](state-management.md) - Integrate with Riverpod/Bloc
- [Nested Navigation](nested-navigation.md) - Protected sections in nested nav

## See Also

- [RouteRedirect Mixin](../api/mixins.md#routeredirect)
- [RouteGuard Mixin](../api/mixins.md#routeguard) - Alternative for preventing navigation
- [Coordinator Pattern Guide](../paradigms/coordinator/coordinator.md)



================================================
FILE: packages/zenrouter/doc/recipes/bottom-navigation.md
================================================
# Recipe: Bottom Navigation with Persistent State

## Problem

Your app has a bottom navigation bar with multiple tabs (e.g., Home, Search, Profile), and you want each tab to maintain its own navigation stack. When users switch tabs and come back, they should see where they left off—not reset to the tab's root page.

## Solution Overview

ZenRouter's **IndexedStackPath** is designed specifically for this use case. Unlike traditional navigation that replaces the screen, `IndexedStackPath`:

- Keeps all tab screens alive in memory
- Maintains each tab's navigation state
- Provides instant tab switching (no rebuild)
- Works with both Coordinator and Imperative paradigms

## Complete Code Example

```dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// 1. Define routes for each tab
abstract class AppRoute extends RouteTarget with RouteUnique {}

class TabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) => coordinator.tabPath;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return RootLayout(
      coordinator: coordinator,
      child: buildPath(coordinator),
    );
  }
}

// Home tab routes
class HomeTabRoute extends AppRoute {
  @override
  Type get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return HomePage();
  }
}

class ArticleRoute extends AppRoute {
  final String articleId;
  ArticleRoute(this.articleId);

  Type get layout => TabLayout;
  
  @override
  List<Object?> get props => [articleId];
  
  @override
  Uri toUri() => Uri.parse('/article/$articleId');
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ArticlePage(articleId: articleId);
  }
}

// Search tab routes
class SearchTabRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/search');
  
  @override
  Type get layout => TabLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const SearchPage();
  }
}

class SearchResultsRoute extends AppRoute {
  final String query;
  SearchResultsRoute(this.query);
  
  @override
  List<Object?> get props => [query];
  
  @override
  Uri toUri() => Uri.parse('/search/results').replace(
        queryParameters: {'q': query},
      );
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return SearchResultsPage(query: query);
  }
}

// Profile tab routes
class ProfileTabRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');

  @override
  Type get layout => TabLayout;
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const ProfilePage();
  }
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile/settings');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const SettingsPage();
  }
}

// 2. Create a Coordinator with IndexedStackPath
class AppCoordinator extends Coordinator<AppRoute> {
  // Create an IndexedStackPath for tab navigation
  late final tabPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'tab',
    [
      HomeTabRoute(),
      SearchTabRoute(),
      ProfileTabRoute(),
    ],
  )..bindLayout(TabLayout.new);
  
  @override
  List<StackPath<AppRoute>> get paths => [...super.paths, tabPath];
  
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeTabRoute(),
      ['article', String id] => ArticleRoute(id),
      ['search'] => SearchTabRoute(),
      ['search', 'results'] => SearchResultsRoute(
          uri.queryParameters['q'] ?? '',
        ),
      ['profile'] => ProfileTabRoute(),
      ['profile', 'settings'] => SettingsRoute(),
      _ => NotFoundRoute(),
    };
  }
  
  // Helper methods for tab navigation
  void switchToTab(int index) {
    tabPath.activeIndex = index;
  }
  
  int get currentTab => tabPath.activeIndex;
}

// 3. Main app with bottom navigation
class MyApp extends StatelessWidget {
  final coordinator = AppCoordinator();
  
  MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// 4. Root layout with bottom navigation bar
class RootLayout extends StatelessWidget {
  final AppCoordinator coordinator;
  final Widget child;
  
  const RootLayout({
    super.key,
    required this.coordinator,
    required this.child,
  });
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: child,
      bottomNavigationBar: ListenableBuilder(
        listenable: coordinator.tabPath,
        builder: (context, _) {
          return BottomNavigationBar(
            currentIndex: coordinator.currentTab,
            onTap: coordinator.switchToTab,
            items: const [
              BottomNavigationBarItem(
                icon: Icon(Icons.home),
                label: 'Home',
              ),
              BottomNavigationBarItem(
                icon: Icon(Icons.search),
                label: 'Search',
              ),
              BottomNavigationBarItem(
                icon: Icon(Icons.person),
                label: 'Profile',
              ),
            ],
          );
        },
      ),
    );
  }
}

// 5. Example tab content with nested navigation
class HomePage extends StatelessWidget {
  const HomePage({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: ListView.builder(
        itemCount: 20,
        itemBuilder: (context, index) {
          return ListTile(
            title: Text('Article ${index + 1}'),
            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
            onTap: () {
              // Push article route onto the home tab's stack
              coordinator.push(ArticleRoute('article-${index + 1}'));
            },
          );
        },
      ),
    );
  }
}

class ArticlePage extends StatelessWidget {
  final String articleId;
  
  const ArticlePage({super.key, required this.articleId});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Article: $articleId'),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Article Content',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 16),
            Text('ID: $articleId'),
          ],
        ),
      ),
    );
  }
}

class SearchPage extends StatefulWidget {
  const SearchPage({super.key});
  
  @override
  State<SearchPage> createState() => _SearchPageState();
}

class _SearchPageState extends State<SearchPage> {
  final _searchController = TextEditingController();
  
  @override
  Widget build(BuildContext context) {
    final coordinator = context.coordinator<AppCoordinator>();
    
    return Scaffold(
      appBar: AppBar(title: const Text('Search')),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            TextField(
              controller: _searchController,
              decoration: InputDecoration(
                hintText: 'Search...',
                suffixIcon: IconButton(
                  icon: const Icon(Icons.search),
                  onPressed: () {
                    if (_searchController.text.isNotEmpty) {
                      coordinator.push(
                        SearchResultsRoute(_searchController.text),
                      );
                    }
                  },
                ),
              ),
              onSubmitted: (query) {
                if (query.isNotEmpty) {
                  coordinator.push(SearchResultsRoute(query));
                }
              },
            ),
          ],
        ),
      ),
    );
  }
  
  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }
}

class SearchResultsPage extends StatelessWidget {
  final String query;
  
  const SearchResultsPage({super.key, required this.query});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Results for "$query"'),
      ),
      body: ListView.builder(
        itemCount: 10,
        itemBuilder: (context, index) {
          return ListTile(
            title: Text('Result ${index + 1} for "$query"'),
            subtitle: Text('Description of result ${index + 1}'),
          );
        },
      ),
    );
  }
}

class ProfilePage extends StatelessWidget {
  const ProfilePage({super.key});
  
  @override
  Widget build(BuildContext context) {
    final coordinator = context.coordinator<AppCoordinator>();
    
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: ListView(
        children: [
          const ListTile(
            leading: CircleAvatar(
              child: Icon(Icons.person),
            ),
            title: Text('John Doe'),
            subtitle: Text('john.doe@example.com'),
          ),
          const Divider(),
          ListTile(
            leading: const Icon(Icons.settings),
            title: const Text('Settings'),
            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
            onTap: () {
              coordinator.push(SettingsRoute());
            },
          ),
          ListTile(
            leading: const Icon(Icons.info),
            title: const Text('About'),
            trailing: const Icon(Icons.arrow_forward_ios, size: 16),
            onTap: () {
              // Navigate to about page
            },
          ),
        ],
      ),
    );
  }
}

class SettingsPage extends StatelessWidget {
  const SettingsPage({super.key});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: const [
          SwitchListTile(
            title: Text('Notifications'),
            subtitle: Text('Enable push notifications'),
            value: true,
            onChanged: null,
          ),
          SwitchListTile(
            title: Text('Dark Mode'),
            subtitle: Text('Use dark theme'),
            value: false,
            onChanged: null,
          ),
        ],
      ),
    );
  }
}
```

## Step-by-Step Explanation

### 1. Create an IndexedStackPath with Layout Binding

```dart
late final tabPath = IndexedStackPath<AppRoute>.createWith(
  coordinator: this,
  label: 'tab',
  [
    HomeTabRoute(),
    SearchTabRoute(),
    ProfileTabRoute(),
  ],
)..bindLayout(TabLayout.new);
```

- `IndexedStackPath.createWith()` creates the path with initial routes
- Pass the coordinator reference and a label for identification
- Provide initial routes as a list (one per tab)
- `..bindLayout(TabLayout.new)` binds the layout that will wrap all tab content
- The `TabLayout` class handles rendering the bottom navigation bar and child content

### 2. Expose the Path in Coordinator

```dart
@override
List<StackPath<AppRoute>> get paths => [...super.paths, tabPath];
```

This tells ZenRouter to use the `tabPath` for navigation. All `push()`, `pop()`, and `replace()` operations will affect the currently active tab's stack.

> **Note:** You have to call `super.paths` to include the default paths.

### 3. Tab Switching

```dart
void switchToTab(int index) {
  tabPath.activeIndex = index;
}
```

Changing `activeIndex` switches the visible tab instantly. Each tab retains its navigation state.

### 4. Listen to Tab Changes

```dart
ListenableBuilder(
  listenable: coordinator.tabPath,
  builder: (context, _) {
    return BottomNavigationBar(
      currentIndex: coordinator.currentTab,
      onTap: coordinator.switchToTab,
      items: const [...],
    );
  },
)
```

`IndexedStackPath` is a `Listenable`, so you can rebuild UI when the active tab changes.

## Advanced Variations

### Per-Tab Navigation Stacks

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  // Separate NavigationPath for each tab
  late final homeStack = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'home',
  );
  late final searchStack = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'search',
  );
  late final profileStack = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'profile',
  );
  
  late final tabPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'tab',
    [
      HomeTabRoute(),
      SearchTabRoute(),
      ProfileTabRoute(),
    ],
  );
  
  int _currentTab = 0;
  
  @override
  List<StackPath<AppRoute>> get paths => [
    ...super.paths,
    tabPath,
    homeStack,
    searchStack,
    profileStack,
  ];
  
  
  void switchToTab(int index) {
    _currentTab = index;
    tabPath.activeIndex = index;
  }
}
```

### Reset Tab on Double Tap

```dart
class RootLayout extends StatelessWidget {
  // ...
  
  void _handleTabTap(int index) {
    if (coordinator.currentTab == index) {
      // User tapped the already active tab - reset the tab stack
    } else {
      coordinator.switchToTab(index);
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: child,
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: coordinator.currentTab,
        onTap: _handleTabTap, // Use custom handler
        items: const [...],
      ),
    );
  }
}
```

### Badge Notifications

```dart
class RootLayout extends StatelessWidget {
  // ...
  
  @override
  Widget build(BuildContext context) {
    return BottomNavigationBar(
      items: [
        const BottomNavigationBarItem(
          icon: Icon(Icons.home),
          label: 'Home',
        ),
        BottomNavigationBarItem(
          icon: Badge(
            label: const Text('3'),
            child: const Icon(Icons.search),
          ),
          label: 'Search',
        ),
        const BottomNavigationBarItem(
          icon: Icon(Icons.person),
          label: 'Profile',
        ),
      ],
    );
  }
}
```

## Common Gotchas

> [!TIP]
> **Use RootLayout wisely**
> Wrap each tab's content in a shared `RootLayout` widget that contains the bottom navigation bar. This prevents the tab bar from disappearing when navigating within a tab.

> [!CAUTION]
> **Memory considerations**
> `IndexedStackPath` keeps all tabs in memory. If your tabs have heavy content or media, consider using lazy loading or disposing unused content.

> [!NOTE]
> **Back button behavior**
> On Android, the back button will pop the current tab's stack first. Only when the tab is at its root will back button switch to the previous tab or exit the app.

> [!WARNING]
> **State restoration**
> If using state restoration, ensure each tab's state is properly serialized. See the [State Restoration Guide](../guides/state-restoration.md) for details.

## Related Recipes

- [Nested Navigation](nested-navigation.md) - Complex nested navigation patterns
- [State Management Integration](state-management.md) - Manage tab state with Riverpod/Bloc
- [Authentication Flow](authentication-flow.md) - Protect tabs with authentication

## See Also

- [IndexedStackPath API](../api/navigation-paths.md#indexedstackpath)
- [Coordinator Pattern Guide](../paradigms/coordinator/coordinator.md)



================================================
FILE: packages/zenrouter/doc/recipes/route-transitions.md
================================================
# Recipe: Custom Route Transitions

## Problem

You want to customize the animation when navigating between pages—whether it's a slide, fade, scale, or even a custom shared-element transition. The default platform transitions (Material/Cupertino) don't fit your app's design language.

## Solution Overview

ZenRouter provides full control over page transitions through the **StackTransition** API. You can:

- Use built-in transitions (material, cupertino, sheet, dialog, none)
- Create custom transitions with `pageBuilder`
- Apply transitions per-route or globally
- Combine multiple animations for complex effects

## Complete Code Example

```dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// Define your routes
abstract class AppRoute extends RouteTarget {}

class HomeRoute extends AppRoute {}
class ProfileRoute extends AppRoute {}
class SettingsRoute extends AppRoute {}

final appPath = NavigationPath<AppRoute>.create();

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: NavigationStack(
        path: appPath,
        defaultRoute: HomeRoute(),
        // Resolver controls which transition each route uses
        resolver: (route) {
          return switch (route) {
            HomeRoute() => StackTransition.material(
                const HomePage(),
              ),
            ProfileRoute() => StackTransition.cupertino(
                const ProfilePage(),
              ),
            SettingsRoute() => StackTransition.sheet(
                const SettingsPage(),
              ),
            _ => StackTransition.material(
                const Scaffold(body: Center(child: Text('Unknown'))),
              ),
          };
        },
      ),
    );
  }
}
```

## Built-in Transitions

### Material Transition
```dart
StackTransition.material(const HomePage())
```
Platform-native Material Design transition (slide from right on Android).

### Cupertino Transition
```dart
StackTransition.cupertino(const ProfilePage())
```
iOS-style transition (slide from right with parallax).

### Sheet Transition
```dart
StackTransition.sheet(
  const SettingsPage(),
)
```
iOS bottom sheet transition.

### Dialog Transition
```dart
StackTransition.dialog(const AlertPage())
```
Dialog overlay presentation.

### No Transition
```dart
StackTransition.none(const DialogPage())
```
Instant switch with no animation (useful for testing).

## Custom Transitions

### Scale Transition

```dart
// First, create a custom Page class for the scale animation
class ScalePage<T> extends Page<T> {
  const ScalePage({super.key, required this.child});
  final Widget child;

  @override
  Route<T> createRoute(BuildContext context) {
    return PageRouteBuilder<T>(
      settings: this,
      pageBuilder: (context, animation, _) {
        const begin = 0.0;
        const end = 1.0;
        const curve = Curves.easeInOut;
        
        final tween = Tween(begin: begin, end: end).chain(
          CurveTween(curve: curve),
        );
        
        return ScaleTransition(
          scale: animation.drive(tween),
          child: child,
        );
      },
      transitionDuration: const Duration(milliseconds: 300),
    );
  }
}

// Then use it with StackTransition.custom
StackTransition.custom<MyRoute>(
  builder: (context) => const ProfilePage(),
  pageBuilder: (context, routeKey, child) => ScalePage(
    key: routeKey,
    child: child,
  ),
)
```

### Rotation Transition

```dart
class RotationPage<T> extends Page<T> {
  const RotationPage({super.key, required this.child});
  final Widget child;

  @override
  Route<T> createRoute(BuildContext context) {
    return PageRouteBuilder<T>(
      settings: this,
      pageBuilder: (context, animation, _) {
        const begin = 0.0;
        const end = 1.0;
        const curve = Curves.easeInOut;
        
        final tween = Tween(begin: begin, end: end).chain(
          CurveTween(curve: curve),
        );
        
        return RotationTransition(
          turns: animation.drive(tween),
          child: child,
        );
      },
      transitionDuration: const Duration(milliseconds: 300),
    );
  }
}

StackTransition.custom<MyRoute>(
  builder: (context) => const SettingsPage(),
  pageBuilder: (context, routeKey, child) => RotationPage(
    key: routeKey,
    child: child,
  ),
)
```

### Combined Fade + Slide

```dart
class FadeSlidePage<T> extends Page<T> {
  const FadeSlidePage({super.key, required this.child});
  final Widget child;

  @override
  Route<T> createRoute(BuildContext context) {
    return PageRouteBuilder<T>(
      settings: this,
      pageBuilder: (context, animation, _) {
        const offsetBegin = Offset(0.0, 0.1);
        const offsetEnd = Offset.zero;
        const curve = Curves.easeOutCubic;
        
        final offsetTween = Tween(begin: offsetBegin, end: offsetEnd).chain(
          CurveTween(curve: curve),
        );
        
        final fadeTween = Tween<double>(begin: 0.0, end: 1.0).chain(
          CurveTween(curve: curve),
        );
        
        return SlideTransition(
          position: animation.drive(offsetTween),
          child: FadeTransition(
            opacity: animation.drive(fadeTween),
            child: child,
          ),
        );
      },
      transitionDuration: const Duration(milliseconds: 400),
    );
  }
}

StackTransition.custom<MyRoute>(
  builder: (context) => const DetailPage(),
  pageBuilder: (context, routeKey, child) => FadeSlidePage(
    key: routeKey,
    child: child,
  ),
)
```

### Shared Element Transition (Hero)

```dart
// On source page
class ProductListPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return GridView.builder(
      itemBuilder: (context, index) {
        return GestureDetector(
          onTap: () => appPath.push(ProductDetailRoute('product-$index')),
          child: Hero(
            tag: 'product-$index',
            child: Image.network('https://example.com/product-$index.jpg'),
          ),
        );
      },
    );
  }
}

// On destination page
class ProductDetailPage extends StatelessWidget {
  final String productId;
  
  const ProductDetailPage({required this.productId});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          Hero(
            tag: productId,
            child: Image.network('https://example.com/$productId.jpg'),
          ),
          // ... product details
        ],
      ),
    );
  }
}

// Use Material transition to enable Hero animations
StackTransition.material(ProductDetailPage(productId: route.productId))
```

## Advanced Patterns

### Global Transition Strategy (Coordinator)

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  TransitionStrategy get transitionStrategy => TransitionStrategy.cupertino;
}
```

### Platform-Specific Transitions

```dart
StackTransition _platformTransition(Widget child) {
  if (Theme.of(context).platform == TargetPlatform.iOS) {
    return StackTransition.cupertino(child);
  }
  return StackTransition.material(child);
}

// In resolver
resolver: (route) {
  return _platformTransition(route.build(context));
}
```

### Secondary Animation (for leaving page)

```dart
class SlideBackPage<T> extends Page<T> {
  const SlideBackPage({super.key, required this.child});
  final Widget child;

  @override
  Route<T> createRoute(BuildContext context) {
    return PageRouteBuilder<T>(
      settings: this,
      pageBuilder: (context, animation, secondaryAnimation) {
        // Use secondaryAnimation to animate the page being covered
        const begin = Offset.zero;
        const end = Offset(-0.3, 0.0);
        
        final slideTween = Tween(begin: begin, end: end);
        
        return SlideTransition(
          position: secondaryAnimation.drive(slideTween),
          child: child,
        );
      },
      transitionDuration: const Duration(milliseconds: 300),
      reverseTransitionDuration: const Duration(milliseconds: 200),
    );
  }
}

StackTransition.custom<MyRoute>(
  builder: (context) => const DetailPage(),
  pageBuilder: (context, routeKey, child) => SlideBackPage(
    key: routeKey,
    child: child,
  ),
)
```

## Common Gotchas

> [!TIP]
> **Use appropriate durations**
> Keep transitions fast (200-400ms). Anything longer feels sluggish.

> [!WARNING]
> **Avoid complex animations on low-end devices**
> Heavy animations can cause jank. Consider using simpler transitions or detecting device performance.

> [!CAUTION]
> **secondaryAnimation is for the leaving page**
> When creating custom Page classes, `animation` animates the entering page, while `secondaryAnimation` animates the page being covered. Both are available in the `pageBuilder` callback of `PageRouteBuilder`.

## Transition Curves Reference

Common curves for natural motion:

```dart
Curves.easeInOut    // Balanced acceleration/deceleration
Curves.easeOut      // Starts fast, ends slow (most natural)
Curves.easeIn       // Starts slow, ends fast
Curves.easeOutCubic // Smooth, modern feel
Curves.easeInOutCubic // Very smooth
Curves.fastOutSlowIn // Material Design standard
Curves.elasticOut   // Bouncy overshoot
Curves.bounceOut    // Exaggerated bounce
```

## Performance Tips

1. **Avoid rebuilding child widgets**: Pass the child widget to the builder, which is then passed to your Page class—don't rebuild it in the `PageRouteBuilder.pageBuilder`
2. **Use `const` constructors**: Make child pages `const` where possible
3. **Limit simultaneous animations**: Don't animate too many properties at once
4. **Test on real devices**: Emulators don't accurately reflect animation performance

## Related Recipes

- [Modal Routing](modal-routing.md) - Full-screen modals with custom transitions
- [Nested Navigation](nested-navigation.md) - Transitions in nested contexts
- [Bottom Navigation](bottom-navigation.md) - Tab switching animations

## See Also

- [StackTransition API](../api/navigation-paths.md#stacktransition)
- [RouteTransition Mixin](../api/mixins.md#routetransition)
- [Flutter Animation Documentation](https://docs.flutter.dev/development/ui/animations)



================================================
FILE: packages/zenrouter/doc/recipes/route-versioning.md
================================================
# Recipe: Route Versioning with Coordinator-as-RouteModule

## Problem

You need to maintain multiple versions of a feature's routes in the same app. For example, you're rolling out a redesigned Shop experience (V2) while keeping the legacy Shop (V1) available for users who haven't migrated yet. Each version has its own routes, layouts, and UI—but they need to coexist and allow cross-version navigation.

## Solution Overview

Since `Coordinator<T>` implements `RouteModule<T>`, you can create separate coordinators for each API version and compose them as modules in a single parent. Each coordinator owns its own:

- **URI prefix** (`/v1/shop/...` vs `/v2/shop/...`)
- **Navigation paths** (isolated stacks)
- **Layouts** (different UI per version)
- **Route parsing logic**

This gives you full isolation between versions while sharing the same parent coordinator for cross-version navigation.

## Complete Code Example

```dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Route Base
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

// ============================================================================
// Shop V1 — Deprecated version
// ============================================================================

class ShopCoordinatorV1 extends Coordinator<AppRoute> {
  ShopCoordinatorV1(this._parent);
  final MainCoordinator _parent;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  late final NavigationPath<AppRoute> shopV1Stack = NavigationPath.createWith(
    label: 'shop-v1',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, shopV1Stack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopV1Layout, ShopV1Layout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['v1', 'shop'] => ShopHomeV1(),
      ['v1', 'shop', 'products'] => ProductListV1(),
      ['v1', 'shop', 'cart'] => CartV1(),
      _ => null,
    };
  }
}

// V1 Layout — shows deprecation banner
class ShopV1Layout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(MainCoordinator coordinator) =>
      coordinator.getModule<ShopCoordinatorV1>().shopV1Stack;

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Shop (V1 — Deprecated)'),
        backgroundColor: Colors.grey[600],
        foregroundColor: Colors.white,
      ),
      body: Column(
        children: [
          MaterialBanner(
            padding: const EdgeInsets.all(12),
            backgroundColor: Colors.orange[100],
            leading: const Icon(Icons.warning_amber, color: Colors.orange),
            content: const Text('This version is deprecated. Migrate to V2.'),
            actions: [
              TextButton(
                onPressed: () => coordinator.replace(ShopHomeV2()),
                child: const Text('Switch to V2'),
              ),
            ],
          ),
          Expanded(child: buildPath(coordinator)),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: 0,
        selectedItemColor: Colors.grey[700],
        onTap: (i) => switch (i) {
          0 => coordinator.push(ShopHomeV1()),
          1 => coordinator.push(ProductListV1()),
          2 => coordinator.push(CartV1()),
          _ => null,
        },
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
          BottomNavigationBarItem(icon: Icon(Icons.list), label: 'Products'),
          BottomNavigationBarItem(icon: Icon(Icons.shopping_cart), label: 'Cart'),
        ],
      ),
    );
  }
}

// V1 Routes
class ShopHomeV1 extends AppRoute {
  @override
  Type get layout => ShopV1Layout;
  @override
  Uri toUri() => Uri.parse('/v1/shop');
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      const Center(child: Text('Shop Home (V1)'));
}

class ProductListV1 extends AppRoute {
  @override
  Type get layout => ShopV1Layout;
  @override
  Uri toUri() => Uri.parse('/v1/shop/products');
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      const Center(child: Text('Products (V1)'));
}

class CartV1 extends AppRoute {
  @override
  Type get layout => ShopV1Layout;
  @override
  Uri toUri() => Uri.parse('/v1/shop/cart');
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      const Center(child: Text('Cart (V1)'));
}

// ============================================================================
// Shop V2 — Current version
// ============================================================================

class ShopCoordinatorV2 extends Coordinator<AppRoute> {
  ShopCoordinatorV2(this._parent);
  final MainCoordinator _parent;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  late final NavigationPath<AppRoute> shopV2Stack = NavigationPath.createWith(
    label: 'shop-v2',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, shopV2Stack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopV2Layout, ShopV2Layout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['v2', 'shop'] => ShopHomeV2(),
      ['v2', 'shop', 'products'] => ProductListV2(),
      ['v2', 'shop', 'products', final id] => ProductDetailV2(id: id),
      ['v2', 'shop', 'cart'] => CartV2(),
      _ => null,
    };
  }
}

// V2 Layout — NavigationRail (modern sidebar)
class ShopV2Layout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(MainCoordinator coordinator) =>
      coordinator.getModule<ShopCoordinatorV2>().shopV2Stack;

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Shop (V2)'),
        backgroundColor: Colors.green[700],
        foregroundColor: Colors.white,
        actions: [
          // Cross-version navigation
          TextButton.icon(
            icon: const Icon(Icons.history, color: Colors.white70),
            label: const Text('V1', style: TextStyle(color: Colors.white70)),
            onPressed: () => coordinator.replace(ShopHomeV1()),
          ),
        ],
      ),
      body: Row(
        children: [
          NavigationRail(
            selectedIndex: 0,
            labelType: NavigationRailLabelType.all,
            onDestinationSelected: (i) => switch (i) {
              0 => coordinator.push(ShopHomeV2()),
              1 => coordinator.push(ProductListV2()),
              2 => coordinator.push(CartV2()),
              _ => null,
            },
            destinations: const [
              NavigationRailDestination(
                icon: Icon(Icons.home_outlined),
                selectedIcon: Icon(Icons.home),
                label: Text('Home'),
              ),
              NavigationRailDestination(
                icon: Icon(Icons.shopping_bag_outlined),
                selectedIcon: Icon(Icons.shopping_bag),
                label: Text('Products'),
              ),
              NavigationRailDestination(
                icon: Icon(Icons.shopping_cart_outlined),
                selectedIcon: Icon(Icons.shopping_cart),
                label: Text('Cart'),
              ),
            ],
          ),
          const VerticalDivider(width: 1),
          Expanded(child: buildPath(coordinator)),
        ],
      ),
    );
  }
}

// V2 Routes
class ShopHomeV2 extends AppRoute {
  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop');
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      const Center(child: Text('Shop Home (V2)'));
}

class ProductListV2 extends AppRoute {
  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop/products');
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      const Center(child: Text('Products (V2)'));
}

class ProductDetailV2 extends AppRoute {
  ProductDetailV2({required this.id});
  final String id;

  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop/products/$id');
  @override
  List<Object?> get props => [id];
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      Center(child: Text('Product $id (V2)'));
}

class CartV2 extends AppRoute {
  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop/cart');
  @override
  Widget build(covariant MainCoordinator c, BuildContext ctx) =>
      const Center(child: Text('Cart (V2)'));
}

// ============================================================================
// Main Coordinator
// ============================================================================

class MainCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    MainRouteModule(this),
    ShopCoordinatorV1(this),
    ShopCoordinatorV2(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class MainRouteModule extends RouteModule<AppRoute> {
  MainRouteModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRedirect(),
      _ => null,
    };
  }
}

class HomeRedirect extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/');
  @override
  AppRoute redirect() => ShopHomeV2(); // Default to latest version
  @override
  Widget build(covariant Coordinator c, BuildContext ctx) => const SizedBox();
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});
  final Uri uri;
  @override
  Uri toUri() => Uri.parse('/not-found');
  @override
  Widget build(covariant Coordinator c, BuildContext ctx) =>
      Center(child: Text('Not found: ${uri.path}'));
}
```

## Step-by-Step Explanation

### 1. Create Versioned Coordinators

Each version is a full `Coordinator` with its own paths and layouts:

```dart
class ShopCoordinatorV1 extends Coordinator<AppRoute> {
  ShopCoordinatorV1(this._parent);
  final MainCoordinator _parent;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;     // ← Link to parent

  late final shopV1Stack = NavigationPath.createWith(
    label: 'shop-v1',
    coordinator: this,   // ← Auto-resolves to root coordinator
  );
  // ...
}
```

**Key points:**
- Override `coordinator` to return the parent
- Pass `this` when creating paths — the framework auto-resolves the root coordinator
- Use unique labels (`shop-v1`, `shop-v2`) to avoid conflicts

### 2. Version-specific URI prefixes

Each version owns its own URI namespace:

```dart
// V1 handles /v1/shop/...
['v1', 'shop'] => ShopHomeV1(),
['v1', 'shop', 'products'] => ProductListV1(),

// V2 handles /v2/shop/...
['v2', 'shop'] => ShopHomeV2(),
['v2', 'shop', 'products', final id] => ProductDetailV2(id: id),
```

### 3. Version-specific Layouts

Each version can have a completely different UI:

- **V1**: `BottomNavigationBar` + deprecation `MaterialBanner`
- **V2**: `NavigationRail` sidebar (modern design)

### 4. Cross-Version Navigation

Navigate between versions using the parent coordinator:

```dart
// V1 → V2: "Switch to V2" button in deprecation banner
coordinator.replace(ShopHomeV2());

// V2 → V1: "V1" button in app bar
coordinator.replace(ShopHomeV1());
```

### 5. Default Redirect

The root route redirects to the latest version:

```dart
class HomeRedirect extends AppRoute with RouteRedirect<AppRoute> {
  @override
  AppRoute redirect() => ShopHomeV2(); // Default to V2
}
```

## Advanced Variations

### Feature Flags

Conditionally include versions based on feature flags:

```dart
@override
Set<RouteModule<AppRoute>> defineModules() {
  final modules = <RouteModule<AppRoute>>{
    ShopCoordinatorV2(this),
  };

  if (featureFlags.enableLegacyShop) {
    modules.add(ShopCoordinatorV1(this));
  }

  return modules;
}
```

### Gradual Migration

Route V1 URIs to V2 handlers using redirects:

```dart
class ShopV1Redirect extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/v1/shop');
  @override
  AppRoute redirect() => ShopHomeV2();
}
```

### Three or More Versions

The pattern scales to any number of versions:

```dart
Set<RouteModule<AppRoute>> defineModules() => {
  ShopCoordinatorV1(this),   // Legacy
  ShopCoordinatorV2(this),   // Current
  ShopCoordinatorV3(this),   // Canary/beta
};
```

## Common Gotchas

> [!WARNING]
> **Use unique path labels** for each version. Duplicate labels will cause state restoration conflicts. Use prefixes like `shop-v1`, `shop-v2`.

> [!TIP]
> **V2-exclusive features** (like product detail with `:id`) don't need V1 equivalents. Each version is independently defined.

> [!NOTE]
> **Module order in `defineModules`** determines parsing priority. If V1 and V2 have overlapping URI patterns, the first will win. Using version prefixes (`/v1/`, `/v2/`) avoids this entirely.

## Related Recipes

- [Bottom Navigation](bottom-navigation.md) — Tab navigation within a version
- [Authentication Flow](authentication-flow.md) — Guards that work across versions
- [404 Handling](404-handling.md) — Handling unknown versioned routes

## See Also

- [Coordinator as RouteModule Guide](../guides/coordinator-as-module.md) — In-depth guide
- [Coordinator Modular Guide](../guides/coordinator-modular.md) — Regular RouteModule pattern
- **Example code**: `packages/zenrouter/example/lib/main_coordinator_module.dart`



================================================
FILE: packages/zenrouter/doc/recipes/state-management.md
================================================
# Recipe: State Management Integration

## Problem

You need to integrate your routing with state management solutions like Riverpod, Bloc, or Provider. Common scenarios include:
- Navigate based on authentication state changes
- Deep link to a page and load its data
- Sync routing state with global app state
- Trigger navigation from business logic layer

## Solution Overview

ZenRouter works seamlessly with any state management solution. Routes are just Dart classes, so they can respond to state changes through:

- `RouteRedirect` for state-based redirects
- Listening to state providers in route widgets
- Coordinator integration with state notifiers
- Deep link handlers that fetch data before navigation

## Riverpod Integration

### Authentication with Riverpod

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:zenrouter/zenrouter.dart';

// Auth state provider
final authProvider = StateNotifierProvider<AuthNotifier, AuthState>((ref) {
  return AuthNotifier();
});

class AuthState {
  final bool isAuthenticated;
  final String? userId;
  
  const AuthState({this.isAuthenticated = false, this.userId});
}

class AuthNotifier extends StateNotifier<AuthState> {
  AuthNotifier() : super(const AuthState());
  
  Future<void> login(String email, String password) async {
    // Simulate auth
    await Future.delayed(const Duration(seconds: 1));
    state = const AuthState(isAuthenticated: true, userId: 'user-123');
  }
  
  void logout() {
    state = const AuthState();
  }
}

// Routes
abstract class AppRoute extends RouteTarget with RouteUnique {}

// Protected route using Riverpod
class ProfileRoute extends AppRoute with RouteRedirect {
  final ProviderContainer container;
  
  ProfileRoute(this.container);
  
  @override
  List<Object?> get props => [];
  
  @override
  Future<AppRoute> redirect() async {
    final authState = container.read(authProvider);
    
    if (!authState.isAuthenticated) {
      return LoginRoute(container, intendedRoute: this);
    }
    
    return this;
  }
  
  @override
  Uri toUri() => Uri.parse('/profile');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const ProfilePage();
  }
}

class LoginRoute extends AppRoute {
  final ProviderContainer container;
  final AppRoute? intendedRoute;
  
  LoginRoute(this.container, {this.intendedRoute});
  
  @override
  List<Object?> get props => [intendedRoute];
  
  @override
  Uri toUri() => Uri.parse('/login');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return LoginPage(
      onLoginSuccess: () async {
        if (intendedRoute != null) {
          coordinator.replace(intendedRoute!);
        } else {
          coordinator.replace(HomeRoute(container));
        }
      },
    );
  }
}

class HomeRoute extends AppRoute {
  final ProviderContainer container;
  
  HomeRoute(this.container);
  
  @override
  List<Object?> get props => [];
  
  @override
  Uri toUri() => Uri.parse('/');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const HomePage();
  }
}

// Coordinator with Riverpod
class AppCoordinator extends Coordinator<AppRoute> {
  final ProviderContainer container;
  
  AppCoordinator(this.container);
  
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(container),
      ['login'] => LoginRoute(container),
      ['profile'] => ProfileRoute(container),
      _ => NotFoundRoute(container),
    };
  }
}

// Listening to auth changes in widgets
class ProfilePage extends ConsumerWidget {
  const ProfilePage({super.key});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Profile'),
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () {
              ref.read(authProvider.notifier).logout();
              context.coordinator<AppCoordinator>().replace(
                HomeRoute(context.container),
              );
            },
          ),
        ],
      ),
      body: Center(
        child: Text('User ID: ${authState.userId}'),
      ),
    );
  }
}
```

### Data Loading with Deep Links

```dart
// Product provider
final productProvider = FutureProvider.family<Product, String>((ref, id) async {
  // Fetch product from API
  await Future.delayed(const Duration(seconds: 1));
  return Product(id: id, name: 'Product $id');
});

class Product {
  final String id;
  final String name;
  
  Product({required this.id, required this.name});
}

// Route with data loading
class ProductRoute extends AppRoute with RouteDeepLink {
  final String productId;
  final ProviderContainer container;
  
  ProductRoute(this.productId, this.container);
  
  @override
  List<Object?> get props => [productId];
  
  @override
  Uri toUri() => Uri.parse('/products/$productId');
  
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(Coordinator coordinator, Uri uri) async {
    // Preload data before showing the page
    await container.read(productProvider(productId).future);
    coordinator.navigate(this);
  }
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return ProductPage(productId: productId);
  }
}

class ProductPage extends ConsumerWidget {
  final String productId;
  
  const ProductPage({super.key, required this.productId});
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final productAsync = ref.watch(productProvider(productId));
    
    return Scaffold(
      appBar: AppBar(title: const Text('Product')),
      body: productAsync.when(
        data: (product) => Center(
          child: Text(product.name),
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(
          child: Text('Error: $error'),
        ),
      ),
    );
  }
}
```

## Bloc Integration

```dart
import 'package:flutter_bloc/flutter_bloc.dart';

// Auth Bloc
class AuthBloc extends Bloc<AuthEvent, AuthState> {
  AuthBloc() : super(const AuthState()) {
    on<LoginRequested>(_onLoginRequested);
    on<LogoutRequested>(_onLogoutRequested);
  }
  
  Future<void> _onLoginRequested(
    LoginRequested event,
    Emitter<AuthState> emit,
  ) async {
    await Future.delayed(const Duration(seconds: 1));
    emit(const AuthState(isAuthenticated: true, userId: 'user-123'));
  }
  
  void _onLogoutRequested(
    LogoutRequested event,
    Emitter<AuthState> emit,
  ) {
    emit(const AuthState());
  }
}

// Protected route with Bloc
class DashboardRoute extends AppRoute with RouteRedirect {
  final AuthBloc authBloc;
  
  DashboardRoute(this.authBloc);
  
  @override
  Future<AppRoute> redirect() async {
    if (!authBloc.state.isAuthenticated) {
      return LoginRoute(authBloc, intendedRoute: DashboardRoute(authBloc));
    }
    return this;
  }
  
  @override
  Uri toUri() => Uri.parse('/dashboard');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const DashboardPage();
  }
}

// Page with Bloc listener for navigation
class DashboardPage extends StatelessWidget {
  const DashboardPage({super.key});
  
  @override
  Widget build(BuildContext context) {
    return BlocListener<AuthBloc, AuthState>(
      listener: (context, state) {
        if (!state.isAuthenticated) {
          // Logged out - navigate to home
          context.coordinator<AppCoordinator>().replace(HomeRoute());
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Dashboard'),
          actions: [
            IconButton(
              icon: const Icon(Icons.logout),
              onPressed: () {
                context.read<AuthBloc>().add(LogoutRequested());
              },
            ),
          ],
        ),
        body: const Center(
          child: Text('Dashboard Content'),
        ),
      ),
    );
  }
}
```

## Provider Integration

```dart
import 'package:provider/provider.dart';

// Auth provider
class AuthProvider extends ChangeNotifier {
  bool _isAuthenticated = false;
  
  bool get isAuthenticated => _isAuthenticated;
  
  Future<void> login() async {
    await Future.delayed(const Duration(seconds: 1));
    _isAuthenticated = true;
    notifyListeners();
  }
  
  void logout() {
    _isAuthenticated = false;
    notifyListeners();
  }
}

// Protected route
class SettingsRoute extends AppRoute with RouteRedirect {
  final BuildContext context;
  
  SettingsRoute(this.context);
  
  @override
  Future<AppRoute> redirect() async {
    final authProvider = context.read<AuthProvider>();
    
    if (!authProvider.isAuthenticated) {
      return LoginRoute();
    }
    
    return this;
  }
  
  @override
  Uri toUri() => Uri.parse('/settings');
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const SettingsPage();
  }
}
```

## Advanced Patterns

### Navigation from Business Logic

```dart
// Navigation service with Riverpod
final navigationServiceProvider = Provider((ref) {
  return NavigationService(ref);
});

class NavigationService {
  final Ref ref;
  late final AppCoordinator coordinator;
  
  NavigationService(this.ref);
  
  void initialize(AppCoordinator coordinator) {
    this.coordinator = coordinator;
  }
  
  void navigateToProfile() {
    coordinator.push(ProfileRoute(ref.container));
  }
  
  void navigateToProduct(String productId) {
    coordinator.push(ProductRoute(productId, ref.container));
  }
  
  void goHome() {
    coordinator.replace(HomeRoute(ref.container));
  }
}

// Usage in business logic
class CheckoutNotifier extends StateNotifier<CheckoutState> {
  final Ref ref;
  
  CheckoutNotifier(this.ref) : super(CheckoutState.initial());
  
  Future<void> completeCheckout() async {
    // Process payment...
    
    // Navigate to success page
    ref.read(navigationServiceProvider).navigateToProduct('order-123');
  }
}
```

### Query Parameters as State

```dart
class SearchRoute extends AppRoute with RouteQueryParameters {
  SearchRoute({String? initialQuery}) {
    if (initialQuery != null) {
      queryParameters['q'].value = initialQuery;
    }
  }
  
  @override
  Uri toUri() {
    final query = queryParameters['q']!.value as String?;
    return Uri.parse('/search').replace(
      queryParameters: query != null ? {'q': query} : null,
    );
  }
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return SearchPage(searchRoute: this);
  }
}

class SearchPage extends StatelessWidget {
  final SearchRoute searchRoute;
  
  const SearchPage({super.key, required this.searchRoute});
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: ValueListenableBuilder<dynamic>(
        valueListenable: searchRoute.queryParameters['q']!,
        builder: (context, query, _) {
          return SearchResults(query: query as String?);
        },
      ),
    );
  }
}
```

## Common Gotchas

> [!TIP]
> **Pass providers/containers to routes**
> Since routes are created during URI parsing (potentially before context is available), pass `ProviderContainer` or similar to route constructors.
> If you don't want to pass providers/containers to routes, you can create a global instance of `ProviderContainer` and use it in all routes.

> [!CAUTION]
> **Avoid context in redirect**
> The `redirect()` method may not have access to `BuildContext`. Use dependency injection or pass state explicitly.

> [!NOTE]
> **State changes triggering navigation**
> Use `BlocListener`, `ref.listen`, or similar to react to state changes and navigate. Don't navigate inside `build()` methods.

> [!WARNING]
> **Circular dependencies**
> Be careful not to create circular dependencies between your coordinator and state management. Use dependency injection patterns.

## Related Recipes

- [Authentication Flow](authentication-flow.md) - Auth patterns with state
- [Bottom Navigation](bottom-navigation.md) - Tab state management
- [Nested Navigation](nested-navigation.md) - Nested state contexts

## See Also

- [RouteRedirect Mixin](../api/mixins.md#routeredirect)
- [RouteQueryParameters](../api/mixins.md#routequeryparameters)
- [Riverpod Documentation](https://riverpod.dev)
- [Bloc Documentation](https://bloclibrary.dev)



================================================
FILE: packages/zenrouter/doc/recipes/url-strategies.md
================================================
# Recipe: URL Strategies for Web

## Problem

When deploying your Flutter web app, you need to configure how URLs are handled:
- **Hash-based routing** (`example.com/#/page`) - works without server configuration
- **Path-based routing** (`example.com/page`) - cleaner URLs but requires server setup
- Supporting both development and production environments
- Handling deep links and browser navigation

## Solution Overview

ZenRouter leverages Flutter's built-in `UrlStrategy` to configure URL handling. You can:

- Use hash URLs for simple deployments (GitHub Pages, S3)
- Use path URLs for production apps with proper server configuration
- Switch strategies based on environment
- Configure custom URL transformations

## Complete Code Example

### Path-Based URLs (Recommended for Production)

```dart
import 'package:flutter/material.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:zenrouter/zenrouter.dart';

void main() {
  // Use path-based URLs (no hash)
  usePathUrlStrategy();
  
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  final coordinator = AppCoordinator();
  
  const MyApp({super.key});
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// URLs will be:
// example.com/
// example.com/profile
// example.com/products/123
```

**Server Configuration Required:**

For path-based URLs, configure your server to serve `index.html` for all routes:

**Nginx:**
```nginx
server {
  listen 80;
  server_name example.com;
  root /var/www/app;
  
  location / {
    try_files $uri $uri/ /index.html;
  }
}
```

**Apache (`.htaccess`):**
```apache
<IfModule mod_rewrite.c>
  RewriteEngine On
  RewriteBase /
  RewriteRule ^index\.html$ - [L]
  RewriteCond %{REQUEST_FILENAME} !-f
  RewriteCond %{REQUEST_FILENAME} !-d
  RewriteRule . /index.html [L]
</IfModule>
```

**Firebase Hosting (`firebase.json`):**
```json
{
  "hosting": {
    "public": "build/web",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
```

### Hash-Based URLs (No Server Config Needed)

```dart
import 'package:flutter/material.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:zenrouter/zenrouter.dart';

void main() {
  // No need to call anything - hash URLs are the default
  // Or explicitly:
  // setHashUrlStrategy();
  
  runApp(const MyApp());
}

// URLs will be:
// example.com/#/
// example.com/#/profile
// example.com/#/products/123
```

**Advantages:**
- ✅ Works on any static file server
- ✅ No server configuration needed
- ✅ Perfect for GitHub Pages, S3, Netlify

**Disadvantages:**
- ❌ Ugly URLs with `#`
- ❌ Less SEO-friendly
- ❌ May confuse users

### Environment-Based Strategy

```dart
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:zenrouter/zenrouter.dart';

void main() {
  // Use path URLs in production, hash URLs in development
  if (kReleaseMode) {
    usePathUrlStrategy();
  } else {
    // Hash strategy is default, but you can be explicit:
    // setHashUrlStrategy();
  }
  
  runApp(const MyApp());
}
```

### Custom Base Path (Subdirectory Hosting)

If your app is hosted at `example.com/app/` instead of the root:

```dart
import 'package:flutter_web_plugins/url_strategy.dart';

void main() {
  usePathUrlStrategy();
  
  runApp(const MyApp());
}

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    // Remove base path if it exists
    var segments = uri.pathSegments;
    if (segments.isNotEmpty && segments.first == 'app') {
      segments = segments.skip(1).toList();
    }
    
    return switch (segments) {
      [] => HomeRoute(),
      ['profile'] => ProfileRoute(),
      _ => NotFoundRoute(),
    };
  }
  
  // Ensure all generated URIs include the base path
  Uri _addBasePath(Uri uri) {
    return uri.replace(
      pathSegments: ['app', ...uri.pathSegments],
    );
  }
}

// Configure in index.html
// <base href="/app/">
```

Update your `web/index.html`:
```html
<!DOCTYPE html>
<html>
<head>
  <base href="/app/">
  <!-- ... -->
</head>
<body>
  <!-- ... -->
</body>
</html>
```

## Advanced Patterns

### Custom URL Transformation

```dart
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    // Custom URL transformations
    var path = uri.path;
    
    // Map legacy URLs to new routes
    if (path.startsWith('/old-products/')) {
      final id = path.replaceFirst('/old-products/', '');
      return ProductRoute(id);
    }
    
    // Handle query parameters as paths
    if (path == '/search' && uri.queryParameters.containsKey('q')) {
      return SearchRoute(uri.queryParameters['q']!);
    }
    
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['products', String id] => ProductRoute(id),
      ['search'] => SearchRoute(),
      _ => NotFoundRoute(),
    };
  }
}
```

### Tracking Page Views

```dart
import 'package:firebase_analytics/firebase_analytics.dart';

class AppCoordinator extends Coordinator<AppRoute> {
  final analytics = FirebaseAnalytics.instance;
  
  @override
  void addListener(VoidCallback listener) {
    super.addListener(listener);
    
    // Track page views on route changes
    _trackCurrentPage();
  }
  
  void _trackCurrentPage() {
    if (routes.isEmpty) return;
    
    final currentRoute = routes.last;
    final uri = currentRoute.toUri();
    
    analytics.logEvent(
      name: 'page_view',
      parameters: {
        'page_path': uri.path,
        'page_title': _getPageTitle(currentRoute),
      },
    );
  }
  
  String _getPageTitle(AppRoute route) {
    return switch (route) {
      HomeRoute() => 'Home',
      ProfileRoute() => 'Profile',
      ProductRoute(id: var id) => 'Product: $id',
      _ => 'Unknown',
    };
  }
}
```

### SEO Meta Tags

```dart
import 'package:flutter/material.dart';
import 'dart:html' as html;
import 'package:meta_seo/meta_seo.dart';

mixin RouteSeo on RouteUnique {
  String get title;
  String get description;
  String get keywords;
  // Optional meta tags with defaults
  String get author => 'Dai Duong';
  String? get ogImage => null; // URL to social media preview image
  String get ogType => 'website';
  TwitterCard? get twitterCard => TwitterCard.summaryLargeImage;
  String? get twitterSite => null; // e.g., '@yourusername'
  String? get canonicalUrl => null; // Canonical URL for this page
  String get language => 'en';
  String? get robots => null; // e.g., 'index, follow'

  final meta = MetaSEO();

  @override
  void onUpdate(covariant RouteTarget newRoute) {
    super.onUpdate(newRoute);
    buildSeo();
  }

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    buildSeo();
    return const SizedBox.shrink();
  }

  void buildSeo() {
    // Add MetaSEO just into Web platform condition
    if (kIsWeb) {
      // Basic meta tags
      meta.author(author: author);
      meta.description(description: description);
      meta.keywords(keywords: keywords);
      // Open Graph meta tags (for Facebook, LinkedIn, etc.)
      setWebTitle(title);
      meta.ogTitle(ogTitle: title);
      meta.ogDescription(ogDescription: description);
      if (ogImage != null) {
        meta.ogImage(ogImage: ogImage!);
      }
      // Twitter Card meta tags
      if (twitterCard != null) {
        meta.twitterCard(twitterCard: twitterCard!);
      }
      meta.twitterTitle(twitterTitle: title);
      meta.twitterDescription(twitterDescription: description);
      if (ogImage != null) {
        meta.twitterImage(twitterImage: ogImage!);
      }
      if (twitterSite != null) {
        // Note: You may need to add this manually if MetaSEO doesn't support it
        // or use meta.config() for custom tags
      }
      // Additional SEO tags
      if (robots != null) {
        // Use meta.config() for custom tags
        meta.robots(robotsName: RobotsName.robots, content: robots!);
      }
    }
  }
}

class ProductRoute extends AppRoute with RouteSeo {
  @override
  String get title => 'Products List';

  @override
  String get description => 'Products List description';

  @override
  String get keywords => 'product, description';

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    super.build(coordinator, context);
    return ProductListRoute();
  }
}

```

## Common Gotchas

> [!TIP]
> **Set URL strategy before runApp**
> Call `usePathUrlStrategy()` or `setHashUrlStrategy()` before calling `runApp()`.

> [!CAUTION]
> **Base href in index.html**
> Ensure your `web/index.html` has the correct `<base href="/">`. For subdirectories, use `<base href="/subdirectory/">`.

> [!WARNING]
> **Path URLs require server configuration**
> Path-based URLs will 404 on refresh unless your server is configured to always serve `index.html`.

> [!NOTE]
> **Hash URLs work everywhere**
> Hash-based URLs work on any static file server without configuration, making them safer for simple deployments.

## Testing URL Strategies

```dart
// Test path URL parsing
void testPathUrl() {
  final coordinator = AppCoordinator();
  
  final route = coordinator.parseRouteFromUri(
    Uri.parse('https://example.com/products/123'),
  );
  
  expect(route, isA<ProductRoute>());
  expect((route as ProductRoute).productId, '123');
}

// Test hash URL parsing (same logic)
void testHashUrl() {
  final coordinator = AppCoordinator();
  
  // The hash is stripped by Flutter before reaching your parser
  final route = coordinator.parseRouteFromUri(
    Uri.parse('https://example.com/products/123'),
  );
  
  expect(route, isA<ProductRoute>());
}
```

## Related Recipes

- [404 Handling](404-handling.md) - Handle invalid URLs gracefully
- [Nested Navigation](nested-navigation.md) - URLs for nested routes
- [Authentication Flow](authentication-flow.md) - Protected URLs

## See Also

- [Flutter URL Strategy Documentation](https://docs.flutter.dev/development/ui/navigation/url-strategies)
- [Coordinator Pattern Guide](../paradigms/coordinator/coordinator.md)
- [RouteUnique Mixin](../api/mixins.md#routeunique)



================================================
FILE: packages/zenrouter/example/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml



================================================
FILE: packages/zenrouter/example/pubspec.yaml
================================================
name: example
description: "A new Flutter project."
publish_to: 'none'
version: 0.1.0+1

environment:
  sdk: ^3.8.0

resolution: workspace

dependencies:
  flutter:
    sdk: flutter
  zenrouter:
  zenrouter_devtools:
  
  cupertino_icons: ^1.0.8

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

flutter:
  uses-material-design: true



================================================
FILE: packages/zenrouter/example/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: android
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: ios
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: linux
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: macos
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: web
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: windows
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
FILE: packages/zenrouter/example/android/build.gradle.kts
================================================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}



================================================
FILE: packages/zenrouter/example/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true



================================================
FILE: packages/zenrouter/example/android/settings.gradle.kts
================================================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.11.1" apply false
    id("org.jetbrains.kotlin.android") version "2.2.20" apply false
}

include(":app")



================================================
FILE: packages/zenrouter/example/android/app/build.gradle.kts
================================================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "dev.zennn.router.example.example"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "dev.zennn.router.example.example"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}



================================================
FILE: packages/zenrouter/example/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter/example/android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            <intent-filter android:label="zenrouter_example">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="devzennn" />
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>



================================================
FILE: packages/zenrouter/example/android/app/src/main/kotlin/dev/zennn/router/example/example/MainActivity.kt
================================================
package dev.zennn.router.example.example

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()



================================================
FILE: packages/zenrouter/example/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter/example/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter/example/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter/example/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter/example/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter/example/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-all.zip



================================================
FILE: packages/zenrouter/example/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter/example/ios/Flutter/Debug.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter/example/ios/Flutter/Release.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter/example/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}



================================================
FILE: packages/zenrouter/example/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Example</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>example</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter/example/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
FILE: packages/zenrouter/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
FILE: packages/zenrouter/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter/example/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
FILE: packages/zenrouter/example/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
FILE: packages/zenrouter/example/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter/example/lib/main.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';

void main() {
  runApp(const MainApp());
}

class MainApp extends StatelessWidget {
  const MainApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(routerConfig: appCoordinator);
  }
}

// ============================================================================
// Coordinator
// ============================================================================

final appCoordinator = AppCoordinator();

class AppCoordinator extends Coordinator<AppRoute> with CoordinatorDebug {
  late final tabPath = IndexedStackPath.createWith(
    coordinator: this,
    label: 'tabs',
    [HomeTab(), SearchTab(), ProfileTab()],
  );

  @override
  void defineLayout() {
    RouteLayout.defineLayout(TabLayout, TabLayout.new);
  }

  @override
  List<StackPath> get paths => [...super.paths, tabPath];

  @override
  List<AppRoute> get debugRoutes => [HomeTab(), SearchTab(), ProfileTab()];

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] || ['home'] => HomeTab(),
      ['search'] => SearchTab(),
      ['profile'] => ProfileTab(),
      ['settings'] => SettingsRoute(),
      _ => HomeTab(),
    };
  }
}

// ============================================================================
// Route Base
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

// ============================================================================
// Tab Layout
// ============================================================================

class TabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.tabPath;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = coordinator.tabPath;
    return Scaffold(
      body: buildPath(coordinator),
      bottomNavigationBar: ListenableBuilder(
        listenable: path,
        builder: (context, _) => BottomNavigationBar(
          currentIndex: path.activeIndex,
          onTap: (index) => path.goToIndexed(index),
          items: const [
            BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
            BottomNavigationBarItem(icon: Icon(Icons.search), label: 'Search'),
            BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
          ],
        ),
      ),
    );
  }
}

// ============================================================================
// Tab Routes
// ============================================================================

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: const Center(
        child: Text('Settings', style: TextStyle(fontSize: 24)),
      ),
    );
  }
}

class HomeTab extends AppRoute {
  @override
  Type get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/home');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const Center(child: Text('Home', style: TextStyle(fontSize: 24)));
  }
}

class SearchTab extends AppRoute {
  @override
  Type get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/search');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const Center(child: Text('Search', style: TextStyle(fontSize: 24)));
  }
}

class ProfileTab extends AppRoute {
  @override
  Type get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/profile');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return const Center(child: Text('Profile', style: TextStyle(fontSize: 24)));
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_coordinator.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';

// ============================================================================
// Main App Entry Point
// ============================================================================

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  static final coordinator = AppCoordinator();

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter Nested Routes Example',
      restorationScopeId: 'main_coordinator',
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// ============================================================================
// Route Definitions
// ============================================================================

/// Base route class for all app routes
abstract class AppRoute extends RouteTarget with RouteUnique {}

/// Home layout - uses NavigatorStack for nested navigation within home
class HomeLayout extends AppRoute with RouteLayout<AppRoute>, RouteTransition {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.homeStack;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home'), backgroundColor: Colors.blue),
      body: buildPath(coordinator),
    );
  }

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    AppCoordinator coordinator,
  ) {
    return StackTransition.cupertino(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }
}

/// Tab bar shell - uses Custom (IndexedStack) for tab navigation
class TabBarLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  Type get layout => HomeLayout;

  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.tabIndexed;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = coordinator.tabIndexed;
    return Scaffold(
      body: Column(
        children: [
          // Tab content (IndexedStack is built by RouteLayout)
          Expanded(child: buildPath(coordinator)),
          // Tab bar
          Container(
            color: Colors.grey[200],
            child: ListenableBuilder(
              listenable: path,
              builder: (context, child) => Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  _TabButton(
                    label: 'Feed',
                    isActive: path.activeIndex == 0,
                    onTap: () => coordinator.push(FeedTabLayout()),
                  ),
                  _TabButton(
                    label: 'Profile',
                    isActive: path.activeIndex == 1,
                    onTap: () => coordinator.push(ProfileTab()),
                  ),
                  _TabButton(
                    label: 'Settings',
                    isActive: path.activeIndex == 2,
                    onTap: () => coordinator.push(SettingsTab()),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

/// Settings shell - uses NavigatorStack for nested settings navigation
class SettingsLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.settingsStack;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: BackButton(onPressed: () => coordinator.tryPop()),
        title: const Text('Settings'),
      ),
      body: buildPath(coordinator),
    );
  }
}

// ============================================================================
// Tab Routes (belong to TabBarLayout - custom layout)
// ============================================================================

class FeedTabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.feedTabStack;

  @override
  Type get layout => TabBarLayout;
}

class FeedTab extends AppRoute {
  @override
  Type get layout => FeedTabLayout;

  @override
  Uri toUri() => Uri.parse('/home/tabs/feed');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Feed',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        _FeedItem(
          title: 'Post 1',
          onTap: () => coordinator.push(FeedDetail(id: '1')),
        ),
        _FeedItem(
          title: 'Post 2',
          onTap: () => coordinator.push(FeedDetail(id: '2')),
        ),
        _FeedItem(
          title: 'Post 3',
          onTap: () => coordinator.push(FeedDetail(id: '3')),
        ),
        _FeedItem(
          title: 'Post "profile" will redirect to ProfileDetail',
          onTap: () => coordinator.push(FeedDetail(id: 'profile')),
        ),
      ],
    );
  }
}

class ProfileTab extends AppRoute {
  @override
  Type get layout => TabBarLayout;

  @override
  Uri toUri() => Uri.parse('/home/tabs/profile');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Profile',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        ElevatedButton(
          onPressed: () => coordinator.push(ProfileDetail()),
          child: const Text('View Profile Details'),
        ),
      ],
    );
  }
}

class SettingsTab extends AppRoute {
  @override
  Type get layout => TabBarLayout;

  @override
  Uri toUri() => Uri.parse('/home/tabs/settings');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Quick Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        ElevatedButton(
          onPressed: () => coordinator.push(GeneralSettings()),
          child: const Text('Go to Full Settings'),
        ),
        const SizedBox(height: 8),
        ElevatedButton(
          onPressed: () => coordinator.push(Login()),
          child: const Text('Go to Login'),
        ),
        const SizedBox(height: 8),
        ElevatedButton(
          onPressed: () {
            coordinator.recoverRouteFromUri(Uri.parse('/home/feed/3221'));
          },
          child: const Text('Recover Route'),
        ),
      ],
    );
  }
}

// ============================================================================
// Detail Routes (belong to HomeLayout - navigatorStack layout)
// ============================================================================

class FeedDetail extends AppRoute
    with RouteGuard, RouteRedirect, RouteDeepLink {
  FeedDetail({required this.id});

  final String id;

  @override
  Type get layout => FeedTabLayout;

  @override
  Uri toUri() => Uri.parse('/home/feed/$id');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Feed Detail $id')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              'Feed Detail for Post $id',
              style: const TextStyle(fontSize: 20),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.pop(),
              child: const Text('Go Back'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  List<Object?> get props => [id];

  /// Showing confirm pop dialog
  @override
  FutureOr<bool> popGuardWith(AppCoordinator coordinator) async {
    final confirm = await showDialog<bool>(
      context: coordinator.navigator.context,
      builder: (context) => AlertDialog(
        title: const Text('Confirm'),
        content: const Text('Are you sure you want to leave this page?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('No'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Yes'),
          ),
        ],
      ),
    );

    return confirm ?? false;
  }

  @override
  AppRoute redirect() {
    /// Redirect to other stack demonstration
    /// The redirect path resolver by the Coordinator
    if (id == 'profile') return ProfileDetail();
    return this;
  }

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  FutureOr<void> deeplinkHandler(AppCoordinator coordinator, Uri uri) {
    coordinator.replace(FeedTab());
    coordinator.push(this);
  }
}

class ProfileDetail extends AppRoute {
  @override
  Type get layout => HomeLayout;

  @override
  Uri toUri() => Uri.parse('/home/profile/detail');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile Detail')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('Profile Detail Page', style: TextStyle(fontSize: 20)),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.pop(),
              child: const Text('Go Back'),
            ),
          ],
        ),
      ),
    );
  }
}

// ============================================================================
// Settings Routes (belong to SettingsLayout - navigatorStack layout)
// ============================================================================

class GeneralSettings extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/general');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'General Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        ListTile(
          title: Text('Account Settings'),
          onTap: () => coordinator.push(AccountSettings()),
        ),
        ListTile(
          title: Text('Privacy Settings'),
          onTap: () => coordinator.push(PrivacySettings()),
        ),
      ],
    );
  }
}

class AccountSettings extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/account');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Account Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const ListTile(title: Text('Email')),
        const ListTile(title: Text('Password')),
        const ListTile(title: Text('Delete Account')),
      ],
    );
  }
}

class PrivacySettings extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/privacy');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Privacy Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const ListTile(title: Text('Data Privacy')),
        const ListTile(title: Text('Location Services')),
        const ListTile(title: Text('Analytics')),
      ],
    );
  }
}

// ============================================================================
// Not Found Route
// ============================================================================

class NotFound extends AppRoute {
  NotFound({required this.uri});

  final Uri uri;

  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Not Found')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Route not found: ${uri.path}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.replace(HomeLayout()),
              child: const Text('Go Home'),
            ),
          ],
        ),
      ),
    );
  }
}

// ============================================================================
// Coordinator
// ============================================================================

class AppCoordinator extends Coordinator<AppRoute> with CoordinatorDebug {
  // Navigation paths for different shells
  late final NavigationPath<AppRoute> homeStack = NavigationPath.createWith(
    label: 'home',
    coordinator: this,
  );
  late final NavigationPath<AppRoute> settingsStack = NavigationPath.createWith(
    label: 'settings',
    coordinator: this,
  );
  late final IndexedStackPath<AppRoute> tabIndexed =
      IndexedStackPath.createWith(coordinator: this, label: 'home-tabs', [
        FeedTabLayout(),
        ProfileTab(),
        SettingsTab(),
      ]);

  late final NavigationPath<AppRoute> feedTabStack = NavigationPath.createWith(
    label: 'feed-nested',
    coordinator: this,
  );

  @override
  void defineLayout() {
    RouteLayout.defineLayout(HomeLayout, HomeLayout.new);
    RouteLayout.defineLayout(SettingsLayout, SettingsLayout.new);
    RouteLayout.defineLayout(TabBarLayout, TabBarLayout.new);
    RouteLayout.defineLayout(FeedTabLayout, FeedTabLayout.new);
  }

  @override
  List<StackPath> get paths => [
    ...super.paths,
    homeStack,
    settingsStack,
    tabIndexed,
    feedTabStack,
  ];

  @override
  List<AppRoute> get debugRoutes => [
    Login(),
    FeedTabLayout(),
    ProfileTab(),
    SettingsTab(),
    FeedDetail(id: '1'),
    ProfileDetail(),
    GeneralSettings(),
    AccountSettings(),
    PrivacySettings(),
    NotFound(uri: Uri.parse('/not-found')),
  ];

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      // Root - default to feed tab (layouts will be set up automatically)
      [] => Login(),
      // Home routes - default to feed tab
      ['home'] => FeedTab(),
      ['home', 'tabs'] => FeedTab(), // Default to feed tab
      ['home', 'tabs', 'feed'] => FeedTab(),
      ['home', 'tabs', 'profile'] => ProfileTab(),
      ['home', 'tabs', 'settings'] => SettingsTab(),
      ['home', 'feed', final id] => FeedDetail(id: id),
      ['home', 'profile', 'detail'] => ProfileDetail(),
      // Settings routes - default to general settings
      ['settings'] => GeneralSettings(),
      ['settings', 'general'] => GeneralSettings(),
      ['settings', 'account'] => AccountSettings(),
      ['settings', 'privacy'] => PrivacySettings(),
      ['login'] => Login(),
      // Not found
      _ => NotFound(uri: uri),
    };
  }
}

class Login extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/login');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      appBar: AppBar(
        leading: BackButton(onPressed: () => coordinator.tryPop()),
        title: const Text('Login'),
      ),
      body: Center(
        child: TextButton(
          onPressed: () => coordinator.replace(FeedTab()),
          child: Text('Go to Feed'),
        ),
      ),
    );
  }
}

// ============================================================================
// Helper Widgets
// ============================================================================

class _TabButton extends StatelessWidget {
  const _TabButton({
    required this.label,
    required this.isActive,
    required this.onTap,
  });

  final String label;
  final bool isActive;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 16),
          decoration: BoxDecoration(
            color: isActive ? Colors.blue : Colors.transparent,
            border: Border(
              bottom: BorderSide(
                color: isActive ? Colors.blue : Colors.transparent,
                width: 2,
              ),
            ),
          ),
          child: Text(
            label,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
              color: isActive ? Colors.white : Colors.black,
            ),
          ),
        ),
      ),
    );
  }
}

class _FeedItem extends StatelessWidget {
  const _FeedItem({required this.title, required this.onTap});

  final String title;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        title: Text(title),
        trailing: const Icon(Icons.arrow_forward),
        onTap: onTap,
      ),
    );
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_coordinator_module.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';

// ============================================================================
// Main App Entry Point
// ============================================================================
//
// This example demonstrates Coordinator-as-RouteModule with ROUTE VERSIONING
// and NESTED CoordinatorModular.
//
// Since Coordinator<T> implements RouteModule<T>, each version of a feature
// can live in its own Coordinator and be composed into the parent. This allows
// multiple route versions to coexist in a single application.
//
// A CoordinatorModular can itself be used as a RouteModule of another
// CoordinatorModular, enabling multi-level nesting. The BlogCoordinator
// below is an example: it's a CoordinatorModular with its own sub-modules
// (BlogPostsModule & BlogCommentsModule) registered as a child of
// MainCoordinator.
//
// Architecture:
//
//   MainCoordinator (CoordinatorModular)
//   ├── MainRouteModule          ← handles / (redirects to V2 shop)
//   ├── ShopCoordinatorV1        ← deprecated shop (/v1/shop/...)
//   │   └── ShopV1Layout (bottom nav + deprecation banner)
//   │       ├── /v1/shop          → ShopHomeV1
//   │       ├── /v1/shop/products → ProductListV1
//   │       └── /v1/shop/cart     → CartV1
//   ├── ShopCoordinatorV2        ← current shop (/v2/shop/...)
//   │   └── ShopV2Layout (NavigationRail, richer UI)
//   │       ├── /v2/shop              → ShopHomeV2
//   │       ├── /v2/shop/products     → ProductListV2
//   │       ├── /v2/shop/products/:id → ProductDetailV2
//   │       └── /v2/shop/cart         → CartV2
//   ├── BlogCoordinator          ← NESTED CoordinatorModular (/blog/...)
//   │   └── BlogLayout (NavigationRail)
//   │       ├── BlogPostsModule
//   │       │   ├── /blog               → BlogHomeRoute
//   │       │   └── /blog/posts/:slug   → BlogPostRoute
//   │       └── BlogCommentsModule
//   │           └── /blog/posts/:slug/comments → BlogCommentRoute
//   └── SettingsCoordinator      ← settings (/settings/...)
//       └── SettingsLayout (master-detail sidebar)
//           ├── /settings          → GeneralSettingsRoute
//           ├── /settings/account  → AccountSettingsRoute
//           └── /settings/privacy  → PrivacySettingsRoute
//
// Key patterns:
//   • Route versioning — V1 & V2 shop coexist with isolated paths/layouts
//   • Deprecation flow — V1 shows a banner linking to V2
//   • Cross-version navigation — routes navigate across coordinator versions
//   • Nested CoordinatorModular — BlogCoordinator delegates to sub-modules
//   • Each version/feature is a full Coordinator with its own state
// ============================================================================

void main() {
  runApp(const CoordinatorModuleApp());
}

class CoordinatorModuleApp extends StatelessWidget {
  const CoordinatorModuleApp({super.key});

  static final coordinator = MainCoordinator();

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter Route Versioning Example',
      theme: ThemeData(colorSchemeSeed: Colors.indigo, useMaterial3: true),
      restorationScopeId: 'coordinator_module',
      routerConfig: coordinator,
    );
  }
}

// ============================================================================
// Shared Route Base Class
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

// ============================================================================
// Shop Coordinator V1 — DEPRECATED version
// ============================================================================

class ShopCoordinatorV1Module extends ShopCoordinatorV1 {
  ShopCoordinatorV1Module(this.coordinator);

  @override
  final CoordinatorModular<AppRoute> coordinator;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['v1', ...final pathSegments] => super.parseRouteFromUri(
        uri.replace(pathSegments: pathSegments),
      ),
      _ => null,
    };
  }
}

class ShopCoordinatorV1 extends Coordinator<AppRoute> {
  late final NavigationPath<AppRoute> shopV1Stack = NavigationPath.createWith(
    label: 'shop-v1',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, shopV1Stack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopV1Layout, ShopV1Layout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeV1(),
      ['shop', 'products'] => ProductListV1(),
      ['shop', 'cart'] => CartV1(),
      _ => null,
    };
  }
}

// V1 Layout — bottom nav with a deprecation banner
class ShopV1Layout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(MainCoordinator coordinator) =>
      coordinator.getModule<ShopCoordinatorV1Module>().shopV1Stack;

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Shop (V1 — Deprecated)'),
        backgroundColor: Colors.grey[600],
        foregroundColor: Colors.white,
      ),
      body: Column(
        children: [
          // Deprecation banner
          MaterialBanner(
            padding: const EdgeInsets.all(12),
            backgroundColor: Colors.orange[100],
            leading: const Icon(Icons.warning_amber, color: Colors.orange),
            content: const Text(
              'This shop version is deprecated. Migrate to V2 for '
              'new features and improved experience.',
            ),
            actions: [
              TextButton(
                onPressed: () => coordinator.replace(ShopHomeV2()),
                child: const Text('Switch to V2'),
              ),
            ],
          ),
          Expanded(child: buildPath(coordinator)),
        ],
      ),
      bottomNavigationBar: ListenableBuilder(
        listenable: resolvePath(coordinator),
        builder: (context, _) {
          final active = coordinator.activePath.stack.lastOrNull;
          return BottomNavigationBar(
            currentIndex: active is ProductListV1
                ? 1
                : active is CartV1
                ? 2
                : 0,
            selectedItemColor: Colors.grey[700],
            onTap: (i) => switch (i) {
              0 => coordinator.navigate(ShopHomeV1()),
              1 => coordinator.navigate(ProductListV1()),
              2 => coordinator.navigate(CartV1()),
              _ => null,
            },
            items: const [
              BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
              BottomNavigationBarItem(
                icon: Icon(Icons.shopping_bag),
                label: 'Products',
              ),
              BottomNavigationBarItem(
                icon: Icon(Icons.shopping_cart),
                label: 'Cart',
              ),
            ],
          );
        },
      ),
    );
  }
}

// V1 Routes
class ShopHomeV1 extends AppRoute {
  @override
  Type get layout => ShopV1Layout;
  @override
  Uri toUri() => Uri.parse('/v1/shop');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Shop Home (V1)',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Text(
          'Managed by ShopCoordinatorV1. This is the legacy version.',
          style: TextStyle(color: Colors.grey[600]),
        ),
        const SizedBox(height: 16),
        Card(
          child: ListTile(
            leading: const Icon(Icons.shopping_bag),
            title: const Text('View Products'),
            trailing: const Icon(Icons.arrow_forward),
            onTap: () => coordinator.push(ProductListV1()),
          ),
        ),
        Card(
          child: ListTile(
            leading: const Icon(Icons.shopping_cart),
            title: const Text('View Cart'),
            trailing: const Icon(Icons.arrow_forward),
            onTap: () => coordinator.push(CartV1()),
          ),
        ),
      ],
    );
  }
}

class ProductListV1 extends AppRoute {
  @override
  Type get layout => ShopV1Layout;
  @override
  Uri toUri() => Uri.parse('/v1/shop/products');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Products (V1)',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        for (var i = 1; i <= 3; i++)
          Card(
            margin: const EdgeInsets.only(bottom: 8),
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: Colors.grey[300],
                child: Text('$i'),
              ),
              title: Text('Legacy Product $i'),
              subtitle: Text('\$${(i * 9.99).toStringAsFixed(2)}'),
            ),
          ),
      ],
    );
  }
}

class CartV1 extends AppRoute {
  @override
  Type get layout => ShopV1Layout;
  @override
  Uri toUri() => Uri.parse('/v1/shop/cart');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.shopping_cart, size: 48, color: Colors.grey),
          SizedBox(height: 16),
          Text('Cart (V1)', style: TextStyle(fontSize: 20)),
          SizedBox(height: 8),
          Text('Legacy cart — use V2 for a better experience'),
        ],
      ),
    );
  }
}

// ============================================================================
// Shop Coordinator V2 — CURRENT version
// ============================================================================

class ShopCoordinatorV2Module extends ShopCoordinatorV2 {
  ShopCoordinatorV2Module(this.coordinator);

  @override
  final CoordinatorModular<AppRoute> coordinator;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['v2', ...final pathSegments] => super.parseRouteFromUri(
        uri.replace(pathSegments: pathSegments),
      ),
      _ => null,
    };
  }
}

class ShopCoordinatorV2 extends Coordinator<AppRoute> {
  late final NavigationPath<AppRoute> shopV2Stack = NavigationPath.createWith(
    label: 'shop-v2',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, shopV2Stack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopV2Layout, ShopV2Layout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeV2(),
      ['shop', 'products'] => ProductListV2(),
      ['shop', 'products', final id] => ProductDetailV2(id: id),
      ['shop', 'cart'] => CartV2(),
      _ => null,
    };
  }
}

// V2 Layout — NavigationRail (modern sidebar)
class ShopV2Layout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(MainCoordinator coordinator) =>
      coordinator.getModule<ShopCoordinatorV2Module>().shopV2Stack;

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Shop (V2)'),
        backgroundColor: Colors.green[700],
        foregroundColor: Colors.white,
        actions: [
          // Cross-coordinator navigation: go to Settings
          IconButton(
            icon: const Icon(Icons.settings),
            tooltip: 'Settings',
            onPressed: () => coordinator.push(GeneralSettingsRoute()),
          ),
          // Cross-version navigation: go back to V1
          TextButton.icon(
            icon: const Icon(Icons.history, color: Colors.white70),
            label: const Text('V1', style: TextStyle(color: Colors.white70)),
            onPressed: () => coordinator.replace(ShopHomeV1()),
          ),
        ],
      ),
      body: ListenableBuilder(
        listenable: resolvePath(coordinator),
        builder: (context, _) {
          final active = coordinator.activePath.stack.lastOrNull;
          final selectedIndex =
              active is ProductListV2 || active is ProductDetailV2
              ? 1
              : active is CartV2
              ? 2
              : 0;
          return Row(
            children: [
              NavigationRail(
                selectedIndex: selectedIndex,
                labelType: NavigationRailLabelType.all,
                onDestinationSelected: (i) => switch (i) {
                  0 => coordinator.push(ShopHomeV2()),
                  1 => coordinator.push(ProductListV2()),
                  2 => coordinator.push(CartV2()),
                  _ => null,
                },
                destinations: const [
                  NavigationRailDestination(
                    icon: Icon(Icons.home_outlined),
                    selectedIcon: Icon(Icons.home),
                    label: Text('Home'),
                  ),
                  NavigationRailDestination(
                    icon: Icon(Icons.shopping_bag_outlined),
                    selectedIcon: Icon(Icons.shopping_bag),
                    label: Text('Products'),
                  ),
                  NavigationRailDestination(
                    icon: Icon(Icons.shopping_cart_outlined),
                    selectedIcon: Icon(Icons.shopping_cart),
                    label: Text('Cart'),
                  ),
                ],
              ),
              const VerticalDivider(width: 1),
              Expanded(child: buildPath(coordinator)),
            ],
          );
        },
      ),
    );
  }
}

// V2 Routes
class ShopHomeV2 extends AppRoute {
  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(24),
        children: [
          const Text(
            'Shop Home (V2)',
            style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          Text(
            'Managed by ShopCoordinatorV2 — the current version with '
            'NavigationRail, product details, and richer UI.',
            style: TextStyle(color: Colors.grey[600], fontSize: 14),
          ),
          const SizedBox(height: 24),
          Card(
            child: ListTile(
              leading: const Icon(Icons.shopping_bag, color: Colors.green),
              title: const Text('Browse Products'),
              subtitle: const Text('V2 adds product detail with :id params'),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.push(ProductListV2()),
            ),
          ),
          Card(
            child: ListTile(
              leading: const Icon(Icons.shopping_cart, color: Colors.green),
              title: const Text('View Cart'),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.push(CartV2()),
            ),
          ),
          const Divider(height: 32),
          const Text(
            'Cross-coordinator Navigation',
            style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
          ),
          const SizedBox(height: 8),
          Card(
            child: ListTile(
              leading: Icon(Icons.article, color: Colors.teal[700]),
              title: const Text('Go to Blog'),
              subtitle: const Text(
                'BlogCoordinator — nested CoordinatorModular',
              ),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.push(BlogHomeRoute()),
            ),
          ),
          Card(
            child: ListTile(
              leading: const Icon(Icons.settings, color: Colors.purple),
              title: const Text('Go to Settings'),
              subtitle: const Text('SettingsCoordinator module'),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.push(GeneralSettingsRoute()),
            ),
          ),
          Card(
            color: Colors.orange[50],
            child: ListTile(
              leading: const Icon(Icons.history, color: Colors.orange),
              title: const Text('Open Legacy Shop (V1)'),
              subtitle: const Text('ShopCoordinatorV1 — deprecated'),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.replace(ShopHomeV1()),
            ),
          ),
        ],
      ),
    );
  }
}

class ProductListV2 extends AppRoute {
  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop/products');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(24),
        children: [
          const Text(
            'Products (V2)',
            style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          for (var i = 1; i <= 5; i++)
            Card(
              margin: const EdgeInsets.only(bottom: 8),
              child: ListTile(
                leading: CircleAvatar(
                  backgroundColor: Colors.green[100],
                  foregroundColor: Colors.green[800],
                  child: Text('$i'),
                ),
                title: Text('Product $i'),
                subtitle: Text('\$${(i * 12.49).toStringAsFixed(2)}'),
                trailing: const Icon(Icons.arrow_forward),
                onTap: () => coordinator.push(ProductDetailV2(id: '$i')),
              ),
            ),
        ],
      ),
    );
  }
}

class ProductDetailV2 extends AppRoute {
  ProductDetailV2({required this.id});
  final String id;

  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop/products/$id');
  @override
  List<Object?> get props => [id];

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              CircleAvatar(
                radius: 48,
                backgroundColor: Colors.green[100],
                child: Text(
                  id,
                  style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: Colors.green[800],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              Text(
                'Product $id',
                style: const TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'V2 exclusive — product detail with :id parameter',
                style: TextStyle(color: Colors.grey[600]),
              ),
              const SizedBox(height: 24),
              FilledButton.icon(
                onPressed: () => coordinator.pop(),
                icon: const Icon(Icons.arrow_back),
                label: const Text('Back to Products'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class CartV2 extends AppRoute {
  @override
  Type get layout => ShopV2Layout;
  @override
  Uri toUri() => Uri.parse('/v2/shop/cart');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(24),
        children: [
          const Text(
            'Cart (V2)',
            style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          Card(
            child: ListTile(
              leading: Icon(Icons.shopping_cart, color: Colors.green[700]),
              title: const Text('Widget Kit Pro'),
              subtitle: const Text('\$24.99'),
              trailing: IconButton(
                icon: const Icon(Icons.delete_outline),
                onPressed: () {},
              ),
            ),
          ),
          Card(
            child: ListTile(
              leading: Icon(Icons.shopping_cart, color: Colors.green[700]),
              title: const Text('State Manager Ultra'),
              subtitle: const Text('\$39.99'),
              trailing: IconButton(
                icon: const Icon(Icons.delete_outline),
                onPressed: () {},
              ),
            ),
          ),
          const Divider(height: 32),
          Align(
            alignment: Alignment.centerRight,
            child: Text(
              'Total: \$64.98',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Colors.green[700],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ============================================================================
// Blog Coordinator — NESTED CoordinatorModular
// ============================================================================
//
// BlogCoordinator is a CoordinatorModular that is itself used as a RouteModule
// of MainCoordinator. It delegates route parsing to its own sub-modules:
// BlogPostsModule and BlogCommentsModule.
//
// This demonstrates multi-level nesting:
//   MainCoordinator → BlogCoordinator → BlogPostsModule / BlogCommentsModule

class BlogCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  BlogCoordinator(this.coordinator);

  @override
  final CoordinatorModular<AppRoute> coordinator;

  late final NavigationPath<AppRoute> blogStack = NavigationPath.createWith(
    label: 'blog',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, blogStack];

  @override
  void defineLayout() {
    super.defineLayout();
    RouteLayout.defineLayout(BlogLayout, BlogLayout.new);
  }

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    BlogPostsModule(this),
    BlogCommentsModule(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

// Blog sub-modules
class BlogPostsModule extends RouteModule<AppRoute> {
  BlogPostsModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['blog'] => BlogHomeRoute(),
      ['blog', 'posts', final slug] => BlogPostRoute(slug: slug),
      _ => null,
    };
  }
}

class BlogCommentsModule extends RouteModule<AppRoute> {
  BlogCommentsModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['blog', 'posts', final slug, 'comments'] => BlogCommentRoute(
        postSlug: slug,
      ),
      _ => null,
    };
  }
}

// Blog Layout — NavigationRail with posts sidebar
class BlogLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(MainCoordinator coordinator) =>
      coordinator.getModule<BlogCoordinator>().blogStack;

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Blog'),
        backgroundColor: Colors.teal[700],
        foregroundColor: Colors.white,
        actions: [
          IconButton(
            icon: const Icon(Icons.shopping_bag),
            tooltip: 'Shop V2',
            onPressed: () => coordinator.push(ShopHomeV2()),
          ),
          IconButton(
            icon: const Icon(Icons.settings),
            tooltip: 'Settings',
            onPressed: () => coordinator.push(GeneralSettingsRoute()),
          ),
        ],
      ),
      body: ListenableBuilder(
        listenable: resolvePath(coordinator),
        builder: (context, _) {
          final active = coordinator.activePath.stack.lastOrNull;
          final selectedIndex =
              active is BlogPostRoute || active is BlogCommentRoute ? 1 : 0;
          return Row(
            children: [
              NavigationRail(
                selectedIndex: selectedIndex,
                labelType: NavigationRailLabelType.all,
                onDestinationSelected: (i) => switch (i) {
                  0 => coordinator.push(BlogHomeRoute()),
                  1 => coordinator.push(BlogPostRoute(slug: 'latest')),
                  _ => null,
                },
                destinations: const [
                  NavigationRailDestination(
                    icon: Icon(Icons.home_outlined),
                    selectedIcon: Icon(Icons.home),
                    label: Text('Home'),
                  ),
                  NavigationRailDestination(
                    icon: Icon(Icons.article_outlined),
                    selectedIcon: Icon(Icons.article),
                    label: Text('Posts'),
                  ),
                ],
              ),
              const VerticalDivider(width: 1),
              Expanded(child: buildPath(coordinator)),
            ],
          );
        },
      ),
    );
  }
}

// Blog Routes
class BlogHomeRoute extends AppRoute {
  @override
  Type get layout => BlogLayout;
  @override
  Uri toUri() => Uri.parse('/blog');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(24),
      children: [
        const Text(
          'Blog Home',
          style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Text(
          'Managed by BlogCoordinator — a nested CoordinatorModular '
          'with its own sub-modules (BlogPostsModule & BlogCommentsModule).',
          style: TextStyle(color: Colors.grey[600], fontSize: 14),
        ),
        const SizedBox(height: 24),
        for (final slug in ['hello-world', 'getting-started', 'advanced-tips'])
          Card(
            margin: const EdgeInsets.only(bottom: 8),
            child: ListTile(
              leading: Icon(Icons.article, color: Colors.teal[700]),
              title: Text(slug.replaceAll('-', ' ').toUpperCase()),
              subtitle: Text('/blog/posts/$slug'),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.push(BlogPostRoute(slug: slug)),
            ),
          ),
        const Divider(height: 32),
        const Text(
          'Cross-coordinator Navigation',
          style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        Card(
          child: ListTile(
            leading: const Icon(Icons.shopping_bag, color: Colors.green),
            title: const Text('Go to Shop V2'),
            trailing: const Icon(Icons.arrow_forward),
            onTap: () => coordinator.push(ShopHomeV2()),
          ),
        ),
      ],
    );
  }
}

class BlogPostRoute extends AppRoute {
  BlogPostRoute({required this.slug});
  final String slug;

  @override
  Type get layout => BlogLayout;
  @override
  Uri toUri() => Uri.parse('/blog/posts/$slug');
  @override
  List<Object?> get props => [slug];

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(24),
      children: [
        Text(
          slug.replaceAll('-', ' ').toUpperCase(),
          style: const TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Text(
          'Parsed by BlogPostsModule (sub-module of BlogCoordinator)',
          style: TextStyle(color: Colors.grey[600]),
        ),
        const SizedBox(height: 24),
        Card(
          child: ListTile(
            leading: Icon(Icons.comment, color: Colors.teal[700]),
            title: const Text('View Comments'),
            subtitle: Text('/blog/posts/$slug/comments'),
            trailing: const Icon(Icons.arrow_forward),
            onTap: () => coordinator.push(BlogCommentRoute(postSlug: slug)),
          ),
        ),
        const SizedBox(height: 8),
        FilledButton.icon(
          onPressed: () => coordinator.pop(),
          icon: const Icon(Icons.arrow_back),
          label: const Text('Back'),
        ),
      ],
    );
  }
}

class BlogCommentRoute extends AppRoute {
  BlogCommentRoute({required this.postSlug});
  final String postSlug;

  @override
  Type get layout => BlogLayout;
  @override
  Uri toUri() => Uri.parse('/blog/posts/$postSlug/comments');
  @override
  List<Object?> get props => [postSlug];

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(24),
      children: [
        Text(
          'Comments for "$postSlug"',
          style: const TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 8),
        Text(
          'Parsed by BlogCommentsModule (sub-module of BlogCoordinator)',
          style: TextStyle(color: Colors.grey[600]),
        ),
        const SizedBox(height: 24),
        for (var i = 1; i <= 3; i++)
          Card(
            margin: const EdgeInsets.only(bottom: 8),
            child: ListTile(
              leading: CircleAvatar(
                backgroundColor: Colors.teal[100],
                foregroundColor: Colors.teal[800],
                child: Text('U$i'),
              ),
              title: Text('Comment by User $i'),
              subtitle: Text('Great post about $postSlug!'),
            ),
          ),
        const SizedBox(height: 16),
        FilledButton.icon(
          onPressed: () => coordinator.pop(),
          icon: const Icon(Icons.arrow_back),
          label: const Text('Back to Post'),
        ),
      ],
    );
  }
}

// ============================================================================
// Settings Coordinator
// ============================================================================

class SettingsCoordinator extends Coordinator<AppRoute> {
  SettingsCoordinator(this.coordinator);
  @override
  final CoordinatorModular<AppRoute> coordinator;

  late final NavigationPath<AppRoute> settingsStack = NavigationPath.createWith(
    label: 'settings',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, settingsStack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(SettingsLayout, SettingsLayout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['settings'] => GeneralSettingsRoute(),
      ['settings', 'account'] => AccountSettingsRoute(),
      ['settings', 'privacy'] => PrivacySettingsRoute(),
      _ => null,
    };
  }
}

// Settings Layout — master-detail sidebar
class SettingsLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(MainCoordinator coordinator) =>
      coordinator.getModule<SettingsCoordinator>().settingsStack;

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: BackButton(onPressed: () => coordinator.tryPop()),
        title: const Text('Settings'),
        backgroundColor: Colors.purple[700],
        foregroundColor: Colors.white,
      ),
      body: Row(
        children: [
          SizedBox(
            width: 220,
            child: ListenableBuilder(
              listenable: resolvePath(coordinator),
              builder: (context, _) {
                return ListView(
                  padding: const EdgeInsets.all(8),
                  children: [
                    _SettingsNavTile(
                      icon: Icons.tune,
                      label: 'General',
                      isActive:
                          coordinator.activePath.stack.last
                              is GeneralSettingsRoute,
                      onTap: () => coordinator.push(GeneralSettingsRoute()),
                    ),
                    _SettingsNavTile(
                      icon: Icons.person,
                      label: 'Account',
                      isActive:
                          coordinator.activePath.stack.last
                              is AccountSettingsRoute,
                      onTap: () => coordinator.push(AccountSettingsRoute()),
                    ),
                    _SettingsNavTile(
                      icon: Icons.lock,
                      label: 'Privacy',
                      isActive:
                          coordinator.activePath.stack.last
                              is PrivacySettingsRoute,
                      onTap: () => coordinator.push(PrivacySettingsRoute()),
                    ),
                  ],
                );
              },
            ),
          ),
          const VerticalDivider(width: 1),
          Expanded(child: buildPath(coordinator)),
        ],
      ),
    );
  }
}

// Settings Routes
class GeneralSettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          const Text(
            'General Settings',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          Text(
            'Managed by SettingsCoordinator — an independent '
            'Coordinator used as a RouteModule.',
            style: TextStyle(color: Colors.grey[600]),
          ),
          const SizedBox(height: 16),
          const ListTile(
            leading: Icon(Icons.language),
            title: Text('Language'),
            subtitle: Text('English'),
          ),
          const ListTile(
            leading: Icon(Icons.dark_mode),
            title: Text('Theme'),
            subtitle: Text('System'),
          ),
          const Divider(height: 32),
          Card(
            child: ListTile(
              leading: const Icon(Icons.shopping_bag, color: Colors.green),
              title: const Text('Go to Shop V2'),
              trailing: const Icon(Icons.arrow_forward),
              onTap: () => coordinator.push(ShopHomeV2()),
            ),
          ),
        ],
      ),
    );
  }
}

class AccountSettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;
  @override
  Uri toUri() => Uri.parse('/settings/account');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          const Text(
            'Account Settings',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          const ListTile(
            leading: Icon(Icons.email),
            title: Text('Email'),
            subtitle: Text('user@example.com'),
          ),
          const ListTile(
            leading: Icon(Icons.password),
            title: Text('Password'),
            subtitle: Text('••••••••'),
          ),
        ],
      ),
    );
  }
}

class PrivacySettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;
  @override
  Uri toUri() => Uri.parse('/settings/privacy');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          const Text(
            'Privacy Settings',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 16),
          const ListTile(
            leading: Icon(Icons.security),
            title: Text('Data Privacy'),
            subtitle: Text('Manage how your data is used'),
          ),
          const ListTile(
            leading: Icon(Icons.location_on),
            title: Text('Location Services'),
            subtitle: Text('Enabled'),
          ),
        ],
      ),
    );
  }
}

// ============================================================================
// Main Coordinator — composes versioned coordinators as modules
// ============================================================================

class MainCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute>, CoordinatorDebug {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    MainRouteModule(this),
    ShopCoordinatorV1Module(this),
    ShopCoordinatorV2Module(this),
    BlogCoordinator(this),
    SettingsCoordinator(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

// ============================================================================
// Root-level Routes
// ============================================================================

class MainRouteModule extends RouteModule<AppRoute> {
  MainRouteModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      _ => null,
    };
  }
}

class HomeRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/');
  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) => const SizedBox();

  /// Default redirect to V2 shop
  @override
  AppRoute redirect() => ShopHomeV2();
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});
  final Uri uri;

  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  Widget build(covariant MainCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Not Found')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Route not found: ${uri.path}'),
            const SizedBox(height: 16),
            FilledButton(
              onPressed: () => coordinator.replace(ShopHomeV2()),
              child: const Text('Go to Shop V2'),
            ),
          ],
        ),
      ),
    );
  }
}

// ============================================================================
// Helper Widgets
// ============================================================================

class _SettingsNavTile extends StatelessWidget {
  const _SettingsNavTile({
    required this.icon,
    required this.label,
    required this.isActive,
    required this.onTap,
  });

  final IconData icon;
  final String label;
  final bool isActive;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: Icon(icon, color: isActive ? Colors.purple : Colors.grey),
      title: Text(
        label,
        style: TextStyle(
          fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
          color: isActive ? Colors.purple : Colors.black87,
        ),
      ),
      selected: isActive,
      selectedTileColor: Colors.purple.withValues(alpha: 0.1),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      onTap: onTap,
    );
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_declrative.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

/// =============================================================================
/// SIMPLE DECLARATIVE NAVIGATION WITH MYERS DIFF DEMO
/// =============================================================================
/// This example demonstrates how Myers diff efficiently updates the navigation
/// stack. Add or remove chips to see the navigation stack update with minimal
/// operations - only changed routes are added/removed!
/// =============================================================================

void main() => runApp(const MyApp());

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      title: 'Declarative Navigation Demo',
      home: DemoScreen(),
    );
  }
}

// Simple route definition
class PageRoute extends RouteTarget {
  final int pageNumber;

  PageRoute(this.pageNumber);

  @override
  List<Object?> get props => [pageNumber];
}

class SpecialRoute extends RouteTarget {}

class DemoScreen extends StatefulWidget {
  const DemoScreen({super.key});

  @override
  State<DemoScreen> createState() => _DemoScreenState();
}

class _DemoScreenState extends State<DemoScreen> {
  // State: list of page numbers to show
  final List<int> _pageNumbers = [1];
  int _nextPageNumber = 2;
  bool showSpecial = false;

  void _addPage() {
    setState(() {
      _pageNumbers.add(_nextPageNumber);
      _nextPageNumber++;
    });
  }

  void _removePage(int pageNumber) {
    setState(() {
      _pageNumbers.remove(pageNumber);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Declarative navigation stack
          Expanded(
            child: NavigationStack.declarative(
              routes: <RouteTarget>[
                for (final pageNumber in _pageNumbers) PageRoute(pageNumber),
                if (showSpecial) SpecialRoute(),
              ],
              resolver: (route) => switch (route) {
                SpecialRoute() => StackTransition.sheet(_buildSpecial()),
                PageRoute(:final pageNumber) => StackTransition.material(
                  _buildPage(pageNumber),
                ),
                _ => throw UnimplementedError(),
              },
            ),
          ),
          // Chip controls at the top
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16),
            color: Colors.amber,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Checkbox(
                      value: showSpecial,
                      onChanged: (value) =>
                          setState(() => showSpecial = !showSpecial),
                    ),
                    Text('Show special page'),
                    const Spacer(),
                    ElevatedButton.icon(
                      onPressed: _addPage,
                      icon: const Icon(Icons.add),
                      label: const Text('Add Page'),
                    ),
                  ],
                ),
                const SizedBox(height: 12),
                if (_pageNumbers.isEmpty)
                  const Text(
                    'No pages - add one to get started!',
                    style: TextStyle(color: Colors.grey),
                  )
                else
                  Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    children: _pageNumbers.map((pageNum) {
                      return Chip(
                        key: ValueKey('Chip-$pageNum'),
                        label: Text('Page $pageNum'),
                        onDeleted: _pageNumbers.length > 1
                            ? () => _removePage(pageNum)
                            : null,
                        deleteIcon: const Icon(Icons.close, size: 16),
                      );
                    }).toList(),
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPage(int pageNumber) {
    return PageView(pageNumber: pageNumber);
  }

  Widget _buildSpecial() {
    return Scaffold(
      appBar: AppBar(title: Text('Super special route with sheet!')),
      body: Center(
        child: ElevatedButton(
          onPressed: () => setState(() => showSpecial = false),
          child: const Text('Pop sheet'),
        ),
      ),
    );
  }
}

// Stateful page widget to demonstrate state preservation
class PageView extends StatefulWidget {
  final int pageNumber;

  const PageView({super.key, required this.pageNumber});

  @override
  State<PageView> createState() => _PageViewState();
}

class _PageViewState extends State<PageView> {
  int _counter = 0;

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Page ${widget.pageNumber}'),
        backgroundColor: Colors.blue,
        automaticallyImplyLeading: false,
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const SizedBox(height: 16),
            Text(
              'This page is part of a declarative navigation stack',
              style: TextStyle(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            // Counter to demonstrate state preservation
            Container(
              padding: const EdgeInsets.all(24),
              margin: const EdgeInsets.symmetric(horizontal: 32),
              decoration: BoxDecoration(
                color: Colors.green[50],
                borderRadius: BorderRadius.circular(12),
                border: Border.all(color: Colors.green[200]!),
              ),
              child: Column(
                children: [
                  const Icon(Icons.timer, color: Colors.green, size: 40),
                  const SizedBox(height: 12),
                  const Text(
                    'State Preservation Demo',
                    style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Counter: $_counter',
                    style: const TextStyle(
                      fontSize: 36,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton.icon(
                    onPressed: _incrementCounter,
                    icon: const Icon(Icons.add),
                    label: const Text('Increment'),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.green,
                      foregroundColor: Colors.white,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 24,
                        vertical: 12,
                      ),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Try adding/removing other pages.\n'
                    'This counter stays preserved!',
                    style: TextStyle(fontSize: 12, color: Colors.grey[600]),
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_imperative.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

/// =============================================================================
/// IMPERATIVE MULTI-SCREEN FORM EXAMPLE (Proper State Management)
/// =============================================================================
/// This example demonstrates complex form handling with explicit state passing:
///
/// ✅ Routes carry their own state (no global variables)
/// ✅ State is passed through route constructors
/// ✅ Each route returns updated state via pop()
/// ✅ Testable, self-contained routes
/// ✅ Clear data flow
/// =============================================================================

void main() => runApp(const MainApp());

class MainApp extends StatelessWidget {
  const MainApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(home: HomeView());
  }
}

// =============================================================================
// FORM DATA MODEL - Immutable state
// =============================================================================

class OnboardingFormData {
  final String? fullName;
  final String? email;
  final DateTime? birthDate;
  final List<String> interests;
  final bool enableNotifications;
  final String? username;
  final String? password;

  const OnboardingFormData({
    this.fullName,
    this.email,
    this.birthDate,
    this.interests = const [],
    this.enableNotifications = true,
    this.username,
    this.password,
  });

  // Validation helpers
  bool get isPersonalInfoComplete =>
      fullName != null && email != null && birthDate != null;

  bool get isPreferencesComplete => interests.isNotEmpty;

  bool get isAccountSetupComplete =>
      username != null && password != null && password!.length >= 6;

  // Copy with method for immutable updates
  OnboardingFormData copyWith({
    String? fullName,
    String? email,
    DateTime? birthDate,
    List<String>? interests,
    bool? enableNotifications,
    String? username,
    String? password,
  }) {
    return OnboardingFormData(
      fullName: fullName ?? this.fullName,
      email: email ?? this.email,
      birthDate: birthDate ?? this.birthDate,
      interests: interests ?? this.interests,
      enableNotifications: enableNotifications ?? this.enableNotifications,
      username: username ?? this.username,
      password: password ?? this.password,
    );
  }
}

// =============================================================================
// ROUTE DEFINITIONS - Each route carries its state
// =============================================================================

sealed class OnboardingRoute extends RouteTarget {
  Widget build(BuildContext context);
}

// =============================================================================
// STEP 1: Personal Information
// =============================================================================

class PersonalInfoStep extends OnboardingRoute with RouteGuard {
  // Route state passed via constructor
  final OnboardingFormData formData;

  final _nameController = TextEditingController();
  final _emailController = TextEditingController();

  PersonalInfoStep({required this.formData}) {
    // Initialize from route state (not global)
    _nameController.text = formData.fullName ?? '';
    _emailController.text = formData.email ?? '';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Personal Information'),
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () async {
            final shouldExit = await _showExitConfirmation(context);
            if (shouldExit) {
              // Return to welcome instead of empty path
              onboardingPath.reset();
              onboardingPath.push(WelcomeStep());
            }
          },
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Step 1 of 3', style: TextStyle(color: Colors.grey)),
            const SizedBox(height: 8),
            const LinearProgressIndicator(value: 0.33),
            const SizedBox(height: 32),
            const Text(
              'Tell us about yourself',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 32),
            TextField(
              controller: _nameController,
              decoration: const InputDecoration(
                labelText: 'Full Name *',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.person),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: const InputDecoration(
                labelText: 'Email Address *',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.email),
              ),
            ),
            const SizedBox(height: 16),
            _DatePickerField(
              label: 'Date of Birth *',
              selectedDate: formData.birthDate,
              onDateSelected: (date) {
                // Update via copyWith
                final updated = formData.copyWith(birthDate: date);
                // Replace current route with updated state
                onboardingPath.stack.last = PersonalInfoStep(formData: updated);
              },
            ),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: () => _onNext(context),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
              child: const Text('Continue'),
            ),
            const SizedBox(height: 16),
            Center(
              child: TextButton(
                onPressed: () {
                  // Return to welcome instead of empty path
                  onboardingPath.reset();
                  onboardingPath.push(WelcomeStep());
                },
                child: const Text('Cancel'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _onNext(BuildContext context) {
    if (_nameController.text.isEmpty ||
        _emailController.text.isEmpty ||
        formData.birthDate == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please fill in all required fields')),
      );
      return;
    }

    // Create updated state
    final updatedData = formData.copyWith(
      fullName: _nameController.text,
      email: _emailController.text,
    );

    // Navigate with state
    onboardingPath.push(PreferencesStep(formData: updatedData));
  }

  @override
  Future<bool> popGuard() async => true;

  Future<bool> _showExitConfirmation(BuildContext context) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Exit Onboarding?'),
        content: const Text('Your progress will be lost.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Continue'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Exit'),
          ),
        ],
      ),
    );
    return result ?? false;
  }
}

// =============================================================================
// STEP 2: Preferences
// =============================================================================

class PreferencesStep extends OnboardingRoute {
  // Route state
  final OnboardingFormData formData;

  PreferencesStep({required this.formData});

  final List<String> availableInterests = [
    'Technology',
    'Sports',
    'Music',
    'Art',
    'Travel',
    'Food',
    'Reading',
    'Gaming',
  ];

  @override
  Widget build(BuildContext context) {
    return StatefulBuilder(
      builder: (context, setState) {
        return Scaffold(
          appBar: AppBar(
            title: const Text('Preferences'),
            leading: IconButton(
              icon: const Icon(Icons.arrow_back),
              onPressed: () => onboardingPath.pop(),
            ),
          ),
          body: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const Text('Step 2 of 3', style: TextStyle(color: Colors.grey)),
                const SizedBox(height: 8),
                const LinearProgressIndicator(value: 0.66),
                const SizedBox(height: 32),
                const Text(
                  'What interests you?',
                  style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                const Text(
                  'Select at least one interest',
                  style: TextStyle(color: Colors.grey),
                ),
                const SizedBox(height: 24),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: availableInterests.map((interest) {
                    final isSelected = formData.interests.contains(interest);
                    return FilterChip(
                      label: Text(interest),
                      selected: isSelected,
                      onSelected: (selected) {
                        setState(() {
                          final newInterests = List<String>.from(
                            formData.interests,
                          );
                          if (selected) {
                            newInterests.add(interest);
                          } else {
                            newInterests.remove(interest);
                          }
                          // Update route with new state
                          final updated = formData.copyWith(
                            interests: newInterests,
                          );
                          onboardingPath.stack.last = PreferencesStep(
                            formData: updated,
                          );
                        });
                      },
                    );
                  }).toList(),
                ),
                const SizedBox(height: 32),
                SwitchListTile(
                  title: const Text('Enable Notifications'),
                  subtitle: const Text(
                    'Get updates about topics you care about',
                  ),
                  value: formData.enableNotifications,
                  onChanged: (value) {
                    setState(() {
                      final updated = formData.copyWith(
                        enableNotifications: value,
                      );
                      onboardingPath.stack.last = PreferencesStep(
                        formData: updated,
                      );
                    });
                  },
                ),
                const SizedBox(height: 32),
                ElevatedButton(
                  onPressed: formData.isPreferencesComplete
                      ? () => onboardingPath.push(
                          AccountSetupStep(formData: formData),
                        )
                      : null,
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.all(16),
                  ),
                  child: const Text('Continue'),
                ),
                const SizedBox(height: 16),
                Center(
                  child: TextButton(
                    onPressed: () {
                      final updated = formData.copyWith(
                        interests: ['Technology'],
                      );
                      onboardingPath.push(AccountSetupStep(formData: updated));
                    },
                    child: const Text('Skip for now'),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

// =============================================================================
// STEP 3: Account Setup
// =============================================================================

class AccountSetupStep extends OnboardingRoute with RouteGuard {
  final OnboardingFormData formData;

  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  AccountSetupStep({required this.formData}) {
    _usernameController.text = formData.username ?? '';
    _passwordController.text = formData.password ?? '';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Account Setup'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => onboardingPath.pop(),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text('Step 3 of 3', style: TextStyle(color: Colors.grey)),
            const SizedBox(height: 8),
            const LinearProgressIndicator(value: 1.0),
            const SizedBox(height: 32),
            const Text(
              'Create your account',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 32),
            TextField(
              controller: _usernameController,
              decoration: const InputDecoration(
                labelText: 'Username *',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.person_outline),
                helperText: 'Choose a unique username',
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _passwordController,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'Password *',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.lock_outline),
                helperText: 'At least 6 characters',
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _confirmPasswordController,
              obscureText: true,
              decoration: const InputDecoration(
                labelText: 'Confirm Password *',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.lock_outline),
              ),
            ),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: () => _onNext(context),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
              ),
              child: const Text('Review & Submit'),
            ),
          ],
        ),
      ),
    );
  }

  void _onNext(BuildContext context) {
    if (_usernameController.text.isEmpty ||
        _passwordController.text.isEmpty ||
        _confirmPasswordController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please fill in all fields')),
      );
      return;
    }

    if (_passwordController.text.length < 6) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Password must be at least 6 characters')),
      );
      return;
    }

    if (_passwordController.text != _confirmPasswordController.text) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('Passwords do not match')));
      return;
    }

    final updatedData = formData.copyWith(
      username: _usernameController.text,
      password: _passwordController.text,
    );

    onboardingPath.push(ReviewStep(formData: updatedData));
  }

  @override
  Future<bool> popGuard() async => true;
}

// =============================================================================
// STEP 4: Review & Submit
// =============================================================================

class ReviewStep extends OnboardingRoute {
  final OnboardingFormData formData;

  ReviewStep({required this.formData});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Review'),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => onboardingPath.pop(),
        ),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Review Your Information',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              'Please review your details before submitting',
              style: TextStyle(color: Colors.grey),
            ),
            const SizedBox(height: 32),
            _ReviewSection(
              title: 'Personal Information',
              onEdit: () {
                // Pop back to personal info with current state
                onboardingPath.pop();
                onboardingPath.pop();
                onboardingPath.pop();
              },
              children: [
                _ReviewItem('Name', formData.fullName ?? ''),
                _ReviewItem('Email', formData.email ?? ''),
                _ReviewItem(
                  'Birth Date',
                  formData.birthDate?.toString().split(' ')[0] ?? '',
                ),
              ],
            ),
            const SizedBox(height: 24),
            _ReviewSection(
              title: 'Preferences',
              onEdit: () {
                onboardingPath.pop();
                onboardingPath.pop();
              },
              children: [
                _ReviewItem('Interests', formData.interests.join(', ')),
                _ReviewItem(
                  'Notifications',
                  formData.enableNotifications ? 'Enabled' : 'Disabled',
                ),
              ],
            ),
            const SizedBox(height: 24),
            _ReviewSection(
              title: 'Account',
              onEdit: () => onboardingPath.pop(),
              children: [
                _ReviewItem('Username', formData.username ?? ''),
                _ReviewItem('Password', '••••••••'),
              ],
            ),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: () => _onSubmit(context),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.all(16),
                backgroundColor: Colors.green,
              ),
              child: const Text('Complete Onboarding'),
            ),
          ],
        ),
      ),
    );
  }

  void _onSubmit(BuildContext context) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (dialogContext) =>
          const Center(child: CircularProgressIndicator()),
    );

    Future.delayed(const Duration(seconds: 2), () {
      if (context.mounted) {
        Navigator.pop(context);
        onboardingPath.push(SuccessStep(formData: formData));
      }
    });
  }
}

// =============================================================================
// SUCCESS SCREEN
// =============================================================================

class SuccessStep extends OnboardingRoute {
  final OnboardingFormData formData;

  SuccessStep({required this.formData});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.check_circle, color: Colors.green, size: 100),
              const SizedBox(height: 32),
              const Text(
                'Welcome aboard!',
                style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              Text(
                'Hi ${formData.fullName}! Your account has been created successfully.',
                textAlign: TextAlign.center,
                style: const TextStyle(fontSize: 16),
              ),
              const SizedBox(height: 48),
              ElevatedButton(
                onPressed: () {
                  // Return to welcome - path should never be empty
                  onboardingPath.reset();
                  onboardingPath.push(WelcomeStep());
                },
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 48,
                    vertical: 16,
                  ),
                ),
                child: const Text('Get Started'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// =============================================================================
// WELCOME SCREEN
// =============================================================================

class WelcomeStep extends OnboardingRoute {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const Icon(Icons.rocket_launch, size: 100, color: Colors.blue),
              const SizedBox(height: 32),
              const Text(
                'Multi-Screen Form Demo',
                textAlign: TextAlign.center,
                style: TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              const Text(
                'Proper state management - each route carries its own state!',
                textAlign: TextAlign.center,
                style: TextStyle(fontSize: 16, color: Colors.grey),
              ),
              const SizedBox(height: 48),
              ElevatedButton(
                onPressed: () {
                  // Start with empty state
                  onboardingPath.push(
                    PersonalInfoStep(formData: const OnboardingFormData()),
                  );
                },
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.all(16),
                ),
                child: const Text('Start Onboarding'),
              ),
              const SizedBox(height: 16),
              OutlinedButton(
                onPressed: () {
                  // Start with pre-filled state
                  final demoData = OnboardingFormData(
                    fullName: 'Demo User',
                    email: 'demo@example.com',
                    birthDate: DateTime(1990, 1, 1),
                  );
                  onboardingPath.push(PreferencesStep(formData: demoData));
                },
                style: OutlinedButton.styleFrom(
                  padding: const EdgeInsets.all(16),
                ),
                child: const Text('Skip to Step 2 (Demo)'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// =============================================================================
// HELPER WIDGETS
// =============================================================================

class _DatePickerField extends StatefulWidget {
  final String label;
  final DateTime? selectedDate;
  final ValueChanged<DateTime> onDateSelected;

  const _DatePickerField({
    required this.label,
    required this.selectedDate,
    required this.onDateSelected,
  });

  @override
  State<_DatePickerField> createState() => _DatePickerFieldState();
}

class _DatePickerFieldState extends State<_DatePickerField> {
  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () async {
        final date = await showDatePicker(
          context: context,
          initialDate: widget.selectedDate ?? DateTime(2000),
          firstDate: DateTime(1900),
          lastDate: DateTime.now(),
        );
        if (date != null) {
          widget.onDateSelected(date);
          setState(() {});
        }
      },
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: widget.label,
          border: const OutlineInputBorder(),
          prefixIcon: const Icon(Icons.calendar_today),
        ),
        child: Text(
          widget.selectedDate != null
              ? widget.selectedDate.toString().split(' ')[0]
              : 'Select date',
          style: TextStyle(
            color: widget.selectedDate != null ? Colors.black : Colors.grey,
          ),
        ),
      ),
    );
  }
}

class _ReviewSection extends StatelessWidget {
  final String title;
  final VoidCallback onEdit;
  final List<Widget> children;

  const _ReviewSection({
    required this.title,
    required this.onEdit,
    required this.children,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  title,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                TextButton(onPressed: onEdit, child: const Text('Edit')),
              ],
            ),
            const Divider(),
            ...children,
          ],
        ),
      ),
    );
  }
}

class _ReviewItem extends StatelessWidget {
  final String label;
  final String value;

  const _ReviewItem(this.label, this.value);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 120,
            child: Text(
              label,
              style: const TextStyle(
                color: Colors.grey,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: const TextStyle(fontWeight: FontWeight.w500),
            ),
          ),
        ],
      ),
    );
  }
}

// =============================================================================
// NAVIGATION PATH
// =============================================================================

final onboardingPath = NavigationPath<OnboardingRoute>.create()
  ..push(WelcomeStep());

class HomeView extends StatelessWidget {
  const HomeView({super.key});

  @override
  Widget build(BuildContext context) {
    return NavigationStack<OnboardingRoute>(
      path: onboardingPath,
      resolver: (route) => switch (route) {
        WelcomeStep() => StackTransition.material(route.build(context)),
        PersonalInfoStep() => StackTransition.material(
          route.build(context),
          guard: route,
        ),
        PreferencesStep() => StackTransition.material(route.build(context)),
        AccountSetupStep() => StackTransition.material(
          route.build(context),
          guard: route,
        ),
        ReviewStep() => StackTransition.material(route.build(context)),
        SuccessStep() => StackTransition.material(route.build(context)),
      },
    );
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_modular.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';

// ============================================================================
// Main App Entry Point
// ============================================================================

void main() {
  runApp(const ModularApp());
}

class ModularApp extends StatelessWidget {
  const ModularApp({super.key});

  static final coordinator = AppCoordinator();

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter Modular Coordinator Example',
      restorationScopeId: 'modular_coordinator',
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// ============================================================================
// Route Base Class
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

// ============================================================================
// Auth Module - Handles authentication routes
// ============================================================================

class AuthModule extends RouteModule<AppRoute> {
  AuthModule(super.coordinator);

  // Auth module doesn't define any paths (uses root path)
  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['login'] => LoginRoute(),
      ['register'] => RegisterRoute(),
      _ => null, // Not handled by this module
    };
  }

  @override
  void defineLayout() {
    // Auth module doesn't define layouts
  }
}

// Auth Routes
class LoginRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/login');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Login')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('Login Page', style: TextStyle(fontSize: 24)),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: () => coordinator.replace(ShopHomeRoute()),
              child: const Text('Login & Go to Shop'),
            ),
            const SizedBox(height: 16),
            TextButton(
              onPressed: () => coordinator.push(RegisterRoute()),
              child: const Text('Go to Register'),
            ),
          ],
        ),
      ),
    );
  }
}

class RegisterRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/register');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Register')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('Register Page', style: TextStyle(fontSize: 24)),
            const SizedBox(height: 32),
            ElevatedButton(
              onPressed: () => coordinator.pop(),
              child: const Text('Back to Login'),
            ),
          ],
        ),
      ),
    );
  }
}

// ============================================================================
// Shop Module - Handles shop/product routes with nested navigation
// ============================================================================

class ShopModule extends RouteModule<AppRoute> {
  ShopModule(super.coordinator);

  // Shop module defines its own navigation path
  late final NavigationPath<AppRoute> shopStack = NavigationPath.createWith(
    label: 'shop',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [shopStack];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeRoute(),
      ['shop', 'products'] => ProductListRoute(),
      ['shop', 'products', final id] => ProductDetailRoute(id: id),
      ['shop', 'cart'] => CartRoute(),
      _ => null, // Not handled by this module
    };
  }

  @override
  void defineLayout() {
    // Register shop layout
    RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  }
}

// Shop Layout - Provides navigation shell for shop routes
class ShopLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) {
    final shopModule = coordinator.getModule<ShopModule>();
    return shopModule.shopStack;
  }

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Shop'), backgroundColor: Colors.green),
      body: buildPath(coordinator),
      bottomNavigationBar: ListenableBuilder(
        listenable: resolvePath(coordinator),
        builder: (context, _) {
          return Container(
            color: Colors.grey[200],
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: [
                _ShopNavButton(
                  icon: Icons.home,
                  label: 'Home',
                  isActive: coordinator.activePath.stack.last is ShopHomeRoute,
                  onTap: () => coordinator.push(ShopHomeRoute()),
                ),
                _ShopNavButton(
                  icon: Icons.shopping_bag,
                  label: 'Products',
                  isActive:
                      coordinator.activePath.stack.last is ProductListRoute,
                  onTap: () => coordinator.push(ProductListRoute()),
                ),
                _ShopNavButton(
                  icon: Icons.shopping_cart,
                  label: 'Cart',
                  isActive: coordinator.activePath.stack.last is CartRoute,
                  onTap: () => coordinator.push(CartRoute()),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}

// Shop Routes
class ShopHomeRoute extends AppRoute {
  @override
  Type get layout => ShopLayout;

  @override
  Uri toUri() => Uri.parse('/shop');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Shop Home',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        Card(
          child: ListTile(
            leading: const Icon(Icons.shopping_bag),
            title: const Text('View Products'),
            trailing: const Icon(Icons.arrow_forward),
            onTap: () => coordinator.push(ProductListRoute()),
          ),
        ),
        Card(
          child: ListTile(
            leading: const Icon(Icons.shopping_cart),
            title: const Text('View Cart'),
            trailing: const Icon(Icons.arrow_forward),
            onTap: () => coordinator.push(CartRoute()),
          ),
        ),
      ],
    );
  }
}

class ProductListRoute extends AppRoute {
  @override
  Type get layout => ShopLayout;

  @override
  Uri toUri() => Uri.parse('/shop/products');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Products',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        _ProductCard(
          title: 'Product 1',
          onTap: () => coordinator.push(ProductDetailRoute(id: '1')),
        ),
        _ProductCard(
          title: 'Product 2',
          onTap: () => coordinator.push(ProductDetailRoute(id: '2')),
        ),
        _ProductCard(
          title: 'Product 3',
          onTap: () => coordinator.push(ProductDetailRoute(id: '3')),
        ),
      ],
    );
  }
}

class ProductDetailRoute extends AppRoute {
  ProductDetailRoute({required this.id});

  final String id;

  @override
  Type get layout => ShopLayout;

  @override
  Uri toUri() => Uri.parse('/shop/products/$id');

  @override
  List<Object?> get props => [id];

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Product $id')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Product Detail $id', style: const TextStyle(fontSize: 20)),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.pop(),
              child: const Text('Back'),
            ),
          ],
        ),
      ),
    );
  }
}

class CartRoute extends AppRoute {
  @override
  Type get layout => ShopLayout;

  @override
  Uri toUri() => Uri.parse('/shop/cart');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Shopping Cart',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const Card(
          child: ListTile(
            leading: Icon(Icons.shopping_cart),
            title: Text('Item 1'),
            subtitle: Text('\$19.99'),
          ),
        ),
        const Card(
          child: ListTile(
            leading: Icon(Icons.shopping_cart),
            title: Text('Item 2'),
            subtitle: Text('\$29.99'),
          ),
        ),
      ],
    );
  }
}

// ============================================================================
// Settings Module - Handles settings routes with nested navigation
// ============================================================================

class SettingsModule extends RouteModule<AppRoute> {
  SettingsModule(super.coordinator);

  // Settings module defines its own navigation path
  late final NavigationPath<AppRoute> settingsStack = NavigationPath.createWith(
    label: 'settings',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [settingsStack];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['settings'] => GeneralSettingsRoute(),
      ['settings', 'account'] => AccountSettingsRoute(),
      ['settings', 'privacy'] => PrivacySettingsRoute(),
      ['settings', 'notifications'] => NotificationsSettingsRoute(),
      _ => null, // Not handled by this module
    };
  }

  @override
  void defineLayout() {
    // Register settings layout
    RouteLayout.defineLayout(SettingsLayout, SettingsLayout.new);
  }
}

// Settings Layout - Provides navigation shell for settings routes
class SettingsLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) {
    final settingsModule = coordinator.getModule<SettingsModule>();
    return settingsModule.settingsStack;
  }

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        leading: BackButton(onPressed: () => coordinator.tryPop()),
        title: const Text('Settings'),
        backgroundColor: Colors.purple,
      ),
      body: Row(
        children: [
          // Sidebar navigation
          Container(
            width: 200,
            color: Colors.grey[200],
            child: ListView(
              padding: const EdgeInsets.all(8),
              children: [
                _SettingsNavItem(
                  icon: Icons.settings,
                  label: 'General',
                  route: GeneralSettingsRoute(),
                  coordinator: coordinator,
                ),
                _SettingsNavItem(
                  icon: Icons.person,
                  label: 'Account',
                  route: AccountSettingsRoute(),
                  coordinator: coordinator,
                ),
                _SettingsNavItem(
                  icon: Icons.lock,
                  label: 'Privacy',
                  route: PrivacySettingsRoute(),
                  coordinator: coordinator,
                ),
                _SettingsNavItem(
                  icon: Icons.notifications,
                  label: 'Notifications',
                  route: NotificationsSettingsRoute(),
                  coordinator: coordinator,
                ),
              ],
            ),
          ),
          // Settings content
          Expanded(child: buildPath(coordinator)),
        ],
      ),
    );
  }
}

// Settings Routes
class GeneralSettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'General Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const ListTile(
          leading: Icon(Icons.language),
          title: Text('Language'),
          subtitle: Text('English'),
        ),
        const ListTile(
          leading: Icon(Icons.dark_mode),
          title: Text('Theme'),
          subtitle: Text('System'),
        ),
      ],
    );
  }
}

class AccountSettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/account');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Account Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const ListTile(
          leading: Icon(Icons.email),
          title: Text('Email'),
          subtitle: Text('user@example.com'),
        ),
        const ListTile(
          leading: Icon(Icons.password),
          title: Text('Password'),
          subtitle: Text('••••••••'),
        ),
      ],
    );
  }
}

class PrivacySettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/privacy');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Privacy Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const ListTile(
          leading: Icon(Icons.security),
          title: Text('Data Privacy'),
        ),
        const ListTile(
          leading: Icon(Icons.location_on),
          title: Text('Location Services'),
        ),
      ],
    );
  }
}

class NotificationsSettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/notifications');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        const Text(
          'Notification Settings',
          style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        const ListTile(
          leading: Icon(Icons.notifications_active),
          title: Text('Push Notifications'),
          trailing: Switch(value: true, onChanged: null),
        ),
        const ListTile(
          leading: Icon(Icons.email),
          title: Text('Email Notifications'),
          trailing: Switch(value: false, onChanged: null),
        ),
      ],
    );
  }
}

// ============================================================================
// Main Coordinator - Uses ModularCoordinator mixin
// ============================================================================

class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute>, CoordinatorDebug {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    AuthModule(this),
    ShopModule(this),
    SettingsModule(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);

  @override
  List<AppRoute> get debugRoutes => [
    LoginRoute(),
    RegisterRoute(),
    ShopHomeRoute(),
    ProductListRoute(),
    ProductDetailRoute(id: '1'),
    CartRoute(),
    GeneralSettingsRoute(),
    AccountSettingsRoute(),
    PrivacySettingsRoute(),
    NotificationsSettingsRoute(),
    NotFoundRoute(uri: Uri.parse('/not-found')),
  ];
}

// ============================================================================
// Not Found Route
// ============================================================================

class AppModule extends RouteModule<AppRoute> {
  AppModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['not-found'] => NotFoundRoute(uri: uri),
      [] => HomeRoute(),
      _ => null,
    };
  }
}

class HomeRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) => SizedBox();

  @override
  AppRoute redirect() => LoginRoute();
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});

  final Uri uri;

  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Not Found')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text('Route not found: ${uri.path}'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.replace(ShopHomeRoute()),
              child: const Text('Go to Shop'),
            ),
          ],
        ),
      ),
    );
  }
}

// ============================================================================
// Helper Widgets
// ============================================================================

class _ShopNavButton extends StatelessWidget {
  const _ShopNavButton({
    required this.icon,
    required this.label,
    required this.isActive,
    required this.onTap,
  });

  final IconData icon;
  final String label;
  final bool isActive;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: InkWell(
        onTap: onTap,
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 12),
          color: isActive ? Colors.green[100] : Colors.transparent,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, color: isActive ? Colors.green[700] : Colors.grey),
              const SizedBox(height: 4),
              Text(
                label,
                style: TextStyle(
                  fontSize: 12,
                  color: isActive ? Colors.green[700] : Colors.grey,
                  fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ProductCard extends StatelessWidget {
  const _ProductCard({required this.title, required this.onTap});

  final String title;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: ListTile(
        leading: const Icon(Icons.shopping_bag),
        title: Text(title),
        trailing: const Icon(Icons.arrow_forward),
        onTap: onTap,
      ),
    );
  }
}

class _SettingsNavItem extends StatelessWidget {
  const _SettingsNavItem({
    required this.icon,
    required this.label,
    required this.route,
    required this.coordinator,
  });

  final IconData icon;
  final String label;
  final AppRoute route;
  final AppCoordinator coordinator;

  @override
  Widget build(BuildContext context) {
    final isActive =
        coordinator.activePath.stack.last.runtimeType == route.runtimeType;
    return ListTile(
      leading: Icon(icon, color: isActive ? Colors.purple : Colors.grey),
      title: Text(
        label,
        style: TextStyle(
          fontWeight: isActive ? FontWeight.bold : FontWeight.normal,
          color: isActive ? Colors.purple : Colors.black,
        ),
      ),
      selected: isActive,
      onTap: () => coordinator.push(route),
    );
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_observer.dart
================================================
import 'dart:async';
import 'dart:developer' as developer;

import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Main App Entry Point
// ============================================================================

void main() {
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  late final AppCoordinator coordinator;

  @override
  void initState() {
    super.initState();
    // Pass the observer to the coordinator via a getter function
    coordinator = AppCoordinator(observers: () => [LoggingNavigatorObserver()]);
  }

  @override
  void dispose() {
    coordinator.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter Observer Example',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),
        useMaterial3: true,
      ),
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// ============================================================================
// Custom Navigator Observer
// ============================================================================

/// A custom NavigatorObserver that logs all navigation events.
/// This demonstrates how observers passed to the Coordinator receive
/// navigation callbacks.
class LoggingNavigatorObserver extends NavigatorObserver {
  final List<String> navigationLog = [];

  void _log(String message) {
    final timestamp = DateTime.now().toIso8601String();
    final logEntry = '[$timestamp] $message';
    navigationLog.add(logEntry);
    developer.log(logEntry, name: 'NavigatorObserver');
  }

  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    _log(
      'PUSH: ${route.settings.name ?? 'unnamed'} (from: ${previousRoute?.settings.name ?? 'none'})',
    );
  }

  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    _log(
      'POP: ${route.settings.name ?? 'unnamed'} (back to: ${previousRoute?.settings.name ?? 'none'})',
    );
  }

  @override
  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {
    _log('REMOVE: ${route.settings.name ?? 'unnamed'}');
  }

  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    _log(
      'REPLACE: ${oldRoute?.settings.name ?? 'unnamed'} -> ${newRoute?.settings.name ?? 'unnamed'}',
    );
  }
}

// ============================================================================
// Route Definitions
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) =>
      HomeView(coordinator: coordinator);

  @override
  Uri toUri() => Uri.parse('/home');
}

class DetailRoute extends AppRoute {
  DetailRoute({required this.id});

  final String id;

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) =>
      DetailView(coordinator: coordinator, id: id);

  @override
  Uri toUri() => Uri.parse('/detail/$id');

  @override
  List<Object?> get props => [id];
}

class SettingsRoute extends AppRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) =>
      SettingsView(coordinator: coordinator);

  @override
  Uri toUri() => Uri.parse('/settings');
}

// ============================================================================
// Views
// ============================================================================

class HomeView extends StatelessWidget {
  const HomeView({super.key, required this.coordinator});

  final AppCoordinator coordinator;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            tooltip: 'View Navigation Log',
            onPressed: () => _showNavigationLog(context),
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.home, size: 64, color: Colors.deepPurple),
            const SizedBox(height: 24),
            const Text(
              'Observer Example',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Padding(
              padding: EdgeInsets.symmetric(horizontal: 32),
              child: Text(
                'Navigation events are being logged by the observer.\n'
                'Check the app logs or tap the history icon.',
                textAlign: TextAlign.center,
                style: TextStyle(color: Colors.grey),
              ),
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              onPressed: () => coordinator.push(DetailRoute(id: '1')),
              icon: const Icon(Icons.arrow_forward),
              label: const Text('Go to Detail 1'),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              onPressed: () => coordinator.push(DetailRoute(id: '2')),
              icon: const Icon(Icons.arrow_forward),
              label: const Text('Go to Detail 2'),
            ),
            const SizedBox(height: 16),
            OutlinedButton.icon(
              onPressed: () => coordinator.push(SettingsRoute()),
              icon: const Icon(Icons.settings),
              label: const Text('Go to Settings'),
            ),
          ],
        ),
      ),
    );
  }

  void _showNavigationLog(BuildContext context) {
    final observer = coordinator.observers.first as LoggingNavigatorObserver;
    showModalBottomSheet(
      context: context,
      builder: (context) => NavigationLogSheet(log: observer.navigationLog),
    );
  }
}

class DetailView extends StatelessWidget {
  const DetailView({super.key, required this.coordinator, required this.id});

  final AppCoordinator coordinator;
  final String id;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Detail $id'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.article, size: 64, color: Colors.deepPurple.shade300),
            const SizedBox(height: 24),
            Text(
              'Detail Page $id',
              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              onPressed: () => coordinator.pop(),
              icon: const Icon(Icons.arrow_back),
              label: const Text('Go Back'),
            ),
            const SizedBox(height: 16),
            OutlinedButton.icon(
              onPressed: () {
                final nextId = int.tryParse(id) ?? 0;
                coordinator.push(DetailRoute(id: '${nextId + 1}'));
              },
              icon: const Icon(Icons.add),
              label: Text('Push Detail ${(int.tryParse(id) ?? 0) + 1}'),
            ),
          ],
        ),
      ),
    );
  }
}

class SettingsView extends StatelessWidget {
  const SettingsView({super.key, required this.coordinator});

  final AppCoordinator coordinator;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Settings'),
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            tooltip: 'View Navigation Log',
            onPressed: () => _showNavigationLog(context),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Card(
            child: ListTile(
              leading: const Icon(Icons.info_outline),
              title: const Text('About Observers'),
              subtitle: const Text(
                'NavigatorObservers can be passed to the Coordinator '
                'using the CoordinatorNavigatorObserver mixin.',
              ),
            ),
          ),
          const SizedBox(height: 16),
          Card(
            child: ListTile(
              leading: const Icon(Icons.code),
              title: const Text('Implementation'),
              subtitle: const Text(
                '1. Mix in CoordinatorNavigatorObserver\n'
                '2. Override the observers getter\n'
                '3. Pass observers via constructor',
              ),
            ),
          ),
          const SizedBox(height: 24),
          Center(
            child: ElevatedButton.icon(
              onPressed: () => coordinator.pop(),
              icon: const Icon(Icons.arrow_back),
              label: const Text('Go Back'),
            ),
          ),
        ],
      ),
    );
  }

  void _showNavigationLog(BuildContext context) {
    final observer = coordinator.observers.first as LoggingNavigatorObserver;
    showModalBottomSheet(
      context: context,
      builder: (context) => NavigationLogSheet(log: observer.navigationLog),
    );
  }
}

/// Bottom sheet that displays the navigation log
class NavigationLogSheet extends StatelessWidget {
  const NavigationLogSheet({super.key, required this.log});

  final List<String> log;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.history, color: Colors.deepPurple),
              const SizedBox(width: 8),
              const Text(
                'Navigation Log',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              const Spacer(),
              Text(
                '${log.length} events',
                style: const TextStyle(color: Colors.grey),
              ),
            ],
          ),
          const Divider(),
          Expanded(
            child: log.isEmpty
                ? const Center(
                    child: Text(
                      'No navigation events yet.\nNavigate around to see logs.',
                      textAlign: TextAlign.center,
                      style: TextStyle(color: Colors.grey),
                    ),
                  )
                : ListView.builder(
                    itemCount: log.length,
                    itemBuilder: (context, index) {
                      final entry =
                          log[log.length - 1 - index]; // Reverse order
                      final isRecent = index < 3;
                      return Container(
                        padding: const EdgeInsets.symmetric(vertical: 4),
                        child: Text(
                          entry,
                          style: TextStyle(
                            fontFamily: 'monospace',
                            fontSize: 12,
                            color: isRecent ? Colors.black : Colors.grey,
                            fontWeight: isRecent
                                ? FontWeight.bold
                                : FontWeight.normal,
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}

// ============================================================================
// Coordinator with Observer Support
// ============================================================================

class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  AppCoordinator({
    NavigatorObserverListGetter observers = kEmptyNavigatorObserverList,
  }) : _observersGetter = observers;

  final NavigatorObserverListGetter _observersGetter;

  /// The observers getter is called by the navigator to get the list
  /// of observers. Using a getter function allows for dynamic observer lists.
  ///
  /// CAUTION:
  /// Don't reuse the same observer inside the getter function unless you know
  /// what you are doing.
  ///
  /// Each time the getter is called, it's expected to return a fresh instance
  /// of the observer. And inner `Coordinator` will handle caching of the observers
  /// for you.
  @override
  List<NavigatorObserver> get observers => _observersGetter();

  @override
  FutureOr<AppRoute> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['home'] => HomeRoute(),
      ['detail', final id] => DetailRoute(id: id),
      ['settings'] => SettingsRoute(),
      _ => HomeRoute(),
    };
  }
}



================================================
FILE: packages/zenrouter/example/lib/main_restoration.dart
================================================
library;

/**
 * A complete example demonstrating state restoration in ZenRouter.
 *
 * ## What This Example Demonstrates
 *
 * This example shows how to implement full state restoration for a navigation hierarchy,
 * allowing the app to survive process death and return users to exactly where they left off.
 * It demonstrates both simple URI-based restoration (for [Home] and [Bookmark] routes) and
 * custom converter-based restoration (for [BookmarkDetail] with complex state).
 *
 * ## How to Test Restoration
 *
 * **On iOS Simulator:**
 * 1. Run the app and navigate through several screens
 * 2. Background the app (Cmd+Shift+H)
 * 3. In Xcode: Debug → Simulate Memory Warning
 * 4. Or use Device → Erase All Content and Settings, then restore
 * 5. Relaunch the app - it should return to the same screen
 *
 * **On Android Emulator:**
 * 1. Run the app and navigate through screens
 * 2. Background the app (Home button)
 * 3. Use `adb shell am kill <package>` to terminate
 * 4. Relaunch - restoration should occur
 *
 * ## How the Components Work Together
 *
 * **MaterialApp setup:**
 * The `restorationScopeId: 'main_restorable'` enables Flutter's restoration framework.
 * The [CoordinatorRouterDelegate] automatically wraps your app with [CoordinatorRestorable]
 * internally, so you don't need to do any manual wrapping. Without the restorationScopeId,
 * no restoration will occur regardless of other setup.
 *
 * **Simple routes (Home, Bookmark):**
 * These routes only implement [RouteUnique], so they're automatically saved and restored
 * using their URI. When restored, the coordinator's `parseRouteFromUri` method converts
 * the saved URI string back into route objects.
 *
 * **Complex route (BookmarkDetail):**
 * This route mixes in [RouteRestorable] with a custom [BookmarkDetailConverter] to preserve
 * the `name` parameter that wouldn't normally be in the URL. The converter serializes both
 * the id and name, allowing the route to be perfectly reconstructed with all its state.
 *
 * **Coordinator registration (AppCoordinator.defineConverter - line 75-79):**
 * The converter must be registered globally during coordinator initialization. This makes
 * it available to the restoration system when deserializing saved state.
 *
 * **Widget state (HomeView with RestorableInt):**
 * The counter in HomeView demonstrates that widget-level state (the count) is separate
 * from navigation state. Each screen needing to persist its own state must implement
 * [RestorationMixin] independently.
 *
 * ## What Gets Restored
 *
 * ✅ **Navigation stack:** All routes in the navigation history
 * ✅ **Active route:** Which screen was visible when the app was backgrounded
 * ✅ **Route parameters:** Both URL parameters and custom converter data
 * ✅ **Widget state:** Any widgets using [RestorationMixin] (like the counter)
 *
 * ❌ **Not restored automatically:**
 * - Network requests or API data (refetch on restore)
 * - Form inputs without [RestorationMixin]
 * - Scroll positions without restoration IDs
 * - In-memory caches or temporary data
 *
 * See the restoration documentation in [CoordinatorRestorable], [RouteRestorable],
 * and [RestorableConverter] for detailed implementation guidance.
 */
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

abstract class AppRoute extends RouteTarget with RouteUnique {}

class Home extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(Coordinator<AppRoute> coordinator, BuildContext context) =>
      HomeView();
}

class Bookmark extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/bookmark');

  @override
  Widget build(Coordinator<AppRoute> coordinator, BuildContext context) =>
      BookmarkView();
}

class BookmarkDetail extends AppRoute with RouteRestorable<BookmarkDetail> {
  BookmarkDetail({required this.id, this.name});

  final String id;
  final String? name;

  @override
  String get restorationId => 'bookmark_${id}_$name';

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.converter;

  @override
  RestorableConverter<BookmarkDetail> get converter =>
      const BookmarkDetailConverter();

  @override
  List<Object?> get props => [id];

  @override
  Uri toUri() => Uri.parse('/bookmark/$id');

  @override
  Widget build(Coordinator<AppRoute> coordinator, BuildContext context) =>
      BookmarkDetailView(id: id, name: name);
}

class BookmarkDetailConverter extends RestorableConverter<BookmarkDetail> {
  const BookmarkDetailConverter();

  static const staticKey = 'bookmark_detail';

  @override
  String get key => staticKey;

  @override
  Map<String, dynamic> serialize(BookmarkDetail route) {
    return {'id': route.id, 'name': route.name};
  }

  @override
  BookmarkDetail deserialize(Map<String, dynamic> data) {
    return BookmarkDetail(
      id: data['id'] as String,
      name: data['name'] as String?,
    );
  }
}

class AppCoordinator extends Coordinator<AppRoute> {
  @override
  void defineConverter() {
    RestorableConverter.defineConverter(
      BookmarkDetailConverter.staticKey,
      BookmarkDetailConverter.new,
    );
  }

  @override
  AppRoute parseRouteFromUri(Uri uri) => switch (uri.pathSegments) {
    [] => Home(),
    ['bookmark'] => Bookmark(),
    ['bookmark', final id] => BookmarkDetail(id: id),
    _ => throw UnimplementedError(),
  };
}

void main() {
  runApp(
    MaterialApp.router(
      // ADD THIS LINE FOR RESTORATION WORKING
      restorationScopeId: 'main_restorable',
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    ),
  );
}

class HomeView extends StatefulWidget {
  const HomeView({super.key});

  @override
  State<HomeView> createState() => _HomeViewState();
}

class _HomeViewState extends State<HomeView> with RestorationMixin {
  final RestorableInt _counter = RestorableInt(0);

  @override
  String? get restorationId => 'home';

  @override
  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {
    registerForRestoration(_counter, 'count');
  }

  void _incrementCounter() {
    setState(() {
      _counter.value++;
    });
  }

  @override
  void dispose() {
    _counter.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home Restorable')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Text('You have pushed the button this many times:'),
            Text(
              '${_counter.value}',
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            FilledButton(
              onPressed: () => coordinator.pushOrMoveToTop(Bookmark()),
              child: Text('Bookmark'),
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _incrementCounter,
        tooltip: 'Increment',
        child: const Icon(Icons.add),
      ),
    );
  }
}

class BookmarkView extends StatefulWidget {
  const BookmarkView({super.key});

  @override
  State<BookmarkView> createState() => _BookmarkViewState();
}

class _BookmarkViewState extends State<BookmarkView> {
  String _text = '';

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Bookmark')),
      body: Column(
        children: [
          TextField(onChanged: (value) => _text = value),
          Expanded(
            child: ListView.builder(
              restorationId: 'bookmark_list',
              itemCount: 100,
              itemBuilder: (context, index) => ListTile(
                title: Text('Bookmark $index'),
                onTap: () => coordinator.pushOrMoveToTop(
                  BookmarkDetail(id: index.toString(), name: _text),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class BookmarkDetailView extends StatelessWidget {
  const BookmarkDetailView({super.key, required this.id, this.name});

  final String id;
  final String? name;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Bookmark $id')),
      body: Center(child: Text(name ?? 'No name')),
    );
  }
}

final coordinator = AppCoordinator();



================================================
FILE: packages/zenrouter/example/lib/file_based_routing/README.md
================================================
<div align="center">

![Logo](https://github.com/definev/zenrouter/blob/main/assets/logo.png?raw=true)

## File-based routing example with `zenrouter_file_generator`

</div>

This example shows how to use **`zenrouter_file_generator`** to get Next.js / Nuxt.js–style **file-based routing** on top of `zenrouter`.

### What this example demonstrates

- **File = route**: each Dart file in `lib/routes/` becomes a route.
- **Dynamic segments**: files like `[id].dart` map to `/path/:id`.
- **Layouts**: `_layout.dart` wraps child routes with a shared layout.
- **Type-safe navigation**: generated methods like `coordinator.goToAbout()` or `coordinator.pushProfileId('123')`.

### How to run the example

From the repository root:

```bash
cd packages/zenrouter_file_generator/example
flutter pub get
dart run build_runner build
flutter run
```

This will:

1. Use `zenrouter_file_generator` to scan `lib/routes/`.
2. Generate route base classes (e.g. `about.g.dart`) and `routes.zen.dart`.
3. Start the Flutter app wired up to the generated `AppCoordinator`.

### How it’s wired together

- `lib/routes/` contains your route files (`index.dart`, `about.dart`, `profile/[id].dart`, `tabs/_layout.dart`, etc.).
- Each route class is annotated with `@ZenRoute()` (and layouts with `@ZenLayout()`).
- `dart run build_runner build` generates:
  - `*.g.dart` files with base route/layout classes.
  - `routes.zen.dart` with:
    - `AppRoute` / `AppCoordinator`
    - URL parsing (`parseRouteFromUri`)
    - type-safe navigation extensions.
- `main.dart` uses `MaterialApp.router` with the generated `AppCoordinator`.

### What to look at

When exploring the example, check:

- `lib/routes/` – how file names map to URLs.
- Generated `routes.zen.dart` – coordinator and navigation helpers.
- Any `@ZenRoute`, `@ZenLayout`, and optional `_coordinator.dart` configuration.

This small example is the best place to see how `zenrouter_file_generator` fits into a real app before you integrate it into your own project.





================================================
FILE: packages/zenrouter/example/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "dev.zennn.router.example.example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
FILE: packages/zenrouter/example/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
FILE: packages/zenrouter/example/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void fl_register_plugins(FlPluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter/example/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter/example/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter/example/linux/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")



================================================
FILE: packages/zenrouter/example/linux/runner/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
FILE: packages/zenrouter/example/linux/runner/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView* view) {
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "example");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "example");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(
      project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000
  // for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb),
                           self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application,
                                                  gchar*** arguments,
                                                  int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
    g_warning("Failed to register: %s", error->message);
    *exit_status = 1;
    return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line =
      my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID, "flags",
                                     G_APPLICATION_NON_UNIQUE, nullptr));
}



================================================
FILE: packages/zenrouter/example/linux/runner/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication,
                     my_application,
                     MY,
                     APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
FILE: packages/zenrouter/example/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter/example/macos/Flutter/Flutter-Release.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter/example/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation


func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
}



================================================
FILE: packages/zenrouter/example/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}



================================================
FILE: packages/zenrouter/example/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter/example/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter/example/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
FILE: packages/zenrouter/example/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter/example/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
FILE: packages/zenrouter/example/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = example

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = dev.zennn.router.example.example

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2025 dev.zennn.router.example. All rights reserved.



================================================
FILE: packages/zenrouter/example/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter/example/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter/example/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
FILE: packages/zenrouter/example/macos/RunnerTests/RunnerTests.swift
================================================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter/example/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>example</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <!--
    You can customize the "flutter_bootstrap.js" script.
    This is useful to provide a custom configuration to the Flutter loader
    or to give the user feedback during the initialization process.

    For more details:
    * https://docs.flutter.dev/platform-integration/web/initialization
  -->
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>



================================================
FILE: packages/zenrouter/example/web/manifest.json
================================================
{
    "name": "example",
    "short_name": "example",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}



================================================
FILE: packages/zenrouter/example/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
FILE: packages/zenrouter/example/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
FILE: packages/zenrouter/example/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void RegisterPlugins(flutter::PluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter/example/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter/example/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter/example/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
FILE: packages/zenrouter/example/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
FILE: packages/zenrouter/example/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
FILE: packages/zenrouter/example/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
FILE: packages/zenrouter/example/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
FILE: packages/zenrouter/example/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>



================================================
FILE: packages/zenrouter/example/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "dev.zennn.router.example" "\0"
            VALUE "FileDescription", "example" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "example" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 dev.zennn.router.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "example.exe" "\0"
            VALUE "ProductName", "example" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
FILE: packages/zenrouter/example/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
FILE: packages/zenrouter/example/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
FILE: packages/zenrouter/example/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
FILE: packages/zenrouter/example/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_



================================================
FILE: packages/zenrouter/lib/zenrouter.dart
================================================
library;

/// Coordinator
export 'src/coordinator/base.dart';
export 'src/coordinator/observer.dart';
export 'src/coordinator/router.dart';
export 'src/coordinator/modular.dart';

/// Path base
export 'src/path/base.dart';
export 'src/path/navigation.dart';
export 'src/path/restoration.dart';
export 'src/path/indexed.dart';
export 'src/path/stack.dart';
export 'src/path/transition.dart';
export 'src/path/navigatable.dart';

/// Route target capabilities
export 'src/mixin/target.dart';
export 'src/mixin/guard.dart';
export 'src/mixin/deeplink.dart';
export 'src/mixin/layout.dart';
export 'src/mixin/query_parameters.dart';
export 'src/mixin/redirect.dart';
export 'src/mixin/redirect_rule.dart';
export 'src/mixin/transition.dart';
export 'src/mixin/unique.dart';
export 'src/mixin/restoration.dart';

/// Internal types
export 'src/internal/type.dart';



================================================
FILE: packages/zenrouter/lib/src/coordinator/base.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/src/internal/equatable.dart';
import 'package:zenrouter/zenrouter.dart';

/// Strategy for resolving parent layouts during navigation.
enum _ResolveLayoutStrategy {
  /// Pushes the layout to the top of the stack.
  ///
  /// Used when pushing new routes (e.g., [Coordinator.push]) to ensure
  /// the new route's layout is added on top of the current stack.
  pushToTop,

  /// Directly activates the layout, potentially resetting the stack.
  ///
  /// This is the default strategy used for [Coordinator.replace] or
  /// when recovering deep links, where the goal is to set a specific state.
  override,
}

/// Strategy for controlling page transition animations in the navigator.
///
/// This enum defines how routes animate when pushed or popped from the
/// navigation stack. The strategy is used by [RouteLayout] when building
/// pages to determine the appropriate [PageTransitionsBuilder].
///
/// **Platform Recommendations:**
/// - **Android/Web/Desktop**: Use [material] for consistency with Material Design
/// - **iOS/macOS**: Use [cupertino] for native iOS-style transitions
/// - **Testing/Screenshots**: Use [none] to disable animations
///
/// Example:
/// ```dart
/// @override
/// DefaultTransitionStrategy get transitionStrategy {
///   // Use platform-appropriate transitions
///   if (Platform.isIOS || Platform.isMacOS) {
///     return DefaultTransitionStrategy.cupertino;
///   }
///   return DefaultTransitionStrategy.material;
/// }
/// ```
enum DefaultTransitionStrategy {
  /// Uses Material Design transitions.
  ///
  /// Provides slide-up, fade, and shared-axis transitions typical of
  /// Android applications. This is the default strategy.
  material,

  /// Uses Cupertino (iOS-style) transitions.
  ///
  /// Provides horizontal slide and parallax transitions typical of
  /// iOS applications, including the edge-swipe-to-go-back gesture.
  cupertino,

  /// Disables transition animations.
  ///
  /// Routes appear and disappear instantly without any animation.
  /// Useful for testing, taking screenshots, or when you want to
  /// implement fully custom transitions.
  none,
}

/// The core class that manages navigation state and logic.
///
/// ## Architecture Overview
///
/// ZenRouter uses a coordinator-based architecture where the [Coordinator]
/// is the central hub for all navigation operations.
///
/// ## Core Components
///
/// - **[Coordinator]**: Manages navigation state, handles deep links, and
///   coordinates between stack paths. Your app typically has one coordinator.
///
/// - **[StackPath]**: A container holding a stack of routes. Two variants:
///   - [NavigationPath]: Mutable stack (push/pop) for standard navigation
///   - [IndexedStackPath]: Fixed stack for indexed navigation (tabs)
///
/// - **[RouteTarget]**: Base class for all navigable destinations. Mix in:
///   - [RouteUnique]: Required for coordinator integration
///   - [RouteGuard]: Intercept and conditionally prevent pops
///   - [RouteRedirect]: Redirect to different routes
///   - [RouteLayout]: Define shell/wrapper with nested [StackPath]
///   - [RouteTransition]: Custom page transitions
///
/// ## Navigation Flow
///
/// When you call a navigation method:
///
/// 1. **Route Resolution**: [RouteRedirect.resolve] follows any redirects
/// 2. **Layout Resolution**: Find/create required [RouteLayout] hierarchy
/// 3. **Stack Update**: Push/pop/activate routes on appropriate [StackPath]
/// 4. **Widget Rebuild**: [NavigationStack] rebuilds with new pages
/// 5. **URL Update**: Browser URL synced via [CoordinatorRouterDelegate]
///
/// ## Navigation Methods
///
/// Choose the right navigation method for your use case:
///
/// | Method        | Use Case                                              |
/// |---------------|-------------------------------------------------------|
/// | [push]        | Standard forward navigation (adds to stack)           |
/// | [pop]         | Go back (removes from stack)                          |
/// | [replace]     | Reset navigation to a single route (clears stack)     |
/// | [navigate]    | Browser back/forward (smart stack manipulation)       |
/// | [recover]     | Deep link handling (respects [RouteDeepLink] strategy)|
///
/// See each method's documentation for detailed behavior and examples.
///
/// ## Quick Start
///
/// ```dart
/// // 1. Define your route type
/// abstract class AppRoute extends RouteTarget with RouteUnique {}
///
/// // 2. Create a coordinator
/// class AppCoordinator extends Coordinator<AppRoute> {
///   @override
///   FutureOr<AppRoute> parseRouteFromUri(Uri uri) {
///     return switch (uri.pathSegments) {
///       ['product', final id] => ProductRoute(id),
///       _ => HomeRoute(),
///     };
///   }
/// }
///
/// // 3. Use in MaterialApp.router
/// MaterialApp.router(
///   routerDelegate: coordinator.routerDelegate,
///   routeInformationParser: coordinator.routeInformationParser,
/// )
/// ```
abstract class Coordinator<T extends RouteUnique> extends Equatable
    with ChangeNotifier
    implements RouterConfig<Uri>, RouteModule<T> {
  Coordinator({this.initialRoutePath}) {
    for (final path in paths) {
      path.addListener(notifyListeners);
    }
    defineLayout();
    defineConverter();
  }

  /// {@macro zenrouter.coordinator.modular.coordinator}
  @override
  CoordinatorModular<T> get coordinator => throw UnimplementedError(
    'This coordinator is standalone and does not belong to any [CoordinatorModular] \n'
    'If you want to make it a part of a [CoordinatorModular] you should override `coordinator` getter or passing it through constructor',
  );

  /// The [rootCoordinator] coordinator return a top level coordinator which used as [routeConfig].
  ///
  /// If this coordinator is a part of another [CoordinatorModular], it will return the [coordinator].
  /// Otherwise, it will return itself.
  late final Coordinator<T> rootCoordinator = isRouteModule
      ? coordinator
      : this;

  @override
  void dispose() {
    routerDelegate.dispose();
    for (final path in paths) {
      path.removeListener(notifyListeners);
      path.dispose();
    }
    super.dispose();
  }

  /// Whether this coordinator is a part of a [CoordinatorModular].
  ///
  /// If it is a part of a [CoordinatorModular], it will not have a root path.
  /// And it will not be able to use [routerDelegate] and [routeInformationParser].
  late final bool isRouteModule = () {
    try {
      coordinator;
      return true;
    } on UnimplementedError {
      return false;
    }
  }();

  /// The root (primary) navigation path.
  ///
  /// All coordinators have at least this one path.
  ///
  /// If this coordinator is a part of a [CoordinatorModular], the root path will point to the root path of the [CoordinatorModular].
  late final NavigationPath<T> root = isRouteModule
      ? coordinator.root
      : NavigationPath.createWith(label: 'root', coordinator: this);

  /// All navigation paths managed by this coordinator.
  ///
  /// If you add custom paths, make sure to override [paths]
  @override
  @mustCallSuper
  List<StackPath> get paths => isRouteModule ? [] : [root];

  /// Defines the layout structure for this coordinator.
  ///
  /// This method is called during initialization. Override this to register
  /// custom layouts using [RouteLayout.defineLayout].
  @override
  void defineLayout() {}

  /// Defines the restorable converters for this coordinator.
  ///
  /// Override this method to register custom restorable converters using
  /// [RestorableConverter.defineConverter].
  @override
  void defineConverter() {}

  String resolveRouteId(covariant T route) {
    RouteLayout? layout = route.resolveLayout(this);
    List<RouteLayout> layouts = [];
    List<StackPath> layoutPaths = [];
    while (layout != null) {
      layouts.add(layout);
      layoutPaths.add(layout.resolvePath(this));
      layout = layout.resolveLayout(this);
    }

    String layoutRestorationId = layoutPaths
        .map((p) {
          final label = p.debugLabel;
          assert(
            label != null,
            '[StackPath] must have an unique label in order to use with Coordinator restorable',
          );
          return label!;
        })
        .join('_');
    layoutRestorationId = '${rootRestorationId}_$layoutRestorationId';
    final routeRestorationId = route is RouteRestorable
        ? (route as RouteRestorable).restorationId
        : route.toUri().toString();

    return '${layoutRestorationId}_$routeRestorationId';
  }

  /// The restoration ID for the root path.
  ///
  /// This ID is used to restore the root path when the app is re-launched.
  String get rootRestorationId => root.debugLabel ?? 'root';

  /// The initial route path for this coordinator.
  ///
  /// This path is used to set the initial route when the app is launched.
  final Uri? initialRoutePath;

  /// The transition strategy for this coordinator.
  ///
  /// Override this getter to customize how page transitions are animated
  /// throughout your navigation stack. The strategy applies to all routes
  /// managed by this coordinator.
  ///
  /// **Default Behavior:**
  /// Returns [DefaultTransitionStrategy.material], which provides Material
  /// Design transitions (slide-up, fade effects).
  ///
  /// **Common Overrides:**
  /// ```dart
  /// // Platform-adaptive transitions
  /// @override
  /// DefaultTransitionStrategy get transitionStrategy {
  ///   return Platform.isIOS
  ///       ? DefaultTransitionStrategy.cupertino
  ///       : DefaultTransitionStrategy.material;
  /// }
  ///
  /// // Disable all transitions
  /// @override
  /// DefaultTransitionStrategy get transitionStrategy =>
  ///     DefaultTransitionStrategy.none;
  /// ```
  ///
  /// **Note:** This strategy is used by [RouteLayout] when constructing
  /// [Page] objects. If you need per-route transition control, consider
  /// implementing custom [RouteTransition] logic on individual routes instead.
  DefaultTransitionStrategy get transitionStrategy =>
      DefaultTransitionStrategy.material;

  /// Returns the current URI based on the active route.
  Uri get currentUri => activePath.activeRoute?.toUri() ?? Uri.parse('/');

  /// Returns the deepest active [RouteLayout] in the navigation hierarchy.
  ///
  /// This traverses through nested layouts to find the most deeply nested
  /// layout that is currently active. Returns `null` if the root layout is active.
  RouteLayout? get activeLayout {
    T? current = root.activeRoute;
    if (current == null || current is! RouteLayout) return null;

    RouteLayout? deepestLayout = current;

    // Traverse through nested layouts to find the deepest one
    while (current is RouteLayout) {
      deepestLayout = current;
      final path = current.resolvePath(this);
      current = path.activeRoute as T?;

      // If the next route is not a layout, we've found the deepest layout
      if (current is! RouteLayout) break;
    }

    return deepestLayout;
  }

  /// Returns all active [RouteLayout] instances in the navigation hierarchy.
  ///
  /// This traverses through the active route to collect all layouts from root
  /// to the deepest layout. Returns an empty list if no layouts are active.
  List<RouteLayout> get activeLayouts {
    List<RouteLayout> layouts = [];
    T? current = root.activeRoute;

    // Traverse through the hierarchy and collect all RouteLayout instances
    while (current != null && current is RouteLayout) {
      layouts.add(current);
      final path = current.resolvePath(this);
      current = path.activeRoute as T?;
    }

    return layouts;
  }

  /// Returns the list of active layout paths in the navigation hierarchy.
  ///
  /// This starts from the [root] path and traverses down through active layouts,
  /// collecting the [StackPath] for each level.
  List<StackPath> get activeLayoutPaths {
    List<StackPath> pathSegment = [root];
    StackPath path = root;
    T? current = root.stack.lastOrNull;
    if (current == null) return pathSegment;

    while (current is RouteLayout) {
      final layout = current as RouteLayout;
      path = layout.resolvePath(this);
      pathSegment.add(path);
      current = path.activeRoute as T?;
    }

    return pathSegment;
  }

  /// Returns the currently active [StackPath].
  ///
  /// This is the path that contains the currently active route.
  StackPath<T> get activePath =>
      (activeLayoutPaths.lastOrNull ?? root) as StackPath<T>;

  /// Parses a [Uri] into a route object.
  ///
  /// **Required override.** This is how deep links and web URLs become routes.
  ///
  /// Example:
  /// ```dart
  /// @override
  /// AppRoute parseRouteFromUri(Uri uri) {
  ///   return switch (uri.pathSegments) {
  ///     ['product', final id] => ProductRoute(id),
  ///     _ => HomeRoute(),
  ///   };
  /// }
  /// ```
  @override
  FutureOr<T?> parseRouteFromUri(Uri uri);

  /// Parses a [Uri] into a route object synchronously.
  ///
  /// If you have an asynchronous [parseRouteFromUri] and still want [restoration] working,
  /// you have to provide a synchronous version of it.
  RouteUriParserSync<T> get parseRouteFromUriSync =>
      (uri) => parseRouteFromUri(uri) as T;

  /// Handles navigation from a deep link URI.
  ///
  /// If the route has [RouteDeepLink], its custom handler is called.
  /// Otherwise, [replace] is called.
  Future<void> recoverRouteFromUri(Uri uri) async {
    final route = await parseRouteFromUri(uri);
    if (route == null) {
      throw StateError(
        'If you want to use coordinator deeplink feature, you must return route from [parseRouteFromUri]',
      );
    }
    return recover(route);
  }

  /// Resolves and activates layouts for a given [layout].
  ///
  /// This ensures that all parent layouts in the hierarchy are properly
  /// activated or pushed onto their respective paths.
  ///
  /// [preferPush] determines whether to push the layout onto the stack
  /// or just activate it if it already exists.
  Future<void> _resolveLayouts(
    RouteLayout? layout, {
    _ResolveLayoutStrategy strategy = _ResolveLayoutStrategy.override,
  }) async {
    List<RouteLayout> layouts = [];
    List<StackPath> layoutPaths = [];
    while (layout != null) {
      layouts.add(layout);
      layoutPaths.add(layout.resolvePath(this));
      layout = layout.resolveLayout(this);
    }
    layoutPaths.add(root);

    for (var i = layoutPaths.length - 1; i >= 1; i--) {
      final layoutOfLayoutPath = layoutPaths[i];
      final layout = layouts[i - 1];
      switch (strategy) {
        case _ResolveLayoutStrategy.pushToTop
            when layoutOfLayoutPath is StackMutatable:
          layoutOfLayoutPath.pushOrMoveToTop(layout);
        default:
          layoutOfLayoutPath.activateRoute(layout);
      }
    }
  }

  /// Recovers navigation state from a route, respecting deep link strategies.
  ///
  /// **When to use:**
  /// Use this when handling deep links or restoring navigation state.
  /// Prefer [push] for regular navigation and [replace] for resetting state.
  ///
  /// **Behavior:**
  /// - If the route implements [RouteDeepLink], uses its [DeeplinkStrategy]:
  ///   - [DeeplinkStrategy.push]: Calls [push] to add route to stack
  ///   - [DeeplinkStrategy.replace]: Calls [replace] to reset stack
  ///   - [DeeplinkStrategy.custom]: Calls the route's [deeplinkHandler]
  /// - Otherwise, defaults to [replace]
  ///
  /// **Error Handling:**
  /// Exceptions from redirect resolution or deep link handlers propagate
  /// to the caller. Handle these in your app's error boundary.
  Future<void> recover(T route) async {
    T? target = await RouteRedirect.resolve(route, this);
    if (target == null) return;
    if (target is RouteDeepLink) {
      switch (target.deeplinkStrategy) {
        case DeeplinkStrategy.navigate:
          navigate(target);
        case DeeplinkStrategy.push:
          push(target);
        case DeeplinkStrategy.replace:
          replace(target);
        case DeeplinkStrategy.custom:
          await target.deeplinkHandler(this, target.toUri());
      }
    } else {
      replace(target);
    }
  }

  /// Navigates to a specific route, handling history restoration and stack management.
  ///
  /// **Why this exists:**
  /// Standard [push] always adds a new route to the stack, which can lead to
  /// duplicate entries and confusing browser history (e.g., A -> B -> A -> B).
  /// [navigate] is smarter: it checks if the target route already exists in the
  /// stack (e.g., in a browser "Back" scenario) and pops back to it instead of
  /// pushing a new instance. This ensures the navigation stack mirrors the
  /// user's expected history state.
  ///
  /// This method is primarily used by [CoordinatorRouterDelegate.setNewRoutePath]
  /// to handle browser back/forward navigation or direct URL updates.
  ///
  /// **Behavior:**
  /// 1. Resolves the layout and path for the target [route].
  /// 2. If the active path is a [NavigationPath]:
  ///    - **Existing Route:** If the route is already in the stack (back navigation),
  ///      it progressively pops the stack until the target route is reached.
  ///      - Respects [RouteGuard]s during popping.
  ///      - If a guard blocks popping, navigation is aborted and the URL is restored.
  ///    - **New Route:** If the route is not in the stack, it calls [push] to add it.
  /// 3. If the active path is an [IndexedStackPath]:
  ///    - Resolves parent layouts and activates the target route (switching tabs).
  ///
  /// **Failure Handling:**
  /// If layout resolution fails or a guard blocks the navigation, [notifyListeners]
  /// is called to sync the browser URL back to the current application state.
  Future<void> navigate(T route) async {
    final target = await RouteRedirect.resolve(route, this);
    if (target == null) return;

    final layout = target.resolveLayout(this);
    final routePath = layout?.resolvePath(this) ?? root;
    await _resolveLayouts(layout, strategy: _ResolveLayoutStrategy.pushToTop);

    assert(
      routePath is StackNavigatable,
      UnimplementedError(
        'ZenRouter: routePath (${routePath.runtimeType}) does not implement '
        'StackNavigatable. The navigate() call for route $route will have no '
        'effect on the navigation stack or browser history.',
      ),
    );

    if (routePath case StackNavigatable routePath) {
      await routePath.navigate(target);
    }
  }

  /// Clears all navigation stacks and navigates to a single route.
  ///
  /// **When to use:**
  /// - App startup/initialization
  /// - After logout (clear all navigation history)
  /// - Deep link recovery (default strategy)
  /// - Resetting to a known state
  ///
  /// **Avoid when:**
  /// - User is navigating forward (use [push] instead)
  /// - You want to preserve back navigation history
  ///
  /// **Behavior:**
  /// 1. Calls [reset] on ALL paths (clears entire navigation history)
  /// 2. Resolves any [RouteRedirect]s
  /// 3. Activates required layouts
  /// 4. Places the final route on its appropriate path
  ///
  /// **Error Handling:**
  /// Exceptions from redirect resolution propagate to the caller.
  /// Guards are NOT consulted since all routes are cleared.
  Future<void> replace(T route) async {
    T? target = await RouteRedirect.resolve(route, this);
    if (target == null) return;

    for (final path in paths) {
      path.reset();
    }

    final layout = target.resolveLayout(this);
    final path = layout?.resolvePath(this) ?? root;
    await _resolveLayouts(layout, strategy: _ResolveLayoutStrategy.override);

    await path.activateRoute(target);
  }

  /// Pushes a new route onto the navigation stack.
  ///
  /// **When to use:**
  /// - Standard forward navigation (user taps a button/link)
  /// - Opening details, forms, or modals
  /// - Any navigation where back should return to current screen
  ///
  /// **Avoid when:**
  /// - Handling deep links (use [recover] instead)
  /// - Resetting navigation state (use [replace] instead)
  /// - Browser back/forward navigation (use [navigate] instead)
  ///
  /// **Behavior:**
  /// 1. Resolves any [RouteRedirect]s (authentication, permissions, etc.)
  /// 2. Ensures required [RouteLayout] hierarchy is active
  /// 3. Adds the route to its [StackPath]
  ///
  /// **Result handling:**
  /// Returns a [Future] that completes when the route is popped:
  /// ```dart
  /// final result = await coordinator.push<String>(SelectColorRoute());
  /// if (result != null) {
  ///   print('User selected: $result');
  /// }
  /// ```
  ///
  /// **Error Handling:**
  /// Exceptions from redirect resolution propagate to the caller.
  Future<R?> push<R extends Object>(T route) async {
    T? target = await RouteRedirect.resolve(route, this);
    if (target == null) return null;

    final layout = target.resolveLayout(this);
    final path = layout?.resolvePath(this) ?? root;
    await _resolveLayouts(layout, strategy: _ResolveLayoutStrategy.pushToTop);

    switch (path) {
      case StackMutatable():
        return path.push(target);
      default:
        path.activateRoute(target);
        return null;
    }
  }

  /// Pushes a route or moves it to the top if already present.
  ///
  /// Useful for tab navigation where you don't want duplicates.
  void pushOrMoveToTop(T route) async {
    final target = await RouteRedirect.resolve(route, this);
    if (target == null) return;

    final layout = target.resolveLayout(this);
    final path = layout?.resolvePath(this) ?? root;
    await _resolveLayouts(layout, strategy: _ResolveLayoutStrategy.pushToTop);

    switch (path) {
      case StackMutatable():
        path.pushOrMoveToTop(target);
      default:
        path.activateRoute(target);
    }
  }

  /// Pops the current route and pushes a new route in its place.
  ///
  /// **When to use:**
  /// - Swap screens during a wizard/onboarding flow
  /// - Replace a loading/splash screen with actual content
  /// - Login → Home transition where back should not return to login
  ///
  /// **Avoid when:**
  /// - You need to clear all navigation history (use [replace] instead)
  ///
  /// **Behavior:**
  /// 1. Resolves any [RouteRedirect]s
  /// 2. Ensures required [RouteLayout] hierarchy is active
  /// 3. Delegates to [StackMutatable.pushReplacement] which:
  ///    - On single-element stack: completes the route and pushes new one
  ///    - On multi-element stack: pops (respecting guards), then pushes
  ///
  /// **Result handling:**
  /// Pass [result] to complete the popped route's push future:
  /// ```dart
  /// // In screen A:
  /// final result = await coordinator.push<String>(ScreenB());
  /// print('Got: $result'); // Prints: Got: from_c
  ///
  /// // In screen B, replacing with C:
  /// coordinator.pushReplacement<void, String>(ScreenC(), result: 'from_c');
  /// ```
  ///
  /// **Error Handling:**
  /// - Returns `null` if redirect resolution returns null
  /// - Returns `null` if a [RouteGuard] blocks the pop operation
  /// - Exceptions from redirect resolution propagate to the caller
  Future<R?> pushReplacement<R extends Object, RO extends Object>(
    T route, {
    RO? result,
  }) async {
    final target = await RouteRedirect.resolve(route, this);
    if (target == null) return null;

    final layout = target.resolveLayout(this);
    final path = layout?.resolvePath(this) ?? root;
    await _resolveLayouts(layout, strategy: _ResolveLayoutStrategy.pushToTop);

    if (path case StackMutatable()) {
      return path.pushReplacement(target, result: result);
    }

    return null;
  }

  /// Pops the last route from the nearest dynamic path.  /// Pops the last route from all eligible dynamic paths.
  ///
  /// This method looks up all active [StackMutatable] paths and attempts
  /// to pop from those whose stack contains at least two elements.
  ///
  /// The returned [Future] completes when all eligible pops have finished.
  /// If no dynamic paths can be popped, this method completes without
  /// performing any action.
  Future<void> pop([Object? result]) async {
    // Get all dynamic paths from the active layout paths
    final dynamicPaths = activeLayoutPaths.whereType<StackMutatable>().toList();

    // Try to pop from the farthest element if stack length >= 2
    for (var i = dynamicPaths.length - 1; i >= 0; i--) {
      final path = dynamicPaths[i];
      if (path.stack.length >= 2) {
        await path.pop(result);
      }
    }
  }

  /// Builds the root widget (the primary navigator).
  ///
  /// Override to customize the root navigation structure.
  Widget layoutBuilder(BuildContext context) => RouteLayout.buildRoot(this);

  /// Attempts to pop the nearest dynamic path.
  /// The [RouteGuard] logic is handled here.
  ///
  /// Returns:
  /// - `true` if the route can pop
  /// - `false` if the route can't pop
  /// - `null` if the [RouteGuard] want manual control
  Future<bool?> tryPop([Object? result]) async {
    // Get all dynamic paths from the active layout paths
    final dynamicPaths = activeLayoutPaths.whereType<StackMutatable>().toList();

    // Try to pop from the farthest element if stack length >= 2
    for (var i = dynamicPaths.length - 1; i >= 0; i--) {
      final path = dynamicPaths[i];
      if (path.stack.length >= 2) {
        return await path.pop(result);
      }
    }

    return false;
  }

  /// Marks the coordinator as needing a rebuild.
  void markNeedRebuild() => notifyListeners();

  /// The router delegate for [Router] of this coordinator
  @override
  late final CoordinatorRouterDelegate routerDelegate =
      CoordinatorRouterDelegate(coordinator: this);

  /// The route information parser for [Router]
  @override
  late final CoordinatorRouteParser routeInformationParser =
      CoordinatorRouteParser(coordinator: this);

  /// The [BackButtonDispatcher] that is used to configure the [Router].
  @override
  final BackButtonDispatcher backButtonDispatcher = RootBackButtonDispatcher();

  /// The [RouteInformationProvider] that is used to configure the [Router].
  @override
  late final RouteInformationProvider routeInformationProvider =
      PlatformRouteInformationProvider(
        initialRouteInformation: RouteInformation(
          uri: initialRoutePath ?? Uri.parse('/'),
        ),
      );

  /// Access to the navigator state.
  NavigatorState get navigator => routerDelegate.navigatorKey.currentState!;
}



================================================
FILE: packages/zenrouter/lib/src/coordinator/modular.dart
================================================
import 'dart:async';

import 'package:zenrouter/zenrouter.dart';

/// Base class for route modules that handle a subset of application routes.
///
/// A [RouteModule] encapsulates a group of related routes, their navigation
/// paths, layouts, and route parsing logic. This enables modular architecture
/// where different parts of your application can be developed independently.
///
/// ## Architecture Overview
///
/// The modular coordinator pattern allows you to split route management across
/// multiple modules:
///
/// - **RouteModule**: Handles a specific domain of routes (e.g., auth, shop, settings)
/// - **CoordinatorModular**: Aggregates multiple modules and delegates route parsing
/// - **Module Isolation**: Each module manages its own paths and layouts independently
///
/// ## Benefits
///
/// - **Separation of Concerns**: Each module handles its own routes and logic
/// - **Team Collaboration**: Different teams can work on different modules
/// - **Code Organization**: Large applications become more maintainable
/// - **Reusability**: Modules can be reused across different applications
///
/// ## Creating a Route Module
///
/// ```dart
/// class AuthModule extends RouteModule<AppRoute> {
///   AuthModule(super.coordinator);
///
///   @override
///   FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
///     return switch (uri.pathSegments) {
///       ['auth', 'login'] => LoginRoute(),
///       ['auth', 'register'] => RegisterRoute(),
///       _ => null, // Not handled by this module
///     };
///   }
///
///   @override
///   void defineLayout() {
///     // Register layouts specific to auth module
///     RouteLayout.defineLayout(AuthLayout, AuthLayout.new);
///   }
/// }
/// ```
///
/// ## Module Responsibilities
///
/// Each module can:
/// - **Parse Routes**: Implement [parseRouteFromUri] to handle specific URI patterns
/// - **Define Paths**: Override [paths] to provide navigation paths for nested routes
/// - **Register Layouts**: Override [defineLayout] to register layout constructors
/// - **Register Converters**: Override [defineConverter] to register restorable converters
///
/// ## Route Parsing Strategy
///
/// When [CoordinatorModular.parseRouteFromUri] is called, it iterates through
/// all registered modules in order. The first module that returns a non-null
/// route wins. If all modules return null, [CoordinatorModular.notFoundRoute]
/// is called.
abstract class RouteModule<T extends RouteUnique> {
  /// Internal constructor used by [CoordinatorModular].
  RouteModule._(this.coordinator);

  /// Creates a route module with a reference to its coordinator.
  RouteModule(CoordinatorModular<T> coordinator)
    : this._(coordinator.rootCoordinator as CoordinatorModular<T>);

  /// {@template zenrouter.coordinator.modular.coordinator}
  /// The coordinator that owns this module.
  ///
  /// Use this to access coordinator methods or other modules via
  /// [CoordinatorModular.getModule].
  /// {@endtemplate}
  final CoordinatorModular<T> coordinator;

  /// The navigation paths managed by this module.
  ///
  /// Override this to provide paths for nested navigation within this module.
  /// These paths will be automatically aggregated by [CoordinatorModular].
  ///
  /// **Example:**
  /// ```dart
  /// @override
  /// List<StackPath> get paths => [shopPath, cartPath];
  /// ```
  List<StackPath> get paths => [];

  /// Parses a URI and returns a route if this module handles it.
  ///
  /// Return `null` if this module doesn't handle the given URI. The coordinator
  /// will continue checking other modules.
  ///
  /// **Example:**
  /// ```dart
  /// @override
  /// FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
  ///   return switch (uri.pathSegments) {
  ///     ['shop'] => ShopHomeRoute(),
  ///     ['shop', 'products', final id] => ProductRoute(id: id),
  ///     _ => null, // Let other modules handle it
  ///   };
  /// }
  /// ```
  FutureOr<T?> parseRouteFromUri(Uri uri);

  /// Defines layouts for this module.
  ///
  /// Override this to register layout constructors using
  /// [RouteLayout.defineLayout]. This is called automatically during
  /// coordinator initialization.
  ///
  /// **Example:**
  /// ```dart
  /// @override
  /// void defineLayout() {
  ///   RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  /// }
  /// ```
  void defineLayout() {}

  /// Defines restorable converters for this module.
  ///
  /// Override this to register converters using
  /// [RestorableConverter.defineConverter]. This is called automatically
  /// during coordinator initialization.
  void defineConverter() {}
}

/// Mixin that enables modular route management by delegating to multiple modules.
///
/// [CoordinatorModular] extends [Coordinator] with the ability to split route
/// management across multiple [RouteModule] instances. This is ideal for
/// large applications where you want to organize routes by domain or feature.
///
/// ## How It Works
///
/// 1. **Module Registration**: Implement [defineModules] to return a set of modules
/// 2. **Route Parsing**: Routes are parsed by modules in order until one matches
/// 3. **Path Aggregation**: All module paths are combined into the coordinator's paths
/// 4. **Layout/Converter Delegation**: Each module's `defineLayout` and `defineConverter`
///    are called automatically
///
/// ## Quick Start
///
/// ```dart
/// abstract class AppRoute extends RouteTarget with RouteUnique {}
///
/// class AppCoordinator extends Coordinator<AppRoute>
///     with CoordinatorModular<AppRoute> {
///   @override
///   Set<RouteModule<AppRoute>> defineModules(
///     CoordinatorModular<AppRoute> coordinator,
///   ) {
///     return {
///       AuthModule(coordinator),
///       ShopModule(coordinator),
///       SettingsModule(coordinator),
///     };
///   }
///
///   @override
///   AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
/// }
/// ```
///
/// ## Module Order Matters
///
/// Modules are checked in the order they appear in the [Set] returned by
/// [defineModules]. The first module that returns a non-null route wins.
/// This allows you to prioritize certain modules or handle route conflicts.
///
/// **Example:**
/// ```dart
/// @override
/// Set<RouteModule<AppRoute>> defineModules(
///   CoordinatorModular<AppRoute> coordinator,
/// ) {
///   return {
///     AdminModule(coordinator),    // Checked first
///     PublicModule(coordinator),  // Checked second
///   };
/// }
/// ```
///
/// ## Accessing Modules
///
/// Use [getModule] to access a specific module by type. This is useful when
/// you need module-specific functionality or paths.
///
/// **Example:**
/// ```dart
/// final shopModule = coordinator.getModule<ShopModule>();
/// shopModule.shopPath.push(ProductRoute(id: '123'));
/// ```
mixin CoordinatorModular<T extends RouteUnique> on Coordinator<T> {
  late final Map<Type, RouteModule<T>> _modules = {
    for (final module in defineModules()) module.runtimeType: module,
  };

  /// Defines the set of route modules for this coordinator.
  ///
  /// This method is called during coordinator initialization. Return a set
  /// containing all modules that should handle routes for this coordinator.
  ///
  /// **Important:** The order of modules in the set determines the order
  /// in which they are checked during route parsing. The first module that
  /// returns a non-null route wins.
  ///
  /// **Example:**
  /// ```dart
  /// @override
  /// Set<RouteModule<AppRoute>> defineModules(
  ///   CoordinatorModular<AppRoute> coordinator,
  /// ) {
  ///   return {
  ///     AuthModule(coordinator),
  ///     ShopModule(coordinator),
  ///     SettingsModule(coordinator),
  ///   };
  /// }
  /// ```
  Set<RouteModule<T>> defineModules();

  /// Retrieves a module by its type.
  ///
  /// Use this to access module-specific functionality or paths.
  ///
  /// **Example:**
  /// ```dart
  /// final shopModule = coordinator.getModule<ShopModule>();
  /// final productPath = shopModule.shopPath;
  /// ```
  ///
  /// **Throws:** [TypeError] if the requested module type is not registered.
  R getModule<R extends RouteModule<T>>() => _modules[R] as R;

  @override
  List<StackPath<RouteTarget>> get paths => [
    ...super.paths,
    for (final module in _modules.values) ...module.paths,
  ];

  /// Returns a route for URIs that don't match any module.
  ///
  /// This is called when all modules return `null` from their
  /// [RouteModule.parseRouteFromUri] methods. Typically, this should return
  /// a "not found" or "404" route.
  ///
  /// **Example:**
  /// ```dart
  /// @override
  /// AppRoute notFoundRoute(Uri uri) {
  ///   return NotFoundRoute(uri: uri);
  /// }
  /// ```
  T notFoundRoute(Uri uri);

  @override
  void defineLayout() {
    super.defineLayout();
    for (final module in _modules.values) {
      module.defineLayout();
    }
  }

  @override
  void defineConverter() {
    super.defineConverter();
    for (final module in _modules.values) {
      module.defineConverter();
    }
  }

  @override
  FutureOr<T?> parseRouteFromUri(Uri uri) async {
    for (final module in _modules.values) {
      final route = await module.parseRouteFromUri(uri);
      if (route != null) return route;
    }

    // If this is a route module, it should not handle not found route.
    if (isRouteModule) return null;
    return notFoundRoute(uri);
  }
}



================================================
FILE: packages/zenrouter/lib/src/coordinator/observer.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:zenrouter/zenrouter.dart';

/// Mixin that provides a list of observers for the coordinator's navigator.
mixin CoordinatorNavigatorObserver<T extends RouteUnique> on Coordinator<T> {
  /// A list of observers that apply for every [NavigationPath] in the coordinator.
  List<NavigatorObserver> get observers;
}

typedef NavigatorObserverListGetter = List<NavigatorObserver> Function();

List<NavigatorObserver> kEmptyNavigatorObserverList() => [];



================================================
FILE: packages/zenrouter/lib/src/coordinator/restoration.dart
================================================
part of 'router.dart';

/// A widget that enables state restoration for a [Coordinator] and its navigation hierarchy.
///
/// ## What This Widget Does
///
/// [CoordinatorRestorable] wraps your application's root widget to provide automatic
/// state restoration for the entire navigation stack managed by the [Coordinator].
/// When the operating system needs to reclaim resources and later restores your
/// application, this widget ensures that the user returns to exactly where they left
/// off, including the complete navigation history, active routes, and even nested
/// navigation stacks.
///
/// ## Where It Fits in the Architecture
///
/// **Important: This widget is used internally by [CoordinatorRouterDelegate] and you
/// typically do not need to use it directly.** The [CoordinatorRouterDelegate.build]
/// method automatically wraps your app's content with this widget when restoration is
/// enabled. It integrates with Flutter's [RestorationMixin] to participate in the
/// framework's restoration protocol, automatically saving and restoring state when
/// the application is backgrounded or terminated by the system.
///
/// The restoration hierarchy looks like this:
/// ```
/// MaterialApp.router(restorationScopeId: 'app')
///   └─ Router(routerDelegate: coordinator.routerDelegate)
///       └─ CoordinatorRestorable (automatically added by routerDelegate.build)
///           └─ NavigationStack(restorationId: 'root_stack')
///               └─ Your app widgets
/// ```
///
/// ## When Restoration Happens Automatically
///
/// Restoration is automatically enabled for your application when you provide a
/// `restorationScopeId` to [MaterialApp.router]. The framework handles all the
/// wrapping and state management internally. This is important for mobile
/// applications where the operating system may terminate your app to free memory,
/// and users expect to return to their previous screen when reopening the app.
///
/// **Restoration works automatically when:**
/// - You provide `restorationScopeId` to MaterialApp.router
/// - All your paths have unique `debugLabel` values
/// - You implement synchronous route parsing (or override `parseRouteFromUriSync`)
/// - Complex routes use [RouteRestorable] with registered converters
///
/// **Restoration is skipped when:**
/// - No `restorationScopeId` is provided to MaterialApp
/// - Your app is stateless or has only simple navigation
/// - You intentionally want users to start fresh on each launch
///
/// ## How to Enable Restoration
///
/// **Step 1: Enable restoration in your MaterialApp**
///
/// Provide a `restorationScopeId` to your [MaterialApp.router]. This automatically
/// enables the restoration framework for your entire application:
///
/// ```dart
/// MaterialApp.router(
///   restorationScopeId: 'main',  // This is all you need to enable restoration!
///   routerDelegate: coordinator.routerDelegate,
///   routeInformationParser: coordinator.routeInformationParser,
/// )
/// ```
///
/// **That's it!** The [CoordinatorRouterDelegate] automatically uses this widget
/// internally. You don't need to wrap anything manually.
///
/// **Step 2: Ensure all paths have debug labels**
///
/// Every [StackPath] that participates in restoration must have a unique `debugLabel`.
/// This label is used as a key to identify which path's state belongs to which data
/// when restoring. Without this, restoration will fail with an assertion error:
///
/// ```dart
/// class MyCoordinator extends Coordinator<MyRoute> {
///   late final tabsPath = NavigationPath<MyRoute>.create(
///     label: 'tabs',  // Required for restoration
///   );
///
///   @override
///   List<StackPath> get paths => [root, tabsPath];
/// }
/// ```
///
/// **Step 3: Implement synchronous route parsing**
///
/// If your [Coordinator.parseRouteFromUri] is asynchronous, you must override
/// [Coordinator.parseRouteFromUriSync] with a synchronous version. Restoration
/// cannot wait for asynchronous operations:
///
/// ```dart
/// class MyCoordinator extends Coordinator<MyRoute> {
///   @override
///   Future<MyRoute> parseRouteFromUri(Uri uri) async {
///     // Async version (for normal navigation)
///     await someAsyncOperation();
///     return MyRoute.fromUri(uri);
///   }
///
///   @override
///   RouteUriParserSync<MyRoute> get parseRouteFromUriSync {
///     // Synchronous version (for restoration)
///     return (Uri uri) => MyRoute.fromUri(uri);
///   }
/// }
/// ```
///
/// **Step 4: Handle complex routes with custom serialization**
///
/// For routes that cannot be fully represented by a URI alone (e.g., routes with
/// in-memory state or complex objects), implement [RouteRestorable] with a custom
/// [RestorableConverter]:
///
/// ```dart
/// class ProductDetailRoute extends MyRoute with RouteRestorable<ProductDetailRoute> {
///   ProductDetailRoute({required this.product});
///
///   final Product product;  // Complex object that can't be in URL
///
///   @override
///   RestorationStrategy get strategy => RestorationStrategy.converter;
///
///   @override
///   RestorableConverter<ProductDetailRoute> get converter =>
///       const ProductDetailConverter();
/// }
///
/// class ProductDetailConverter extends RestorableConverter<ProductDetailRoute> {
///   const ProductDetailConverter();
///
///   @override
///   String get key => 'product_detail';
///
///   @override
///   Map<String, dynamic> serialize(ProductDetailRoute route) {
///     return {'productId': route.product.id, 'productName': route.product.name};
///   }
///
///   @override
///   ProductDetailRoute deserialize(Map<String, dynamic> data) {
///     return ProductDetailRoute(
///       product: Product(id: data['productId'], name: data['productName']),
///     );
///   }
/// }
/// ```
///
/// ## Important Considerations
///
/// **Restoration only saves navigation structure, not widget state:**
/// If individual screens have their own state (form inputs, scroll positions, etc.),
/// those widgets need their own [RestorationMixin] implementation. This widget only
/// restores which routes are on the stack and which route is active.
///
/// **Debug labels must be stable across app versions:**
/// If you change a path's `debugLabel` between app versions, restoration data for
/// that path will be lost. Plan your path naming strategy carefully.
///
/// **Restoration happens synchronously on startup:**
/// The restoration process blocks the UI from rendering until complete. Keep your
/// route parsing logic fast to avoid slow startup times.
///
/// See also:
/// - [RouteRestorable] for custom route serialization
/// - [RestorableConverter] for implementing custom converters
/// - [NavigationStack] which handles restoration for individual navigation paths
class CoordinatorRestorable extends StatefulWidget {
  const CoordinatorRestorable({
    super.key,
    required this.restorationId,
    required this.coordinator,
    required this.child,
  });

  /// The restoration identifier used to save and restore this coordinator's state.
  ///
  /// This ID must be unique within the parent restoration scope. It becomes part
  /// of the restoration bucket hierarchy and is used to associate saved state
  /// with this specific coordinator instance.
  final String restorationId;

  /// The coordinator whose navigation state will be saved and restored.
  ///
  /// This coordinator's entire navigation hierarchy, including all [StackPath]
  /// instances and their route stacks, will be persisted when the application
  /// goes into the background and restored when it returns.
  final Coordinator coordinator;

  /// The child widget to render.
  ///
  /// This is typically the [Router] or root widget of your application's
  /// navigation hierarchy.
  final Widget child;

  @override
  State<CoordinatorRestorable> createState() => _CoordinatorRestorableState();
}

class _CoordinatorRestorableState extends State<CoordinatorRestorable>
    with RestorationMixin {
  late final _restorable = _CoordinatorRestorable(widget.coordinator);
  late final _activeRoute = ActiveRouteRestorable(
    initialRoute: widget.coordinator.activePath.activeRoute,
    parseRouteFromUri: widget.coordinator.parseRouteFromUriSync,
  );

  void _saveCoordinator() {
    final result = <String, dynamic>{};
    for (final path in widget.coordinator.paths) {
      if (path is NavigationPath) {
        assert(
          path.debugLabel != null,
          'NavigationPath must have a debugLabel for restoration to work',
        );
        result[path.debugLabel!] = path.stack;
      }
      if (path is IndexedStackPath) {
        assert(
          path.debugLabel != null,
          'IndexedStackPath must have a debugLabel for restoration to work',
        );
        result[path.debugLabel!] = path.activeIndex;
      }
    }

    _restorable.value = result;
  }

  void _saveActiveRoute() {
    _activeRoute.value = widget.coordinator.activePath.activeRoute;
  }

  void _restoreCoordinator() {
    final raw = _restorable.value;

    for (final MapEntry(:key, :value) in raw.entries) {
      final path = widget.coordinator.paths.firstWhereOrNull(
        (p) => p.debugLabel == key,
      );

      if (path case RestorablePath path) {
        path.restore(value);
      }
    }
    if (_activeRoute.value case RouteUnique route) {
      widget.coordinator.navigate(route);
    }
  }

  @override
  void initState() {
    super.initState();
    widget.coordinator.addListener(_saveCoordinator);
    widget.coordinator.addListener(_saveActiveRoute);
  }

  @override
  void didUpdateWidget(covariant CoordinatorRestorable oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.coordinator != oldWidget.coordinator) {
      // coverage:ignore-start
      oldWidget.coordinator.removeListener(_saveCoordinator);
      widget.coordinator.addListener(_saveCoordinator);
      oldWidget.coordinator.removeListener(_saveActiveRoute);
      widget.coordinator.addListener(_saveActiveRoute);
      // coverage:ignore-end
    }
  }

  @override
  void dispose() {
    widget.coordinator.removeListener(_saveCoordinator);
    widget.coordinator.removeListener(_saveActiveRoute);
    _restorable.dispose();
    _activeRoute.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => widget.child;

  @override
  String? get restorationId => widget.restorationId;

  @override
  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {
    registerForRestoration(_restorable, '_restorable');
    registerForRestoration(_activeRoute, '_activeRoute');
    if (initialRestore) {
      _restoreCoordinator();
    }
  }
}

/// A [RestorableValue] that manages the restoration of the currently active route in the navigation stack.
///
/// ## What This Class Does
///
/// [ActiveRouteRestorable] is responsible for remembering which route was active (visible to the user)
/// when the application was backgrounded or terminated. When the application restores, this ensures
/// that the user returns to the exact same screen they were viewing, not just somewhere in the
/// navigation stack. This is a critical component of providing a seamless user experience where
/// interruptions from the operating system are invisible to the user.
///
/// ## Where It Fits in the Architecture
///
/// This class is used internally by [_CoordinatorRestorableState] to track the active route
/// separately from the full navigation stack. While the coordinator saves the entire stack of
/// routes for each path, this class specifically tracks which single route from which path
/// was active when the app was paused. Upon restoration, the coordinator uses this information
/// to navigate to the correct route using [Coordinator.navigate].
///
/// The restoration data flow looks like this:
/// ```
/// CoordinatorRestorableState
///   ├─ _CoordinatorRestorable       (saves ALL routes in ALL paths)
///   └─ ActiveRouteRestorable        (saves the ONE active route)
///        └─ On restore → Coordinator.navigate(activeRoute)
/// ```
///
/// ## When This Gets Called
///
/// **Saving (toPrimitives):**
/// This is called whenever the coordinator's active route changes. The [_CoordinatorRestorableState]
/// listens to coordinator changes via `_saveActiveRoute()` and updates this restorable's value,
/// which triggers serialization to the restoration bucket.
///
/// **Restoring (fromPrimitives):**
/// This is called during app startup when Flutter detects existing restoration data. It happens
/// synchronously before the first frame is rendered, ensuring the user never sees an intermediate
/// state. The restoration process deserializes the saved data back into a route object that the
/// coordinator can navigate to.
///
/// ## How It Handles Different Route Types
///
/// This class intelligently handles two different route serialization strategies:
///
/// **Strategy 1: RouteUnique (URI-based)**
/// Routes that implement [RouteUnique] can be completely represented by their URI. These are
/// serialized as simple strings and deserialized by calling [parseRouteFromUri]:
///
/// ```dart
/// // Route definition
/// class HomeRoute extends RouteTarget with RouteUnique {
///   @override
///   Uri toUri() => Uri.parse('/home');
/// }
///
/// // Serialized as: "/home"
/// // Deserialized via: parseRouteFromUri(Uri.parse("/home"))
/// ```
///
/// **Strategy 2: RouteRestorable (Custom serialization)**
/// Routes that implement [RouteRestorable] with custom converters can preserve complex state
/// that wouldn't fit in a URI. These are serialized as maps containing the converter key and
/// serialized data:
///
/// ```dart
/// // Route definition
/// class ProductRoute extends RouteTarget with RouteRestorable<ProductRoute> {
///   ProductRoute({required this.product});
///   final Product product;
///
///   @override
///   RestorationStrategy get strategy => RestorationStrategy.converter;
///
///   @override
///   RestorableConverter<ProductRoute> get converter => ProductConverter();
/// }
///
/// // Serialized as: {"strategy": "converter", "converter": "product", "value": {...}}
/// // Deserialized via: ProductConverter().deserialize(data)
/// ```
///
/// The class automatically detects which strategy to use by checking if the route implements
/// [RouteRestorable] during serialization, and by examining the data structure during
/// deserialization.
///
/// ## Important Implementation Details
///
/// **Null handling:**
/// This class properly handles null values, which occur when no route is active yet (app first
/// launch) or when the active route shouldn't be restored. The [createDefaultValue] returns
/// the [initialRoute] provided during construction, or null if none was provided.
///
/// **Type safety:**
/// The generic type parameter `<T extends RouteUnique>` ensures compile-time type safety while
/// still allowing the class to work with any route type that implements [RouteUnique]. The
/// route is cast to `T` after deserialization, which is safe because we control the serialization
/// format.
///
/// **Deserialization format detection:**
/// The [fromPrimitives] method uses pattern matching to detect whether the saved data is a
/// simple string (URI-based) or a map (custom converter-based), and handles each case appropriately.
///
/// See also:
/// - [RouteRestorable] for implementing custom route serialization
/// - [CoordinatorRestorable] for the overall restoration orchestration
/// - [RestorableValue] (Flutter framework) for the base restoration mechanism
class ActiveRouteRestorable<T extends RouteUnique> extends RestorableValue<T?> {
  ActiveRouteRestorable({
    required this.initialRoute,
    required this.parseRouteFromUri,
  });

  /// The initial route to use when no restoration data is available.
  ///
  /// This is typically null for a fresh app launch, but can be set to provide a
  /// default route when restoration data doesn't exist.
  final T? initialRoute;

  /// Function to parse a route from a URI string.
  ///
  /// This must be a synchronous version of your coordinator's route parser. It's
  /// used to deserialize [RouteUnique] routes that were saved as URI strings.
  /// The function should handle all possible URIs that your application can generate.
  final RouteUriParserSync<RouteUnique> parseRouteFromUri;

  @override
  T? createDefaultValue() => initialRoute;

  @override
  void didUpdateValue(T? oldValue) {
    notifyListeners();
  }

  @override
  T? fromPrimitives(Object? data) {
    // Never happen
    // coverage:ignore-start
    if (data == null) return null;
    // coverage:ignore-end
    return RouteTarget.deserialize(data, parseRouteFromUri: parseRouteFromUri);
  }

  @override
  Object? toPrimitives() {
    if (value == null) return null;
    return RouteTarget.serialize(value!);
  }
}

class _CoordinatorRestorable<T extends RouteUnique>
    extends RestorableValue<Map<String, dynamic>> {
  _CoordinatorRestorable(this.coordinator);
  final Coordinator coordinator;

  @override
  Map<String, dynamic> createDefaultValue() {
    final map = <String, dynamic>{};
    for (final path in coordinator.paths) {
      if (path is NavigationPath) {
        assert(
          path.debugLabel != null,
          'NavigationPath must have a debugLabel for restoration to work',
        );
        map[path.debugLabel!] = path.stack.cast<T>();
        continue;
      }
      if (path is IndexedStackPath) {
        assert(
          path.debugLabel != null,
          'IndexedStackPath must have a debugLabel for restoration to work',
        );
        map[path.debugLabel!] = path.activeIndex;
        continue;
      }
    }
    return map;
  }

  @override
  void didUpdateValue(Map<String, dynamic>? oldValue) {
    notifyListeners();
  }

  @override
  Map<String, dynamic> fromPrimitives(Object? data) {
    final result = <String, dynamic>{};

    final map = (data as Map).cast<String, dynamic>();
    for (final pathEntry in map.entries) {
      final path = coordinator.paths.firstWhereOrNull(
        (p) => p.debugLabel == pathEntry.key,
      );
      if (path case NavigationPath path) {
        assert(
          path.debugLabel != null,
          'NavigationPath must have a debugLabel for restoration to work',
        );
        result[path.debugLabel!] = path.deserialize(
          pathEntry.value,
          coordinator.parseRouteFromUriSync,
        );
      }
      if (path case RestorablePath path) {
        assert(
          path.debugLabel != null,
          'RestorablePath must have a debugLabel for restoration to work',
        );
        result[path.debugLabel!] = path.deserialize(pathEntry.value);
      }
    }

    return result;
  }

  @override
  Map<String, dynamic> toPrimitives() {
    final result = <String, dynamic>{};

    for (final path in coordinator.paths) {
      if (path case RestorablePath path) {
        assert(
          path.debugLabel != null,
          'RestorablePath must have a debugLabel for restoration to work',
        );
        result[path.debugLabel!] = path.serialize();
      }
    }

    return result;
  }
}



================================================
FILE: packages/zenrouter/lib/src/coordinator/router.dart
================================================
import 'package:collection/collection.dart';
import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

part 'restoration.dart';

/// Parses [RouteInformation] to and from [Uri].
///
/// This is used by Flutter's Router widget to handle URL changes.
class CoordinatorRouteParser extends RouteInformationParser<Uri> {
  CoordinatorRouteParser({required this.coordinator});

  final Coordinator coordinator;

  /// Converts [RouteInformation] to a [Uri] configuration.
  @override
  Future<Uri> parseRouteInformation(RouteInformation routeInformation) async {
    return routeInformation.uri;
  }

  /// Converts a [Uri] configuration back to [RouteInformation].
  @override
  RouteInformation? restoreRouteInformation(Uri configuration) {
    return RouteInformation(uri: configuration);
  }
}

/// Router delegate that connects the [Coordinator] to Flutter's Router.
///
/// Manages the navigator stack and handles system navigation events.
class CoordinatorRouterDelegate extends RouterDelegate<Uri>
    with ChangeNotifier, PopNavigatorRouterDelegateMixin<Uri> {
  CoordinatorRouterDelegate({required this.coordinator}) {
    coordinator.addListener(notifyListeners);
  }

  final Coordinator coordinator;

  @override
  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

  @override
  Uri? get currentConfiguration => coordinator.currentUri;

  String get coordinatorRestorationId =>
      '_${coordinator.rootRestorationId}_coordinator_restorable';

  final GlobalKey<_CoordinatorRestorableState> _coordinatorRestorableKey =
      GlobalKey();

  @override
  Widget build(BuildContext context) {
    return CoordinatorRestorable(
      key: _coordinatorRestorableKey,
      coordinator: coordinator,
      restorationId: coordinatorRestorationId,
      child: coordinator.layoutBuilder(context),
    );
  }

  /// Handles browser navigation events (back/forward buttons, URL changes).
  ///
  /// This method is called by Flutter's Router when the browser URL changes,
  /// either from user action (back/forward buttons) or programmatic navigation.
  ///
  /// **Subsequent Navigation:**
  /// For browser back/forward buttons:
  ///
  /// - **NavigationPath**: If the route exists in the stack, pops until
  ///   reaching that route. If not found, pushes it as a new route.
  ///   - Guards are consulted during popping
  ///   - If any guard blocks navigation, the URL is restored via [notifyListeners]
  ///   - Uses a while loop to handle dynamic stack changes during iteration
  ///
  /// - **IndexedStackPath**: Activates the route (switches tab) after ensuring
  ///   parent layouts are properly resolved.
  ///
  /// **URL Synchronization:**
  /// When navigation fails (guard blocks or layout resolution fails),
  /// [notifyListeners] is called to restore the browser URL to match
  /// the current app state, keeping URL and navigation state in sync.
  ///
  /// **Invariants:**
  /// - Routes cannot exist in multiple paths (each route has one path)
  /// - Route layouts are determined at creation and don't change
  /// - Path types (NavigationPath vs IndexedStackPath) are static
  @override
  Future<void> setNewRoutePath(Uri configuration) async {
    final route = await coordinator.parseRouteFromUri(configuration);
    assert(
      () {
        try {
          final _ = coordinator.coordinator;
          return true;
        } on UnimplementedError catch (err) {
          if (err.message?.contains('This coordinator is standalone') == true) {
            return route != null;
          }
          return true;
        }
      }(),
      'If you want to use coordinator as [RouterConfig], you must return route from [parseRouteFromUri]',
    );

    if (route is RouteDeepLink &&
        route.deeplinkStrategy == DeeplinkStrategy.custom) {
      coordinator.recover(route);
    } else {
      assert(
        route != null,
        'You must to provide a parse route for $configuration in [parseRouteFromUri] to use deeplink to it',
      );
      coordinator.navigate(route!);
    }
  }

  /// Dont need to handle restored route since it handled in [CoordinatorRestorable]
  @override
  Future<void> setRestoredRoutePath(Uri configuration) async {}

  @override
  Future<bool> popRoute() async {
    final result = await coordinator.tryPop();
    return result ?? false;
  }

  @override
  void dispose() {
    coordinator.removeListener(notifyListeners);
    super.dispose();
  }
}



================================================
FILE: packages/zenrouter/lib/src/internal/diff.dart
================================================
import 'package:zenrouter/zenrouter.dart';

/// Represents a diff operation between two lists.
sealed class DiffOp<T> {
  const DiffOp();
}

/// Represents keeping an element at a specific index (no change).
///
/// Indicates that the element at [oldIndex] in the old list is the same
/// as the element at [newIndex] in the new list.
class Keep<T> extends DiffOp<T> {
  const Keep(this.oldIndex, this.newIndex);

  /// The index of the element in the old list.
  final int oldIndex;

  /// The index of the element in the new list.
  final int newIndex;

  @override
  String toString() => 'Keep(old: $oldIndex, new: $newIndex)';
}

/// Represents inserting a new element at a specific index.
///
/// Indicates that [element] should be inserted at [newIndex] in the new list.
class Insert<T> extends DiffOp<T> {
  const Insert(this.element, this.newIndex);

  /// The element to insert.
  final T element;

  /// The index in the new list where the element should be inserted.
  final int newIndex;

  @override
  String toString() => 'Insert($element at $newIndex)';
}

/// Represents deleting an element at a specific index.
///
/// Indicates that the element at [oldIndex] in the old list should be removed.
class Delete<T> extends DiffOp<T> {
  const Delete(this.oldIndex);

  /// The index of the element in the old list to be removed.
  final int oldIndex;

  @override
  String toString() => 'Delete(at $oldIndex)';
}

/// Myers diff algorithm implementation.
///
/// Computes the shortest edit script (SES) between two lists using the
/// Myers O(ND) algorithm. This is the same algorithm used by Git.
///
/// This implementation is optimized for small lists (n ≤ 50) such as
/// navigation routes, using List-based storage for better cache locality
/// instead of Map-based storage.
///
/// The optional [equals] parameter allows custom equality comparison.
/// If not provided, the default `==` operator is used.
///
/// Example:
/// ```dart
/// final oldList = [route1, route2, route3];
/// final newList = [route1, route4, route3];
/// final ops = myersDiff(oldList, newList);
/// // ops will contain: [Keep(0,0), Delete(1), Insert(route4, 1), Keep(2,2)]
/// ```
List<DiffOp<T>> myersDiff<T>(
  List<T> oldList,
  List<T> newList, {
  bool Function(T a, T b)? equals,
}) {
  final n = oldList.length;
  final m = newList.length;

  // Early exit for empty cases
  if (n == 0 && m == 0) return const [];
  if (n == 0) {
    return List.generate(m, (i) => Insert<T>(newList[i], i), growable: false);
  }
  if (m == 0) {
    return List.generate(n, (i) => Delete<T>(i), growable: false);
  }

  final max = n + m;
  final offset = max;
  final equalityCheck = equals ?? (a, b) => a == b;

  // Use List instead of Map for better cache locality with small lists.
  // V[k] contains the furthest reaching x value on diagonal k.
  // We access v[k] as v[k + offset] to handle negative indices.
  final vSize = 2 * max + 1;
  final v = List<int>.filled(vSize, -1, growable: false);

  // Trace stores snapshots of v for backtracking.
  // For small lists, copying the list is faster than Map overhead.
  final trace = <List<int>>[];

  v[1 + offset] = 0;

  // Find the shortest edit script
  for (var d = 0; d <= max; d++) {
    // Store snapshot for backtracking
    trace.add(List.from(v, growable: false));

    for (var k = -d; k <= d; k += 2) {
      final kIndex = k + offset;
      int x;

      // Decide whether to move right (insert) or down (delete)
      // Add bounds checking to prevent array access errors
      final kMinusOneIndex = k - 1 + offset;
      final kPlusOneIndex = k + 1 + offset;

      final kMinusOne = (kMinusOneIndex >= 0 && kMinusOneIndex < vSize)
          ? v[kMinusOneIndex]
          : -1;
      final kPlusOne = (kPlusOneIndex >= 0 && kPlusOneIndex < vSize)
          ? v[kPlusOneIndex]
          // coverage:ignore-start
          : -1;
      // coverage:ignore-end

      if (k == -d || (k != d && kMinusOne < kPlusOne)) {
        x = kPlusOne;
      } else {
        x = kMinusOne + 1;
      }

      var y = x - k;

      // Follow diagonal (matching elements)
      while (x < n && y < m && equalityCheck(oldList[x], newList[y])) {
        x++;
        y++;
      }

      v[kIndex] = x;

      // Check if we've reached the end
      if (x >= n && y >= m) {
        return _backtrack(trace, oldList, newList, d, offset);
      }
    }
  }

  // coverage:ignore-start
  // Should never reach here, but return empty list as fallback
  return [];
  // coverage:ignore-end
}

/// Backtrack through the trace to construct the edit script.
///
/// This function has been optimized to build operations in reverse order
/// and then reverse the list once at the end, avoiding O(n²) complexity
/// from repeated insertions at index 0.
List<DiffOp<T>> _backtrack<T>(
  List<List<int>> trace,
  List<T> oldList,
  List<T> newList,
  int d,
  int offset,
) {
  final n = oldList.length;
  final m = newList.length;
  var x = n;
  var y = m;

  // Build in reverse order to avoid O(n) insertions at index 0.
  // This changes backtracking from O(n²) to O(n).
  final opsReversed = <DiffOp<T>>[];

  // Backtrack from the end to the beginning
  for (var depth = d; depth >= 0; depth--) {
    final v = trace[depth];
    final k = x - y;
    final vSize = v.length;

    int prevK;
    // Add bounds checking to prevent array access errors
    final kMinusOneIndex = k - 1 + offset;
    final kPlusOneIndex = k + 1 + offset;

    final kMinusOne = (kMinusOneIndex >= 0 && kMinusOneIndex < vSize)
        ? v[kMinusOneIndex]
        // coverage:ignore-start
        : -1;
    // coverage:ignore-end
    final kPlusOne = (kPlusOneIndex >= 0 && kPlusOneIndex < vSize)
        ? v[kPlusOneIndex]
        // coverage:ignore-start
        : -1;
    // coverage:ignore-end

    if (k == -depth || (k != depth && kMinusOne < kPlusOne)) {
      prevK = k + 1;
    } else {
      prevK = k - 1;
    }

    final prevX = v[prevK + offset];
    final prevY = prevX - prevK;

    // Follow diagonal backwards (these are Keep operations)
    while (x > prevX && y > prevY) {
      x--;
      y--;
      opsReversed.add(Keep<T>(x, y));
    }

    if (depth == 0) break;

    // Determine if this was an insert or delete
    if (x == prevX) {
      // Insert
      y--;
      opsReversed.add(Insert<T>(newList[y], y));
    } else {
      // Delete
      x--;
      opsReversed.add(Delete<T>(x));
    }
  }

  // Reverse once at the end instead of inserting at 0 each time
  return opsReversed.reversed.toList();
}

/// Apply diff operations to a NavigationPath.
///
/// This function applies the diff operations calculated by [myersDiff]
/// to efficiently update the navigation path from the old state to the new state.
///
/// The operations are processed carefully to maintain correct indices:
/// - If both deletes and inserts exist, we rebuild the stack once
/// - Deletes alone are processed from highest to lowest index
/// - Inserts alone are processed by building a new stack
/// - Keeps are no-ops
void applyDiff<T extends RouteTarget>(
  NavigationPath<T> path,
  List<DiffOp<T>> operations,
) {
  // Early exit if no operations
  if (operations.isEmpty) return;

  // Group operations by type for efficient processing
  final deletes = <Delete<T>>[];
  final inserts = <Insert<T>>[];

  for (final op in operations) {
    switch (op) {
      case Delete<T>():
        deletes.add(op);
      case Insert<T>():
        inserts.add(op);
      case Keep<T>():
        // No action needed for Keep operations
        break;
    }
  }

  // If we have both deletes and inserts, it's more efficient to
  // build a new stack in one pass rather than multiple modifications
  if (deletes.isNotEmpty && inserts.isNotEmpty) {
    final stackList = path.stack.toList();

    // Apply deletes (reverse order to maintain indices)
    deletes.sort((a, b) => b.oldIndex.compareTo(a.oldIndex));
    for (final delete in deletes) {
      if (delete.oldIndex < stackList.length) {
        stackList.removeAt(delete.oldIndex);
      }
    }

    // Apply inserts
    for (final insert in inserts) {
      if (insert.newIndex <= stackList.length) {
        stackList.insert(insert.newIndex, insert.element);
        // coverage:ignore-start
      } else {
        stackList.add(insert.element);
        // coverage:ignore-end
      }
    }

    // Rebuild the path once
    path.reset();
    for (final route in stackList) {
      path.push(route);
    }
  } else if (deletes.isNotEmpty) {
    // Only deletes: process in reverse order to avoid index shifting
    deletes.sort((a, b) => b.oldIndex.compareTo(a.oldIndex));
    for (final delete in deletes) {
      if (delete.oldIndex < path.stack.length) {
        final element = path.stack[delete.oldIndex];
        path.remove(element);
      }
    }
  } else if (inserts.isNotEmpty) {
    // Only inserts: build new stack
    final stackList = path.stack.toList();
    for (final insert in inserts) {
      if (insert.newIndex <= stackList.length) {
        stackList.insert(insert.newIndex, insert.element);
      } else {
        stackList.add(insert.element);
      }
    }

    // Rebuild the path once
    path.reset();
    for (final route in stackList) {
      path.push(route);
    }
  }
}



================================================
FILE: packages/zenrouter/lib/src/internal/equatable.dart
================================================
import 'package:collection/collection.dart';

/// Returns a `hashCode` for [props].
///
/// This combines the hash codes of all elements in [props] using the Jenkins
/// hash function, similar to how `Equatable` calculates hash codes.
int mapPropsToHashCode(Iterable<Object?>? props) {
  return _finish(props == null ? 0 : props.fold(0, _combine));
}

/// Determines whether two lists ([a] and [b]) are equal.
///
/// Returns `true` if both lists contain the same elements in the same order.
/// Returns `false` if either list is null or if they have different lengths
/// or contents.
// See https://github.com/felangel/equatable/issues/187.
@pragma('vm:prefer-inline')
bool equals(List<Object?>? a, List<Object?>? b) {
  if (identical(a, b)) return true;
  if (a == null || b == null) return false;
  return iterableEquals(a, b);
}

/// Determines whether two iterables are equal.
///
/// Returns `true` if both iterables contain the same elements in the same order.
/// Throws an [AssertionError] if either argument is a [Set], as sets should
/// be compared using [setEquals].
@pragma('vm:prefer-inline')
bool iterableEquals(Iterable<Object?> a, Iterable<Object?> b) {
  assert(
    a is! Set && b is! Set,
    "iterableEquals doesn't support Sets. Use setEquals instead.",
  );
  if (identical(a, b)) return true;
  if (a.length != b.length) return false;
  for (var i = 0; i < a.length; i++) {
    if (!objectsEquals(a.elementAt(i), b.elementAt(i))) return false;
  }
  return true;
}

/// Determines whether two numbers are equal.
///
/// Returns `true` if [a] and [b] are equal.
@pragma('vm:prefer-inline')
bool numEquals(num a, num b) => a == b;

/// Determines whether two sets are equal.
///
/// Returns `true` if both sets contain the same elements, regardless of order.
/// Elements are compared using [objectsEquals].
bool setEquals(Set<Object?> a, Set<Object?> b) {
  if (identical(a, b)) return true;
  if (a.length != b.length) return false;
  for (final element in a) {
    if (!b.any((e) => objectsEquals(element, e))) return false;
  }
  return true;
}

/// Determines whether two maps are equal.
///
/// Returns `true` if both maps contain the same keys and values.
/// Keys and values are compared using [objectsEquals].
bool mapEquals(Map<Object?, Object?> a, Map<Object?, Object?> b) {
  if (identical(a, b)) return true;
  if (a.length != b.length) return false;
  for (final key in a.keys) {
    if (!objectsEquals(a[key], b[key])) return false;
  }
  return true;
}

/// Determines whether two objects are equal.
///
/// This handles various types including numbers, [RouteTarget]s, [Set]s,
/// [Iterable]s, and [Map]s. It performs deep equality checks where appropriate.
@pragma('vm:prefer-inline')
bool objectsEquals(Object? a, Object? b) {
  if (identical(a, b)) return true;
  if (a is num && b is num) {
    return numEquals(a, b);
  } else if (_isEquatable(a) && _isEquatable(b)) {
    return a == b;
  } else if (a is Set && b is Set) {
    return setEquals(a, b);
  } else if (a is Iterable && b is Iterable) {
    return iterableEquals(a, b);
  } else if (a is Map && b is Map) {
    return mapEquals(a, b);
  } else if (a?.runtimeType != b?.runtimeType) {
    return false;
  } else if (a != b) {
    return false;
  }
  return true;
}

@pragma('vm:prefer-inline')
bool _isEquatable(Object? object) {
  return object is Equatable;
}

/// Jenkins Hash Functions
/// https://en.wikipedia.org/wiki/Jenkins_hash_function
int _combine(int hash, Object? object) {
  if (object is Map) {
    object.keys
        .sorted((Object? a, Object? b) => a.hashCode - b.hashCode)
        .forEach((Object? key) {
          hash = hash ^ _combine(hash, [key, (object! as Map)[key]]);
        });
    return hash;
  }
  if (object is Set) {
    object = object.sorted((Object? a, Object? b) => a.hashCode - b.hashCode);
  }
  if (object is Iterable) {
    for (final value in object) {
      hash = hash ^ _combine(hash, value);
    }
    return hash ^ object.length;
  }

  hash = 0x1fffffff & (hash + object.hashCode);
  hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
  return hash ^ (hash >> 6);
}

int _finish(int hash) {
  hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
  hash = hash ^ (hash >> 11);
  return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
}

/// Returns a string for [props].
String mapPropsToString(Type runtimeType, List<Object?> props) {
  return '$runtimeType(${props.map((prop) => prop.toString()).join(', ')})';
}

/// Base class for objects that can be compared for equality.
///
/// [Equatable] provides value-based equality for ZenRouter routes and paths.
/// Unlike Dart's default reference equality, two [Equatable] objects are
/// equal if they have the same [runtimeType] and [props].
///
/// ## Why ZenRouter has its own Equatable
///
/// While similar to the `equatable` package, this implementation:
/// - Integrates with ZenRouter's internal state ([internalProps])
/// - Provides [compareWith] for controlled equality checks
/// - Avoids external dependencies
///
/// ## props vs internalProps
///
/// | Property       | Purpose                                    | When to override? |
/// |----------------|-------------------------------------------|-------------------|
/// | [props]        | User-defined equality (route parameters)   | **Yes** - always  |
/// | [internalProps]| Framework state (path, completer, etc.)    | **Never**         |
///
/// **Example:**
/// ```dart
/// class ProductRoute extends RouteTarget with RouteUnique {
///   final String productId;
///   final String? variant;
///
///   ProductRoute(this.productId, {this.variant});
///
///   // Include all parameters that make this route unique
///   @override
///   List<Object?> get props => [productId, variant];
///
///   // Do NOT override internalProps - framework manages it
/// }
/// ```
///
/// ## Equality Behavior
///
/// Two routes are equal when:
/// 1. Same [runtimeType] (e.g., both are `ProductRoute`)
/// 2. Same [props] values (e.g., same `productId`)
///
/// [internalProps] are NOT compared in [compareWith] but ARE used for:
/// - Hash code generation
/// - Internal framework identity checks
abstract class Equatable {
  // coverage:ignore-start
  /// Framework-managed properties for internal identity.
  ///
  /// **Do not override.** This is used by ZenRouter to track:
  /// - Runtime type
  /// - Path binding (`_path`)
  /// - Result completer (`_onResult`)
  ///
  /// These are combined with [props] for hash code generation but are
  /// NOT compared in [compareWith] / `==` operator.
  List<Object?> get internalProps => [];
  // coverage:ignore-end

  /// User-defined properties for equality comparison.
  ///
  /// Override this to include all parameters that make this route unique.
  ///
  /// **Guidelines:**
  /// - Include all constructor parameters that affect identity
  /// - Use consistent ordering across instances
  /// - Avoid including mutable state
  ///
  /// **Example:**
  /// ```dart
  /// class OrderRoute extends RouteTarget with RouteUnique {
  ///   final String orderId;
  ///   final bool isReadOnly;
  ///
  ///   OrderRoute(this.orderId, {this.isReadOnly = false});
  ///
  ///   @override
  ///   List<Object?> get props => [orderId, isReadOnly];
  /// }
  /// ```
  List<Object?> get props => [];

  @override
  operator ==(Object other) => compareWith(other);

  /// Compares this object with another for equality.
  ///
  /// This is the implementation behind the `==` operator. It checks:
  /// 1. Identity (same reference)
  /// 2. Type equality
  /// 3. [props] equality (deep comparison)
  ///
  /// **When to use directly:**
  /// Call this from a custom `==` override if you need pre/post processing:
  /// ```dart
  /// @override
  /// operator ==(Object other) {
  ///   if (other is! MyRoute) return false;
  ///   // Custom pre-check
  ///   return compareWith(other);
  /// }
  /// ```
  @pragma('vm:prefer-inline')
  bool compareWith(Object other) {
    if (identical(this, other)) return true;
    return other is Equatable &&
        other.runtimeType == runtimeType &&
        iterableEquals(props, other.props);
  }

  @override
  int get hashCode =>
      mapPropsToHashCode(internalProps) ^ mapPropsToHashCode(props);

  @override
  String toString() {
    if (props.isEmpty) return runtimeType.toString();
    return '$runtimeType[${props.map((prop) => prop.toString()).join(',')}]';
  }
}



================================================
FILE: packages/zenrouter/lib/src/internal/type.dart
================================================
import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

/// Synchronous parser function that converts a [Uri] into a route instance.
///
/// This typedef defines a function signature for parsing URIs into route objects.
/// The parser should extract route information from the URI and construct
/// an appropriate route instance of type [T].
///
/// **Parameters:**
/// - `uri`: The URI to parse into a route.
///
/// **Returns:**
/// A route instance of type [T] that represents the parsed URI.
///
/// **Example:**
/// ```dart
/// RouteUriParserSync<AppRoute> parser = (Uri uri) {
///   final path = uri.path;
///   if (path == '/home') return HomeRoute();
///   if (path == '/settings') return SettingsRoute();
///   return NotFoundRoute();
/// };
/// ```
typedef RouteUriParserSync<T extends RouteTarget> = T Function(Uri uri);

/// Builder function for creating a layout widget that wraps route content.
///
/// This typedef defines a function signature for building layout widgets that
/// can wrap and decorate the content of routes in a navigation stack. Layouts
/// are useful for adding common UI elements like app bars, navigation rails,
/// or background decorations around route content.
///
/// **Parameters:**
/// - `coordinator`: The coordinator managing navigation state.
/// - `path`: The current navigation stack path containing the route.
/// - `layout`: Optional layout instance that may contain additional configuration.
///
/// **Returns:**
/// A [Widget] that provides the layout structure for the route.
///
/// See also:
/// - [RouteLayoutConstructor], which creates layout instances.
/// - [RouteLayout], the base class for layout implementations.
typedef RouteLayoutBuilder<T extends RouteUnique> =
    Widget Function(
      Coordinator coordinator,
      StackPath<T> path,
      RouteLayout<T>? layout,
    );

/// Constructor function for creating a layout instance.
///
/// This typedef defines a function signature for constructing [RouteLayout]
/// instances. Layout constructors are typically used in route definitions to
/// specify which layout should wrap the route's content.
///
/// **Returns:**
/// A new [RouteLayout] instance of type [T].
///
/// **Example:**
/// ```dart
/// RouteLayoutConstructor<AppRoute> constructor = () => MainLayout();
/// ```
///
/// See also:
/// - [RouteLayoutBuilder], which builds the layout widget.
/// - [RouteLayout], the base class for layout implementations.
typedef RouteLayoutConstructor<T extends RouteUnique> =
    RouteLayout<T> Function();

/// Widget builder for query parameters.
///
/// You can use this typedef to allow passing the [RouteQueryParameters.selectorBuilder] to inner widgets.
typedef QuerySelectorBuilder<T> =
    Widget Function({
      required T Function(Map<String, String> queries) selector,
      required Widget Function(BuildContext context, T value) builder,
    });

/// Constructor function for creating a restorable value converter.
///
/// This typedef defines a function signature for constructing [RestorableConverter]
/// instances. Restorable converters are used to serialize and deserialize route
/// data for state restoration, allowing routes to be recreated after app restarts
/// or process death.
///
/// **Type Parameters:**
/// - `T`: The type of object that can be converted. Must be a non-nullable Object.
///
/// **Returns:**
/// A new [RestorableConverter] instance that can convert values of type [T].
///
/// **Example:**
/// ```dart
/// RestoratableConverterConstructor<User> converter = () => UserConverter();
/// ```
///
/// See also:
/// - [RestorableConverter], the base class for implementing converters.
/// - [RouteRestoration], mixin for routes that support state restoration.
typedef RestoratableConverterConstructor<T extends Object> =
    RestorableConverter<T> Function();

/// Callback that builds a [Page] from a route and child widget.
///
/// This typedef defines a function signature for creating [Page] instances that
/// wrap route widgets in the navigation stack. Pages are the fundamental building
/// blocks used by Flutter's [Navigator] to manage routes.
///
/// **Parameters:**
/// - `context`: The build context for the page.
/// - `routeKey`: A unique key identifying this route instance. Typically derived
///   from the route's identity.
/// - `child`: The widget content to be wrapped by the page.
///
/// **Returns:**
/// A [Page] instance that wraps the child widget.
///
/// **Example:**
/// ```dart
/// PageCallback<AppRoute> callback = (context, routeKey, child) {
///   return MaterialPage(
///     key: routeKey,
///     child: child,
///   );
/// };
/// ```
///
/// See also:
/// - [StackTransition], which provides different page transition styles.
typedef PageCallback<T> =
    Page<void> Function(
      BuildContext context,
      ValueKey<T> routeKey,
      Widget child,
    );

/// Callback that maps routes to their [StackTransition].
///
/// Used by [NavigationStack] to determine how each route should be displayed.
///
/// **Example - Route-based transitions:**
/// ```dart
/// NavigationStack(
///   path: coordinator.root,
///   coordinator: coordinator,
///   resolver: (route) {
///     return switch (route) {
///       // Dialogs use dialog transition
///       ConfirmRoute() => StackTransition.dialog(route.build(coordinator, context)),
///
///       // Sheets use sheet transition
///       ShareRoute() => StackTransition.sheet(route.build(coordinator, context)),
///
///       // iOS gets cupertino, others get material
///       _ when Platform.isIOS => StackTransition.cupertino(
///         route.build(coordinator, context),
///       ),
///       _ => StackTransition.material(route.build(coordinator, context)),
///     };
///   },
/// )
/// ```
///
/// **Example - RouteTransition mixin:**
/// Routes can also define their own transition by mixing in [RouteTransition]:
/// ```dart
/// class SettingsRoute extends RouteTarget with RouteUnique, RouteTransition {
///   @override
///   StackTransition<T> transition<T extends RouteUnique>(Coordinator coordinator) {
///     return StackTransition.cupertino(build(coordinator, context));
///   }
/// }
/// ```
typedef StackTransitionResolver<T extends RouteTarget> =
    StackTransition<T> Function(T route);



================================================
FILE: packages/zenrouter/lib/src/mixin/deeplink.dart
================================================
import 'dart:async';

import 'package:zenrouter/src/coordinator/base.dart';

import 'unique.dart';

/// Strategy for handling deep links.
///
/// - [replace]: Replace the current navigation stack (default)
/// - [navigate]: Navigate to the route (Go to route if exists, else push to top)
/// - [push]: Push onto the existing navigation stack
/// - [custom]: Custom strategy for handling deep links
enum DeeplinkStrategy { replace, navigate, push, custom }

mixin RouteDeepLink on RouteUnique {
  /// The strategy to use when handling this deep link.
  DeeplinkStrategy get deeplinkStrategy;

  // coverage:ignore-start
  /// Custom handler for deep links.
  ///
  /// This is called when [deeplinkStrategy] is [DeeplinkStrategy.custom].
  FutureOr<void> deeplinkHandler(covariant Coordinator coordinator, Uri uri) =>
      null;
  // coverage:ignore-end
}



================================================
FILE: packages/zenrouter/lib/src/mixin/guard.dart
================================================
import 'dart:async';

import 'package:zenrouter/zenrouter.dart';

/// Mixin for routes that need to guard against being popped.
///
/// Use this mixin to intercept pop operations and conditionally prevent them.
/// Common use cases include:
/// - **Unsaved changes**: Prompt user before losing form data
/// - **Confirmation dialogs**: Require explicit confirmation before leaving
/// - **Async validation**: Check with a server before allowing navigation
///
/// **Example - Confirmation Dialog:**
/// ```dart
/// class EditFormRoute extends RouteTarget with RouteUnique, RouteGuard {
///   bool hasUnsavedChanges = false;
///
///   @override
///   FutureOr<bool> popGuard() async {
///     if (!hasUnsavedChanges) return true;
///
///     // Show confirmation dialog
///     final shouldPop = await showDialog<bool>(
///       context: navigatorContext,
///       builder: (context) => AlertDialog(
///         title: Text('Discard changes?'),
///         content: Text('You have unsaved changes.'),
///         actions: [
///           TextButton(
///             onPressed: () => Navigator.pop(context, false),
///             child: Text('Cancel'),
///           ),
///           TextButton(
///             onPressed: () => Navigator.pop(context, true),
///             child: Text('Discard'),
///           ),
///         ],
///       ),
///     );
///     return shouldPop ?? false;
///   }
/// }
/// ```
///
/// **Note:** Guards are consulted during:
/// - [NavigationPath.pop] and [Coordinator.tryPop]
/// - Browser back button navigation
/// - [IndexedStackPath.goToIndexed] when leaving the current tab
mixin RouteGuard on RouteTarget {
  // coverage:ignore-start
  /// Called when the route is about to be popped.
  ///
  /// Return `true` to allow the pop, or `false` to prevent it.
  /// This can be async to show dialogs or perform validation.
  ///
  /// **Important:** This method should not have side effects beyond
  /// showing UI (like dialogs). The actual pop happens after this returns.
  FutureOr<bool> popGuard() => true;
  // coverage:ignore-end

  /// Called when the route is about to be popped, with coordinator access.
  ///
  /// This variant provides access to the [Coordinator] for routes that need
  /// to check application state or access dependencies during the guard check.
  ///
  /// **Coordinator Binding:**
  /// The assertion ensures the route's path was created with the same coordinator
  /// that is handling the navigation. This prevents bugs where routes are
  /// accidentally managed by the wrong coordinator.
  ///
  /// **Example - State-dependent guard:**
  /// ```dart
  /// @override
  /// FutureOr<bool> popGuardWith(AppCoordinator coordinator) async {
  ///   // Access app state through coordinator
  ///   if (coordinator.authState.isLoggingOut) {
  ///     return false; // Prevent navigation during logout
  ///   }
  ///   return popGuard();
  /// }
  /// ```
  FutureOr<bool> popGuardWith(covariant Coordinator coordinator) {
    assert(stackPath?.coordinator == coordinator, '''
[RouteGuard] The path [${stackPath.toString()}] is associated with a different coordinator (or null) than the one currently handling the navigation.
Expected coordinator: $coordinator
Path's coordinator: ${stackPath?.coordinator}
Ensure that the path is created with the correct coordinator using `.createWith()` and that routes are being managed by the correct coordinator.
''');
    return popGuard();
  }
}



================================================
FILE: packages/zenrouter/lib/src/mixin/layout.dart
================================================
import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

/// Mixin for routes that define a layout structure.
///
/// A layout is a route that wraps other routes, such as a shell or a tab bar.
/// It defines how its children are displayed and managed.
mixin RouteLayout<T extends RouteUnique> on RouteUnique {
  /// Registers a custom layout constructor.
  ///
  /// Use this to define how a specific layout type should be instantiated.
  static void defineLayout<T extends RouteLayout>(
    Type layout,
    T Function() constructor,
  ) {
    RouteLayout.layoutConstructorTable[layout] = constructor;
    final layoutInstance = constructor();
    layoutInstance.completeOnResult(null, null, true);
    RouteLayout._reflectionLayoutType[layoutInstance.runtimeType.toString()] =
        layoutInstance.runtimeType;
  }

  /// Table of registered layout constructors.
  static Map<Type, RouteLayoutConstructor> layoutConstructorTable = {};

  static final Map<String, Type> _reflectionLayoutType = {};
  static RouteLayout deserialize(Map<String, dynamic> value) {
    final type = _reflectionLayoutType[value['value'] as String];
    if (type == null) {
      throw UnimplementedError(
        'The [${value['value']}] layout isn\'t defined. You must define it using RouteLayout.defineLayout',
      );
    }
    return RouteLayout.layoutConstructorTable[type]!();
  }

  /// Table of registered layout builders.
  ///
  /// This maps layout identifiers to their widget builder functions.
  static final Map<PathKey, RouteLayoutBuilder> _layoutBuilderTable = {
    NavigationPath.key: (coordinator, path, layout) {
      final restorationId = switch (layout) {
        RouteUnique route => coordinator.resolveRouteId(route),
        _ => coordinator.rootRestorationId,
      };

      return NavigationStack(
        path: path as NavigationPath<RouteUnique>,
        navigatorKey: layout == null
            ? coordinator.routerDelegate.navigatorKey
            : null,
        coordinator: coordinator,
        restorationId: restorationId,
        resolver: (route) {
          switch (route) {
            case RouteTransition():
              return route.transition(coordinator);
            default:
              final routeRestorationId = coordinator.resolveRouteId(route);
              final builder = Builder(
                builder: (context) => route.build(coordinator, context),
              );
              return switch (coordinator.transitionStrategy) {
                DefaultTransitionStrategy.material => StackTransition.material(
                  builder,
                  restorationId: routeRestorationId,
                ),
                DefaultTransitionStrategy.cupertino =>
                  StackTransition.cupertino(
                    builder,
                    restorationId: routeRestorationId,
                  ),
                DefaultTransitionStrategy.none => StackTransition.none(
                  builder,
                  restorationId: routeRestorationId,
                ),
              };
          }
        },
      );
    },
    IndexedStackPath.key: (coordinator, path, layout, [restorationId]) =>
        ListenableBuilder(
          listenable: path,
          builder: (context, child) {
            final indexedStackPath = path as IndexedStackPath<RouteUnique>;
            return IndexedStackPathBuilder(
              path: indexedStackPath,
              coordinator: coordinator,
              restorationId: restorationId,
            );
          },
        ),
  };

  static Widget buildRoot(Coordinator coordinator) {
    final rootPathKey = coordinator.root.pathKey;

    if (!_layoutBuilderTable.containsKey(rootPathKey)) {
      // coverage:ignore-start
      throw UnimplementedError(
        'No layout builder provided for [${rootPathKey.key}]. If you extend the [StackPath] class, you must register it via [RouteLayout.definePath] to use [RouteLayout.buildRoot].',
      );
      // coverage:ignore-end
    }

    return _layoutBuilderTable[rootPathKey]!(
      coordinator,
      coordinator.root,
      null,
    );
  }

  /// Build the layout for this route.
  Widget buildPath(covariant Coordinator coordinator) {
    final path = resolvePath(coordinator);

    if (!_layoutBuilderTable.containsKey(path.pathKey)) {
      throw UnimplementedError(
        'No layout builder provided for [${path.pathKey.key}]. If you extend the [StackPath] class, you must register it via [RouteLayout.definePath] to use [RouteLayout.buildPath].',
      );
    }
    return _layoutBuilderTable[path.pathKey]!(coordinator, path, this);
  }

  // coverage:ignore-start
  /// Registers a custom layout builder.
  ///
  /// Use this to define how a specific layout type should be built.
  static void definePath(PathKey key, RouteLayoutBuilder builder) =>
      _layoutBuilderTable[key] = builder;
  // coverage:ignore-end

  /// Resolves the stack path for this layout.
  ///
  /// This determines which [StackPath] this layout manages.
  StackPath<RouteUnique> resolvePath(covariant Coordinator coordinator);

  // coverage:ignore-start
  /// RouteLayout does not use a URI.
  @override
  Uri toUri() => Uri.parse('/__layout/$runtimeType');
  // coverage:ignore-end

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) =>
      buildPath(coordinator);

  @override
  void onDidPop(Object? result, covariant Coordinator? coordinator) {
    super.onDidPop(result, coordinator);
    assert(
      coordinator != null,
      '[RouteLayout] must be used with a [Coordinator]',
    );
    resolvePath(coordinator!).reset();
  }

  @override
  operator ==(Object other) => other.runtimeType == runtimeType;

  @override
  int get hashCode => runtimeType.hashCode;

  Map<String, dynamic> serialize() => {
    'type': 'layout',
    'value': runtimeType.toString(),
  };
}

extension RouteLayoutBinding<T extends RouteUnique> on StackPath<T> {
  void bindLayout(RouteLayoutConstructor constructor) {
    final instance = constructor()..onDiscard();
    RouteLayout.defineLayout(instance.runtimeType, constructor);
  }
}



================================================
FILE: packages/zenrouter/lib/src/mixin/query_parameters.dart
================================================
import 'package:flutter/widgets.dart';
import 'package:zenrouter/src/coordinator/base.dart';

import 'unique.dart';

/// Mixin for routes that support query parameters.
///
/// This mixin provides a [ValueNotifier] for queries that allows widgets to
/// rebuild only when query parameters change, not on every coordinator update.
///
/// **Example usage:**
/// ```dart
/// class ProductListRoute extends RouteTarget
///     with RouteUnique, RouteQueryParameter {
///   @override
///   final ValueNotifier<Map<String, String>> queryNotifier =
///       ValueNotifier({});
///
///   void setPage(int page, AppCoordinator coordinator) {
///     updateQueries(coordinator, queries: {'page': '$page'});
///   }
/// }
///
/// // In build method, use ValueListenableBuilder for targeted rebuilds:
/// ValueListenableBuilder(
///   valueListenable: queryNotifier,
///   builder: (context, queries, child) => Text('Page: ${queries['page']}'),
/// )
/// ```
///
/// **Note:** Query parameters are intentionally excluded from [RouteTarget.props]
/// so that changing queries does not affect route identity. This allows updating
/// the URL without triggering navigation transitions.
mixin RouteQueryParameters on RouteUnique {
  /// ValueNotifier for query parameters.
  ///
  /// Use this with [ValueListenableBuilder] to rebuild widgets only when
  /// queries change, rather than listening to the entire coordinator.
  ValueNotifier<Map<String, String>> get queryNotifier;

  /// Current query parameters.
  Map<String, String> get queries => queryNotifier.value;

  /// Sets new query parameters.
  set queries(Map<String, String> value) => queryNotifier.value = value;

  /// Get a query parameter by name.
  ///
  /// Returns null if the parameter is not present.
  String? query(String name) => queries[name];

  Widget selectorBuilder<T>({
    required T Function(Map<String, String> queries) selector,
    required Widget Function(BuildContext context, T value) builder,
  }) => _QuerySelectorBuilder<T>(
    notifier: queryNotifier,
    selector: selector,
    builder: builder,
  );

  /// Updates the query parameters and notifies listeners.
  ///
  /// This updates both:
  /// - [queryNotifier] for widget rebuilds (targeted)
  /// - [coordinator] for URL sync
  ///
  /// **Example:**
  /// ```dart
  /// // Replace all queries
  /// updateQueries(coordinator, queries: {'page': '2', 'sort': 'asc'});
  ///
  /// // Add/modify a single query while keeping others
  /// updateQueries(coordinator, queries: {...queries, 'filter': 'active'});
  /// ```
  void updateQueries(
    covariant Coordinator coordinator, {
    required Map<String, String> queries,
  }) {
    queryNotifier.value = queries;
    // If current route is not active, navigate to it
    if (coordinator.activePath.activeRoute != this) {
      coordinator.navigate(this);
    }
    coordinator.markNeedRebuild(); // Sync browser URL
  }

  @override
  void onDiscard() {
    super.onDiscard();
    queryNotifier.dispose();
  }

  @override
  void onUpdate(covariant RouteQueryParameters newRoute) {
    super.onUpdate(newRoute);
    queryNotifier.value = newRoute.queries;
  }
}

class _QuerySelectorBuilder<T> extends StatefulWidget {
  const _QuerySelectorBuilder({
    required this.notifier,
    required this.selector,
    required this.builder,
  });

  final ValueNotifier<Map<String, String>> notifier;
  final T Function(Map<String, String>) selector;
  final Widget Function(BuildContext, T) builder;

  @override
  State<_QuerySelectorBuilder<T>> createState() =>
      _QuerySelectorBuilderState<T>();
}

class _QuerySelectorBuilderState<T> extends State<_QuerySelectorBuilder<T>> {
  late T _selectedValue;

  @override
  void initState() {
    super.initState();
    _selectedValue = widget.selector(widget.notifier.value);
    widget.notifier.addListener(_onNotifierChanged);
  }

  @override
  void dispose() {
    widget.notifier.removeListener(_onNotifierChanged);
    super.dispose();
  }

  void _onNotifierChanged() {
    final newValue = widget.selector(widget.notifier.value);
    if (newValue != _selectedValue) {
      setState(() => _selectedValue = newValue);
    }
  }

  @override
  Widget build(BuildContext context) => widget.builder(context, _selectedValue);
}



================================================
FILE: packages/zenrouter/lib/src/mixin/redirect.dart
================================================
import 'dart:async';

import 'package:zenrouter/zenrouter.dart';

/// A mixin that provides redirection logic for routes.
///
/// `RouteRedirect` allows a route to specify another route to navigate to
/// instead of itself. This is commonly used for:
/// - **Authentication**: Redirecting unauthenticated users to a login page.
/// - **Permissions**: Redirecting users to an "Access Denied" page.
/// - **Aliases**: Mapping old route definitions to new ones.
///
/// When a route with this mixin is resolved by the [Coordinator], it calls
/// [redirect] (or [redirectWith]) to determine the final target. If multiple
/// redirects are chained, they are followed sequentially until a non-redirecting
/// route is reached.
///
/// **Example - Authentication Redirect:**
/// ```dart
/// class ProfileRoute extends RouteTarget with RouteUnique, RouteRedirect<AppRoute> {
///   @override
///   FutureOr<AppRoute?> redirectWith(AppCoordinator coordinator) {
///     // Check authentication state
///     if (!coordinator.authService.isLoggedIn) {
///       return LoginRoute(returnTo: this);
///     }
///     // Return self to stop redirection and navigate here
///     return this;
///   }
/// }
/// ```
///
/// **Example - Chained Redirects:**
/// ```dart
/// class OldDashboardRoute extends RouteTarget with RouteUnique, RouteRedirect<AppRoute> {
///   @override
///   FutureOr<AppRoute?> redirect() => NewDashboardRoute();
/// }
///
/// class NewDashboardRoute extends RouteTarget with RouteUnique, RouteRedirect<AppRoute> {
///   @override
///   FutureOr<AppRoute?> redirect() => this; // Stop here
/// }
/// ```
///
/// **Redirect Resolution Order:**
/// 1. Framework calls [redirectWith] (or [redirect] if no coordinator)
/// 2. If result is `null`, redirection is cancelled (user handled navigation manually)
/// 3. If result is `this`, navigation proceeds to this route
/// 4. If result is another route, process repeats with the new route
mixin RouteRedirect<T extends RouteTarget> on RouteTarget {
  /// Resolves the final destination route by following any redirects.
  ///
  /// This method is used internally by the framework to find the ultimate [RouteTarget].
  /// It follows the [redirect] chain until it reaches a route that doesn't redirect.
  ///
  /// **Error Handling:**
  /// If any redirect throws an exception, it propagates up to the caller
  /// (typically [Coordinator.push] or [Coordinator.replace]).
  static Future<T?> resolve<T extends RouteTarget>(
    T route,
    Coordinator? coordinator,
  ) async {
    T target = route;
    while (target is RouteRedirect) {
      final redirect = target as RouteRedirect;
      final newTarget = await switch (coordinator) {
        null => redirect.redirect(),
        final coordinator => redirect.redirectWith(coordinator),
      };

      // If redirect returns null, stop redirection and return null so the
      // navigation is cancelled.
      if (newTarget == null) {
        // Discard the target route since it was not used
        target.onDiscard();
        return null;
      }

      // If it redirects to itself, we've found our destination
      if (newTarget == target) break;

      if (newTarget is T) {
        // Discard the target route since it was not used
        target.onDiscard();
        target = newTarget;
      }
    }
    return target;
  }

  // coverage:ignore-start
  /// Defines the redirection target for this route.
  ///
  /// Implement this method to return:
  /// - `null`: Redirect was handled manually by user code (e.g., you called
  ///   [Coordinator.push] yourself). Framework stops and uses original route.
  /// - `this`: Stop here and navigate to this route.
  /// - `anotherRoute`: Continue redirection with the new target.
  ///
  /// **Async Support:**
  /// This method returns [FutureOr], allowing async operations like
  /// checking server state or loading data before determining the target.
  FutureOr<T> redirect() => this as T;
  // coverage:ignore-end

  /// Called when the route is being resolved, providing access to the [Coordinator].
  ///
  /// This variant is preferred when redirection logic depends on application state
  /// or services accessible via the coordinator.
  ///
  /// **Example:**
  /// ```dart
  /// @override
  /// FutureOr<AppRoute?> redirectWith(AppCoordinator coordinator) async {
  ///   final user = await coordinator.userService.getCurrentUser();
  ///   if (user == null) return LoginRoute();
  ///   if (!user.hasPermission('admin')) return AccessDeniedRoute();
  ///   return this;
  /// }
  /// ```
  ///
  /// Default implementation calls [redirect].
  FutureOr<T?> redirectWith(covariant Coordinator coordinator) => redirect();
}



================================================
FILE: packages/zenrouter/lib/src/mixin/redirect_rule.dart
================================================
import 'dart:async';

import 'package:zenrouter/zenrouter.dart';

/// Result of a redirect rule that determines what happens next.
///
/// **3 types of results:**
/// - [StopRedirect]: Stop navigation, prevent route from being displayed
/// - [ContinueRedirect]: Continue processing the next rule in the chain
/// - [RedirectTo]: Redirect to a different route instead of the original one
///
/// **Sealed class**: Ensures switch/case handles all possible cases.
///
/// **Example:**
/// ```dart
/// class AuthRule extends RedirectRule<AppRoute> {
///   @override
///   FutureOr<RedirectResult<AppRoute>> redirectResult(
///     Coordinator coordinator,
///     AppRoute route,
///   ) {
///     if (!isAuthenticated) {
///       return RedirectResult.redirectTo(LoginRoute()); // Redirect
///     }
///     return const RedirectResult.continueRedirect(); // Continue
///   }
/// }
/// ```
sealed class RedirectResult<T extends RouteTarget> {
  const RedirectResult();

  /// Create a "stop navigation" result - prevents route from being displayed.
  ///
  /// **When to use:**
  /// - User doesn't have access permission
  /// - Feature is disabled
  /// - Required conditions are not met
  const factory RedirectResult.stop() = StopRedirect;

  /// Create a "continue" result - proceed to the next rule.
  ///
  /// **When to use:**
  /// - Conditions are met, allow continuation
  /// - Rule only does side effects (logging, analytics)
  /// - Need to combine multiple rules
  const factory RedirectResult.continueRedirect() = ContinueRedirect;

  /// Create a "redirect" result - navigate to a different route.
  ///
  /// **When to use:**
  /// - Not logged in → redirect to login
  /// - Permission denied → redirect to error page
  /// - Route deprecated → redirect to new route
  const factory RedirectResult.redirectTo(T route) = RedirectTo;
}

/// Stop navigation result - route will not be displayed.
///
/// Navigation will be cancelled, user stays on the current screen.
class StopRedirect<T extends RouteTarget> extends RedirectResult<T> {
  // coverage:ignore-start
  const StopRedirect();
  // coverage:ignore-end
}

/// Continue result - proceed to the next rule in the chain.
///
/// If this is the last rule, the original route will be displayed.
class ContinueRedirect<T extends RouteTarget> extends RedirectResult<T> {
  // coverage:ignore-start
  const ContinueRedirect();
  // coverage:ignore-end
}

/// Redirect result - replace the original route with a different one.
///
/// The new route will be displayed instead of the original route.
class RedirectTo<T extends RouteTarget> extends RedirectResult<T> {
  const RedirectTo(this.route);

  /// The destination route to redirect to.
  final T route;
}

/// Base class for reusable redirect rules.
///
/// **Benefits of the Rule-based approach:**
/// - **Reusable**: One rule can be used for multiple routes
/// - **Composable**: Chain multiple rules together (auth → feature flag → logging)
/// - **Testable**: Test each rule independently
/// - **Maintainable**: Centralized redirect logic, easy to modify
///
/// **Common rule types:**
/// - Authentication: Check login status
/// - Authorization: Check access permissions
/// - Feature Flags: Check if feature is enabled
/// - Logging/Analytics: Log navigation events
/// - A/B Testing: Redirect based on experiments
///
/// **Example - Authentication Rule:**
/// ```dart
/// class AuthenticationRule extends RedirectRule<AppRoute> {
///   @override
///   FutureOr<RedirectResult<AppRoute>> redirectResult(
///     Coordinator coordinator,
///     AppRoute route,
///   ) {
///     if (!AuthService.isAuthenticated) {
///       // Not logged in → redirect to login page
///       return RedirectResult.redirectTo(LoginRoute());
///     }
///     // Logged in → continue
///     return const RedirectResult.continueRedirect();
///   }
/// }
/// ```
///
/// **Example - Feature Flag Rule:**
/// ```dart
/// class FeatureFlagRule extends RedirectRule<AppRoute> {
///   final String feature;
///   FeatureFlagRule({required this.feature});
///
///   @override
///   FutureOr<RedirectResult<AppRoute>> redirectResult(
///     Coordinator coordinator,
///     AppRoute route,
///   ) async {
///     final isEnabled = await FeatureService.isEnabled(feature);
///     if (!isEnabled) {
///       return RedirectResult.stop(); // Stop navigation
///     }
///     return const RedirectResult.continueRedirect();
///   }
/// }
/// ```
abstract class RedirectRule<T extends RouteTarget> {
  /// Determines the redirect result for a specific route.
  ///
  /// **Parameters:**
  /// - [coordinator]: Access coordinator methods and state
  /// - [route]: Route being navigated to
  ///
  /// **Returns:**
  /// - [StopRedirect]: Stop navigation
  /// - [ContinueRedirect]: Continue to next rule
  /// - [RedirectTo]: Redirect to a different route
  ///
  /// This method can be async to call APIs, read from database, etc.
  FutureOr<RedirectResult<T>> redirectResult(
    covariant Coordinator coordinator,
    covariant T route,
  );
}

/// Mixin that allows a route to use a list of redirect rules.
///
/// **Usage:**
/// ```dart
/// class ProtectedRoute extends AppRoute
///     with RouteRedirect, RouteRedirectRule {
///   @override
///   List<RedirectRule> get redirectRules => [
///         AuthenticationRule(),           // Check login first
///         FeatureFlagRule(feature: 'new'), // Then check feature flag
///         LoggingRule(),                   // Finally log
///       ];
/// }
/// ```
///
/// **Execution order:**
/// Rules are executed in list order. If any rule returns
/// [StopRedirect] or [RedirectTo], subsequent rules won't run.
///
/// **Chain Flow:**
/// ```
/// Rule 1 → ContinueRedirect
///   ↓
/// Rule 2 → ContinueRedirect
///   ↓
/// Rule 3 → RedirectTo(LoginRoute) → STOP, redirect immediately
/// Rule 4 → Never executed
/// ```
mixin RouteRedirectRule<T extends RouteTarget> on RouteRedirect<T> {
  /// List of rules applied to this route.
  ///
  /// **Order matters:**
  /// - Critical rules (auth, permissions) should come first
  /// - Side-effect rules (logging) should come last
  List<RedirectRule> get redirectRules;

  /// Implementation of RouteRedirect.redirectWith() - runs all rules.
  ///
  /// **Processing flow:**
  /// 1. Iterate through each rule in order
  /// 2. Call rule's `redirectResult()`
  /// 3. Handle result:
  ///    - StopRedirect: Return null (cancel navigation)
  ///    - ContinueRedirect: Move to next rule
  ///    - RedirectTo: Return new route (stop chain)
  /// 4. If all rules continue: Return original route
  @override
  FutureOr<T?> redirectWith(covariant Coordinator coordinator) async {
    for (final rule in redirectRules) {
      final result = await rule.redirectResult(coordinator, this as T);
      switch (result) {
        case StopRedirect():
          return null; // Cancel navigation
        case ContinueRedirect():
          continue; // Next rule
        case RedirectTo():
          return result.route as T; // Redirect immediately
      }
    }
    return this as T; // All rules passed → display original route
  }
}



================================================
FILE: packages/zenrouter/lib/src/mixin/restoration.dart
================================================
import 'package:zenrouter/zenrouter.dart';

/// Defines the strategy used to serialize and deserialize a route for state restoration.
///
/// ## What This Enum Represents
///
/// When Flutter needs to save your app's navigation state (for example, when the operating
/// system terminates your app to free memory), each route in the navigation stack must be
/// converted to a format that can be persisted. This enum determines which serialization
/// strategy ZenRouter uses for a particular route type.
///
/// ## The Two Strategies
///
/// **[unique]** - URI-based serialization:
/// This strategy serializes routes by converting them to their URI representation using
/// [RouteUnique.toUri]. The URI string is saved, and during restoration, the string is
/// parsed back into a route using your coordinator's [Coordinator.parseRouteFromUri] method.
/// This is the default and simplest strategy, suitable for routes where all necessary
/// information can be encoded in the URL path and query parameters.
///
/// **[converter]** - Custom serialization:
/// This strategy uses a custom [RestorableConverter] that you implement to serialize and
/// deserialize the route. This is necessary when your route contains complex data that
/// cannot (or should not) be represented in a URI, such as in-memory objects, computed
/// state, or data that's too large for a URL.
///
/// ## When to Use Each Strategy
///
/// Use **[unique]** when:
/// - Your route can be fully represented by its URI (path and query parameters)
/// - You want the simplest implementation with no custom serialization code
/// - The route's state can be reconstructed from the URL alone
/// - Examples: `/home`, `/products/123`, `/search?q=laptop`
///
/// Use **[converter]** when:
/// - Your route contains complex objects that can't be in a URL
/// - You need to preserve in-memory state like form data or user selections
/// - The amount of data is too large to reasonably fit in a URL
/// - You want explicit control over what gets saved and restored
/// - Examples: Routes with shopping cart items, complex filter objects, or rich text content
///
/// See also:
/// - [RouteRestorable] mixin for implementing restorable routes
/// - [RestorableConverter] for creating custom serializers
enum RestorationStrategy { unique, converter }

/// A mixin that enables custom state restoration for routes that cannot be fully represented by a URI.
///
/// ## What This Mixin Does
///
/// [RouteRestorable] extends [RouteTarget] to provide explicit control over how a route is
/// serialized to and deserialized from restoration data. While [RouteUnique] routes can only
/// be saved as URI strings, [RouteRestorable] routes can preserve arbitrary complex state
/// through custom serialization logic. This is essential for routes that carry rich data
/// objects, computed state, or information that doesn't belong in a URL.
///
/// ## Where to Use This Mixin
///
/// Apply this mixin to any route class that needs to preserve state beyond what can be
/// encoded in a URI. This is particularly common for:
/// - Detail pages with complex loaded data (avoiding refetching on restore)
/// - Routes with form state or user input that's not yet submitted
/// - Routes with computed or derived state that's expensive to recreate
/// - Routes with objects from your domain model (products, users, documents, etc.)
///
/// ## When Restoration Happens
///
/// **Serialization** ([serialize] is called):
/// Whenever the coordinator's state changes and Flutter needs to save navigation state to
/// the restoration bucket. This happens automatically in the background, typically when the
/// app goes to the background, the user switches to another app, or the system needs to free memory.
///
/// **Deserialization** ([deserialize] is called):
/// During app launch when Flutter detects existing restoration data. This happens when the system
/// restores your app after terminating it, when the user force-quits and relaunches the app
/// (on some platforms), or during development when hot restart occurs with restoration enabled.
///
/// ## How to Implement Custom Restoration
///
/// Complete implementation example combining all required pieces:
///
/// ```dart
/// // 1. Define your route with RouteRestorable
/// class BookDetailRoute extends AppRoute with RouteRestorable<BookDetailRoute> {
///   BookDetailRoute({required this.book});
///
///   final Book book;  // Complex object that can't be in URL
///
///   @override
///   RestorationStrategy get strategy => RestorationStrategy.converter;
///
///   @override
///   RestorableConverter<BookDetailRoute> get converter => const BookDetailConverter();
///
///   @override
///   String get restorationId => 'book_${book.id}';
///
///   @override
///   Uri toUri() => Uri.parse('/books/${book.id}');
/// }
///
/// // 2. Implement the converter
/// class BookDetailConverter extends RestorableConverter<BookDetailRoute> {
///   const BookDetailConverter();
///
///   @override
///   String get key => 'book_detail';
///
///   @override
///   Map<String, dynamic> serialize(BookDetailRoute route) => {
///     'id': route.book.id,
///     'title': route.book.title,
///     'author': route.book.author,
///   };
///
///   @override
///   BookDetailRoute deserialize(Map<String, dynamic> data) => BookDetailRoute(
///     book: Book(
///       id: data['id'],
///       title: data['title'],
///       author: data['author'],
///     ),
///   );
/// }
///
/// // 3. Register in your coordinator
/// class AppCoordinator extends Coordinator<AppRoute> {
///   @override
///   void defineConverter() {
///     RestorableConverter.defineConverter('book_detail', BookDetailConverter.new);
///   }
/// }
/// ```
///
/// ## Important Considerations
///
/// **Converter keys must be globally unique and stable:** Never change a converter's key in
/// production as it will break restoration for existing users. Prefix keys with your app or
/// package name to avoid collisions.
///
/// **Serialize efficiently:** Only serialize the minimum data needed to reconstruct the route.
/// Large serialized data slows down app startup during restoration.
///
/// **Handle missing data gracefully:** Your deserialize method should handle cases where data
/// might be missing or invalid from older app versions. Provide sensible defaults or fail gracefully.
///
/// See also:
/// - [RestorableConverter] for implementing the serialization logic
/// - [RestorationStrategy] for understanding the available strategies
/// - [CoordinatorRestorable] for the overall restoration orchestration
mixin RouteRestorable<T extends RouteTarget> on RouteTarget {
  /// Serializes a [RouteRestorable] route into a map that can be persisted.
  ///
  /// This static method is called internally by the restoration system to convert a route
  /// into a format that can be saved to the restoration bucket. It inspects the route's
  /// [restorationStrategy] and delegates to either URI-based or converter-based serialization.
  Map<String, dynamic> serialize() => {
    'strategy': restorationStrategy.name,
    if (restorationStrategy == RestorationStrategy.converter) ...{
      'converter': converter.key,
      'value': converter.serialize(this as T),
    } else if (restorationStrategy == RestorationStrategy.unique &&
        this is RouteUnique) ...{
      'value': (this as RouteUnique).toUri().toString(),
    },
  };

  /// Deserializes restoration data back into a [RouteTarget] instance.
  ///
  /// This static method is called during app startup when restoration data exists. It
  /// examines the [data] map to determine which restoration strategy was used and
  /// then delegates to the appropriate deserialization method.
  ///
  /// For [RestorationStrategy.unique] routes, it requires a [parseRouteFromUri] function
  /// to convert the saved URI string back into a route object.
  ///
  /// For [RestorationStrategy.converter] routes, it looks up the converter by key and
  /// uses it to deserialize the route.
  static T deserialize<T extends RouteTarget>(
    Map<String, dynamic> data, {
    required RouteUriParserSync<T>? parseRouteFromUri,
  }) {
    final rawStrategy = data['strategy'];
    if (rawStrategy == null || rawStrategy is! String) {
      throw UnimplementedError();
    }
    final strategy = RestorationStrategy.values.asNameMap()[rawStrategy]!;
    assert(
      (strategy == RestorationStrategy.converter ||
          (strategy == RestorationStrategy.unique &&
              parseRouteFromUri != null)),
      'Invalid strategy: $strategy or parseRouteFromUri is null when parsing .unique strategy',
    );
    switch (strategy) {
      case RestorationStrategy.unique:
        final value = parseRouteFromUri!(Uri.parse(data['value']! as String));
        if (value is Future) throw UnimplementedError();
        return value;
      case RestorationStrategy.converter:
        final converter = RestorableConverter.buildConverter(
          data['converter']! as String,
        );
        if (converter == null) throw UnimplementedError();
        final route = converter.deserialize((data['value']! as Map).cast());
        return route as T;
    }
  }

  // coverage:ignore-start
  /// The restoration strategy to use for this route.
  ///
  /// Defaults to [RestorationStrategy.unique], which serializes the route using its URI.
  /// Override to return [RestorationStrategy.converter] when you need custom serialization.
  RestorationStrategy get restorationStrategy => RestorationStrategy.unique;

  /// The converter to use when [restorationStrategy] is [RestorationStrategy.converter].
  ///
  /// This getter must be overridden (it throws [UnimplementedError] by default) when using
  /// custom serialization. Return an instance of your [RestorableConverter] implementation.
  RestorableConverter<T> get converter => throw UnimplementedError();
  // coverage:ignore-end

  /// The unique identifier for this route in the restoration system.
  ///
  /// This must be unique within your application and stable across app versions. It's used
  /// by Flutter's restoration framework to associate saved state with route instances.
  String get restorationId;
}

/// An abstract base class for implementing custom serialization logic for routes.
///
/// ## What This Class Does
///
/// [RestorableConverter] provides the interface for converting route objects to and from
/// primitive data types that can be persisted by Flutter's restoration framework. When a
/// route implements [RouteRestorable] with [RestorationStrategy.converter], it must provide
/// a converter that knows how to break down the route into serializable data (maps, lists,
/// strings, numbers) and reconstruct it from that same data structure.
///
/// ## Where It Fits in the Architecture
///
/// Converters are registered globally in your [Coordinator] via [defineConverter] during
/// initialization. When the restoration system needs to serialize or deserialize a route,
/// it looks up the converter by its unique key and delegates the work to it. This architecture
/// allows converters to be reused across different parts of your application and provides
/// a centralized registry for all custom serialization logic.
///
/// The registration and usage flow:
/// ```
/// App startup:
///   Coordinator.defineConverter() registers converters
///     └─ RestorableConverter.defineConverter('key', constructor)
///         └─ Stored in global _converterTable
///
/// During restoration:
///   RouteRestorable.deserialize(data)
///     └─ RestorableConverter.buildConverter(key)
///         └─ Lookup in _converterTable
///             └─ Call converter.deserialize(data)
/// ```
///
/// ## When This Gets Called
///
/// **[serialize]** is invoked:
/// When the coordinator's navigation state changes and Flutter needs to persist the current
/// state to the restoration bucket. This happens automatically in the background, typically
/// whenever routes are pushed, popped, or their state changes, and the app is in a state
/// where it might be terminated by the system.
///
/// **[deserialize]** is invoked:
/// During app startup, before the first frame is rendered, when Flutter detects existing
/// restoration data. The restoration system calls this method to reconstruct route objects
/// from the previously saved primitive data, allowing the app to return to the exact state
/// it was in before termination.
///
/// ## How to Implement a Custom Converter
///
/// Create a subclass of [RestorableConverter] and implement the three required members:
///
/// ```dart
/// class UserProfileConverter extends RestorableConverter<UserProfileRoute> {
///   const UserProfileConverter();
///
///   // 1. Provide a unique, stable key for this converter
///   @override
///   String get key => 'myapp_user_profile';
///
///   // 2. Convert route to serializable data
///   @override
///   Map<String, dynamic> serialize(UserProfileRoute route) {
///     return {
///       'userId': route.user.id,
///       'userName': route.user.name,
///       'userEmail': route.user.email,
///       'viewMode': route.viewMode.name,  // enum serialized as string
///     };
///   }
///
///   // 3. Reconstruct route from serialized data
///   @override
///   UserProfileRoute deserialize(Map<String, dynamic> data) {
///     return UserProfileRoute(
///       user: User(
///         id: data['userId'] as String,
///         name: data['userName'] as String,
///         email: data['userEmail'] as String,
///       ),
///       viewMode: ViewMode.values.byName(data['viewMode'] as String),
///     );
///   }
/// }
/// ```
///
/// Then register it in your coordinator:
///
/// ```dart
/// class AppCoordinator extends Coordinator<AppRoute> {
///   @override
///   void defineConverter() {
///     RestorableConverter.defineConverter(
///       'myapp_user_profile',
///       () => const UserProfileConverter(),
///     );
///   }
/// }
/// ```
///
/// ## Important Implementation Guidelines
///
/// **Keys must be globally unique:** The [key] getter must return a string that uniquely
/// identifies this converter across your entire application and all installed packages.
/// Use a prefix like your app or package name to avoid collisions with third-party code.
///
/// **Keys must never change:** Once deployed to production, never change a converter's key.
/// Changing it will cause restoration to fail for users who have saved state with the old
/// key. If you need to change the serialization format, add versioning within your converter
/// instead of changing the key.
///
/// **Only serialize necessary data:** The [serialize] method should only output the minimum
/// data needed to reconstruct the route. Avoid serializing computed values, large objects,
/// or anything that can be derived or refetched. Remember that this data is saved to disk
/// and loaded synchronously at startup, so excessive data will slow down app launch.
///
/// **Handle version changes gracefully:** Your [deserialize] method should be defensive
/// about missing or unexpected data. Users might restore from data saved by an older version
/// of your app, so handle missing fields with sensible defaults:
///
/// ```dart
/// @override
/// MyRoute deserialize(Map<String, dynamic> data) {
///   return MyRoute(
///     id: data['id'] as String,
///     // Provide default for fields that might be missing in old data
///     newField: data['newField'] as String? ?? 'default_value',
///   );
/// }
/// ```
///
/// **Use const constructors:** Converters should be stateless and use const constructors
/// for better performance. The same converter instance can be used for multiple serialization
/// and deserialization operations.
///
/// ## Global Registry Pattern
///
/// The converter registry is a global singleton map that associates converter keys with
/// constructor functions. This design allows converters to be registered once during app
/// initialization and then efficiently looked up during restoration without maintaining
/// references to coordinator instances or other complex state management.
///
/// See also:
/// - [RouteRestorable] for implementing routes that use converters
/// - [RestorationStrategy.converter] for when to use custom serialization
abstract class RestorableConverter<T extends Object> {
  // coverage:ignore-start
  const RestorableConverter();
  // coverage:ignore-end

  /// The global registry mapping converter keys to their constructor functions.
  ///
  /// This table is populated during app initialization via [defineConverter] and queried
  /// during restoration via [buildConverter]. It persists for the entire application lifetime.
  static final Map<String, RestoratableConverterConstructor> _converterTable =
      {};

  /// Registers a converter in the global registry.
  ///
  /// Call this method during coordinator initialization ([Coordinator.defineConverter]) to
  /// make your custom converter available to the restoration system. The [key] must match
  /// the key returned by your converter's [key] getter, and the [constructor] should be a
  /// function that creates a new instance of your converter (typically a const constructor).
  ///
  /// Example:
  /// ```dart
  /// RestorableConverter.defineConverter(
  ///   'user_profile',
  ///   () => const UserProfileConverter(),
  /// );
  /// ```
  static void defineConverter<T extends Object>(
    String key,
    RestoratableConverterConstructor<T> constructor,
  ) => _converterTable[key] = constructor;

  /// Looks up and constructs a converter by its key.
  ///
  /// This method is called internally during route deserialization to find the appropriate
  /// converter for a given route type. Returns `null` if no converter is registered with
  /// the given [key], which typically indicates a configuration error or version mismatch.
  static RestorableConverter? buildConverter(String key) {
    if (!_converterTable.containsKey(key)) return null;
    return _converterTable[key]!();
  }

  /// The unique identifier for this converter.
  ///
  /// This key is used to store and retrieve converter instances from the global registry.
  /// It must be unique across your application and stable across app versions. Changing
  /// this key in a deployed app will break restoration for existing users.
  String get key;

  /// Converts a route into primitive data that can be persisted.
  ///
  /// The returned map should only contain primitive Dart types (String, int, double, bool,
  /// List, Map) that can be serialized by Flutter's restoration framework. Avoid complex
  /// objects, closures, or circular references.
  Map<String, dynamic> serialize(T route);

  /// Reconstructs a route from previously serialized data.
  ///
  /// This method receives the same map structure that was returned by [serialize] and must
  /// reconstruct the original route object. Handle missing or invalid data gracefully to
  /// support restoration from older app versions.
  T deserialize(Map<String, dynamic> data);
}



================================================
FILE: packages/zenrouter/lib/src/mixin/target.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/src/internal/equatable.dart';
import 'package:zenrouter/zenrouter.dart';

/// The base class for all navigation targets (routes).
///
/// A [RouteTarget] represents a destination in the app. It can hold state
/// and parameters. Every screen, dialog, or navigable destination should
/// extend this class.
///
/// ## Route Lifecycle
///
/// Routes go through distinct phases during their lifetime:
///
/// ```
/// ┌─────────────────────────────────────────────────────────────────────┐
/// │                        ROUTE LIFECYCLE                              │
/// ├─────────────────────────────────────────────────────────────────────┤
/// │  1. CREATION        → Route instance created (constructor called)   │
/// │  2. REDIRECT CHECK  → RouteRedirect.redirect() called if applicable │
/// │  3. PATH BINDING    → Route assigned to a StackPath (_path set)     │
/// │  4. BUILD           → build() called to create the widget           │
/// │  5. ACTIVE          → Route is visible and receiving interactions   │
/// │  6. POP REQUEST     → User/system requests pop (guard consulted)    │
/// │  7. POP COMPLETION  → onDidPop() + completeOnResult() called        │
/// │  8. CLEANUP         → Route removed from path, _path set to null    │
/// └─────────────────────────────────────────────────────────────────────┘
/// ```
///
/// ## Internal State
///
/// Routes maintain internal state managed by the framework:
/// - **`_path`**: The [StackPath] containing this route. Set during push.
/// - **`_onResult`**: A [Completer] that resolves when the route is popped.
/// - **`_resultValue`**: The result passed to [pop] before [onDidPop] is called.
/// - **`isPopByPath`**: Whether the pop was initiated by [StackPath.pop].
///
/// ## Result Handling
///
/// Routes can return a result when popped:
/// ```dart
/// // Pushing with result
/// final result = await coordinator.push<String>(SelectColorRoute());
/// print('Selected: $result');
///
/// // Popping with result (in route or widget)
/// coordinator.pop('blue');
/// ```
///
/// ## Equality
///
/// Override [props] to include route parameters in equality checks:
/// ```dart
/// class ProductRoute extends RouteTarget with RouteUnique {
///   final String productId;
///   ProductRoute(this.productId);
///
///   @override
///   List<Object?> get props => [productId];
/// }
/// ```
abstract class RouteTarget extends Equatable {
  /// Converts [RouteTarget] to primitive data
  ///
  /// This is called by Flutter's restoration framework when the app is being
  /// killed.
  ///
  /// Built-in Types supports:
  /// - [RouteLayout] - Serialize [RouteLayout]
  /// - [RouteRestorable] - Call custom `serialize` method
  /// - [RouteUnique] - Leverage `toUri` for serialization
  static Object serialize(RouteTarget value) => switch (value) {
    RouteLayout() => value.serialize(),
    RouteRestorable() => value.serialize(),
    RouteUnique() => value.toUri().toString(),
    _ => throw UnimplementedError(),
  };

  /// Converts saved primitive data back into a route object.
  ///
  /// This is called by Flutter's restoration framework when the app is being
  /// restored. It receives the data that was previously returned by [toPrimitives]
  /// and reconstructs the route stack.
  static T? deserialize<T extends RouteTarget>(
    Object value, {
    required RouteUriParserSync? parseRouteFromUri,
  }) => switch (value) {
    String() => parseRouteFromUri!(Uri.parse(value)) as T,
    Map() when value['type'] == 'layout' =>
      RouteLayout.deserialize(value.cast()) as T,
    Map() =>
      RouteRestorable.deserialize(
            value.cast(),
            parseRouteFromUri: parseRouteFromUri,
          )
          as T,
    // coverage:ignore-start
    _ => null,
    // coverage:ignore-end
  };

  /// Completer that resolves when this route is popped.
  ///
  /// The future completes with the result passed to [completeOnResult].
  /// This is set fresh each time the route is pushed.
  final Completer<Object?> _onResult = Completer();

  @protected
  @visibleForTesting
  /// The completer for the result of the route.
  /// DO NOT USE THIS MANUALLY. USE [completeOnResult] instead.
  Completer<Object?> get onResult => _onResult;

  /// The [StackPath] that currently contains this route.
  ///
  /// This is set when the route is pushed onto a path and cleared when popped.
  /// Used internally to ensure routes are managed by the correct path.
  StackPath? _path;

  /// The [StackPath] that currently contains this route.
  StackPath? get stackPath => _path;

  /// Binds the route to a path.
  ///
  /// This is called internally when the route is pushed onto a path.
  /// Useful when you want to create your custom [StackPath].
  @protected
  void bindStackPath(StackPath path) => _path = path;

  /// Clears the path binding.
  ///
  /// This is called internally when the route is removed from a path.
  @protected
  void clearStackPath() => _path = null;

  /// The result value to be returned when this route is popped.
  ///
  /// This is set by [StackPath.pop] before [onDidPop] is called, allowing
  /// the widget tree to access the result during disposal.
  Object? _resultValue;

  /// The result value to be returned when this route is popped.
  Object? get resultValue => _resultValue;

  @protected
  void bindResultValue(Object? value) => _resultValue = value;

  /// Whether this route was popped by the path mechanism.
  ///
  /// When `true`, the pop was initiated by [NavigationPath.pop] or similar.
  /// When `false`, the pop was initiated by the system (e.g., back button).
  ///
  /// This is used internally to prevent double removal from the stack.
  bool isPopByPath = false;

  /// Internal properties that are hardcoded and cannot be ignored.
  ///
  /// These are used for identity checks within the framework. Do not override.
  /// See [props] for user-defined equality properties.
  @override
  List<Object?> get internalProps => [runtimeType, _path, _onResult];

  /// The list of properties used for equality comparison.
  ///
  /// Override this to include route parameters in equality checks.
  /// Two routes are equal if they have the same type and equal [props].
  ///
  /// **Example:**
  /// ```dart
  /// class UserRoute extends RouteTarget with RouteUnique {
  ///   final int userId;
  ///   UserRoute(this.userId);
  ///
  ///   @override
  ///   List<Object?> get props => [userId];
  /// }
  /// ```
  @override
  List<Object?> get props => [];

  /// Deep equality check for routes.
  ///
  /// This is used to determine if two routes are identical.
  bool deepEquals(RouteTarget other) => hashCode == other.hashCode;

  @mustCallSuper
  void onDidPop(Object? result, covariant Coordinator? coordinator) {
    onDiscard();

    /// Handle force pop from navigator
    if (isPopByPath == false && _path?.stack.contains(this) == true) {
      if (_path case StackMutatable path) {
        path.remove(this, discard: false);
      }
    }

    clearStackPath();
  }

  /// Completes the route's result future.
  ///
  /// This is called when the route is popped with a result.
  void completeOnResult(
    Object? result,
    covariant Coordinator? coordinator, [
    bool failSilent = false,
  ]) {
    if (failSilent && _onResult.isCompleted) return;
    _onResult.complete(result);
    _resultValue = result;
  }

  /// Call when the route is discarded.
  ///
  /// That is difference with [onDidPop], [onDidPop] called when route is removed from stack.
  /// [onDiscard] called when route isn't in any path yet but it is in the process of being removed.
  @mustCallSuper
  void onDiscard() {
    completeOnResult(null, null, true);
  }

  /// Called when this route is updated with state from a new route instance.
  ///
  /// When navigation occurs and a route with the same identity already exists
  /// in the stack, instead of pushing a duplicate, the existing route's
  /// [onUpdate] method is called with the new route instance as a parameter.
  /// This allows you to transfer state from the new route to the existing one.
  ///
  /// **Common use cases:**
  /// - Updating query parameters without rebuilding the route
  /// - Refreshing route data when navigating to the same screen
  /// - Syncing state between duplicate route instances
  ///
  /// **Example:**
  /// ```dart
  /// class ProductRoute extends RouteTarget with RouteUnique {
  ///   ProductRoute(this.id, {this.highlightReview});
  ///
  ///   final String id;
  ///   String? highlightReview;
  ///
  ///   @override
  ///   void onUpdate(covariant ProductRoute newRoute) {
  ///     super.onUpdate(newRoute);
  ///     // Transfer the new highlight state to this existing route
  ///     highlightReview = newRoute.highlightReview;
  ///   }
  ///
  ///   @override
  ///   List<Object?> get props => [id]; // highlightReview not in props
  /// }
  /// ```
  ///
  /// **Parameters:**
  /// - [newRoute]: The new route instance being navigated to with potentially updated state.
  ///
  /// **Important:** Always call `super.onUpdate(newRoute)` if you override this.
  @mustCallSuper
  void onUpdate(covariant RouteTarget newRoute) {}
}



================================================
FILE: packages/zenrouter/lib/src/mixin/transition.dart
================================================
import 'package:zenrouter/zenrouter.dart';

/// Mixin for routes that define a custom transition.
mixin RouteTransition on RouteUnique {
  /// Returns the [StackTransition] for this route.
  StackTransition<T> transition<T extends RouteUnique>(
    covariant Coordinator coordinator,
  );
}



================================================
FILE: packages/zenrouter/lib/src/mixin/unique.dart
================================================
import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

/// Base mixin for unique routes in the application.
///
/// Most routes should mix this in. It provides integration with the [Coordinator]
/// and layout system.
mixin RouteUnique on RouteTarget {
  /// The type of layout that wraps this route.
  ///
  /// Return the type of the [RouteLayout] subclass that should contain this route.
  Type? get layout => null;

  /// Creates an instance of the layout for this route.
  ///
  /// This uses the registered constructor from [RouteLayout.layoutConstructorTable].
  RouteLayout? createLayout(covariant Coordinator coordinator) {
    final constructor = RouteLayout.layoutConstructorTable[layout];
    if (constructor == null) {
      throw UnimplementedError(
        '$this: Missing RouteLayout constructor for [$layout] must define by calling [RouteLayout.defineLayout] in [defineLayout] function at [${coordinator.runtimeType}]',
      );
    }
    return constructor();
  }

  /// Resolves the active layout instance for this route.
  ///
  /// Checks if an instance of the required layout is already active in the
  /// coordinator. If so, returns it. Otherwise, creates a new one.
  RouteLayout? resolveLayout(covariant Coordinator coordinator) {
    if (layout == null) return null;
    final layouts = coordinator.activeLayouts;
    if (layouts.isEmpty && layout == null) return null;

    // Find existing layout or create new one
    RouteLayout? resolvedLayout;
    for (var i = layouts.length - 1; i >= 0; i -= 1) {
      final l = layouts[i];
      if (l.runtimeType == layout) {
        resolvedLayout = l;
        break;
      }
    }
    resolvedLayout ??= createLayout(coordinator);

    // Validate that routes using IndexedStackPath are in the initial stack
    // Using assert with closure to ensure all validation logic is removed in production
    assert(() {
      final path = resolvedLayout!.resolvePath(coordinator);
      if (path is IndexedStackPath) {
        final routeInStack = path.stack.any(
          (r) => r.runtimeType == runtimeType,
        );
        if (!routeInStack) {
          throw AssertionError(
            'Route [$runtimeType] uses an IndexedStackPath layout but is not present in the initial stack.\n'
            'IndexedStackPath: ${path.debugLabel ?? 'unlabeled'}\n'
            'Current stack: ${path.stack.map((r) => r.runtimeType).toList()}\n\n'
            'Fix: Add an instance of [$runtimeType] to the IndexedStackPath when creating it:\n'
            '  IndexedStackPath.createWith(\n'
            '    [...existing routes..., $runtimeType()],\n'
            '    coordinator: this,\n'
            '    label: \'${path.debugLabel ?? 'your-label'}\',\n'
            '  )',
          );
        }
      }
      return true;
    }());

    return resolvedLayout;
  }

  /// Builds the widget for this route.
  Widget build(covariant Coordinator coordinator, BuildContext context);

  /// Returns the URI representation of this route.
  Uri toUri();
}



================================================
FILE: packages/zenrouter/lib/src/path/base.dart
================================================
// ignore_for_file: invalid_use_of_protected_member, invalid_use_of_visible_for_testing_member

import 'dart:async';

import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

part 'mutatable.dart';

/// A type-safe identifier for [StackPath] types.
///
/// [PathKey] is used to register and look up layout builders in
/// [RouteLayout.definePath]. Each [StackPath] subclass should have
/// a unique static [PathKey].
///
/// **Built-in keys:**
/// - [NavigationPath.key]: `PathKey('NavigationPath')`
/// - [IndexedStackPath.key]: `PathKey('IndexedStackPath')`
///
/// **Custom path example:**
/// ```dart
/// class ModalPath<T extends RouteTarget> extends StackPath<T>
///     with StackMutatable<T> {
///   static const key = PathKey('ModalPath');
///
///   @override
///   PathKey get pathKey => key;
/// }
/// ```
extension type const PathKey(String key) {}

/// A stack-based container for managing navigation history.
///
/// A [StackPath] holds a list of [RouteTarget]s and manages their lifecycle.
/// It notifies listeners when the stack changes.
///
/// ## Built-in Implementations
///
/// - **[NavigationPath]**: Mutable stack with push/pop for standard navigation
/// - **[IndexedStackPath]**: Fixed stack for indexed navigation (tabs)
///
/// ## Creating Custom Stack Paths
///
/// To create a custom stack path (e.g., for modals, sheets, or custom navigation):
///
/// ```dart
/// class ModalPath<T extends RouteTarget> extends StackPath<T>
///     with StackMutatable<T> {
///   // 1. Define a unique PathKey
///   static const key = PathKey('ModalPath');
///
///   ModalPath._(
///     super.stack, {
///     super.debugLabel,
///     super.coordinator,
///   });
///
///   factory ModalPath.createWith({
///     required Coordinator coordinator,
///     required String label,
///   }) => ModalPath._([], debugLabel: label, coordinator: coordinator);
///
///   // 2. Return the key
///   @override
///   PathKey get pathKey => key;
///
///   @override
///   T? get activeRoute => _stack.lastOrNull;
///
///   @override
///   void reset() {
///     for (final route in _stack) {
///       route.completeOnResult(null, null, true);
///     }
///     _stack.clear();
///   }
///
///   @override
///   Future<void> activateRoute(T route) async {
///     reset();
///     push(route);
///   }
/// }
/// ```
///
/// Then register a builder in your coordinator's [defineLayout]:
/// ```dart
/// @override
/// void defineLayout() {
///   RouteLayout.definePath(
///     ModalPath.key,
///     (coordinator, path, layout) => ModalStack(path: path as ModalPath),
///   );
/// }
/// ```
abstract class StackPath<T extends RouteTarget> with ChangeNotifier {
  StackPath(this._stack, {this.debugLabel, Coordinator? coordinator})
    : _proxyCoordinator = coordinator?.isRouteModule == true
          ? coordinator
          : null,
      _coordinator = coordinator?.isRouteModule == true
          ? coordinator?.coordinator
          : coordinator;

  // coverage:ignore-start
  /// Creates a [NavigationPath] with an optional initial stack.
  static NavigationPath<T> navigationStack<T extends RouteTarget>([
    String? debugLabel,
    List<T>? stack,
  ]) => NavigationPath<T>.create(label: debugLabel, stack: stack);

  /// Creates an [IndexedStackPath] with a fixed list of routes.
  static IndexedStackPath<T> indexedStack<T extends RouteTarget>(
    List<T> stack, [
    String? label,
  ]) => IndexedStackPath<T>.create(stack, label: label);
  // coverage:ignore-end

  /// A label for debugging purposes.
  final String? debugLabel;

  /// The internal mutable stack.
  final List<T> _stack;

  @protected
  void bindStack(List<T> stack) {
    _stack.clear();
    for (final route in stack) {
      route.isPopByPath = false;
      route.bindStackPath(this);
      _stack.add(route);
    }
  }

  /// The coordinator this path is bound to.
  ///
  /// When this path is created with a route module coordinator,
  /// this field holds the parent/root coordinator of that module.
  final Coordinator? _coordinator;

  /// The proxy coordinator for this path.
  ///
  /// When this path is created with a route module coordinator,
  /// this field holds the original (nested/module) coordinator,
  /// while [_coordinator] points to its parent/root coordinator.
  final Coordinator? _proxyCoordinator;

  /// The coordinator this path belongs to.
  Coordinator? get coordinator => _coordinator;

  /// The proxy coordinator for this path.
  ///
  /// For module paths, this is the original module coordinator that
  /// created the path (the "nested" coordinator); [coordinator]
  /// then refers to its parent/root coordinator.
  Coordinator? get proxyCoordinator => _proxyCoordinator;

  /// The currently active route in this stack.
  ///
  /// For [NavigationPath], this is the top of the stack.
  /// For [IndexedStackPath], this is the route at [activeIndex].
  T? get activeRoute;

  /// The unique key identifying this path type.
  ///
  /// Used by [RouteLayout.buildPath] to look up the appropriate builder.
  /// Each [StackPath] subclass should define a unique static [PathKey].
  PathKey get pathKey;

  /// The current navigation stack as an unmodifiable list.
  ///
  /// The first element is the bottom of the stack (first route),
  /// and the last element is the top of the stack (current route).
  List<T> get stack => List.unmodifiable(_stack);

  @protected
  /// Clears all routes from this path.
  ///
  /// **Important:** Guards are NOT consulted. Use this for forced resets
  /// like logout or app restart. For user-initiated back navigation,
  /// use [StackMutatable.pop] which respects guards.
  void clear() {
    for (final route in _stack) {
      route.completeOnResult(null, null, true);
      route.clearStackPath();
    }
    _stack.clear();
  }

  /// Reset stack of this path.
  ///
  /// **Important:** Guards are NOT consulted. Use this for forced resets
  /// like logout or app restart. For user-initiated back navigation,
  /// use [StackMutatable.pop] which respects guards.
  @mustCallSuper
  void reset();

  /// Activates a specific route in the stack.
  ///
  /// **Behavior varies by implementation:**
  /// - [NavigationPath]: Resets stack and pushes this route
  /// - [IndexedStackPath]: Switches to the route's index
  ///
  /// **Error Handling:**
  /// - [IndexedStackPath] throws [StateError] if route not in stack
  Future<void> activateRoute(T route);

  @override
  String toString() =>
      '${debugLabel ?? hashCode} [${proxyCoordinator ?? coordinator} | $pathKey]';
}



================================================
FILE: packages/zenrouter/lib/src/path/indexed.dart
================================================
// ignore_for_file: invalid_use_of_protected_member

import 'package:zenrouter/zenrouter.dart';

/// A fixed stack path for indexed navigation (like tabs).
///
/// Routes are pre-defined and cannot be added or removed. Navigation switches
/// the active index.
class IndexedStackPath<T extends RouteTarget> extends StackPath<T>
    with StackNavigatable<T>, RestorablePath<T, int, int> {
  IndexedStackPath._(super.stack, {super.debugLabel, super.coordinator})
    : assert(stack.isNotEmpty, 'Read-only path must have at least one route'),
      super() {
    for (final path in stack) {
      /// Set the output of every route to null since this cannot pop
      path.completeOnResult(null, null);
      path.bindStackPath(this);
    }
  }

  /// Creates an [IndexedStackPath] with a fixed list of routes.
  ///
  /// This is the standard way to create a fixed stack for indexed navigation.
  factory IndexedStackPath.create(
    List<T> stack, {
    String? label,
    Coordinator? coordinator,
  }) => IndexedStackPath._(stack, debugLabel: label, coordinator: coordinator);

  /// Creates an [IndexedStackPath] associated with a [Coordinator].
  ///
  /// This constructor binds the path to a specific coordinator, allowing it to
  /// interact with the coordinator for navigation actions.
  factory IndexedStackPath.createWith(
    List<T> stack, {
    required Coordinator coordinator,
    required String label,
  }) => IndexedStackPath._(stack, debugLabel: label, coordinator: coordinator);

  /// The key used to identify this type in [RouteLayout.definePath].
  static const key = PathKey('IndexedStackPath');

  /// IndexedStackPath key. This is used to identify this type in [RouteLayout.definePath].
  @override
  PathKey get pathKey => key;

  int _activeIndex = 0;

  /// The index of the currently active path in the stack.
  int get activeIndex => _activeIndex;

  @override
  T get activeRoute => stack[activeIndex];

  /// Switches the active route to the one at [index].
  ///
  /// Handles guards on the current route and redirects on the new route.
  Future<void> goToIndexed(int index) async {
    if (index >= stack.length || index < 0) {
      throw StateError('Index out of bounds');
    }

    /// Ignore already active index
    if (index == _activeIndex) return;

    final oldIndex = _activeIndex;
    final oldRoute = stack[oldIndex];
    if (oldRoute is RouteGuard) {
      final guard = oldRoute as RouteGuard;
      final canPop = await switch (coordinator) {
        null => guard.popGuard(),
        final coordinator => guard.popGuardWith(coordinator),
      };
      if (!canPop) return;
    }
    var newRoute = stack[index];
    while (newRoute is RouteRedirect) {
      final routeRedirect = newRoute as RouteRedirect;
      final redirectTo = await switch (coordinator) {
        null => routeRedirect.redirect(),
        final coordinator => routeRedirect.redirectWith(coordinator),
      };
      assert(
        redirectTo == null || redirectTo is T,
        'Redirected route must be the same type as the stack route',
      );
      if (redirectTo == null) return;
      if (identical(redirectTo, newRoute)) break;
      newRoute = redirectTo as T;
    }

    final newIndex = stack.indexOf(newRoute);
    // Not found
    if (newIndex == -1) return;
    _activeIndex = newIndex;
    notifyListeners();
  }

  @override
  Future<void> activateRoute(T route) async {
    final index = stack.indexOf(route);
    if (index == -1) {
      route.onDiscard();
      throw StateError('Route not found');
    }

    final indexRoute = stack[index];

    /// Update the existing route with new state
    indexRoute.onUpdate(route);

    if (!indexRoute.deepEquals(route)) {
      route.onDiscard();
    }

    if (index == _activeIndex) return;
    await goToIndexed(index);
  }

  @override
  void reset() {
    _activeIndex = 0;
    notifyListeners();
  }

  @override
  void restore(int data) {
    assert(data >= 0 && data < stack.length, 'Index out of bounds');
    _activeIndex = data;
  }

  @override
  int serialize() => _activeIndex;

  @override
  int deserialize(int data) => data;

  @override
  Future<void> navigate(T route) async {
    final routeIndex = stack.indexOf(route);
    if (routeIndex == -1) {
      // Route not found in IndexedStackPath - restore the URL to current state
      notifyListeners();
      return;
    }
    await activateRoute(route);
  }
}



================================================
FILE: packages/zenrouter/lib/src/path/mutatable.dart
================================================
// ignore_for_file: invalid_use_of_protected_member

part of 'base.dart';

/// Mixin for stack paths that support mutable operations (push/pop).
///
/// Apply this mixin to [StackPath] subclasses that need push/pop navigation.
/// This provides standard implementations for:
/// - [push]: Add a route to the top
/// - [pushReplacement]: Pop the top route and push a new one
/// - [pushOrMoveToTop]: Add or promote existing route
/// - [pop]: Remove the top route (with guard support)
/// - [remove]: Remove a specific route from the stack
mixin StackMutatable<T extends RouteTarget> on StackPath<T>
    implements StackNavigatable<T> {
  /// Pushes a new route onto the stack.
  ///
  /// This handles redirects and sets up the route's path reference.
  /// Returns a future that completes when the route is popped with a result.
  ///
  /// **Error Handling:**
  /// Exceptions from [RouteRedirect.resolve] propagate to the caller.
  Future<R?> push<R extends Object>(T element) async {
    T? target = await RouteRedirect.resolve(element, coordinator);
    if (target == null) return null;

    target.isPopByPath = false;
    target.bindStackPath(this);
    _stack.add(target);
    notifyListeners();
    // ignore: invalid_use_of_visible_for_testing_member
    return await target.onResult.future as R?;
  }

  /// Pops the current route and pushes a new route in its place.
  ///
  /// This is useful for replacing the current screen without adding to the
  /// navigation history. The new route takes the place of the popped route.
  ///
  /// **Behavior based on stack state:**
  /// - **Empty stack:** Pushes the new route normally
  /// - **Single element:** Completes the active route with [result], resets
  ///   the stack, then pushes the new route
  /// - **Multiple elements:** Pops the top route (respecting [RouteGuard]),
  ///   waits for the pop animation, then pushes the new route
  ///
  /// **Parameters:**
  /// - [element]: The new route to push after popping
  /// - [result]: Optional result to pass to the popped route's push future
  ///
  /// **Returns:**
  /// - A [Future] that completes with the result when the new route is popped
  /// - `null` if redirect resolution returns null or guard blocks the pop
  ///
  /// **Error Handling:**
  /// Exceptions from [RouteRedirect.resolve] propagate to the caller.
  /// If a [RouteGuard] blocks the pop, returns `null` without pushing.
  Future<R?> pushReplacement<R extends Object, RO extends Object>(
    T element, {
    RO? result,
  }) async {
    T? target = await RouteRedirect.resolve(element, coordinator);
    if (target == null) return null;

    final activeRoute = this.activeRoute;
    if (activeRoute case final activeRoute?) {
      // Manually complete the active route since it is the only one on the stack
      if (stack.length == 1) {
        activeRoute.completeOnResult(result, coordinator);
        activeRoute.onDiscard();
        reset();
        return push(target);
      }

      final popped = await pop(result);
      // Pop is prevented by guard
      if (popped == null || !popped) return null;
      // Wait the pop animation to finish
      // ignore: invalid_use_of_visible_for_testing_member
      await activeRoute.onResult.future;
      return push(target);
    }

    // If the active route is null => push normal
    return push(target);
  }

  /// Pushes a route to the top of the stack, or moves it if already present.
  ///
  /// If the route is already in the stack, it's moved to the top.
  /// If not, it's added to the top. Follows redirects like [push].
  ///
  /// Useful for tab navigation where you want to switch to a tab
  /// without duplicating it in the stack.
  Future<void> pushOrMoveToTop(T element) async {
    T? target = await RouteRedirect.resolve(element, coordinator);
    if (target == null) return;

    target.isPopByPath = false;
    target.bindStackPath(this);
    final index = _stack.indexOf(target);
    if (_stack.isNotEmpty && index == _stack.length - 1) {
      final last = _stack.last;
      last.onUpdate(target);
      if (!last.deepEquals(target)) {
        target.onDiscard();
        target.clearStackPath();
      }
      return;
    }

    if (index != -1) {
      final removed = _stack.removeAt(index);
      if (!removed.deepEquals(target)) {
        removed.onDiscard();
        removed.clearStackPath();
      }
    }
    _stack.add(target);
    notifyListeners();
  }

  /// Removes the top route from the navigation stack.
  ///
  /// **Difference from [remove] on concrete path implementations:**
  /// - [pop]: Respects [RouteGuard], removes only the top route, returns result
  /// - [remove]: Bypasses guards, can remove at any index, returns no result
  ///
  /// **Return values:**
  /// - `true`: Pop was successful
  /// - `false`: Guard cancelled the pop (route remains on stack)
  /// - `null`: Stack was empty (nothing to pop)
  Future<bool?> pop([Object? result]) async {
    if (_stack.isEmpty) {
      return null;
    }
    final last = _stack.last;
    if (last is RouteGuard) {
      final canPop = await switch (coordinator) {
        null => last.popGuard(),
        final coordinator => last.popGuardWith(coordinator),
      };
      if (!canPop) return false;
    }

    final element = _stack.removeLast();
    element.isPopByPath = true;
    element.bindResultValue(result);
    notifyListeners();
    return true;
  }

  /// Removes a specific route from the stack at any position.
  ///
  /// **Difference from [pop]:**
  /// - [remove]: Bypasses guards, can remove at any index, no result returned
  /// - [pop]: Respects [RouteGuard], only removes top route, returns result
  ///
  /// **When to use:**
  /// - Removing routes that were force-closed by the system
  /// - Cleaning up routes during navigation state changes
  /// - Internal framework operations
  ///
  /// **Avoid when:**
  /// - User-initiated back navigation (use [pop] instead)
  /// - You need to respect guards
  void remove(T element, {bool discard = true}) {
    final removed = _stack.remove(element);
    if (removed) {
      if (discard) element.onDiscard();
      element.clearStackPath();
      notifyListeners();
    }
  }

  @override
  Future<void> navigate(T route) async {
    T? target = await RouteRedirect.resolve(route, coordinator);
    if (target == null) return;

    final routeIndex = stack.indexOf(target);
    if (routeIndex != -1) {
      // Pop until we reach the target route
      while (stack.length > routeIndex + 1) {
        final allowPop = await pop();
        if (allowPop == null || !allowPop) {
          // Guard blocked navigation or stack is empty - restore the URL
          notifyListeners();
          return;
        }
      }

      final existingRoute = stack[routeIndex];
      existingRoute.onUpdate(target);
      notifyListeners();

      /// If routes differ by hash code, discard the incoming route
      if (!existingRoute.deepEquals(target)) {
        target.onDiscard();
      }
    } else {
      await push(target);
    }
  }
}



================================================
FILE: packages/zenrouter/lib/src/path/navigatable.dart
================================================
import 'package:zenrouter/zenrouter.dart';

/// Mixin for stack paths that support navigation.
///
/// Apply this mixin to [StackPath] subclasses that need navigation support.
mixin StackNavigatable<T extends RouteTarget> on StackPath<T> {
  /// Navigate to a specific route in the stack.
  ///
  /// This is useful for handling back/forward button on the browser.
  Future<void> navigate(T route);
}



================================================
FILE: packages/zenrouter/lib/src/path/navigation.dart
================================================
// ignore_for_file: invalid_use_of_protected_member

import 'package:zenrouter/zenrouter.dart';

/// A mutable stack path for standard navigation.
///
/// Supports pushing and popping routes. Used for the main navigation stack
/// and modal flows.
class NavigationPath<T extends RouteTarget> extends StackPath<T>
    with StackMutatable<T>, RestorablePath<T, List<dynamic>, List<T>> {
  NavigationPath._([
    String? debugLabel,
    List<T>? stack,
    Coordinator? coordinator,
  ]) : super(stack ?? [], debugLabel: debugLabel, coordinator: coordinator);

  /// Creates a [NavigationPath] with an optional initial stack.
  ///
  /// This is the standard way to create a mutable navigation stack.
  factory NavigationPath.create({
    String? label,
    List<T>? stack,
    Coordinator? coordinator,
  }) => NavigationPath._(label, stack ?? [], coordinator);

  /// Creates a [NavigationPath] associated with a [Coordinator].
  ///
  /// This constructor binds the path to a specific coordinator, allowing it to
  /// interact with the coordinator for navigation actions.
  factory NavigationPath.createWith({
    required Coordinator coordinator,
    required String label,
    List<T>? stack,
  }) => NavigationPath._(label, stack ?? [], coordinator);

  /// The key used to identify this type in [RouteLayout.definePath].
  static const key = PathKey('NavigationPath');

  /// NavigationPath key. This is used to identify this type in [RouteLayout.definePath].
  @override
  PathKey get pathKey => key;

  @override
  void reset() => clear();

  @override
  T? get activeRoute => stack.lastOrNull;

  @override
  Future<void> activateRoute(T route) async {
    reset();
    push(route);
  }

  @override
  void restore(dynamic data) => bindStack(data.cast<RouteTarget>().cast<T>());

  @override
  List<dynamic> serialize() => [
    for (final route in stack) RouteTarget.serialize(route),
  ];

  @override
  List<T> deserialize(
    List<dynamic> data, [
    RouteUriParserSync<RouteUnique>? parseRouteFromUri,
  ]) {
    parseRouteFromUri ??= coordinator?.parseRouteFromUriSync;
    return <T>[
      for (final routeRaw in data)
        RouteTarget.deserialize(routeRaw, parseRouteFromUri: parseRouteFromUri!)
            as T,
    ];
  }
}



================================================
FILE: packages/zenrouter/lib/src/path/restoration.dart
================================================
import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

/// A mixin that adds state restoration capabilities to navigation paths.
///
/// ## What This Mixin Does
///
/// [RestorablePath] provides the contract for serializing and deserializing navigation
/// state within a [StackPath]. It enables paths to save their current navigation stack
/// to persistent storage and restore it later, allowing users to return to exactly where
/// they left off even after the app is terminated by the system.
///
/// This mixin defines three core operations that each path type must implement:
/// - **Serialization**: Converting the current navigation state to a persistable format
/// - **Deserialization**: Reconstructing navigation data from the persisted format
/// - **Restoration**: Applying the deserialized data back to the navigation stack
///
/// ## Where It's Used
///
/// This mixin is applied to concrete path types that need restoration support:
/// - [NavigationPath]: Uses it to serialize/deserialize the route stack
/// - [IndexedStackPath]: Uses it to serialize/deserialize the active tab index
///
/// The mixin is used internally by the restoration framework and you typically interact
/// with the concrete implementations rather than this mixin directly.
///
/// ## Type Parameters
///
/// - `T`: The route type that extends [RouteTarget]
/// - `S`: The serialized format (e.g., `List<dynamic>` for route stacks, `int` for indices)
/// - `D`: The deserialized format (e.g., `List<T>` for routes, `int` for index values)
///
/// ## How Paths Implement Restoration
///
/// **NavigationPath example:**
/// ```dart
/// class NavigationPath<T extends RouteTarget> extends StackPath<T>
///     with RestorablePath<T, List<dynamic>, List<T>> {
///
///   @override
///   List<dynamic> serialize() {
///     // Convert stack to primitives (strings, maps)
///     return stack.map((route) => /* serialize route */).toList();
///   }
///
///   @override
///   List<T> deserialize(List<dynamic> data) {
///     // Convert primitives back to route objects
///     return data.map((item) => /* deserialize route */).toList();
///   }
///
///   @override
///   void restore(List<T> data) {
///     // Replace current stack with restored routes
///     reset();
///     for (final route in data) {
///       push(route);
///     }
///   }
/// }
/// ```
///
/// See also:
/// - [NavigationPath] for the full stack restoration implementation
/// - [IndexedStackPath] for tab index restoration implementation
/// - [CoordinatorRestorable] for how restoration is orchestrated at the coordinator level
mixin RestorablePath<T extends RouteTarget, S, D> on StackPath<T> {
  /// Serializes the current navigation state into a persistable format.
  ///
  /// This method is called automatically by the restoration framework when the app
  /// needs to save its state (e.g., when backgrounded). The returned value should
  /// contain all necessary information to recreate the current navigation state.
  ///
  /// The serialized format (type `S`) must be compatible with Flutter's restoration
  /// system, typically primitive types like lists, maps, strings, and numbers.
  S serialize();

  /// Deserializes previously saved navigation state back into route objects.
  ///
  /// This method converts the persisted data (type `S`) back into the format needed
  /// to restore the navigation stack (type `D`). It's called during app launch when
  /// restoration data exists.
  ///
  /// The [data] parameter contains the value previously returned by [serialize].
  D deserialize(S data);

  /// Restores the navigation state from deserialized data.
  ///
  /// This method applies the deserialized routes or state to the actual navigation
  /// stack, replacing the current state with the restored one. It's called after
  /// [deserialize] to actually update the navigation.
  ///
  /// Implementations should clear the existing state and apply the restored data.
  void restore(D data);
}

/// A [RestorableValue] that manages the restoration of navigation route stacks.
///
/// ## What This Class Does
///
/// [NavigationPathRestorable] is the bridge between Flutter's restoration framework
/// and ZenRouter's navigation state. It implements Flutter's [RestorableValue] protocol
/// to save and restore a list of routes, handling the conversion between route objects
/// and the primitive types (strings, maps) that Flutter's restoration system can persist.
///
/// This class is used internally by [NavigationPath] to provide automatic state
/// restoration. You typically don't interact with this class directly - instead,
/// it works behind the scenes when you enable restoration by providing a
/// `restorationScopeId` to your MaterialApp.
///
/// ## Where It Fits in the Architecture
///
/// The restoration data flow:
/// ```
/// Flutter Restoration System
///   ↕ (primitives: strings, maps, lists)
/// NavigationPathRestorable
///   ↕ (route objects: HomeRoute, DetailRoute, etc.)
/// NavigationPath
///   ↕ (navigation stack)
/// Your App
/// ```
///
/// ## How It Handles Different Route Types
///
/// **RouteUnique routes (URI-based):**
/// - Serialized as URI strings: `"/home"`, `"/products/123"`
/// - Deserialized by parsing the URI and calling [parseRouteFromUri]
/// - Simple, compact, works for routes that can be fully represented by a URL
///
/// **RouteRestorable routes (custom converters):**
/// - Serialized as maps containing strategy and custom data
/// - Deserialized using registered [RestorableConverter] instances
/// - Supports complex routes with rich state that doesn't fit in a URL
///
/// ## When Serialization/Deserialization Happens
///
/// **Serialization ([toPrimitives]):**
/// - Called by Flutter when the app is backgrounded
/// - Called when the system needs to save state to free memory
/// - Converts each route in the stack to either a string or map
///
/// **Deserialization ([fromPrimitives]):**
/// - Called by Flutter when restoring the app after termination
/// - Called during hot restart in development (if enabled)
/// - Reconstructs route objects from the saved strings/maps
///
/// ## Example Output
///
/// For a navigation stack containing:
/// ```dart
/// [
///   HomeRoute(),
///   ProductDetailRoute(id: "123", data: {...}),
///   SettingsRoute(),
/// ]
/// ```
///
/// Serialized to:
/// ```dart
/// [
///   "/home",                              // RouteUnique as string
///   {                                     // RouteRestorable as map
///     "strategy": "converter",
///     "converter": "product_detail",
///     "value": {"id": "123", "data": {...}}
///   },
///   "/settings",                          // RouteUnique as string
/// ]
/// ```
///
/// See also:
/// - [RestorableValue] - Flutter's base class for restorable values
/// - [NavigationPath] - Uses this class for stack restoration
/// - [RouteRestorable] - Mixin for routes that need custom serialization
class NavigationPathRestorable<T extends RouteTarget>
    extends RestorableValue<List<T>> {
  /// Creates a restorable navigation path with the given route parser.
  ///
  /// The [parseRouteFromUri] function is used to convert URI strings back into
  /// route objects during deserialization. This must be a synchronous function
  /// that can handle all possible URIs that might be saved in the restoration data.
  NavigationPathRestorable(this.parseRouteFromUri);

  /// The function used to parse URIs back into route objects during restoration.
  ///
  /// This is typically the coordinator's [Coordinator.parseRouteFromUriSync] method.
  /// It must be synchronous because restoration happens during app initialization
  /// and cannot wait for asynchronous operations.
  final T Function(Uri uri) parseRouteFromUri;

  @override
  List<T> createDefaultValue() => [];

  @override
  void didUpdateValue(List<T>? oldValue) => notifyListeners();

  /// Converts saved primitive data back into a list of route objects.
  ///
  /// This is called by Flutter's restoration framework when the app is being
  /// restored. It receives the data that was previously returned by [toPrimitives]
  /// and reconstructs the route stack.
  ///
  /// Returns a list of route objects ready to be restored to the navigation stack.
  @override
  List<T> fromPrimitives(Object? data) => [
    for (final route in data as List)
      RouteTarget.deserialize(route, parseRouteFromUri: parseRouteFromUri) as T,
  ];

  /// Converts the current route stack into primitive types for persistence.
  ///
  /// This is called by Flutter's restoration framework when the app needs to
  /// save its state. It converts each route in [value] to either:
  /// - A URI string (for RouteUnique routes)
  /// - A map with serialization data (for RouteRestorable routes)
  ///
  /// The returned list contains only primitive types that Flutter's restoration
  /// system can persist (strings, maps, lists, numbers, booleans).
  ///
  /// Throws [UnimplementedError] if a route doesn't implement either [RouteUnique]
  /// or [RouteRestorable], as there's no way to serialize it.
  @override
  Object? toPrimitives() => [
    for (final route in value) RouteTarget.serialize(route),
  ];
}



================================================
FILE: packages/zenrouter/lib/src/path/stack.dart
================================================
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:zenrouter/src/internal/diff.dart';
import 'package:zenrouter/zenrouter.dart';

/// A widget that renders a stack of pages based on a [NavigationPath].
///
/// This is the core widget for imperative navigation. It listens to the [path]
/// and updates the [Navigator] with the corresponding pages.
class NavigationStack<T extends RouteTarget> extends StatefulWidget {
  const NavigationStack({
    super.key,
    required this.path,
    required this.resolver,
    this.defaultRoute,
    this.observers = const [],
    this.coordinator,
    this.navigatorKey,
    this.parseRouteFromUri,
    this.restorationId,
  }) : assert(
         restorationId == null ||
             (coordinator != null || parseRouteFromUri != null),
         'Please provide either coordinator or parseRouteFromUri for restoration working',
       );

  /// Creates a declarative navigation stack.
  ///
  /// This factory method creates a [DeclarativeNavigationStack] which manages
  /// the stack based on a list of routes.
  static DeclarativeNavigationStack<T> declarative<T extends RouteTarget>({
    required List<T> routes,
    required StackTransitionResolver<T> resolver,
    GlobalKey<NavigatorState>? navigatorKey,
    String? debugLabel,
    String? restorationId,
    T Function(Uri uri)? parseRouteFromUri,
  }) {
    return DeclarativeNavigationStack(
      routes: routes,
      navigatorKey: navigatorKey,
      debugLabel: debugLabel,
      resolver: resolver,
      restorationId: restorationId,
      parseRouteFromUri: parseRouteFromUri,
    );
  }

  /// Optional key for accessing the navigator state.
  final GlobalKey<NavigatorState>? navigatorKey;

  /// The associated coordinator
  final Coordinator? coordinator;

  final String? restorationId;

  final T Function(Uri uri)? parseRouteFromUri;

  /// A list of observers for this navigator.
  final List<NavigatorObserver> observers;

  /// The navigation path to render.
  final NavigationPath<T> path;

  /// Callback that converts routes to destinations.
  final StackTransitionResolver<T> resolver;

  /// Optional route to push when the stack initializes.
  final T? defaultRoute;

  @override
  State<NavigationStack<T>> createState() => _NavigationStackState<T>();
}

class _NavigationStackState<T extends RouteTarget>
    extends State<NavigationStack<T>>
    with RestorationMixin {
  List<Page> _pages = [];
  List<T> _previousRoutes = [];

  List<NavigatorObserver> _observers = [];

  NavigationPathRestorable<T>? _restorable;

  void _updateObservers() {
    _observers = switch (widget.coordinator) {
      CoordinatorNavigatorObserver coordinator => [
        ...coordinator.observers,
        ...widget.observers,
      ],
      _ => widget.observers,
    };
  }

  @override
  void initState() {
    super.initState();
    if (widget.defaultRoute != null) {
      widget.path.pushOrMoveToTop(widget.defaultRoute!);
    }
    widget.path.addListener(_updatePages);
    widget.path.addListener(_updateRestorable);
    _updatePages();
    _updateObservers();
  }

  @override
  void dispose() {
    widget.path.removeListener(_updatePages);
    widget.path.removeListener(_updateRestorable);
    _restorable?.dispose();
    super.dispose();
  }

  Page _buildPage(T route) {
    /// Set path to route
    // ignore: invalid_use_of_protected_member
    route.bindStackPath(widget.path);
    final destination = widget.resolver(route);
    return destination.pageBuilder(
      context,
      ValueKey(route),
      PopScope(
        canPop: switch (route) {
          RouteGuard() => false,
          _ when destination.guard != null => false,
          _ => true,
        },
        onPopInvokedWithResult: (didPop, result) async {
          // ignore: invalid_use_of_protected_member
          if (route.stackPath == null) route.bindStackPath(widget.path);
          if (!(kIsWeb || kIsWasm)) {
            assert(
              identical(route.stackPath, widget.path),
              'Route must be from the same path',
            );
          }

          switch (didPop) {
            case true when result != null:
              route.completeOnResult(result, widget.coordinator);
              route.onDidPop(result, widget.coordinator);
            case true:
              result = route.resultValue;
              route.completeOnResult(
                result,
                widget.coordinator,

                /// Fail silently if it's a force pop from the platform.
                route.isPopByPath == false,
              );
              route.onDidPop(result, widget.coordinator);
            case false when route is RouteGuard:
              widget.path.pop();
            case false when destination.guard != null:
              final popped = switch (widget.coordinator) {
                null => await destination.guard?.popGuard(),
                // Never happen
                // coverage:ignore-start
                final coordinator => await destination.guard?.popGuardWith(
                  coordinator,
                ),
              };
              if (popped == true) widget.path.pop();
            case false:
            // coverage:ignore-end
          }
        },
        child: destination.builder(context),
      ),
    );
  }

  void _updatePages() {
    final currentRoutes = widget.path.stack;

    // Calculate diff between previous and current routes
    final diffOps = myersDiff(_previousRoutes, currentRoutes);

    // Build new pages list using diff operations
    final newPages = <Page>[];
    for (final op in diffOps) {
      switch (op) {
        case Keep<T>(:final oldIndex):
          // Reuse existing page
          newPages.add(_pages[oldIndex]);
        case Insert<T>(:final element):
          // Create new page
          newPages.add(_buildPage(element));
        case Delete<T>():
          // Skip deleted pages
          break;
      }
    }

    _pages = newPages;
    _previousRoutes = List.from(currentRoutes);
    setState(() {});
  }

  void _updateRestorable() {
    if (_restorable == null) return;
    if (listEquals(_restorable!.value, widget.path.stack)) return;
    _restorable!.value = widget.path.stack;
  }

  bool coordinatorEquals(Coordinator? a, Coordinator? b) {
    if (a is CoordinatorNavigatorObserver &&
        b is CoordinatorNavigatorObserver) {
      return listEquals(a.observers, b.observers);
    }
    return false;
  }

  @override
  void didUpdateWidget(covariant NavigationStack<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.path != widget.path) {
      oldWidget.path.removeListener(_updatePages);
      widget.path.addListener(_updatePages);
      // Reset previous routes and rebuild pages for the new path
      _previousRoutes = [];
      _updatePages();
    }
    if (!listEquals(oldWidget.observers, widget.observers) ||
        !coordinatorEquals(oldWidget.coordinator, widget.coordinator)) {
      _updateObservers();
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_pages.isEmpty) return const SizedBox.shrink();
    return Navigator(
      key: widget.navigatorKey,
      pages: _pages,
      observers: _observers,
      onDidRemovePage: (page) {},
      restorationScopeId: switch (widget.restorationId) {
        null => null,
        final restorationId => '${restorationId}_navigator',
      },
    );
  }

  @override
  String? get restorationId => switch (widget.restorationId) {
    null => null,
    final restorationId => '${restorationId}_stack',
  };

  @override
  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {
    /// If the path is managed by Coordinator, it will be restored based on the Coordinator
    if (widget.coordinator != null) return;

    if (widget.parseRouteFromUri != null && _restorable == null) {
      _restorable ??= NavigationPathRestorable(widget.parseRouteFromUri!);
      registerForRestoration(_restorable!, '_path');
    }

    if (initialRestore && _restorable != null) {
      if (_restorable!.value.isNotEmpty == false) return;
      widget.path.restore(_restorable!.value);
    }
  }
}

/// A widget that manages a navigation stack declaratively.
///
/// Instead of pushing and popping, you provide a list of [routes]. The widget
/// calculates the difference between the old and new routes (using Myers diff)
/// and updates the stack accordingly.
class DeclarativeNavigationStack<T extends RouteTarget> extends StatefulWidget {
  const DeclarativeNavigationStack({
    super.key,
    required this.routes,
    this.navigatorKey,
    this.debugLabel,
    required this.resolver,
    this.restorationId,
    this.parseRouteFromUri,
  });

  /// The list of routes to display.
  final List<T> routes;

  /// Optional key for the navigator.
  final GlobalKey<NavigatorState>? navigatorKey;

  /// Optional debug label for the path.
  final String? debugLabel;

  /// Callback to resolve routes to pages.
  final StackTransitionResolver<T> resolver;

  final String? restorationId;

  /// Callback to parse routes from Uri.
  final T Function(Uri uri)? parseRouteFromUri;

  @override
  // ignore: library_private_types_in_public_api
  State<DeclarativeNavigationStack<T>> createState() =>
      _DeclarativeNavigationStackState<T>();
}

class _DeclarativeNavigationStackState<T extends RouteTarget>
    extends State<DeclarativeNavigationStack<T>> {
  late final path = NavigationPath<T>.create(label: widget.debugLabel);
  List<T> _previousRoutes = [];

  @override
  void initState() {
    super.initState();
    _updateStack();
  }

  @override
  void didUpdateWidget(DeclarativeNavigationStack<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.routes != oldWidget.routes) {
      _updateStack();
    }
  }

  void _updateStack() {
    // Calculate diff between previous and current routes
    final diffOps = myersDiff(_previousRoutes, widget.routes);

    // Apply the diff operations to the navigation path
    applyDiff(path, diffOps);

    // Update previous routes for next comparison
    _previousRoutes = List.from(widget.routes);
  }

  @override
  Widget build(BuildContext context) {
    return NavigationStack(
      path: path,
      resolver: widget.resolver,
      navigatorKey: widget.navigatorKey,
      restorationId: widget.restorationId,
      parseRouteFromUri: widget.parseRouteFromUri,
    );
  }
}

/// Widget that builds an [IndexedStack] from an [IndexedStackPath].
/// Ensures that the stack caches pages when rebuilding the widget tree.
class IndexedStackPathBuilder<T extends RouteUnique> extends StatefulWidget {
  const IndexedStackPathBuilder({
    super.key,
    required this.path,
    required this.coordinator,
    this.restorationId,
  });

  /// The path that maintains the indexed stack state.
  final IndexedStackPath<T> path;

  /// The coordinator used to resolve and build routes in the stack.
  final Coordinator coordinator;

  final String? restorationId;

  @override
  State<IndexedStackPathBuilder<T>> createState() =>
      _IndexedStackPathBuilderState<T>();
}

class _IndexedStackPathBuilderState<T extends RouteUnique>
    extends State<IndexedStackPathBuilder<T>> {
  List<Widget>? _children;

  List<Widget> _buildChildren(List<T> stack) =>
      stack.map((ele) => ele.build(widget.coordinator, context)).toList();

  @override
  Widget build(BuildContext context) {
    return IndexedStack(
      index: widget.path.activeIndex,
      children: _children ??= _buildChildren(widget.path.stack),
    );
  }
}



================================================
FILE: packages/zenrouter/lib/src/path/transition.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

/// Defines how a route should be displayed as a widget and wrapped in a page.
///
/// [StackTransition] separates the route logic from the presentation.
/// It contains:
/// - [builder]: How to build the widget for this route
/// - [pageBuilder]: How to wrap the widget in a Flutter [Page]
/// - [guard]: Optional guard that applies even if the route doesn't have [RouteGuard]
///
/// ## Built-in Factories
///
/// Use these for common patterns:
/// - [StackTransition.material] - Material page transition (Android)
/// - [StackTransition.cupertino] - Cupertino page transition (iOS)
/// - [StackTransition.sheet] - Bottom sheet presentation
/// - [StackTransition.dialog] - Dialog presentation
/// - [StackTransition.none] - No animation (testing/screenshots)
/// - [StackTransition.custom] - Full control over page and transition
///
/// ## Custom Transitions
///
/// For custom animations, use [StackTransition.custom]:
///
/// ```dart
/// // Fade transition example
/// StackTransition.custom<MyRoute>(
///   builder: (context) => MyWidget(),
///   pageBuilder: (context, routeKey, child) => FadePage(
///     key: routeKey,
///     child: child,
///   ),
/// )
/// ```
///
/// To create a custom page with animation:
///
/// ```dart
/// class FadePage<T> extends Page<T> {
///   const FadePage({super.key, required this.child});
///   final Widget child;
///
///   @override
///   Route<T> createRoute(BuildContext context) {
///     return PageRouteBuilder<T>(
///       settings: this,
///       pageBuilder: (context, animation, _) => FadeTransition(
///         opacity: animation,
///         child: child,
///       ),
///       transitionDuration: Duration(milliseconds: 300),
///     );
///   }
/// }
/// ```
class StackTransition<T extends RouteTarget> {
  /// Creates a custom route destination with full control.
  ///
  /// **Parameters:**
  /// - [builder]: Returns the widget for this route
  /// - [pageBuilder]: Wraps the widget in a [Page] for the Navigator
  /// - [guard]: Optional guard (useful for route-agnostic guards)
  ///
  /// **Example - Slide from bottom:**
  /// ```dart
  /// StackTransition.custom<MyRoute>(
  ///   builder: (context) => MySheet(),
  ///   pageBuilder: (context, routeKey, child) => SlideUpPage(
  ///     key: routeKey,
  ///     child: child,
  ///   ),
  /// )
  /// ```
  const StackTransition.custom({
    required this.builder,
    required this.pageBuilder,
    this.guard,
  });

  /// Creates a [MaterialPage] with a [Widget].
  ///
  /// This uses Material Design page transitions.
  static StackTransition<T> material<T extends RouteTarget>(
    Widget child, {
    RouteGuard? guard,
    String? restorationId,
  }) => StackTransition<T>.custom(
    builder: (context) => child,
    pageBuilder: (context, route, child) =>
        MaterialPage(key: route, child: child, restorationId: restorationId),
    guard: guard,
  );

  /// Creates a [CupertinoPage] with a [Widget].
  ///
  /// This uses iOS-style page transitions.
  static StackTransition<T> cupertino<T extends RouteTarget>(
    Widget child, {
    RouteGuard? guard,
    String? restorationId,
  }) => StackTransition<T>.custom(
    builder: (context) => child,
    pageBuilder: (context, route, child) =>
        CupertinoPage(key: route, child: child, restorationId: restorationId),
    guard: guard,
  );

  /// Creates a [CupertinoSheetPage] with a [Widget].
  ///
  /// This presents the route as a bottom sheet.
  static StackTransition<T> sheet<T extends RouteTarget>(
    Widget child, {
    RouteGuard? guard,
    String? restorationId,
  }) => StackTransition<T>.custom(
    builder: (context) => child,
    pageBuilder: (context, route, child) => CupertinoSheetPage(
      key: route,
      restorationId: restorationId,
      builder: (context) => child,
    ),
    guard: guard,
  );

  /// Creates a [DialogPage] with a [Widget].
  ///
  /// This presents the route as a dialog overlay.
  static StackTransition<T> dialog<T extends RouteTarget>(
    Widget child, {
    RouteGuard? guard,
    String? restorationId,
  }) => StackTransition<T>.custom(
    builder: (context) => child,
    pageBuilder: (context, route, child) =>
        DialogPage(key: route, restorationId: restorationId, child: child),
    guard: guard,
  );

  /// Creates a [NoTransitionPage] with instant appearance.
  ///
  /// Routes appear and disappear instantly without animation.
  ///
  /// **Use cases:**
  /// - Widget tests (avoid waiting for animations)
  /// - Screenshot tools
  /// - When custom animations are handled elsewhere
  /// - Performance-sensitive scenarios
  static StackTransition<T> none<T extends RouteTarget>(
    Widget child, {
    RouteGuard? guard,
    String? restorationId,
  }) => StackTransition<T>.custom(
    builder: (context) => child,
    pageBuilder: (context, route, child) => NoTransitionPage(
      key: route,
      child: child,
      restorationId: restorationId,
    ),
    guard: guard,
  );

  /// Builds the widget for this route.
  final WidgetBuilder builder;

  /// Wraps the widget in a Flutter [Page].
  final PageCallback<T> pageBuilder;

  /// Optional guard that applies even if the route doesn't have [RouteGuard].
  final RouteGuard? guard;
}

/// A page that presents its route as a Cupertino-style bottom sheet.
///
/// Use this for modal overlays that slide up from the bottom of the screen,
/// commonly used for iOS-style action sheets or forms.
///
/// Example:
/// ```dart
///   StackTransition.sheet(MyWidget())
/// ```
class CupertinoSheetPage<T extends Object> extends Page<T> {
  const CupertinoSheetPage({
    super.key,
    required this.builder,
    super.restorationId,
  });

  /// Builder for the sheet content.
  final WidgetBuilder builder;

  @override
  /// Creates the route for this page.
  Route<T> createRoute(BuildContext context) {
    return CupertinoSheetRoute(settings: this, builder: builder);
  }
}

/// A page that presents its route as a dialog overlay.
///
/// Use this for modal dialogs that appear on top of the current screen,
/// typically with a backdrop. Common for alerts, confirmations, or forms.
///
/// Example:
/// ```dart
///   StackTransition.dialog(AlertWidget())
/// ```
class DialogPage<T> extends Page<T> {
  const DialogPage({super.key, required this.child, super.restorationId});

  /// The widget to display in the dialog.
  final Widget child;

  @override
  /// Creates the route for this page.
  Route<T> createRoute(BuildContext context) {
    return DialogRoute<T>(
      context: context,
      settings: this,
      builder: (context) => child,
    );
  }
}

class NoTransitionPage<T> extends Page<T> {
  const NoTransitionPage({super.key, required this.child, super.restorationId});

  final Widget child;

  @override
  Route<T> createRoute(BuildContext context) {
    return _NoTransitionRoute<T>(settings: this, child: child);
  }
}

class _NoTransitionRoute<T> extends PageRoute<T> {
  _NoTransitionRoute({super.settings, required this.child});

  final Widget child;

  @override
  Color? get barrierColor => Colors.transparent;

  @override
  String? get barrierLabel => 'No transition';

  @override
  Widget buildPage(
    BuildContext context,
    Animation<double> animation,
    Animation<double> secondaryAnimation,
  ) {
    return child;
  }

  @override
  bool get maintainState => true;

  @override
  Duration get transitionDuration => Duration.zero;

  @override
  Duration get reverseTransitionDuration => Duration.zero;
}



================================================
FILE: packages/zenrouter/test/coordinator/coordinator_route_module_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Routes
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text(toString()));
  }

  @override
  List<Object?> get props => [];
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');
  @override
  String toString() => 'HomeRoute';
}

class ShopHomeRoute extends AppRoute {
  @override
  Type get layout => ShopLayout;
  @override
  Uri toUri() => Uri.parse('/shop');
  @override
  String toString() => 'ShopHomeRoute';
}

class ShopProductRoute extends AppRoute {
  ShopProductRoute({required this.id});
  final String id;

  @override
  Type get layout => ShopLayout;
  @override
  Uri toUri() => Uri.parse('/shop/products/$id');
  @override
  String toString() => 'ShopProductRoute(id: $id)';
  @override
  List<Object?> get props => [id];
}

class SettingsRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;
  @override
  Uri toUri() => Uri.parse('/settings');
  @override
  String toString() => 'SettingsRoute';
}

class SettingsDetailRoute extends AppRoute {
  @override
  Type get layout => SettingsLayout;
  @override
  Uri toUri() => Uri.parse('/settings/detail');
  @override
  String toString() => 'SettingsDetailRoute';
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});
  final Uri uri;

  @override
  Uri toUri() => Uri.parse('/not-found');
  @override
  String toString() => 'NotFoundRoute(uri: $uri)';
  @override
  List<Object?> get props => [uri];
}

/// A simple route with no layout dependency — safe for standalone coordinators.
class StandalonePageRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/standalone-page');
  @override
  String toString() => 'StandalonePageRoute';
}

// --- Nested CoordinatorModular routes ---

class BlogHomeRoute extends AppRoute {
  @override
  Type get layout => BlogLayout;
  @override
  Uri toUri() => Uri.parse('/blog');
  @override
  String toString() => 'BlogHomeRoute';
}

class BlogPostRoute extends AppRoute {
  BlogPostRoute({required this.slug});
  final String slug;

  @override
  Type get layout => BlogLayout;
  @override
  Uri toUri() => Uri.parse('/blog/posts/$slug');
  @override
  String toString() => 'BlogPostRoute(slug: $slug)';
  @override
  List<Object?> get props => [slug];
}

class BlogCommentRoute extends AppRoute {
  BlogCommentRoute({required this.postSlug});
  final String postSlug;

  @override
  Type get layout => BlogLayout;
  @override
  Uri toUri() => Uri.parse('/blog/posts/$postSlug/comments');
  @override
  String toString() => 'BlogCommentRoute(postSlug: $postSlug)';
  @override
  List<Object?> get props => [postSlug];
}

// ============================================================================
// Test Layouts
// ============================================================================

class ShopLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(
    covariant CoordinatorModular<AppRoute> coordinator,
  ) {
    final module = coordinator.getModule<ShopCoordinator>();
    return module.shopStack;
  }

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: buildPath(coordinator));
  }
}

class SettingsLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(
    covariant CoordinatorModular<AppRoute> coordinator,
  ) {
    final module = coordinator.getModule<SettingsCoordinator>();
    return module.settingsStack;
  }

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: buildPath(coordinator));
  }
}

class BlogLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(
    covariant CoordinatorModular<AppRoute> coordinator,
  ) {
    final module = coordinator.getModule<BlogCoordinator>();
    return module.blogStack;
  }

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: buildPath(coordinator));
  }
}

// ============================================================================
// Child Coordinators used as RouteModules
// ============================================================================

/// A Coordinator that is used as a RouteModule inside a parent
/// CoordinatorModular. It overrides `coordinator` to point to the parent.
class ShopCoordinator extends Coordinator<AppRoute> {
  ShopCoordinator(this._parent);
  final CoordinatorModular<AppRoute> _parent;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  late final NavigationPath<AppRoute> shopStack = NavigationPath.createWith(
    label: 'shop',
    coordinator: _parent,
  );

  @override
  List<StackPath> get paths => [...super.paths, shopStack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeRoute(),
      ['shop', 'products', final id] => ShopProductRoute(id: id),
      _ => null,
    };
  }
}

class SettingsCoordinator extends Coordinator<AppRoute> {
  SettingsCoordinator(this._parent);
  final TestParentCoordinator _parent;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  late final NavigationPath<AppRoute> settingsStack = NavigationPath.createWith(
    label: 'settings',
    coordinator: _parent,
  );

  @override
  List<StackPath> get paths => [...super.paths, settingsStack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(SettingsLayout, SettingsLayout.new);
  }

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['settings'] => SettingsRoute(),
      ['settings', 'detail'] => SettingsDetailRoute(),
      _ => null,
    };
  }
}

// ============================================================================
// Parent Coordinator — composes child coordinators as modules
// ============================================================================

class TestParentCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    TestMainRouteModule(this),
    ShopCoordinator(this),
    SettingsCoordinator(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

// ============================================================================
// Nested CoordinatorModular — a CoordinatorModular used as RouteModule
// ============================================================================

/// A Coordinator that is itself a CoordinatorModular AND acts as a RouteModule
/// of a grandparent CoordinatorModular. It has its own child modules.
class BlogCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  BlogCoordinator(this._grandParent);
  final NestedGrandParentCoordinator _grandParent;

  @override
  CoordinatorModular<AppRoute> get coordinator => _grandParent;

  late final NavigationPath<AppRoute> blogStack = NavigationPath.createWith(
    label: 'blog',
    coordinator: _grandParent,
  );

  @override
  List<StackPath> get paths => [...super.paths, blogStack];

  @override
  void defineLayout() {
    super.defineLayout();
    RouteLayout.defineLayout(BlogLayout, BlogLayout.new);
  }

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    BlogPostsModule(this),
    BlogCommentsModule(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class BlogPostsModule extends RouteModule<AppRoute> {
  BlogPostsModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['blog'] => BlogHomeRoute(),
      ['blog', 'posts', final slug] => BlogPostRoute(slug: slug),
      _ => null,
    };
  }
}

class BlogCommentsModule extends RouteModule<AppRoute> {
  BlogCommentsModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['blog', 'posts', final slug, 'comments'] => BlogCommentRoute(
        postSlug: slug,
      ),
      _ => null,
    };
  }
}

/// The top-level grandparent that contains both regular modules
/// and a nested CoordinatorModular (BlogCoordinator).
class NestedGrandParentCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    TestMainRouteModule(this),
    ShopCoordinator(this),
    BlogCoordinator(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class TestMainRouteModule extends RouteModule<AppRoute> {
  TestMainRouteModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      _ => null,
    };
  }
}

// ============================================================================
// Standalone Coordinator — does NOT override `coordinator` getter
// ============================================================================

/// A standalone coordinator that always returns a route from parseRouteFromUri.
/// The assert in setNewRoutePath should pass because route is non-null.
class StandaloneCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['standalone-page'] => StandalonePageRoute(),
      _ => HomeRoute(),
    };
  }
}

/// A standalone coordinator that returns null from parseRouteFromUri for
/// unknown URIs. This should trigger the assert in setNewRoutePath.
class StandaloneNullReturningCoordinator extends Coordinator<AppRoute> {
  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      _ => null, // Returns null for unknown routes
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('Coordinator as RouteModule', () {
    group('coordinator getter', () {
      test(
        'standalone coordinator throws UnimplementedError when accessing coordinator getter',
        () {
          final coordinator = StandaloneCoordinator();

          expect(
            () => coordinator.coordinator,
            throwsA(
              isA<UnimplementedError>().having(
                (e) => e.message,
                'message',
                contains('This coordinator is standalone'),
              ),
            ),
          );
        },
      );

      test(
        'child coordinator returns parent when coordinator getter is overridden',
        () {
          final parent = TestParentCoordinator();
          final shopCoordinator = parent.getModule<ShopCoordinator>();

          expect(shopCoordinator.coordinator, equals(parent));
        },
      );

      test('all child coordinators point to the same parent', () {
        final parent = TestParentCoordinator();
        final shopCoordinator = parent.getModule<ShopCoordinator>();
        final settingsCoordinator = parent.getModule<SettingsCoordinator>();

        expect(shopCoordinator.coordinator, same(parent));
        expect(settingsCoordinator.coordinator, same(parent));
      });
    });

    group('isRouteModule', () {
      test('standalone coordinator returns false', () {
        final coordinator = StandaloneCoordinator();

        expect(coordinator.isRouteModule, isFalse);
      });

      test('child coordinator returns true', () {
        final parent = TestParentCoordinator();
        final shopCoordinator = parent.getModule<ShopCoordinator>();

        expect(shopCoordinator.isRouteModule, isTrue);
      });
    });

    group('root', () {
      test('standalone coordinator creates its own root NavigationPath', () {
        final coordinator = StandaloneCoordinator();

        expect(coordinator.root, isA<NavigationPath<AppRoute>>());
        expect(coordinator.root.debugLabel, equals('root'));
      });

      test('child coordinator root points to parent root (same instance)', () {
        final parent = TestParentCoordinator();
        final shopCoordinator = parent.getModule<ShopCoordinator>();
        final settingsCoordinator = parent.getModule<SettingsCoordinator>();

        expect(shopCoordinator.root, same(parent.root));
        expect(settingsCoordinator.root, same(parent.root));
      });

      test('child coordinator paths does not include root', () {
        final parent = TestParentCoordinator();
        final shopCoordinator = parent.getModule<ShopCoordinator>();

        // When isRouteModule is true, paths returns [] (no root)
        // Only the custom shopStack is added by the child's override
        expect(shopCoordinator.paths, isNot(contains(parent.root)));
      });

      test('standalone coordinator paths includes its own root', () {
        final coordinator = StandaloneCoordinator();

        expect(coordinator.paths, contains(coordinator.root));
      });
    });

    group('Module Registration', () {
      test('child coordinators are registered as modules', () {
        final parent = TestParentCoordinator();

        expect(parent.getModule<ShopCoordinator>(), isA<ShopCoordinator>());
        expect(
          parent.getModule<SettingsCoordinator>(),
          isA<SettingsCoordinator>(),
        );
      });

      test('child coordinator modules are singletons within parent', () {
        final parent = TestParentCoordinator();

        final shop1 = parent.getModule<ShopCoordinator>();
        final shop2 = parent.getModule<ShopCoordinator>();

        expect(identical(shop1, shop2), isTrue);
      });

      test('child coordinators are also Coordinator instances', () {
        final parent = TestParentCoordinator();

        final shopModule = parent.getModule<ShopCoordinator>();
        expect(shopModule, isA<Coordinator<AppRoute>>());
        expect(shopModule, isA<RouteModule<AppRoute>>());
      });
    });

    group('Route Parsing delegation', () {
      test('parent delegates to child coordinator for route parsing', () async {
        final parent = TestParentCoordinator();

        final route = await parent.parseRouteFromUri(Uri.parse('/shop'));
        expect(route, isA<ShopHomeRoute>());
      });

      test('parent delegates to correct child for each route', () async {
        final parent = TestParentCoordinator();

        final shopRoute = await parent.parseRouteFromUri(Uri.parse('/shop'));
        expect(shopRoute, isA<ShopHomeRoute>());

        final settingsRoute = await parent.parseRouteFromUri(
          Uri.parse('/settings'),
        );
        expect(settingsRoute, isA<SettingsRoute>());

        final homeRoute = await parent.parseRouteFromUri(Uri.parse('/'));
        expect(homeRoute, isA<HomeRoute>());
      });

      test('child coordinator parses routes with parameters', () async {
        final parent = TestParentCoordinator();

        final route = await parent.parseRouteFromUri(
          Uri.parse('/shop/products/42'),
        );
        expect(route, isA<ShopProductRoute>());
        expect((route as ShopProductRoute).id, equals('42'));
      });

      test('notFoundRoute is returned when no child handles the URI', () async {
        final parent = TestParentCoordinator();

        final route = await parent.parseRouteFromUri(
          Uri.parse('/unknown/path'),
        );
        expect(route, isA<NotFoundRoute>());
      });
    });

    group('Path Aggregation', () {
      test('parent aggregates paths from child coordinators', () {
        final parent = TestParentCoordinator();
        final shopCoordinator = parent.getModule<ShopCoordinator>();
        final settingsCoordinator = parent.getModule<SettingsCoordinator>();

        final paths = parent.paths;
        expect(paths, contains(parent.root));
        expect(paths, contains(shopCoordinator.shopStack));
        expect(paths, contains(settingsCoordinator.settingsStack));
      });

      test('child coordinator paths are independently addressable', () {
        final parent = TestParentCoordinator();
        final shopCoordinator = parent.getModule<ShopCoordinator>();
        final settingsCoordinator = parent.getModule<SettingsCoordinator>();

        expect(
          shopCoordinator.shopStack,
          isNot(same(settingsCoordinator.settingsStack)),
        );
        expect(shopCoordinator.shopStack.debugLabel, equals('shop'));
        expect(
          settingsCoordinator.settingsStack.debugLabel,
          equals('settings'),
        );
      });
    });

    group('Layout Definition delegation', () {
      test('child coordinator layouts are registered via parent', () {
        var shopLayoutCalled = false;
        var settingsLayoutCalled = false;

        _LayoutTrackingParent(
          onShopLayout: () => shopLayoutCalled = true,
          onSettingsLayout: () => settingsLayoutCalled = true,
        );

        expect(shopLayoutCalled, isTrue);
        expect(settingsLayoutCalled, isTrue);
      });
    });

    group('Converter Definition delegation', () {
      test('child coordinator converters are registered via parent', () {
        var shopConverterCalled = false;
        var settingsConverterCalled = false;

        _ConverterTrackingParent(
          onShopConverter: () => shopConverterCalled = true,
          onSettingsConverter: () => settingsConverterCalled = true,
        );

        expect(shopConverterCalled, isTrue);
        expect(settingsConverterCalled, isTrue);
      });
    });

    group('Navigation via parent', () {
      test('push route into child coordinator path', () async {
        final parent = TestParentCoordinator();

        parent.push(ShopHomeRoute());
        await Future.delayed(Duration.zero);

        final shopCoordinator = parent.getModule<ShopCoordinator>();
        expect(shopCoordinator.shopStack.stack, contains(isA<ShopHomeRoute>()));
      });

      test('push routes into different child coordinator paths', () async {
        final parent = TestParentCoordinator();

        await parent.replace(ShopHomeRoute());
        final shopCoordinator = parent.getModule<ShopCoordinator>();
        expect(shopCoordinator.shopStack.stack.last, isA<ShopHomeRoute>());

        await parent.replace(SettingsRoute());
        final settingsCoordinator = parent.getModule<SettingsCoordinator>();
        expect(
          settingsCoordinator.settingsStack.stack.last,
          isA<SettingsRoute>(),
        );
      });

      test('cross-coordinator navigation works', () async {
        final parent = TestParentCoordinator();

        // Start in shop
        parent.replace(ShopHomeRoute());
        await Future.delayed(Duration.zero);
        final shopCoordinator = parent.getModule<ShopCoordinator>();
        expect(shopCoordinator.shopStack.stack.last, isA<ShopHomeRoute>());

        // Navigate to settings (different child coordinator)
        parent.push(SettingsRoute());
        await Future.delayed(Duration.zero);
        final settingsCoordinator = parent.getModule<SettingsCoordinator>();
        expect(
          settingsCoordinator.settingsStack.stack.last,
          isA<SettingsRoute>(),
        );
      });
    });
  });

  group('Router assert — standalone coordinator', () {
    test(
      'standalone coordinator that always returns non-null passes assert',
      () async {
        final coordinator = StandaloneCoordinator();

        // Should not throw — route is non-null for a standalone coordinator
        await expectLater(
          coordinator.routerDelegate.setNewRoutePath(Uri.parse('/')),
          completes,
        );
      },
    );

    test(
      'standalone coordinator returning null for unknown URI triggers assert',
      () async {
        final coordinator = StandaloneNullReturningCoordinator();

        // The assert checks: if coordinator is standalone (throws
        // UnimplementedError with 'This coordinator is standalone') AND
        // route is null, the assert fails.
        expect(
          () => coordinator.routerDelegate.setNewRoutePath(
            Uri.parse('/unknown/path'),
          ),
          throwsA(isA<AssertionError>()),
        );
      },
    );

    testWidgets(
      'standalone coordinator navigation works when route is non-null',
      (tester) async {
        final coordinator = StandaloneCoordinator();

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );

        coordinator.replace(HomeRoute());
        await tester.pumpAndSettle();

        expect(find.text('HomeRoute'), findsOneWidget);

        // Navigate via setNewRoutePath — assert should pass
        await coordinator.routerDelegate.setNewRoutePath(
          Uri.parse('/standalone-page'),
        );
        await tester.pumpAndSettle();

        expect(coordinator.root.stack.last, isA<StandalonePageRoute>());
      },
    );
  });

  group('Router assert — Coordinator as RouteModule (child coordinator)', () {
    test(
      'child coordinator does not trigger standalone assert (has parent)',
      () async {
        final parent = TestParentCoordinator();

        // The coordinator.coordinator getter does NOT throw
        // UnimplementedError, so the assert always passes regardless of
        // whether route is null.
        await expectLater(
          parent.routerDelegate.setNewRoutePath(Uri.parse('/shop')),
          completes,
        );
      },
    );

    test(
      'child coordinator with unknown route falls through to notFoundRoute',
      () async {
        final parent = TestParentCoordinator();

        // Parent has notFoundRoute so it always returns non-null.
        // The assert passes because coordinator.coordinator does NOT throw.
        await expectLater(
          parent.routerDelegate.setNewRoutePath(Uri.parse('/unknown')),
          completes,
        );
      },
    );

    testWidgets('full router flow with child coordinator modules', (
      tester,
    ) async {
      final parent = TestParentCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: parent.routerDelegate,
          routeInformationParser: parent.routeInformationParser,
        ),
      );

      parent.replace(HomeRoute());
      await tester.pumpAndSettle();
      expect(find.text('HomeRoute'), findsOneWidget);

      // Navigate to shop (handled by ShopCoordinator module)
      await parent.routerDelegate.setNewRoutePath(Uri.parse('/shop'));
      await tester.pumpAndSettle();

      final shopCoordinator = parent.getModule<ShopCoordinator>();
      expect(shopCoordinator.shopStack.stack.last, isA<ShopHomeRoute>());

      // Navigate to settings (handled by SettingsCoordinator module)
      await parent.routerDelegate.setNewRoutePath(Uri.parse('/settings'));
      await tester.pumpAndSettle();

      final settingsCoordinator = parent.getModule<SettingsCoordinator>();
      expect(
        settingsCoordinator.settingsStack.stack.last,
        isA<SettingsRoute>(),
      );
    });
  });

  group('Nested CoordinatorModular (CoordinatorModular as RouteModule)', () {
    group('isRouteModule and root', () {
      test('nested CoordinatorModular has isRouteModule == true', () {
        final grandParent = NestedGrandParentCoordinator();
        final blogCoordinator = grandParent.getModule<BlogCoordinator>();

        expect(blogCoordinator.isRouteModule, isTrue);
      });

      test('nested CoordinatorModular root points to grandparent root', () {
        final grandParent = NestedGrandParentCoordinator();
        final blogCoordinator = grandParent.getModule<BlogCoordinator>();

        expect(blogCoordinator.root, same(grandParent.root));
      });

      test('grandparent isRouteModule is false (it is standalone)', () {
        final grandParent = NestedGrandParentCoordinator();

        expect(grandParent.isRouteModule, isFalse);
      });
    });

    group('Route Parsing cascading', () {
      test(
        'grandparent delegates to nested CoordinatorModular for route parsing',
        () async {
          final grandParent = NestedGrandParentCoordinator();

          final blogHome = await grandParent.parseRouteFromUri(
            Uri.parse('/blog'),
          );
          expect(blogHome, isA<BlogHomeRoute>());
        },
      );

      test(
        'grandparent cascades through nested CoordinatorModular to its child modules',
        () async {
          final grandParent = NestedGrandParentCoordinator();

          final blogPost = await grandParent.parseRouteFromUri(
            Uri.parse('/blog/posts/hello-world'),
          );
          expect(blogPost, isA<BlogPostRoute>());
          expect((blogPost as BlogPostRoute).slug, equals('hello-world'));

          final blogComment = await grandParent.parseRouteFromUri(
            Uri.parse('/blog/posts/hello-world/comments'),
          );
          expect(blogComment, isA<BlogCommentRoute>());
          expect(
            (blogComment as BlogCommentRoute).postSlug,
            equals('hello-world'),
          );
        },
      );

      test(
        'routes from sibling modules of the grandparent still work',
        () async {
          final grandParent = NestedGrandParentCoordinator();

          final homeRoute = await grandParent.parseRouteFromUri(Uri.parse('/'));
          expect(homeRoute, isA<HomeRoute>());

          final shopRoute = await grandParent.parseRouteFromUri(
            Uri.parse('/shop'),
          );
          expect(shopRoute, isA<ShopHomeRoute>());
        },
      );

      test(
        'unknown URI falls through all levels to grandparent notFoundRoute',
        () async {
          final grandParent = NestedGrandParentCoordinator();

          final route = await grandParent.parseRouteFromUri(
            Uri.parse('/completely/unknown'),
          );
          expect(route, isA<NotFoundRoute>());
        },
      );
    });

    group('Path Aggregation across levels', () {
      test('grandparent aggregates paths from all levels', () {
        final grandParent = NestedGrandParentCoordinator();
        final shopCoordinator = grandParent.getModule<ShopCoordinator>();
        final blogCoordinator = grandParent.getModule<BlogCoordinator>();

        final paths = grandParent.paths;
        expect(paths, contains(grandParent.root));
        expect(paths, contains(shopCoordinator.shopStack));
        expect(paths, contains(blogCoordinator.blogStack));
      });
    });

    group('Navigation via grandparent to nested module', () {
      test(
        'push route handled by nested CoordinatorModular child module',
        () async {
          final grandParent = NestedGrandParentCoordinator();

          await grandParent.replace(BlogHomeRoute());

          final blogCoordinator = grandParent.getModule<BlogCoordinator>();
          expect(blogCoordinator.blogStack.stack.last, isA<BlogHomeRoute>());
        },
      );

      test('push route with parameters through nested modules', () async {
        final grandParent = NestedGrandParentCoordinator();

        await grandParent.replace(BlogPostRoute(slug: 'my-post'));

        final blogCoordinator = grandParent.getModule<BlogCoordinator>();
        expect(blogCoordinator.blogStack.stack.last, isA<BlogPostRoute>());
      });

      test(
        'cross-module navigation between sibling and nested CoordinatorModular',
        () async {
          final grandParent = NestedGrandParentCoordinator();

          // Navigate to shop (sibling module)
          await grandParent.replace(ShopHomeRoute());
          final shopCoordinator = grandParent.getModule<ShopCoordinator>();
          expect(shopCoordinator.shopStack.stack.last, isA<ShopHomeRoute>());

          // Navigate to blog (nested CoordinatorModular module)
          await grandParent.replace(BlogHomeRoute());
          final blogCoordinator = grandParent.getModule<BlogCoordinator>();
          expect(blogCoordinator.blogStack.stack.last, isA<BlogHomeRoute>());
        },
      );
    });

    group('Layout Definition in nested CoordinatorModular', () {
      test(
        'nested CoordinatorModular layouts are registered via grandparent',
        () {
          var blogLayoutCalled = false;

          _NestedLayoutTrackingGrandParent(
            onBlogLayout: () => blogLayoutCalled = true,
          );

          expect(blogLayoutCalled, isTrue);
        },
      );
    });
  });
}

// ============================================================================
// Test Helper Coordinators
// ============================================================================

class _LayoutTrackingShopCoordinator extends Coordinator<AppRoute> {
  _LayoutTrackingShopCoordinator(this._parent, {required this.onLayout});
  final _LayoutTrackingParent _parent;
  final VoidCallback onLayout;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() => onLayout();
}

class _LayoutTrackingSettingsCoordinator extends Coordinator<AppRoute> {
  _LayoutTrackingSettingsCoordinator(this._parent, {required this.onLayout});
  final _LayoutTrackingParent _parent;
  final VoidCallback onLayout;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() => onLayout();
}

class _LayoutTrackingParent extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  _LayoutTrackingParent({
    required this.onShopLayout,
    required this.onSettingsLayout,
  });

  final VoidCallback onShopLayout;
  final VoidCallback onSettingsLayout;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    _LayoutTrackingShopCoordinator(this, onLayout: onShopLayout),
    _LayoutTrackingSettingsCoordinator(this, onLayout: onSettingsLayout),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class _ConverterTrackingShopCoordinator extends Coordinator<AppRoute> {
  _ConverterTrackingShopCoordinator(this._parent, {required this.onConverter});
  final _ConverterTrackingParent _parent;
  final VoidCallback onConverter;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineConverter() => onConverter();
}

class _ConverterTrackingSettingsCoordinator extends Coordinator<AppRoute> {
  _ConverterTrackingSettingsCoordinator(
    this._parent, {
    required this.onConverter,
  });
  final _ConverterTrackingParent _parent;
  final VoidCallback onConverter;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineConverter() => onConverter();
}

class _ConverterTrackingParent extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  _ConverterTrackingParent({
    required this.onShopConverter,
    required this.onSettingsConverter,
  });

  final VoidCallback onShopConverter;
  final VoidCallback onSettingsConverter;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    _ConverterTrackingShopCoordinator(this, onConverter: onShopConverter),
    _ConverterTrackingSettingsCoordinator(
      this,
      onConverter: onSettingsConverter,
    ),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

// --- Nested layout tracking helpers ---

class _NestedLayoutTrackingBlogCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  _NestedLayoutTrackingBlogCoordinator(this._parent, {required this.onLayout});
  final _NestedLayoutTrackingGrandParent _parent;
  final VoidCallback onLayout;

  @override
  CoordinatorModular<AppRoute> get coordinator => _parent;

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() => onLayout();

  @override
  Set<RouteModule<AppRoute>> defineModules() => {};

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class _NestedLayoutTrackingGrandParent extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  _NestedLayoutTrackingGrandParent({required this.onBlogLayout});

  final VoidCallback onBlogLayout;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    _NestedLayoutTrackingBlogCoordinator(this, onLayout: onBlogLayout),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}



================================================
FILE: packages/zenrouter/test/coordinator/error_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Application Setup
// ============================================================================

/// Base route for all test routes
abstract class ErrorTestRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

/// Simple route for basic testing
class SimpleErrorRoute extends ErrorTestRoute {
  SimpleErrorRoute({this.id = 'default'});
  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(
    covariant ErrorTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(key: ValueKey('simple-$id'), body: Text('Simple: $id'));
  }

  @override
  List<Object?> get props => [id];
}

// Mock a custom StackPath type by using a fake Type
class FakeStackPathType {}

/// Layout that uses a non-existent path type name for testing
class MockUnregisteredPathLayout extends ErrorTestRoute
    with RouteLayout<ErrorTestRoute> {
  @override
  UnregisteredCustomPath<ErrorTestRoute> resolvePath(
    ErrorTestCoordinator coordinator,
  ) => coordinator.testStack;

  @override
  Uri toUri() => Uri.parse('/mock-unregistered-layout');

  @override
  List<Object?> get props => [];
}

/// Layout type that is NOT defined in defineLayout (for testing constructor error)
class UndefinedLayout extends ErrorTestRoute with RouteLayout<ErrorTestRoute> {
  @override
  UnregisteredCustomPath<ErrorTestRoute> resolvePath(
    ErrorTestCoordinator coordinator,
  ) => coordinator.testStack;

  @override
  Uri toUri() => Uri.parse('/undefined-layout');

  @override
  List<Object?> get props => [];
}

/// Route that requires UndefinedLayout
class RouteWithUndefinedLayout extends ErrorTestRoute {
  @override
  Type get layout => UndefinedLayout;

  @override
  Uri toUri() => Uri.parse('/route-with-undefined-layout');

  @override
  Widget build(
    covariant ErrorTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('route-with-undefined-layout'),
      body: const Text('Should not render'),
    );
  }

  @override
  List<Object?> get props => [];
}

/// Child route that uses MockUnregisteredPathLayout as its layout
class RouteWithMockLayout extends ErrorTestRoute {
  @override
  Type get layout => MockUnregisteredPathLayout;

  @override
  Uri toUri() => Uri.parse('/route-with-mock-layout');

  @override
  Widget build(
    covariant ErrorTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('route-with-mock-layout'),
      body: const Text('Should not render'),
    );
  }

  @override
  List<Object?> get props => [];
}

class NormalIndexedStackLayout extends ErrorTestRoute
    with RouteLayout<ErrorTestRoute> {
  @override
  IndexedStackPath<ErrorTestRoute> resolvePath(
    ErrorTestCoordinator coordinator,
  ) => coordinator.normalIndexedStack;

  @override
  Uri toUri() => Uri.parse('/normal-indexed-stack-layout');

  @override
  List<Object?> get props => [];
}

class NormalNavigationLayout extends ErrorTestRoute
    with RouteLayout<ErrorTestRoute> {
  @override
  NavigationPath<ErrorTestRoute> resolvePath(
    ErrorTestCoordinator coordinator,
  ) => coordinator.normalStack;

  @override
  Uri toUri() => Uri.parse('/normal-layout');

  @override
  List<Object?> get props => [];
}

/// Route that is NOT in the IndexedStackPath but uses the same layout
class MissingTabRoute extends ErrorTestRoute {
  @override
  Type get layout => NormalIndexedStackLayout;

  @override
  Uri toUri() => Uri.parse('/missing-tab');

  @override
  Widget build(
    covariant ErrorTestCoordinator coordinator,
    BuildContext context,
  ) {
    return const Scaffold(
      key: ValueKey('missing-tab'),
      body: Text('Missing Tab'),
    );
  }

  @override
  List<Object?> get props => [];
}

/// Test coordinator
class ErrorTestCoordinator extends Coordinator<ErrorTestRoute> {
  late final UnregisteredCustomPath<ErrorTestRoute> testStack =
      UnregisteredCustomPath(coordinator: this, label: 'test');
  late final NavigationPath<ErrorTestRoute> normalStack =
      NavigationPath.createWith(coordinator: this, label: 'root');
  late final IndexedStackPath<ErrorTestRoute> normalIndexedStack =
      IndexedStackPath.createWith(
        [SimpleErrorRoute(id: 'home')],
        coordinator: this,
        label: 'root',
      );

  @override
  void defineLayout() {
    // Intentionally NOT defining UndefinedLayout to test the error
    // But DO define MockUnregisteredPathLayout so we can test the path builder error
    RouteLayout.defineLayout(
      MockUnregisteredPathLayout,
      () => MockUnregisteredPathLayout(),
    );
    RouteLayout.defineLayout(
      NormalIndexedStackLayout,
      () => NormalIndexedStackLayout(),
    );
  }

  @override
  List<StackPath> get paths => [...super.paths, testStack];

  @override
  ErrorTestRoute parseRouteFromUri(Uri uri) {
    final segments = uri.pathSegments;
    if (segments.isEmpty) return SimpleErrorRoute(id: 'home');

    return switch (segments) {
      ['simple', final id] => SimpleErrorRoute(id: id),
      ['mock-unregistered-layout'] => MockUnregisteredPathLayout(),
      ['route-with-mock-layout'] => RouteWithMockLayout(),
      ['undefined-layout'] => UndefinedLayout(),
      ['route-with-undefined-layout'] => RouteWithUndefinedLayout(),
      _ => SimpleErrorRoute(id: 'home'),
    };
  }
}

// Custom StackPath that will not have a registered builder
class UnregisteredCustomPath<T extends RouteUnique> extends StackPath<T> {
  final List<T> _internalStack;
  UnregisteredCustomPath({
    required Coordinator coordinator,
    required String label,
  }) : _internalStack = <T>[],
       super(<T>[], debugLabel: label, coordinator: coordinator);

  @override
  PathKey get pathKey => const PathKey('FakeStackPathType');

  @override
  T? get activeRoute => _internalStack.isEmpty ? null : _internalStack.last;

  @override
  Future<void> activateRoute(T route) async {
    if (!_internalStack.contains(route)) {
      _internalStack.add(route);
    }
    notifyListeners();
  }

  @override
  void reset() {
    _internalStack.clear();
    notifyListeners();
  }

  @override
  List<T> get stack => List.unmodifiable(_internalStack);
}

class LayoutWithUnregisteredPath extends ErrorTestRoute
    with RouteLayout<ErrorTestRoute> {
  final UnregisteredCustomPath<ErrorTestRoute> customPath;

  LayoutWithUnregisteredPath(this.customPath);

  @override
  StackPath<RouteUnique> resolvePath(ErrorTestCoordinator coordinator) =>
      customPath;

  @override
  Uri toUri() => Uri.parse('/layout-unregistered-path');

  @override
  List<Object?> get props => [];
}

class GuardedTestRoute extends ErrorTestRoute with RouteGuard {
  GuardedTestRoute({this.allowPop = true});
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guarded');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(
    covariant ErrorTestCoordinator coordinator,
    BuildContext context,
  ) {
    return const Scaffold(body: Text('Guarded'));
  }

  @override
  List<Object?> get props => [allowPop];
}

class SecondCoordinator extends Coordinator<ErrorTestRoute> {
  @override
  void defineLayout() {}

  @override
  ErrorTestRoute parseRouteFromUri(Uri uri) {
    return SimpleErrorRoute(id: 'second');
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('IndexedStackPath Error Tests', () {
    test(
      'goToIndexed throws StateError with meaningful message for out of bounds index',
      () {
        final stack = IndexedStackPath<ErrorTestRoute>.create([
          SimpleErrorRoute(id: 'tab1'),
          SimpleErrorRoute(id: 'tab2'),
          SimpleErrorRoute(id: 'tab3'),
        ], label: 'test-tabs');

        // Test index too high
        expect(
          () => stack.goToIndexed(3),
          throwsA(
            isA<StateError>().having(
              (e) => e.message,
              'message',
              'Index out of bounds',
            ),
          ),
        );

        expect(
          () => stack.goToIndexed(99),
          throwsA(
            isA<StateError>().having(
              (e) => e.message,
              'message',
              'Index out of bounds',
            ),
          ),
        );
      },
    );

    test('goToIndexed allows valid indices', () {
      final stack = IndexedStackPath<ErrorTestRoute>.create([
        SimpleErrorRoute(id: 'tab1'),
        SimpleErrorRoute(id: 'tab2'),
        SimpleErrorRoute(id: 'tab3'),
      ], label: 'test-tabs');

      // These should not throw
      expect(() => stack.goToIndexed(0), returnsNormally);
      expect(() => stack.goToIndexed(1), returnsNormally);
      expect(() => stack.goToIndexed(2), returnsNormally);
    });

    test(
      'activateRoute throws StateError with meaningful message for route not in stack',
      () {
        final stack = IndexedStackPath<ErrorTestRoute>.create([
          SimpleErrorRoute(id: 'tab1'),
          SimpleErrorRoute(id: 'tab2'),
        ], label: 'test-tabs');

        final missingRoute = SimpleErrorRoute(id: 'not-in-stack');

        expect(
          () => stack.activateRoute(missingRoute),
          throwsA(
            isA<StateError>().having(
              (e) => e.message,
              'message',
              'Route not found',
            ),
          ),
        );
      },
    );

    test('activateRoute works for routes that are in stack', () {
      final route1 = SimpleErrorRoute(id: 'tab1');
      final route2 = SimpleErrorRoute(id: 'tab2');

      final stack = IndexedStackPath<ErrorTestRoute>.create([
        route1,
        route2,
      ], label: 'test-tabs');

      // Should not throw
      expect(() => stack.activateRoute(route1), returnsNormally);
      expect(() => stack.activateRoute(route2), returnsNormally);
    });
  });

  group('RouteLayout Error Tests', () {
    test(
      'buildPath throws UnimplementedError with helpful message for unregistered StackPath type',
      () {
        final coordinator = ErrorTestCoordinator();

        final errorLayout = MockUnregisteredPathLayout();

        expect(
          () => errorLayout.buildPath(coordinator),
          throwsA(
            isA<UnimplementedError>()
                .having(
                  (e) => e.message,
                  'message',
                  contains(
                    'No layout builder provided for [FakeStackPathType]',
                  ),
                )
                .having(
                  (e) => e.message,
                  'message',
                  contains(
                    'If you extend the [StackPath] class, you must register it',
                  ),
                )
                .having(
                  (e) => e.message,
                  'message',
                  contains('[RouteLayout.definePath]'),
                ),
          ),
        );
      },
    );

    testWidgets(
      'RouteLayout.build throws UnimplementedError when path layout not registered',
      (tester) async {
        final coordinator = ErrorTestCoordinator();

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        // Push a child route that HAS MockUnregisteredPathLayout as its layout
        // Don't await push -it returns a future that completes when route is popped
        coordinator.push(RouteWithMockLayout());

        // Try to build - this will trigger the error during the build phase
        await tester.pumpAndSettle();

        // Flutter catches build errors, so we need to retrieve it using takeException
        final exception = tester.takeException();
        expect(exception, isA<UnimplementedError>());
        expect(
          (exception as UnimplementedError).message,
          contains('No layout builder provided for [FakeStackPathType]'),
        );
      },
    );
  });

  group('Error Message Quality Tests', () {
    test('StateError messages are concise and clear', () async {
      final stack = IndexedStackPath<ErrorTestRoute>.create([
        SimpleErrorRoute(id: 'tab1'),
      ], label: 'test');

      try {
        await stack.goToIndexed(5);
        fail('Should have thrown StateError');
      } on StateError catch (e) {
        // Verify message is concise and actionable
        expect(e.message, 'Index out of bounds');
        expect(e.message.length, lessThan(50)); // Keep it short
      }

      try {
        await stack.activateRoute(SimpleErrorRoute(id: 'missing'));
        fail('Should have thrown StateError');
      } on StateError catch (e) {
        // Verify message is concise and actionable
        expect(e.message, 'Route not found');
        expect(e.message.length, lessThan(50)); // Keep it short
      }
    });

    test('UnimplementedError messages contain actionable information', () {
      final coordinator = ErrorTestCoordinator();

      final errorLayout = MockUnregisteredPathLayout();

      // Test buildPath error
      try {
        errorLayout.buildPath(coordinator);
        fail('Should have thrown UnimplementedError');
      } on UnimplementedError catch (e) {
        // Should mention the type name
        expect(e.message, contains('FakeStackPathType'));
        // Should tell where to register
        expect(e.message, contains('RouteLayout.definePath'));
        // Should explain the condition
        expect(e.message, contains('extend the [StackPath]'));
      }

      // Test createLayout error
      try {
        RouteWithUndefinedLayout().createLayout(coordinator);
        fail('Should have thrown UnimplementedError');
      } on UnimplementedError catch (e) {
        // Should mention the layout type
        expect(e.message, contains('UndefinedLayout'));
        // Should tell where to define
        expect(e.message, contains('defineLayout'));
        // Should mention how to define
        expect(e.message, contains('RouteLayout.defineLayout'));
        // Should reference your coordinator
        expect(e.message, contains('ErrorTestCoordinator'));
      }
    });

    test('Error messages guide developers to the solution', () {
      // Test that error messages include:
      // 1. What went wrong (the type/value that caused the issue)
      // 2. Where to fix it (the class/table/method)
      // 3. How to fix it (register/define/add)

      final coordinator = ErrorTestCoordinator();

      try {
        RouteWithUndefinedLayout().createLayout(coordinator);
        fail('Should have thrown');
      } on UnimplementedError catch (e) {
        final message = e.message ?? '';

        // What: mentions the specific layout type
        expect(message, contains('Missing'));
        expect(message, contains('UndefinedLayout'));

        // Where: mentions where to register
        expect(message, contains('RouteLayout.defineLayout'));
        expect(message, contains('defineLayout'));
        expect(message, contains('ErrorTestCoordinator'));
      }
    });
  });

  group('Error Prevention Tests', () {
    test('IndexedStackPath prevents invalid construction', () {
      // Empty stack should be caught by assertion
      expect(
        () => IndexedStackPath<ErrorTestRoute>.create([], label: 'test'),
        throwsA(isA<AssertionError>()),
      );
    });

    test('Registered types do not throw errors', () {
      final coordinator = ErrorTestCoordinator();

      final normalLayout = NormalNavigationLayout();

      // NavigationPath is registered by default
      expect(() => normalLayout.buildPath(coordinator), returnsNormally);

      // IndexedStackPath is registered by default
      final indexedStackLayout = NormalIndexedStackLayout();
      expect(() => indexedStackLayout.buildPath(coordinator), returnsNormally);
    });
  });

  group('RouteLayout.build Error Tests', () {
    testWidgets(
      'RouteLayout.build throws UnimplementedError when builder is null',
      (tester) async {
        final coordinator = ErrorTestCoordinator();
        final customPath = UnregisteredCustomPath<ErrorTestRoute>(
          coordinator: coordinator,
          label: 'custom',
        );
        final layout = LayoutWithUnregisteredPath(customPath);

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        // Push the layout which will trigger RouteLayout.build
        coordinator.push(layout);
        await tester.pumpAndSettle();

        // Flutter catches build errors
        final exception = tester.takeException();
        expect(exception, isA<UnimplementedError>());
        expect(
          (exception as UnimplementedError).message,
          contains('If you extend the [StackPath] class, you must register it'),
        );
      },
    );

    test('RouteLayout.build error message is helpful', () {
      final coordinator = ErrorTestCoordinator();
      final customPath = UnregisteredCustomPath<ErrorTestRoute>(
        coordinator: coordinator,
        label: 'custom',
      );
      final layout = LayoutWithUnregisteredPath(customPath);

      // Verify that attempting to build will throw an error
      // by checking that buildPath fails for this type
      expect(
        () => layout.buildPath(coordinator),
        throwsA(
          isA<UnimplementedError>().having(
            (e) => e.message,
            'message',
            contains('definePath'),
          ),
        ),
      );
    });
  });

  group('RouteGuard.popGuardWith Assertion Tests', () {
    test('popGuardWith asserts when coordinator mismatch', () async {
      final coordinator1 = ErrorTestCoordinator();
      final coordinator2 = SecondCoordinator();

      final route = GuardedTestRoute();

      // Push the route to coordinator1
      coordinator1.push(route);

      // Try to call popGuardWith with coordinator2 (wrong coordinator)
      expect(
        () => route.popGuardWith(coordinator2),
        throwsA(isA<AssertionError>()),
      );
    });

    test(
      'popGuardWith assertion message contains helpful information',
      () async {
        final coordinator1 = ErrorTestCoordinator();
        final coordinator2 = SecondCoordinator();

        final route = GuardedTestRoute();

        // Push the route to coordinator1
        coordinator1.push(route);

        // Try to call popGuardWith with coordinator2
        try {
          route.popGuardWith(coordinator2);
          fail('Should have thrown AssertionError');
        } on AssertionError catch (e) {
          final message = e.message.toString();
          // Should mention RouteGuard
          expect(message, contains('RouteGuard'));
          // Should mention the expected coordinator
          expect(message, contains('Expected coordinator'));
          // Should mention path's coordinator
          expect(message, contains('Path\'s coordinator'));
          // Should guide on using createWith
          expect(message, contains('.createWith()'));
        }
      },
    );

    test('popGuardWith works correctly when coordinators match', () async {
      final coordinator = ErrorTestCoordinator();
      final route = GuardedTestRoute(allowPop: true);

      coordinator.push(route);
      await Future.delayed(Duration.zero);

      // Should not throw when using the correct coordinator
      final result = await route.popGuardWith(coordinator);
      expect(result, isTrue);
    });

    test('popGuardWith respects popGuard return value', () async {
      final coordinator = ErrorTestCoordinator();

      // Test with allowPop = false
      final blockedRoute = GuardedTestRoute(allowPop: false);
      coordinator.push(blockedRoute);
      await Future.delayed(Duration.zero);

      final blockedResult = await blockedRoute.popGuardWith(coordinator);
      expect(blockedResult, isFalse);

      // Clear the stack
      coordinator.root.reset();

      // Test with allowPop = true
      final allowedRoute = GuardedTestRoute(allowPop: true);
      coordinator.push(allowedRoute);
      await Future.delayed(Duration.zero);

      final allowedResult = await allowedRoute.popGuardWith(coordinator);
      expect(allowedResult, isTrue);
    });

    testWidgets(
      'popGuardWith assertion prevents incorrect coordinator usage in navigation',
      (tester) async {
        final coordinator1 = ErrorTestCoordinator();
        final coordinator2 = SecondCoordinator();

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator1.routerDelegate,
            routeInformationParser: coordinator1.routeInformationParser,
          ),
        );

        final route = GuardedTestRoute();
        coordinator1.push(route);
        await tester.pumpAndSettle();

        // Attempting to use the wrong coordinator should trigger the assertion
        expect(
          () => route.popGuardWith(coordinator2),
          throwsA(isA<AssertionError>()),
        );
      },
    );
  });

  group('IndexedStackPath Missing Route Tests', () {
    test(
      'resolveLayout throws AssertionError when route not in IndexedStackPath',
      () {
        final coordinator = ErrorTestCoordinator();
        final missingRoute = MissingTabRoute();

        // Attempting to resolve layout for a route that's not in the IndexedStackPath
        // should trigger an assertion error
        expect(
          () => missingRoute.resolveLayout(coordinator),
          throwsA(
            isA<AssertionError>().having(
              (e) => e.message.toString(),
              'message',
              allOf([
                contains('MissingTabRoute'),
                contains('IndexedStackPath'),
                contains('not present in the initial stack'),
                contains('root'), // The label of the indexed stack
                contains('Fix:'),
                contains('IndexedStackPath.createWith'),
              ]),
            ),
          ),
        );
      },
    );

    testWidgets(
      'navigate fails gracefully when route not in IndexedStackPath (production mode)',
      (tester) async {
        final coordinator = ErrorTestCoordinator();

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        // Test the guard in navigate() that prevents crashes when route is not in IndexedStackPath
        // Even if the assertion in resolveLayout is bypassed, navigate should handle this gracefully

        // First establish the IndexedStackPath layout
        coordinator.push(NormalIndexedStackLayout());
        await tester.pumpAndSettle();

        // Now directly call navigate with a route not in the stack
        final missingRoute = MissingTabRoute();

        // Create the layout manually to verify route is not in the stack
        final layout = NormalIndexedStackLayout();
        final path = layout.resolvePath(coordinator);

        // Verify the route is not in the stack
        expect(
          path.stack.any((r) => r.runtimeType == MissingTabRoute),
          isFalse,
        );

        try {
          // The navigate method should handle this gracefully and not crash
          await coordinator.navigate(missingRoute);
          await tester.pumpAndSettle();
        } on AssertionError catch (e) {
          final message = e.message.toString();

          // Should mention the route type
          expect(message, contains('MissingTabRoute'));

          // Should mention IndexedStackPath
          expect(message, contains('IndexedStackPath'));

          // Should show the path label
          expect(message, contains('root'));

          // Should explain the problem
          expect(message, contains('not present in the initial stack'));

          // Should show current stack contents
          expect(message, contains('Current stack'));
          expect(message, contains('SimpleErrorRoute'));

          // Should provide a fix with code example
          expect(message, contains('Fix:'));
          expect(message, contains('IndexedStackPath.createWith'));
          expect(message, contains('MissingTabRoute()'));
        }
      },
    );

    test('assertion message includes helpful information', () {
      final coordinator = ErrorTestCoordinator();
      final missingRoute = MissingTabRoute();

      try {
        missingRoute.resolveLayout(coordinator);
        fail('Should have thrown AssertionError');
      } on AssertionError catch (e) {
        final message = e.message.toString();

        // Should mention the route type
        expect(message, contains('MissingTabRoute'));

        // Should mention IndexedStackPath
        expect(message, contains('IndexedStackPath'));

        // Should show the path label
        expect(message, contains('root'));

        // Should explain the problem
        expect(message, contains('not present in the initial stack'));

        // Should show current stack contents
        expect(message, contains('Current stack'));
        expect(message, contains('SimpleErrorRoute'));

        // Should provide a fix with code example
        expect(message, contains('Fix:'));
        expect(message, contains('IndexedStackPath.createWith'));
        expect(message, contains('MissingTabRoute()'));
      }
    });
  });
}



================================================
FILE: packages/zenrouter/test/coordinator/modular_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Routes
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text(toString()));
  }

  @override
  List<Object?> get props => [];
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  String toString() => 'HomeRoute';
}

class AuthLoginRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/auth/login');

  @override
  String toString() => 'AuthLoginRoute';
}

class AuthRegisterRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/auth/register');

  @override
  String toString() => 'AuthRegisterRoute';
}

class ShopHomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/shop');

  @override
  String toString() => 'ShopHomeRoute';
}

class ShopProductRoute extends AppRoute {
  ShopProductRoute({required this.id});

  final String id;

  @override
  Uri toUri() => Uri.parse('/shop/products/$id');

  @override
  String toString() => 'ShopProductRoute(id: $id)';

  @override
  List<Object?> get props => [id];
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  String toString() => 'SettingsRoute';
}

class NotFoundRoute extends AppRoute {
  NotFoundRoute({required this.uri});

  final Uri uri;

  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  String toString() => 'NotFoundRoute(uri: $uri)';

  @override
  List<Object?> get props => [uri];
}

// ============================================================================
// Test Modules
// ============================================================================

class AuthModule extends RouteModule<AppRoute> {
  AuthModule(super.coordinator);

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['auth', 'login'] => AuthLoginRoute(),
      ['auth', 'register'] => AuthRegisterRoute(),
      _ => null,
    };
  }

  @override
  void defineLayout() {
    // Auth module doesn't define layouts
  }
}

class ShopModule extends RouteModule<AppRoute> {
  ShopModule(super.coordinator);

  late final NavigationPath<AppRoute> shopPath = NavigationPath.createWith(
    label: 'shop',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [shopPath];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['shop'] => ShopHomeRoute(),
      ['shop', 'products', final id] => ShopProductRoute(id: id),
      _ => null,
    };
  }

  @override
  void defineLayout() {
    RouteLayout.defineLayout(ShopLayout, ShopLayout.new);
  }
}

class SettingsModule extends RouteModule<AppRoute> {
  SettingsModule(super.coordinator);

  late final NavigationPath<AppRoute> settingsPath = NavigationPath.createWith(
    label: 'settings',
    coordinator: coordinator,
  );

  @override
  List<StackPath> get paths => [settingsPath];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['settings'] => SettingsRoute(),
      _ => null,
    };
  }

  @override
  void defineLayout() {
    // Settings module doesn't define layouts
  }
}

// Module that returns null for all routes (should be skipped)
class EmptyModule extends RouteModule<AppRoute> {
  EmptyModule(super.coordinator);

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() {}
}

// Module with async parsing
class AsyncModule extends RouteModule<AppRoute> {
  AsyncModule(super.coordinator, {this.delay = Duration.zero});

  final Duration delay;

  @override
  List<StackPath> get paths => [];

  @override
  Future<AppRoute?> parseRouteFromUri(Uri uri) async {
    await Future.delayed(delay);
    return switch (uri.pathSegments) {
      ['async'] => HomeRoute(),
      _ => null,
    };
  }

  @override
  void defineLayout() {}
}

// Module that throws an error
class ErrorModule extends RouteModule<AppRoute> {
  ErrorModule(super.coordinator);

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) {
    throw Exception('Module error');
  }

  @override
  void defineLayout() {}
}

// ============================================================================
// Test Layouts
// ============================================================================

class ShopLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) {
    final shopModule = coordinator.getModule<ShopModule>();
    return shopModule.shopPath;
  }

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: buildPath(coordinator));
  }
}

// ============================================================================
// Test Coordinators
// ============================================================================

class AppCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    AuthModule(this),
    ShopModule(this),
    SettingsModule(this),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class SingleModuleCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {AuthModule(this)};

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class EmptyModulesCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {EmptyModule(this)};

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class AsyncModulesCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  AsyncModulesCoordinator({Duration delay = Duration.zero}) : _delay = delay;

  final Duration _delay;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    AsyncModule(this, delay: _delay),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class ErrorModulesCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {ErrorModule(this)};

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('CoordinatorModular', () {
    group('Module Registration', () {
      test('registers modules correctly', () {
        final coordinator = AppCoordinator();

        expect(coordinator.getModule<AuthModule>(), isA<AuthModule>());
        expect(coordinator.getModule<ShopModule>(), isA<ShopModule>());
        expect(coordinator.getModule<SettingsModule>(), isA<SettingsModule>());
      });

      test('throws when accessing non-existent module', () {
        final coordinator = SingleModuleCoordinator();

        expect(
          () => coordinator.getModule<ShopModule>(),
          throwsA(isA<TypeError>()),
        );
      });

      test('modules are initialized with coordinator reference', () {
        final coordinator = AppCoordinator();

        final authModule = coordinator.getModule<AuthModule>();
        expect(authModule.coordinator, equals(coordinator));

        final shopModule = coordinator.getModule<ShopModule>();
        expect(shopModule.coordinator, equals(coordinator));
      });

      test('modules are stored by type', () {
        final coordinator = AppCoordinator();

        final module1 = coordinator.getModule<AuthModule>();
        final module2 = coordinator.getModule<AuthModule>();

        expect(identical(module1, module2), isTrue);
      });
    });

    group('Route Parsing', () {
      test('delegates to first matching module', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/auth/login'),
        );

        expect(route, isA<AuthLoginRoute>());
      });

      test('returns null from module when route not found in module', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/unknown'),
        );

        expect(route, isA<NotFoundRoute>());
      });

      test('checks modules in order until match found', () async {
        final coordinator = AppCoordinator();

        // Auth module should match first
        final authRoute = await coordinator.parseRouteFromUri(
          Uri.parse('/auth/login'),
        );
        expect(authRoute, isA<AuthLoginRoute>());

        // Shop module should match
        final shopRoute = await coordinator.parseRouteFromUri(
          Uri.parse('/shop'),
        );
        expect(shopRoute, isA<ShopHomeRoute>());

        // Settings module should match
        final settingsRoute = await coordinator.parseRouteFromUri(
          Uri.parse('/settings'),
        );
        expect(settingsRoute, isA<SettingsRoute>());
      });

      test('handles async route parsing', () async {
        final coordinator = AsyncModulesCoordinator();

        final route = await coordinator.parseRouteFromUri(Uri.parse('/async'));

        expect(route, isA<HomeRoute>());
      });

      test('handles routes with parameters', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/shop/products/123'),
        );

        expect(route, isA<ShopProductRoute>());
        expect((route as ShopProductRoute).id, equals('123'));
      });

      test('calls notFoundRoute when no module matches', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/unknown/route'),
        );

        expect(route, isA<NotFoundRoute>());
        expect((route as NotFoundRoute).uri.path, equals('/unknown/route'));
      });

      test('handles empty modules gracefully', () async {
        final coordinator = EmptyModulesCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/any/route'),
        );

        expect(route, isA<NotFoundRoute>());
      });

      test('propagates errors from module parsing', () async {
        final coordinator = ErrorModulesCoordinator();

        expect(
          () => coordinator.parseRouteFromUri(Uri.parse('/any')),
          throwsA(isA<Exception>()),
        );
      });
    });

    group('Path Aggregation', () {
      test('aggregates paths from all modules', () {
        final coordinator = AppCoordinator();

        final paths = coordinator.paths;

        // Should include root path + paths from ShopModule and SettingsModule
        expect(paths.length, greaterThan(1));

        // Check that shop path exists
        final shopModule = coordinator.getModule<ShopModule>();
        expect(paths, contains(shopModule.shopPath));

        // Check that settings path exists
        final settingsModule = coordinator.getModule<SettingsModule>();
        expect(paths, contains(settingsModule.settingsPath));
      });

      test('includes super paths', () {
        final coordinator = AppCoordinator();

        final paths = coordinator.paths;

        // Should include root path
        expect(paths, contains(coordinator.root));
      });

      test('modules without paths still work', () {
        final coordinator = SingleModuleCoordinator();

        final paths = coordinator.paths;

        // Should only have root path
        expect(paths.length, equals(1));
        expect(paths, contains(coordinator.root));
      });
    });

    group('Layout Definition', () {
      test('calls defineLayout on all modules', () {
        var authLayoutCalled = false;
        var shopLayoutCalled = false;
        var settingsLayoutCalled = false;

        _TestLayoutCoordinator(
          onAuthLayout: () => authLayoutCalled = true,
          onShopLayout: () => shopLayoutCalled = true,
          onSettingsLayout: () => settingsLayoutCalled = true,
        );

        // defineLayout is called during coordinator construction
        expect(authLayoutCalled, isTrue);
        expect(shopLayoutCalled, isTrue);
        expect(settingsLayoutCalled, isTrue);
      });

      test('allows modules to register layouts', () {
        final coordinator = AppCoordinator();

        // Shop module should have registered ShopLayout
        final shopModule = coordinator.getModule<ShopModule>();
        expect(shopModule.shopPath, isNotNull);
      });
    });

    group('Converter Definition', () {
      test('calls defineConverter on all modules', () {
        var authConverterCalled = false;
        var shopConverterCalled = false;
        var settingsConverterCalled = false;

        _TestConverterCoordinator(
          onAuthConverter: () => authConverterCalled = true,
          onShopConverter: () => shopConverterCalled = true,
          onSettingsConverter: () => settingsConverterCalled = true,
        );

        // defineConverter is called during coordinator construction
        expect(authConverterCalled, isTrue);
        expect(shopConverterCalled, isTrue);
        expect(settingsConverterCalled, isTrue);
      });
    });

    group('Module Isolation', () {
      test('modules do not interfere with each other', () async {
        final coordinator = AppCoordinator();

        // Each module should only handle its own routes
        final authRoute = await coordinator.parseRouteFromUri(
          Uri.parse('/auth/login'),
        );
        expect(authRoute, isA<AuthLoginRoute>());

        final shopRoute = await coordinator.parseRouteFromUri(
          Uri.parse('/shop'),
        );
        expect(shopRoute, isA<ShopHomeRoute>());

        // Modules should not handle each other's routes
        final notShopRoute = await coordinator.parseRouteFromUri(
          Uri.parse('/auth/shop'),
        );
        expect(notShopRoute, isA<NotFoundRoute>());
      });

      test('modules maintain separate path instances', () {
        final coordinator = AppCoordinator();

        final shopModule = coordinator.getModule<ShopModule>();
        final settingsModule = coordinator.getModule<SettingsModule>();

        expect(shopModule.shopPath, isNot(equals(settingsModule.settingsPath)));
      });
    });

    group('Edge Cases', () {
      test('handles empty URI', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(Uri.parse('/'));

        // Should fall through to notFoundRoute
        expect(route, isA<NotFoundRoute>());
      });

      test('handles URI with query parameters', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/auth/login?redirect=/home'),
        );

        expect(route, isA<AuthLoginRoute>());
      });

      test('handles URI with fragments', () async {
        final coordinator = AppCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/auth/login#section'),
        );

        expect(route, isA<AuthLoginRoute>());
      });

      test('handles multiple consecutive null returns', () async {
        final coordinator = EmptyModulesCoordinator();

        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/any/route'),
        );

        expect(route, isA<NotFoundRoute>());
      });
    });

    group('Integration Tests', () {
      test('full flow: parse route and navigate', () async {
        final coordinator = AppCoordinator();

        // Parse route from URI
        final route = await coordinator.parseRouteFromUri(
          Uri.parse('/shop/products/456'),
        );

        expect(route, isA<ShopProductRoute>());
        expect((route as ShopProductRoute).id, equals('456'));

        // Push route
        coordinator.push(route);
        await Future.delayed(Duration.zero);

        // Verify route is in stack
        expect(coordinator.root.stack.isNotEmpty, isTrue);
      });

      test('module paths are accessible for navigation', () async {
        final coordinator = AppCoordinator();

        final shopModule = coordinator.getModule<ShopModule>();

        // Module paths should be accessible and functional
        expect(shopModule.shopPath, isNotNull);
        expect(shopModule.shopPath.debugLabel, equals('shop'));

        // Should be able to push directly to module's path
        shopModule.shopPath.push(ShopHomeRoute());
        await Future.delayed(Duration.zero);
        expect(shopModule.shopPath.stack.length, equals(1));
        expect(shopModule.shopPath.stack.last, isA<ShopHomeRoute>());
      });

      test('coordinator can access module-specific functionality', () {
        final coordinator = AppCoordinator();

        final shopModule = coordinator.getModule<ShopModule>();

        // Module-specific paths should be accessible
        expect(shopModule.shopPath, isNotNull);
        expect(shopModule.shopPath.debugLabel, equals('shop'));
      });
    });
  });

  group('RouteModule', () {
    test('can be instantiated with coordinator', () {
      final coordinator = AppCoordinator();
      final module = AuthModule(coordinator);

      expect(module.coordinator, equals(coordinator));
    });

    test('default paths returns empty list', () {
      final coordinator = AppCoordinator();
      final module = AuthModule(coordinator);

      expect(module.paths, isEmpty);
    });

    test('default defineLayout does nothing', () {
      final coordinator = AppCoordinator();
      final module = AuthModule(coordinator);

      // Should not throw
      expect(() => module.defineLayout(), returnsNormally);
    });

    test('default defineConverter does nothing', () {
      final coordinator = AppCoordinator();
      final module = AuthModule(coordinator);

      // Should not throw
      expect(() => module.defineConverter(), returnsNormally);
    });

    test('can override paths getter', () {
      final coordinator = AppCoordinator();
      final shopModule = coordinator.getModule<ShopModule>();

      expect(shopModule.paths.length, equals(1));
      expect(shopModule.paths.first, equals(shopModule.shopPath));
    });

    test('can override defineLayout', () {
      final coordinator = AppCoordinator();
      final shopModule = coordinator.getModule<ShopModule>();

      // Shop module defines layout, should not throw
      expect(() => shopModule.defineLayout(), returnsNormally);
    });
  });
}

// ============================================================================
// Test Helper Coordinators
// ============================================================================

class _TestLayoutCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  _TestLayoutCoordinator({
    required this.onAuthLayout,
    required this.onShopLayout,
    required this.onSettingsLayout,
  });

  final VoidCallback onAuthLayout;
  final VoidCallback onShopLayout;
  final VoidCallback onSettingsLayout;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    _TestAuthModule(this, onLayout: onAuthLayout),
    _TestShopModule(this, onLayout: onShopLayout),
    _TestSettingsModule(this, onLayout: onSettingsLayout),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class _TestAuthModule extends RouteModule<AppRoute> {
  _TestAuthModule(super.coordinator, {required this.onLayout});

  final VoidCallback onLayout;

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() => onLayout();
}

class _TestShopModule extends RouteModule<AppRoute> {
  _TestShopModule(super.coordinator, {required this.onLayout});

  final VoidCallback onLayout;

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() => onLayout();
}

class _TestSettingsModule extends RouteModule<AppRoute> {
  _TestSettingsModule(super.coordinator, {required this.onLayout});

  final VoidCallback onLayout;

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineLayout() => onLayout();
}

class _TestConverterCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  _TestConverterCoordinator({
    required this.onAuthConverter,
    required this.onShopConverter,
    required this.onSettingsConverter,
  });

  final VoidCallback onAuthConverter;
  final VoidCallback onShopConverter;
  final VoidCallback onSettingsConverter;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {
    _TestAuthConverterModule(this, onConverter: onAuthConverter),
    _TestShopConverterModule(this, onConverter: onShopConverter),
    _TestSettingsConverterModule(this, onConverter: onSettingsConverter),
  };

  @override
  AppRoute notFoundRoute(Uri uri) => NotFoundRoute(uri: uri);
}

class _TestAuthConverterModule extends RouteModule<AppRoute> {
  _TestAuthConverterModule(super.coordinator, {required this.onConverter});

  final VoidCallback onConverter;

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineConverter() => onConverter();
}

class _TestShopConverterModule extends RouteModule<AppRoute> {
  _TestShopConverterModule(super.coordinator, {required this.onConverter});

  final VoidCallback onConverter;

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineConverter() => onConverter();
}

class _TestSettingsConverterModule extends RouteModule<AppRoute> {
  _TestSettingsConverterModule(super.coordinator, {required this.onConverter});

  final VoidCallback onConverter;

  @override
  List<StackPath> get paths => [];

  @override
  FutureOr<AppRoute?> parseRouteFromUri(Uri uri) => null;

  @override
  void defineConverter() => onConverter();
}



================================================
FILE: packages/zenrouter/test/coordinator/navigation_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup (Duplicated from coordinator_router_delegate_test.dart)
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home'));
  }

  @override
  List<Object?> get props => [];
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Settings'));
  }

  @override
  List<Object?> get props => [];
}

class ProfileRoute extends AppRoute {
  ProfileRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/profile/$id');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Profile $id'));
  }

  @override
  List<Object?> get props => [id];
}

class TabLayout extends AppRoute with RouteLayout {
  @override
  StackPath<RouteUnique> resolvePath(TestCoordinator coordinator) =>
      coordinator.tabStack;
}

class HomeTab extends AppRoute {
  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/home');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home Tab'));
  }

  @override
  List<Object?> get props => [];
}

class SearchTab extends AppRoute {
  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/search');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Search Tab'));
  }

  @override
  List<Object?> get props => [];
}

class RedirectRoute extends AppRoute with RouteRedirect<AppRoute> {
  RedirectRoute(this.target);
  final AppRoute target;

  @override
  Uri toUri() => Uri.parse('/redirect');

  @override
  FutureOr<AppRoute> redirect() => target;

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const SizedBox();
  }

  @override
  List<Object?> get props => [target];
}

class RedirectNullRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  Uri toUri() => Uri.parse('/redirect-null');

  @override
  FutureOr<AppRoute?> redirectWith(Coordinator coordinator) => null;

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const SizedBox();
  }
}

class GuardRoute extends AppRoute with RouteGuard {
  GuardRoute({this.allowPop = true});
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guard');

  @override
  FutureOr<bool> popGuard() => allowPop;

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const SizedBox();
  }

  @override
  List<Object?> get props => [allowPop];
}

class TestCoordinator extends Coordinator<AppRoute> {
  late final IndexedStackPath<AppRoute> tabStack = IndexedStackPath.createWith(
    [HomeTab(), SearchTab()],
    coordinator: this,
    label: 'tabs',
  )..bindLayout(TabLayout.new);

  @override
  List<StackPath> get paths => [...super.paths, tabStack];

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return HomeRoute(); // Not used in these tests
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('Coordinator.pushOrMoveToTop', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('pushes new route to root stack', () async {
      final route = SettingsRoute();
      coordinator.pushOrMoveToTop(route);

      // Wait for async operations (redirect resolution, layout resolution)
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, route);
    });

    test('moves existing route to top of root stack', () async {
      final home = HomeRoute();
      final settings = SettingsRoute();

      coordinator.push(home);
      coordinator.push(settings);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.map((r) => r.runtimeType), [
        HomeRoute,
        SettingsRoute,
      ]);

      // Move Home to top
      coordinator.pushOrMoveToTop(HomeRoute());
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.map((r) => r.runtimeType), [
        SettingsRoute,
        HomeRoute,
      ]);
    });

    test('resolves redirects before pushing', () async {
      final target = SettingsRoute();
      final redirect = RedirectRoute(target);

      coordinator.pushOrMoveToTop(redirect);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, isA<SettingsRoute>());
    });

    test('activates route in IndexedStackPath (switching tabs)', () async {
      // Initial state: HomeTab is active (index 0)
      expect(coordinator.tabStack.activeRoute, isA<HomeTab>());

      // Push SearchTab (index 1) via coordinator
      coordinator.pushOrMoveToTop(SearchTab());
      await Future.delayed(Duration.zero);

      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());
      expect(coordinator.tabStack.activeIndex, 1);
    });

    test('resolves layout before pushing (implicit path selection)', () async {
      // Pushing a tab route should target the tabStack, not root
      final searchTab = SearchTab();

      coordinator.pushOrMoveToTop(searchTab);
      await Future.delayed(Duration.zero);

      // Root should contain the layout (TabLayout)
      expect(coordinator.root.stack.last, isA<TabLayout>());

      // But Root should NOT contain the SearchTab
      expect(coordinator.root.stack.whereType<SearchTab>(), isEmpty);

      // Tab stack should have switched
      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());
    });

    test(
      'pushOrMoveToTop works with same route on top (idempotent-ish)',
      () async {
        final route = SettingsRoute();
        coordinator.push(route);
        await Future.delayed(Duration.zero);

        expect(coordinator.root.stack.length, 1);

        coordinator.pushOrMoveToTop(SettingsRoute());
        await Future.delayed(Duration.zero);

        expect(coordinator.root.stack.length, 1);
        expect(coordinator.root.stack.last, isA<SettingsRoute>());
      },
    );
  });

  group('Coordinator.push', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('pushes new route to stack', () async {
      final route = SettingsRoute();
      coordinator.push(route);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, route);
    });

    test('pushes duplicate route to stack (unlike pushOrMoveToTop)', () async {
      final home = HomeRoute();
      coordinator.push(home);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);

      // Push another HomeRoute
      coordinator.push(HomeRoute());
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack[0], isA<HomeRoute>());
      expect(coordinator.root.stack[1], isA<HomeRoute>());
    });

    test('resolves layout and pushes to correct path', () async {
      final searchTab = SearchTab();
      coordinator.push(searchTab);
      await Future.delayed(Duration.zero);

      // Root should imply the layout exists
      expect(coordinator.root.stack.last, isA<TabLayout>());

      // Tab stack should be active on the correct tab
      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());
    });
  });

  group('Coordinator.replace', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('replaces entire stack with new route', () async {
      // Setup initial stack
      coordinator.push(HomeRoute());
      await Future.delayed(Duration.zero);
      coordinator.push(SettingsRoute());
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);

      // Replace with Profile
      final profile = ProfileRoute('1');
      coordinator.replace(profile);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, profile);
    });

    test('resets all paths (including tabs) when replacing', () async {
      // 1. Go to Search Tab (index 1)
      coordinator.push(SearchTab());
      await Future.delayed(Duration.zero);
      expect(coordinator.tabStack.activeIndex, 1);

      // 2. Replace with HomeRoute (root path)
      coordinator.replace(HomeRoute());
      await Future.delayed(Duration.zero);

      // Root should have HomeRoute
      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, isA<HomeRoute>());

      // Tab stack should be reset (index 0)
      expect(coordinator.tabStack.activeIndex, 0);
    });
  });

  group('Coordinator.tryPop', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('pops correctly when RouteGuard allows pop', () async {
      // Setup: Home -> GuardRoute(allowPop: true)
      final home = HomeRoute();
      final guard = GuardRoute(allowPop: true);

      coordinator.push(home);
      coordinator.push(guard);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, guard);

      // tryPop should work
      final result = await coordinator.tryPop();

      expect(result, isTrue);
      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, home);
    });

    test('blocks pop when RouteGuard rejects pop', () async {
      // Setup: Home -> GuardRoute(allowPop: false)
      final home = HomeRoute();
      final guard = GuardRoute(allowPop: false);

      coordinator.push(home);
      coordinator.push(guard);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, guard);

      // tryPop should fail
      final result = await coordinator.tryPop();

      expect(result, isFalse);
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, guard);
    });

    test('pops normally when no RouteGuard is present', () async {
      // Setup: Home -> Settings
      final home = HomeRoute();
      final settings = SettingsRoute();

      coordinator.push(home);
      coordinator.push(settings);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);

      // tryPop should work
      final result = await coordinator.tryPop();

      expect(result, isTrue);
      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, home);
    });

    test('returns false when stack cannot be popped (length 1)', () async {
      // Setup: Home only
      coordinator.push(HomeRoute());
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);

      // tryPop should return false (nothing to pop)
      final result = await coordinator.tryPop();

      expect(result, isFalse);
      expect(coordinator.root.stack.length, 1);
    });
  });

  group('Coordinator.pushReplacement', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    testWidgets('pushes to empty stack', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push replacement on empty stack should just push
      final route = SettingsRoute();
      coordinator.pushReplacement(route);
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.first, route);
    });

    testWidgets('replaces single element stack and completes result', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push first route
      final home = coordinator.root.stack.first;
      final homeResult = home.onResult.future;
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.first, home);

      // Push replacement with result
      final settings = SettingsRoute();
      coordinator.pushReplacement<String, String>(settings, result: 'replaced');
      await tester.pumpAndSettle();

      // Stack should now have only settings
      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.first, settings);

      // home should have received the result
      expect(await homeResult, 'replaced');
      expect(home.onResult.isCompleted, true);
    });

    testWidgets(
      'replaces top route when stack has multiple elements and completes result',
      (tester) async {
        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        // Push routes
        final settings = SettingsRoute();
        final settingsResult = coordinator.push(settings);
        await tester.pumpAndSettle();

        expect(coordinator.root.stack.length, 2);

        // Push replacement - should pop settings and push profile
        final profile = ProfileRoute('1');
        coordinator.pushReplacement<String, String>(profile, result: 'popped');
        await tester.pumpAndSettle();

        // Stack should have home and profile
        expect(coordinator.root.stack.length, 2);
        expect(coordinator.root.stack[1], profile);

        // settings should have received the result
        expect(await settingsResult, 'popped');
        expect(settings.onResult.isCompleted, true);
      },
    );

    testWidgets('handles redirect and replaces correctly', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push first route
      final home = coordinator.root.stack.first;
      final homeResult = home.onResult.future;
      await tester.pumpAndSettle();

      // Push replacement with redirect - should redirect to target
      final target = SettingsRoute();
      final redirect = RedirectRoute(target);
      coordinator.pushReplacement(redirect);
      await tester.pumpAndSettle();

      // Stack should have only the target (not the redirect)
      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.first, isA<SettingsRoute>());
      expect(coordinator.root.stack.first, isNot(isA<RedirectRoute>()));
      expect(await homeResult, null);
    });

    testWidgets('respects guard that blocks pop during replacement', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push routes
      final home = coordinator.root.stack.first;
      final guard = GuardRoute(allowPop: false);
      coordinator.push(guard);
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 2);

      // Push replacement - should be blocked by guard
      final settings = SettingsRoute();
      final result = await coordinator.pushReplacement(settings);
      await tester.pumpAndSettle();

      // Guard blocked pop, so replacement should fail
      expect(result, isNull);
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack[0], home);
      expect(coordinator.root.stack[1], guard);
    });

    testWidgets('respects guard that allows pop during replacement', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push routes
      final home = coordinator.root.stack.first;

      final guard = GuardRoute(allowPop: true);
      final guardResult = coordinator.push(guard);
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 2);

      // Push replacement - guard should allow pop
      final settings = SettingsRoute();
      coordinator.pushReplacement<String, String>(settings, result: 'popped');
      await tester.pumpAndSettle();

      // Guard allowed, replacement should succeed
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack[0], home);
      expect(coordinator.root.stack[1], settings);
      expect(await guardResult, 'popped');
    });

    testWidgets('pushReplacement with Redirect to null should do nothing', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push routes
      final home = coordinator.root.stack.first;

      final redirectNull = RedirectNullRoute();
      final guardResult = await coordinator.pushReplacement(redirectNull);
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack[0], home);
      expect(guardResult, isNull);
    });

    testWidgets(
      'pushReplacement with Redirect to null should do nothing if called in path',
      (tester) async {
        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        // Push routes
        final home = coordinator.root.stack.first;

        final redirectNull = RedirectNullRoute();
        final guardResult = await coordinator.root.pushReplacement(
          redirectNull,
        );
        await tester.pumpAndSettle();

        expect(coordinator.root.stack.length, 1);
        expect(coordinator.root.stack[0], home);
        expect(guardResult, isNull);
      },
    );
  });
}



================================================
FILE: packages/zenrouter/test/coordinator/observer_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup - Custom Observer for Tracking
// ============================================================================

/// A custom observer that tracks all navigation events
class TrackingNavigatorObserver extends NavigatorObserver {
  final List<String> events = [];

  @override
  void didPush(Route route, Route? previousRoute) {
    events.add('didPush: ${route.settings.name ?? 'unnamed'}');
  }

  @override
  void didPop(Route route, Route? previousRoute) {
    events.add('didPop: ${route.settings.name ?? 'unnamed'}');
  }

  @override
  void didRemove(Route route, Route? previousRoute) {
    events.add('didRemove: ${route.settings.name ?? 'unnamed'}');
  }

  @override
  void didReplace({Route? newRoute, Route? oldRoute}) {
    events.add(
      'didReplace: ${oldRoute?.settings.name ?? 'unnamed'} -> ${newRoute?.settings.name ?? 'unnamed'}',
    );
  }

  void reset() => events.clear();
}

// ============================================================================
// Test Routes
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home'));
  }

  @override
  List<Object?> get props => [];
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Settings'));
  }

  @override
  List<Object?> get props => [];
}

class ProfileRoute extends AppRoute {
  ProfileRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/profile/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Profile $id'));
  }

  @override
  List<Object?> get props => [id];
}

class GuardedRoute extends AppRoute with RouteGuard {
  GuardedRoute({this.allowPop = false});
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guarded');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Guarded'));
  }

  @override
  List<Object?> get props => [allowPop];
}

// ============================================================================
// Test Coordinators
// ============================================================================

/// Coordinator WITH observer mixin
class CoordinatorWithObservers extends Coordinator<AppRoute>
    with CoordinatorNavigatorObserver {
  CoordinatorWithObservers({this.customObservers = const []});

  final List<NavigatorObserver> customObservers;

  @override
  List<NavigatorObserver> get observers => customObservers;

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    final segments = uri.pathSegments;
    if (segments.isEmpty) return HomeRoute();

    return switch (segments) {
      ['settings'] => SettingsRoute(),
      ['profile', final id] => ProfileRoute(id),
      ['guarded'] => GuardedRoute(),
      _ => HomeRoute(),
    };
  }
}

/// Coordinator WITHOUT observer mixin
class CoordinatorWithoutObservers extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    final segments = uri.pathSegments;
    if (segments.isEmpty) return HomeRoute();

    return switch (segments) {
      ['settings'] => SettingsRoute(),
      ['profile', final id] => ProfileRoute(id),
      ['guarded'] => GuardedRoute(),
      _ => HomeRoute(),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('CoordinatorNavigatorObserver Mixin', () {
    testWidgets('coordinator observers are passed to NavigationStack', (
      tester,
    ) async {
      final coordinatorObserver = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(
        customObservers: [coordinatorObserver],
      );

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // Coordinator observer should receive events
      expect(coordinatorObserver.events.isNotEmpty, isTrue);
    });

    testWidgets(
      'coordinator observers combine with NavigationStack observers',
      (tester) async {
        final coordinatorObserver = TrackingNavigatorObserver();
        final stackObserver = TrackingNavigatorObserver();
        final coordinator = CoordinatorWithObservers(
          customObservers: [coordinatorObserver],
        );

        // Create a custom NavigationStack with its own observer
        await tester.pumpWidget(
          MaterialApp(
            home: Builder(
              builder: (context) {
                return NavigationStack<AppRoute>(
                  path: coordinator.root,
                  coordinator: coordinator,
                  observers: [stackObserver],
                  resolver: (route) => StackTransition.material(
                    route.build(coordinator, context),
                  ),
                );
              },
            ),
          ),
        );

        coordinator.root.push(HomeRoute());
        await tester.pumpAndSettle();

        // Both observers should receive events
        expect(coordinatorObserver.events.isNotEmpty, isTrue);
        expect(stackObserver.events.isNotEmpty, isTrue);

        // Verify they received the same events
        expect(coordinatorObserver.events.length, stackObserver.events.length);
      },
    );

    testWidgets('multiple coordinator observers receive notifications', (
      tester,
    ) async {
      final observer1 = TrackingNavigatorObserver();
      final observer2 = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(
        customObservers: [observer1, observer2],
      );

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      // Both observers should receive the same events
      expect(observer1.events.isNotEmpty, isTrue);
      expect(observer2.events.isNotEmpty, isTrue);
      expect(observer1.events, equals(observer2.events));
    });

    testWidgets('observers track push operations', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      observer.reset();

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      // Should have didPush events
      final pushEvents = observer.events.where((e) => e.startsWith('didPush'));
      expect(pushEvents.isNotEmpty, isTrue);
    });

    testWidgets('observers track pop operations', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      observer.reset();

      coordinator.pop();
      await tester.pumpAndSettle();

      // Should have didPop events
      final popEvents = observer.events.where((e) => e.startsWith('didPop'));
      expect(popEvents.isNotEmpty, isTrue);
    });

    testWidgets('observers work with RouteGuard', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      coordinator.push(GuardedRoute(allowPop: false));
      await tester.pumpAndSettle();

      observer.reset();

      // Try to pop - should be blocked by guard
      await coordinator.tryPop();
      await tester.pumpAndSettle();

      // Should NOT have didPop events since guard blocked it
      final popEvents = observer.events.where((e) => e.startsWith('didPop'));
      expect(popEvents.isEmpty, isTrue);
    });

    testWidgets('empty observers list works correctly', (tester) async {
      final coordinator = CoordinatorWithObservers(customObservers: []);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      // Should not throw, navigation should work normally
      expect(coordinator.root.stack.length, 2);
      expect(find.text('Settings'), findsOneWidget);
    });

    test('Check kEmptyNavigatorObserverList return empty list', () {
      expect(kEmptyNavigatorObserverList(), []);
    });
  });

  group('NavigationStack Observer Integration', () {
    testWidgets('uses coordinator observers when coordinator has mixin', (
      tester,
    ) async {
      final coordinatorObserver = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(
        customObservers: [coordinatorObserver],
      );

      await tester.pumpWidget(
        MaterialApp(
          home: Builder(
            builder: (context) {
              return NavigationStack<AppRoute>(
                path: coordinator.root,
                coordinator: coordinator,
                resolver: (route) =>
                    StackTransition.material(route.build(coordinator, context)),
              );
            },
          ),
        ),
      );

      coordinator.root.push(HomeRoute());
      await tester.pumpAndSettle();

      // Coordinator observer should receive events
      expect(coordinatorObserver.events.isNotEmpty, isTrue);
    });

    testWidgets('uses only local observers when coordinator lacks mixin', (
      tester,
    ) async {
      final stackObserver = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithoutObservers();

      await tester.pumpWidget(
        MaterialApp(
          home: Builder(
            builder: (context) {
              return NavigationStack<AppRoute>(
                path: coordinator.root,
                coordinator: coordinator,
                observers: [stackObserver],
                resolver: (route) =>
                    StackTransition.material(route.build(coordinator, context)),
              );
            },
          ),
        ),
      );

      coordinator.root.push(HomeRoute());
      await tester.pumpAndSettle();

      // Stack observer should receive events
      expect(stackObserver.events.isNotEmpty, isTrue);
    });

    testWidgets('observers update when coordinator changes', (tester) async {
      final observer1 = TrackingNavigatorObserver();
      final coordinator1 = CoordinatorWithObservers(
        customObservers: [observer1],
      );

      // Start with coordinator1
      await tester.pumpWidget(
        MaterialApp(
          home: Builder(
            builder: (context) {
              return NavigationStack<AppRoute>(
                path: coordinator1.root,
                coordinator: coordinator1,
                resolver: (route) => StackTransition.material(
                  route.build(coordinator1, context),
                ),
              );
            },
          ),
        ),
      );

      coordinator1.root.push(HomeRoute());
      await tester.pumpAndSettle();
      coordinator1.root.push(SettingsRoute());
      await tester.pumpAndSettle();
      coordinator1.root.pop();
      await tester.pumpAndSettle();

      expect(observer1.events.length, 3);
    });

    testWidgets('observers update when local observers list changes', (
      tester,
    ) async {
      final observer1 = TrackingNavigatorObserver();
      final observer2 = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithoutObservers();

      // Start with observer1
      await tester.pumpWidget(
        MaterialApp(
          home: Builder(
            builder: (context) {
              return NavigationStack<AppRoute>(
                path: coordinator.root,
                coordinator: coordinator,
                observers: [observer1],
                resolver: (route) =>
                    StackTransition.material(route.build(coordinator, context)),
              );
            },
          ),
        ),
      );

      coordinator.root.push(HomeRoute());
      await tester.pumpAndSettle();

      expect(observer1.events.isNotEmpty, isTrue);
      expect(observer2.events.isEmpty, isTrue);

      observer1.reset();
      observer2.reset();

      // Switch to observer2
      await tester.pumpWidget(
        MaterialApp(
          home: Builder(
            builder: (context) {
              return NavigationStack<AppRoute>(
                path: coordinator.root,
                coordinator: coordinator,
                observers: [observer2],
                resolver: (route) =>
                    StackTransition.material(route.build(coordinator, context)),
              );
            },
          ),
        ),
      );

      coordinator.root.push(SettingsRoute());
      await tester.pumpAndSettle();

      // Now observer2 should receive events, not observer1
      expect(observer1.events.isEmpty, isTrue);
      expect(observer2.events.isNotEmpty, isTrue);
    });

    testWidgets(
      'NavigationStack without coordinator uses only local observers',
      (tester) async {
        final stackObserver = TrackingNavigatorObserver();
        final path = NavigationPath<AppRoute>.create();

        await tester.pumpWidget(
          MaterialApp(
            home: NavigationStack<AppRoute>(
              path: path,
              observers: [stackObserver],
              resolver: (route) =>
                  StackTransition.material(const Scaffold(body: Text('Test'))),
            ),
          ),
        );

        path.push(HomeRoute());
        await tester.pumpAndSettle();

        // Stack observer should receive events
        expect(stackObserver.events.isNotEmpty, isTrue);
      },
    );
  });

  group('Observer Lifecycle with Complex Navigation', () {
    testWidgets('observers track multiple push/pop operations', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      observer.reset();

      // Build a stack: Home -> Settings -> Profile
      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      coordinator.push(ProfileRoute('1'));
      await tester.pumpAndSettle();

      final pushCount = observer.events
          .where((e) => e.startsWith('didPush'))
          .length;
      expect(pushCount, greaterThan(0));

      observer.reset();

      // Pop back to Settings
      coordinator.pop();
      await tester.pumpAndSettle();

      final popCount = observer.events
          .where((e) => e.startsWith('didPop'))
          .length;
      expect(popCount, greaterThan(0));
    });

    testWidgets('observers track navigation with replace', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      observer.reset();

      // Replace with a different route
      coordinator.replace(SettingsRoute());
      await tester.pumpAndSettle();

      // Should have events from the replace operation
      expect(observer.events.isNotEmpty, isTrue);
    });

    testWidgets('observers work correctly with pushOrMoveToTop', (
      tester,
    ) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      final homeRoute = HomeRoute();
      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      observer.reset();

      // Push or move to top - should move existing route
      coordinator.pushOrMoveToTop(homeRoute);
      await tester.pumpAndSettle();

      // Observer should track this operation
      expect(observer.events.isNotEmpty, isTrue);
    });
  });

  group('Observer Edge Cases', () {
    testWidgets('observers handle rapid navigation changes', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      observer.reset();

      // Rapid navigation
      coordinator.push(SettingsRoute());
      coordinator.push(ProfileRoute('1'));
      coordinator.push(ProfileRoute('2'));
      await tester.pumpAndSettle();

      // All events should be tracked
      expect(observer.events.isNotEmpty, isTrue);
      final pushCount = observer.events
          .where((e) => e.startsWith('didPush'))
          .length;
      expect(pushCount, greaterThanOrEqualTo(3));
    });

    testWidgets('observers work with nested navigation', (tester) async {
      final observer = TrackingNavigatorObserver();
      final coordinator = CoordinatorWithObservers(customObservers: [observer]);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      observer.reset();

      // Push multiple routes
      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      coordinator.push(ProfileRoute('1'));
      await tester.pumpAndSettle();

      // Observer should track all navigation
      expect(observer.events.isNotEmpty, isTrue);
    });
  });
}



================================================
FILE: packages/zenrouter/test/coordinator/restoration_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home'));
  }

  @override
  List<Object?> get props => [];
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Settings'));
  }

  @override
  List<Object?> get props => [];
}

class ProfileRoute extends AppRoute {
  ProfileRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/profile/$id');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Profile $id'));
  }

  @override
  List<Object?> get props => [id];
}

class UndefinedTabLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  StackPath<RouteUnique> resolvePath(TestCoordinator coordinator) =>
      coordinator.undefinedTabStack;
}

class UndefinedHomeTab extends AppRoute {
  @override
  Type? get layout => UndefinedTabLayout;

  @override
  Uri toUri() => Uri.parse('/undefined-home-tab');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return const Scaffold(body: Text('Undefined Home Tab'));
  }
}

class UndefinedSearchTab extends AppRoute {
  @override
  Type? get layout => UndefinedTabLayout;

  @override
  Uri toUri() => Uri.parse('/undefined-search-tab');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return const Scaffold(body: Text('Undefined Search Tab'));
  }
}

// Route with custom restoration converter
class BookmarkRoute extends AppRoute with RouteRestorable<BookmarkRoute> {
  BookmarkRoute({required this.id, this.customData});

  final String id;
  final String? customData;

  @override
  String get restorationId => 'bookmark_$id';

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.converter;

  @override
  RestorableConverter<BookmarkRoute> get converter => const BookmarkConverter();

  @override
  Uri toUri() => Uri.parse('/bookmark/$id');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Bookmark $id: $customData'));
  }

  @override
  List<Object?> get props => [id, customData];
}

class BookmarkConverter extends RestorableConverter<BookmarkRoute> {
  const BookmarkConverter();

  @override
  String get key => 'test_bookmark';

  @override
  Map<String, dynamic> serialize(BookmarkRoute route) {
    return {'id': route.id, 'customData': route.customData};
  }

  @override
  BookmarkRoute deserialize(Map<String, dynamic> data) {
    return BookmarkRoute(
      id: data['id'] as String,
      customData: data['customData'] as String?,
    );
  }
}

// Route with RouteRestorable using unique strategy (for testing)
class RestorableProfileRoute extends AppRoute
    with RouteRestorable<RestorableProfileRoute> {
  RestorableProfileRoute(this.id);
  final String id;

  @override
  String get restorationId => 'profile_$id';

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.unique;

  @override
  RestorableConverter<RestorableProfileRoute> get converter =>
      throw UnimplementedError(); // Not used with unique strategy

  @override
  Uri toUri() => Uri.parse('/restorable-profile/$id');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Restorable Profile $id'));
  }

  @override
  List<Object?> get props => [id];
}

class TabLayout extends AppRoute with RouteLayout {
  @override
  StackPath<RouteUnique> resolvePath(TestCoordinator coordinator) =>
      coordinator.tabStack;
}

class HomeTab extends AppRoute {
  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/home');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home Tab'));
  }

  @override
  List<Object?> get props => [];
}

class SearchTab extends AppRoute {
  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/search');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Search Tab'));
  }

  @override
  List<Object?> get props => [];
}

class TestCoordinator extends Coordinator<AppRoute> {
  TestCoordinator({super.initialRoutePath});

  late final tabStack = IndexedStackPath.createWith(
    [HomeTab(), SearchTab()],
    coordinator: this,
    label: 'tabs',
  );
  late final undefinedTabStack = IndexedStackPath.createWith(
    [UndefinedHomeTab(), UndefinedSearchTab()],
    coordinator: this,
    label: 'undefined_tabs',
  );

  @override
  List<StackPath> get paths => [...super.paths, tabStack, undefinedTabStack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(TabLayout, TabLayout.new);
  }

  @override
  void defineConverter() {
    RestorableConverter.defineConverter(
      'test_bookmark',
      () => const BookmarkConverter(),
    );
  }

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['settings'] => SettingsRoute(),
      ['profile', final id] => ProfileRoute(id),
      ['bookmark', final id] => BookmarkRoute(id: id),
      ['tabs', 'home'] => HomeTab(),
      ['tabs', 'search'] => SearchTab(),
      _ => HomeRoute(),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('NavigationPath Restoration', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('serializes simple route stack correctly', () async {
      // Build initial stack
      coordinator.root.push(HomeRoute());
      coordinator.root.push(SettingsRoute());
      await Future.delayed(Duration.zero); // Wait for async operations

      // Serialize
      final serialized = coordinator.root.serialize();

      expect(serialized, hasLength(2));
      expect(serialized[0], equals('/'));
      expect(serialized[1], equals('/settings'));
    });

    test('deserializes simple route stack correctly', () {
      // Prepare serialized data
      final serialized = ['/', '/settings'];

      // Deserialize
      final deserialized = coordinator.root.deserialize(
        serialized,
        coordinator.parseRouteFromUriSync,
      );

      expect(deserialized, hasLength(2));
      expect(deserialized[0], isA<HomeRoute>());
      expect(deserialized[1], isA<SettingsRoute>());
    });

    test('restores navigation stack from serialized data', () async {
      // Build initial stack
      coordinator.root.push(HomeRoute());
      coordinator.root.push(SettingsRoute());
      coordinator.root.push(ProfileRoute('123'));
      await Future.delayed(Duration.zero);

      // Serialize
      final serialized = coordinator.root.serialize();

      // Clear stack
      coordinator.root.reset();
      expect(coordinator.root.stack, isEmpty);

      // Restore
      final deserialized = coordinator.root.deserialize(
        serialized,
        coordinator.parseRouteFromUriSync,
      );
      coordinator.root.restore(deserialized);

      // Verify
      expect(coordinator.root.stack.length, 3);
      expect(coordinator.root.stack[0], isA<HomeRoute>());
      expect(coordinator.root.stack[1], isA<SettingsRoute>());
      expect(coordinator.root.stack[2], isA<ProfileRoute>());
      expect((coordinator.root.stack[2] as ProfileRoute).id, equals('123'));
    });

    test('serializes routes with custom converters', () async {
      final bookmark = BookmarkRoute(id: '456', customData: 'test data');
      coordinator.root.push(bookmark);
      await Future.delayed(Duration.zero);

      final serialized = coordinator.root.serialize();

      expect(serialized, hasLength(1));
      expect(serialized[0], isA<Map>());

      final bookmarkData = serialized[0] as Map;
      expect(bookmarkData['strategy'], equals('converter'));
      expect(bookmarkData['converter'], equals('test_bookmark'));
      expect(bookmarkData['value']['id'], equals('456'));
      expect(bookmarkData['value']['customData'], equals('test data'));
    });

    test('deserializes routes with custom converters', () {
      final serialized = [
        {
          'strategy': 'converter',
          'converter': 'test_bookmark',
          'value': {'id': '789', 'customData': 'restored data'},
        },
      ];

      final deserialized = coordinator.root.deserialize(
        serialized,
        coordinator.parseRouteFromUriSync,
      );

      expect(deserialized, hasLength(1));
      expect(deserialized[0], isA<BookmarkRoute>());
      final bookmark = deserialized[0] as BookmarkRoute;
      expect(bookmark.id, equals('789'));
      expect(bookmark.customData, equals('restored data'));
    });

    test('round-trip: serialize then deserialize maintains state', () async {
      // Build complex stack
      coordinator.root.push(HomeRoute());
      coordinator.root.push(BookmarkRoute(id: '123', customData: 'data'));
      coordinator.root.push(SettingsRoute());
      await Future.delayed(Duration.zero);

      // Serialize
      final serialized = coordinator.root.serialize();

      // Deserialize
      final deserialized = coordinator.root.deserialize(
        serialized,
        coordinator.parseRouteFromUriSync,
      );

      // Verify
      expect(deserialized.length, 3);
      expect(deserialized[0], isA<HomeRoute>());
      expect(deserialized[1], isA<BookmarkRoute>());
      expect((deserialized[1] as BookmarkRoute).customData, equals('data'));
      expect(deserialized[2], isA<SettingsRoute>());
    });

    test('throws error when deserializing undefined layout', () {
      final serialized = [
        {'type': 'layout', 'value': 'UndefinedTabLayout'},
      ];

      expect(
        () => coordinator.root.deserialize(
          serialized,
          coordinator.parseRouteFromUriSync,
        ),
        throwsA(
          isA<UnimplementedError>().having(
            (e) => e.message,
            'message',
            contains('UndefinedTabLayout'),
          ),
        ),
      );
    });
  });

  group('IndexedStackPath Restoration', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('serializes active index', () {
      // Change to tab 1
      coordinator.tabStack.goToIndexed(1);

      final serialized = coordinator.tabStack.serialize();

      expect(serialized, equals(1));
    });

    test('deserializes active index', () {
      final deserialized = coordinator.tabStack.deserialize(1);

      expect(deserialized, equals(1));
    });

    test('restores active index correctly', () {
      // Set to tab 1
      coordinator.tabStack.goToIndexed(1);
      expect(coordinator.tabStack.activeIndex, equals(1));

      // Serialize
      final serialized = coordinator.tabStack.serialize();

      // Reset
      coordinator.tabStack.reset();
      expect(coordinator.tabStack.activeIndex, equals(0));

      // Restore
      final deserialized = coordinator.tabStack.deserialize(serialized);
      coordinator.tabStack.restore(deserialized);

      expect(coordinator.tabStack.activeIndex, equals(1));
      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());
    });

    test('asserts when restoring out-of-bounds index', () {
      expect(() => coordinator.tabStack.restore(5), throwsAssertionError);
    });
  });

  group('RouteRestorable Mixin', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('serialize creates correct map structure for converter strategy', () {
      final route = BookmarkRoute(id: '123', customData: 'test');

      final serialized = route.serialize();

      expect(serialized['strategy'], equals('converter'));
      expect(serialized['converter'], equals('test_bookmark'));
      expect(serialized['value']['id'], equals('123'));
      expect(serialized['value']['customData'], equals('test'));
    });

    test('serialize creates URI string for unique strategy', () {
      final route = RestorableProfileRoute('456');

      final serialized = route.serialize();

      expect(serialized['strategy'], equals('unique'));
      expect(serialized['value'], equals('/restorable-profile/456'));
    });

    test('deserialize reconstructs route from converter strategy', () {
      final data = {
        'strategy': 'converter',
        'converter': 'test_bookmark',
        'value': {'id': '999', 'customData': 'deserialized'},
      };

      final route = RouteRestorable.deserialize<AppRoute>(
        data,
        parseRouteFromUri: coordinator.parseRouteFromUriSync,
      );

      expect(route, isA<BookmarkRoute>());
      expect((route as BookmarkRoute).id, equals('999'));
      expect(route.customData, equals('deserialized'));
    });

    test('deserialize reconstructs route from unique strategy', () {
      final data = {'strategy': 'unique', 'value': '/profile/777'};

      final route = RouteRestorable.deserialize<AppRoute>(
        data,
        parseRouteFromUri: coordinator.parseRouteFromUriSync,
      );

      expect(route, isA<ProfileRoute>());
      expect((route as ProfileRoute).id, equals('777'));
    });

    test('throws on invalid strategy', () {
      final data = {'strategy': null, 'value': '/test'};

      expect(
        () => RouteRestorable.deserialize<AppRoute>(
          data,
          parseRouteFromUri: coordinator.parseRouteFromUriSync,
        ),
        throwsA(isA<UnimplementedError>()),
      );
    });
  });

  group('RestorableConverter Registry', () {
    test('registers and retrieves converter by key', () {
      final converter = RestorableConverter.buildConverter('test_bookmark');

      expect(converter, isNotNull);
      expect(converter, isA<BookmarkConverter>());
    });

    test('returns null for unregistered converter key', () {
      final converter = RestorableConverter.buildConverter('non_existent');

      expect(converter, isNull);
    });

    test('converter round-trip maintains data', () {
      final original = BookmarkRoute(id: '123', customData: 'original');
      final converter = const BookmarkConverter();

      // Serialize
      final serialized = converter.serialize(original);

      // Deserialize
      final restored = converter.deserialize(serialized);

      expect(restored.id, equals(original.id));
      expect(restored.customData, equals(original.customData));
    });
  });

  group('Multi-Path Restoration Integration', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('restores complex coordinator state with multiple paths', () async {
      // Setup complex state
      coordinator.root.push(HomeRoute());
      coordinator.root.push(SettingsRoute());
      coordinator.tabStack.goToIndexed(1);
      await Future.delayed(Duration.zero);

      // Serialize all paths
      final rootData = coordinator.root.serialize();
      final tabData = coordinator.tabStack.serialize();

      // Clear all state
      coordinator.root.reset();
      coordinator.tabStack.reset();

      expect(coordinator.root.stack, isEmpty);
      expect(coordinator.tabStack.activeIndex, equals(0));

      // Restore all paths
      final restoredRoot = coordinator.root.deserialize(
        rootData,
        coordinator.parseRouteFromUriSync,
      );
      coordinator.root.restore(restoredRoot);

      final restoredTab = coordinator.tabStack.deserialize(tabData);
      coordinator.tabStack.restore(restoredTab);

      // Verify all paths restored correctly
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack[0], isA<HomeRoute>());
      expect(coordinator.root.stack[1], isA<SettingsRoute>());

      expect(coordinator.tabStack.activeIndex, equals(1));
      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());
    });
  });

  group('CoordinatorRestorable - Listener Management', () {
    testWidgets('updates listeners when coordinator changes', (tester) async {
      final coordinator1 = TestCoordinator();
      final coordinator2 = TestCoordinator();

      // Track listener calls
      var coordinator1Notified = 0;
      var coordinator2Notified = 0;

      coordinator1.addListener(() {
        coordinator1Notified++;
      });

      coordinator2.addListener(() {
        coordinator2Notified++;
      });

      // Create widget with first coordinator
      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'test',
          home: CoordinatorRestorable(
            restorationId: 'coordinator',
            coordinator: coordinator1,
            child: const SizedBox(),
          ),
        ),
      );

      // Make a change to coordinator1 - should trigger save
      coordinator1.push(HomeRoute());
      await tester.pump();

      expect(coordinator1Notified, greaterThan(0));
      expect(coordinator2Notified, equals(0));

      // Update to coordinator2
      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'test',
          home: CoordinatorRestorable(
            restorationId: 'coordinator',
            coordinator: coordinator2,
            child: const SizedBox(),
          ),
        ),
      );

      await tester.pumpAndSettle();

      // Make a change to coordinator2 - SHOULD trigger notifications
      // because listeners should have been added
      coordinator2.push(HomeRoute());
      await tester.pump();

      expect(coordinator2Notified, greaterThan(0));
    });

    testWidgets('restores coordinator state correctly after restart', (
      tester,
    ) async {
      final coordinator = TestCoordinator();

      // Build app with restoration enabled
      await tester.pumpWidget(
        MaterialApp.router(
          restorationScopeId: 'app',
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      await tester.pumpAndSettle();

      // Set up some navigation state
      coordinator.push(SettingsRoute());
      coordinator.push(ProfileRoute('user123'));
      await tester.pumpAndSettle();

      coordinator.push(SearchTab());

      await tester.pumpAndSettle();

      // Verify initial state
      expect(coordinator.root.stack.length, equals(4));
      expect(coordinator.root.stack[2], isA<ProfileRoute>());
      expect((coordinator.root.stack[2] as ProfileRoute).id, equals('user123'));
      expect(coordinator.root.stack[3], isA<TabLayout>());
      expect(coordinator.tabStack.activeIndex, 1);
      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());

      // Simulate app restart with restoration
      final future = tester.restartAndRestore();
      for (final path in coordinator.paths) {
        path.reset();
      }
      await future;

      // State should be restored
      expect(coordinator.root.stack.length, equals(4));
      expect(coordinator.root.stack[0], isA<HomeRoute>());
      expect(coordinator.root.stack[1], isA<SettingsRoute>());
      expect(coordinator.root.stack[2], isA<ProfileRoute>());
      expect(coordinator.root.stack[3], isA<TabLayout>());
      expect((coordinator.root.stack[2] as ProfileRoute).id, equals('user123'));
      expect(coordinator.tabStack.activeIndex, 1);
    });

    testWidgets('restores RouteRestorable with custom data', (tester) async {
      final coordinator = TestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          restorationScopeId: 'app',
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      await tester.pumpAndSettle();

      // Push a route with custom data
      const customData = 'My Bookmark Data';
      coordinator.push(
        BookmarkRoute(id: 'bookmark123', customData: customData),
      );

      await tester.pumpAndSettle();

      // Verify initial state
      expect(coordinator.root.stack.length, equals(2));
      final originalRoute = coordinator.root.stack[1] as BookmarkRoute;
      expect(originalRoute.id, equals('bookmark123'));
      expect(originalRoute.customData, equals(customData));

      // Restart and restore
      // Simulate app restart with restoration
      final future = tester.restartAndRestore();
      for (final path in coordinator.paths) {
        path.reset();
      }
      await future;

      // Verify restored data
      expect(coordinator.root.stack.length, equals(2));
      final restoredRoute = coordinator.root.stack[1] as BookmarkRoute;
      expect(restoredRoute.id, equals('bookmark123'));
      expect(restoredRoute.customData, equals(customData));
    });

    testWidgets('handles empty state restoration', (tester) async {
      final coordinator = TestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          restorationScopeId: 'app',
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      await tester.pumpAndSettle();

      // Don't push any routes - test empty state
      expect(coordinator.root.stack.length, equals(1));

      // Restart and restore
      // Simulate app restart with restoration
      final future = tester.restartAndRestore();
      for (final path in coordinator.paths) {
        path.reset();
      }
      await future;

      // Should still be empty
      expect(coordinator.root.stack.length, equals(1));
      expect(coordinator.tabStack.activeIndex, equals(0));
    });

    testWidgets('handles multiple coordinator updates', (tester) async {
      final coordinators = [
        TestCoordinator(),
        TestCoordinator(),
        TestCoordinator(),
      ];

      var currentCoordinatorIndex = 0;

      // Start with first coordinator
      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'test',
          home: CoordinatorRestorable(
            restorationId: 'coordinator',
            coordinator: coordinators[currentCoordinatorIndex],
            child: const SizedBox(),
          ),
        ),
      );

      // Update through all coordinators
      for (var i = 1; i < coordinators.length; i++) {
        await tester.pumpWidget(
          MaterialApp(
            restorationScopeId: 'test',
            home: CoordinatorRestorable(
              restorationId: 'coordinator',
              coordinator: coordinators[i],
              child: const SizedBox(),
            ),
          ),
        );

        // Verify widget is still mounted and working
        expect(find.byType(CoordinatorRestorable), findsOneWidget);
      }

      // No exceptions should be thrown
      expect(tester.takeException(), isNull);
    });

    testWidgets('no-op when coordinator remains the same', (tester) async {
      final coordinator = TestCoordinator();

      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'test',
          home: CoordinatorRestorable(
            restorationId: 'coordinator',
            coordinator: coordinator,
            child: const SizedBox(),
          ),
        ),
      );

      // Trigger rebuild with same coordinator
      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'test',
          home: CoordinatorRestorable(
            restorationId: 'coordinator',
            coordinator: coordinator, // Same instance
            child: const SizedBox(),
          ),
        ),
      );

      // Should not throw and should continue working
      coordinator.push(HomeRoute());
      await tester.pump();

      expect(tester.takeException(), isNull);
    });
  });

  group('CoordinatorRestorable with asRouterConfig', () {
    testWidgets(
      'sets initial route path when useAsRouterConfig is true and no active route',
      (tester) async {
        final coordinator = TestCoordinator();
        final config = coordinator;

        await tester.pumpWidget(MaterialApp.router(routerConfig: config));

        await tester.pumpAndSettle();

        // Should have initial route set
        expect(coordinator.root.stack.length, equals(1));
        expect(coordinator.root.stack[0], isA<HomeRoute>());
      },
    );

    testWidgets('respects custom initialRoutePath when using asRouterConfig', (
      tester,
    ) async {
      final coordinator = TestCoordinator(
        initialRoutePath: Uri.parse('/settings'),
      );
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));

      await tester.pumpAndSettle();

      // Should have custom initial route set
      expect(coordinator.root.stack.length, equals(1));
      expect(coordinator.root.stack[0], isA<SettingsRoute>());
    });

    testWidgets('navigation push works after asRouterConfig initialization', (
      tester,
    ) async {
      final coordinator = TestCoordinator();
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));
      await tester.pumpAndSettle();

      // Reset to known state
      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // Push a route
      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, equals(2));
      expect(coordinator.root.stack[1], isA<SettingsRoute>());
      expect(find.text('Settings'), findsOneWidget);
    });

    testWidgets('navigation pop works with asRouterConfig', (tester) async {
      final coordinator = TestCoordinator();
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));
      await tester.pumpAndSettle();

      // Reset to known state and push routes
      coordinator.replace(HomeRoute());
      coordinator.push(SettingsRoute());
      coordinator.push(ProfileRoute('123'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, equals(3));
      expect(find.text('Profile 123'), findsOneWidget);

      // Pop
      coordinator.pop();
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, equals(2));
      expect(find.text('Settings'), findsOneWidget);
    });

    testWidgets('tab navigation works with asRouterConfig', (tester) async {
      final coordinator = TestCoordinator();
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));
      await tester.pumpAndSettle();

      // Navigate to tab layout
      await coordinator.recover(HomeTab());
      await tester.pumpAndSettle();

      expect(find.text('Home Tab'), findsOneWidget);

      // Switch tabs
      coordinator.tabStack.activateRoute(SearchTab());
      await tester.pumpAndSettle();

      expect(find.text('Search Tab'), findsOneWidget);
      expect(coordinator.tabStack.activeIndex, equals(1));
    });

    testWidgets('setNewRoutePath works with asRouterConfig', (tester) async {
      final coordinator = TestCoordinator();
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));
      await tester.pumpAndSettle();

      // Reset to known state
      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      expect(find.text('Home'), findsOneWidget);

      // Simulate URL change
      await coordinator.routerDelegate.setNewRoutePath(Uri.parse('/settings'));
      await tester.pumpAndSettle();

      expect(find.text('Settings'), findsOneWidget);
      expect(coordinator.root.stack.length, equals(2));
    });

    testWidgets('URL updates correctly with asRouterConfig', (tester) async {
      final coordinator = TestCoordinator();
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));
      await tester.pumpAndSettle();

      expect(coordinator.currentUri.toString(), '/');

      coordinator.push(ProfileRoute('user456'));
      await tester.pumpAndSettle();

      expect(coordinator.currentUri.toString(), '/profile/user456');
    });

    testWidgets('replace navigation works with asRouterConfig', (tester) async {
      final coordinator = TestCoordinator();
      final config = coordinator;

      await tester.pumpWidget(MaterialApp.router(routerConfig: config));
      await tester.pumpAndSettle();

      // Reset to known state and push some routes
      coordinator.replace(HomeRoute());
      coordinator.push(SettingsRoute());
      coordinator.push(ProfileRoute('123'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, equals(3));

      // Replace clears the stack
      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, equals(1));
      expect(coordinator.root.stack[0], isA<HomeRoute>());
    });
  });
}



================================================
FILE: packages/zenrouter/test/coordinator/router_assert_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(covariant StrictCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home'));
  }

  @override
  List<Object?> get props => [];
}

class ParentCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  @override
  Set<RouteModule<AppRoute>> defineModules() => {};

  @override
  AppRoute? parseRouteFromUri(Uri uri) => HomeRoute();

  @override
  void defineLayout() {}

  @override
  AppRoute notFoundRoute(Uri uri) => HomeRoute();
}

class StrictCoordinator extends Coordinator<AppRoute>
    with CoordinatorModular<AppRoute> {
  StrictCoordinator({required this.parent});
  final CoordinatorModular<AppRoute> parent;

  @override
  CoordinatorModular<AppRoute> get coordinator => parent;

  @override
  Set<RouteModule<AppRoute>> defineModules() => {};

  @override
  AppRoute notFoundRoute(Uri uri) => HomeRoute();

  late final NavigationPath<AppRoute> homeStack = NavigationPath.createWith(
    label: 'home',
    coordinator: this,
  );

  @override
  List<StackPath> get paths => [...super.paths, homeStack];

  @override
  void defineLayout() {}

  @override
  AppRoute? parseRouteFromUri(Uri uri) {
    if (uri.path == '/') return HomeRoute();
    // Intentionally return null for any other route to trigger assertion
    return null;
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  testWidgets(
    'CoordinatorRouterDelegate asserts when parseRouteFromUri returns null for unknown route',
    (tester) async {
      final parent = ParentCoordinator();
      final coordinator = StrictCoordinator(parent: parent);

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Initial route
      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // Attempt to navigate to an unknown route
      // This should trigger the assertion because parseRouteFromUri returns null
      final unknownUri = Uri.parse('/unknown');

      expect(
        () async =>
            await coordinator.routerDelegate.setNewRoutePath(unknownUri),
        throwsA(
          isA<AssertionError>().having(
            (e) => e.message,
            'message',
            contains(
              'You must to provide a parse route for $unknownUri in [parseRouteFromUri] to use deeplink to it',
            ),
          ),
        ),
      );
      expect(
        () async => await coordinator.recoverRouteFromUri(unknownUri),
        throwsA(isA<StateError>()),
      );
    },
  );
}



================================================
FILE: packages/zenrouter/test/coordinator/router_delegate_test.dart
================================================
// ignore_for_file: deprecated_member_use_from_same_package

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home'));
  }

  @override
  List<Object?> get props => [];
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Settings'));
  }

  @override
  List<Object?> get props => [];
}

class ProfileRoute extends AppRoute {
  ProfileRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/profile/$id');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Profile $id'));
  }

  @override
  List<Object?> get props => [id];
}

class GuardedRoute extends AppRoute with RouteGuard {
  GuardedRoute({this.allowPop = false});
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guarded');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Guarded'));
  }

  @override
  List<Object?> get props => [allowPop];
}

class DeepLinkRoute extends AppRoute with RouteDeepLink {
  DeepLinkRoute(this.path);
  final String path;

  @override
  Uri toUri() => Uri.parse('/deeplink/$path');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const SizedBox();
  }

  @override
  List<Object?> get props => [path];

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  FutureOr<void> deeplinkHandler(
    covariant TestCoordinator coordinator,
    Uri uri,
  ) {
    coordinator.push(ProfileRoute(path));
  }
}

class TabLayout extends AppRoute with RouteLayout {
  @override
  StackPath<RouteUnique> resolvePath(TestCoordinator coordinator) =>
      coordinator.tabStack;
}

class HomeTab extends AppRoute {
  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/home');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home Tab'));
  }

  @override
  List<Object?> get props => [];
}

class SearchTab extends AppRoute {
  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/search');

  @override
  Widget build(covariant TestCoordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Search Tab'));
  }

  @override
  List<Object?> get props => [];
}

class TestCoordinator extends Coordinator<AppRoute> {
  late final IndexedStackPath<AppRoute> tabStack = IndexedStackPath.createWith(
    [HomeTab(), SearchTab()],
    coordinator: this,
    label: 'tabs',
  );

  @override
  List<StackPath> get paths => [...super.paths, tabStack];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(TabLayout, TabLayout.new);
  }

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    final segments = uri.pathSegments;
    if (segments.isEmpty) return HomeRoute();

    return switch (segments) {
      ['settings'] => SettingsRoute(),
      ['profile', final id] => ProfileRoute(id),
      ['guarded'] => GuardedRoute(),
      ['deeplink', final path] => DeepLinkRoute(path),
      ['tabs', 'home'] => HomeTab(),
      ['tabs', 'search'] => SearchTab(),
      _ => HomeRoute(),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('CoordinatorRouterDelegate.setNewRoutePath', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    testWidgets('Browser back pops to existing route', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Setup stack: Home -> Settings -> Profile
      coordinator.replace(HomeRoute());
      coordinator.push(SettingsRoute());
      coordinator.push(ProfileRoute('1'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 3);
      expect(find.text('Profile 1'), findsOneWidget);

      // Simulate back button to Settings
      await coordinator.routerDelegate.setNewRoutePath(Uri.parse('/settings'));
      await tester.pumpAndSettle();

      // Should pop Profile and show Settings
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, isA<SettingsRoute>());
      expect(find.text('Settings'), findsOneWidget);

      await coordinator.routerDelegate.popRoute();
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.last, isA<HomeRoute>());
      expect(find.text('Home'), findsOneWidget);
    });

    testWidgets('Browser forward/new route pushes to stack', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Setup stack: Home
      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // Simulate navigation to Settings (not in stack)
      await coordinator.routerDelegate.setNewRoutePath(Uri.parse('/settings'));
      await tester.pumpAndSettle();

      // Should push Settings
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, isA<SettingsRoute>());
      expect(find.text('Settings'), findsOneWidget);
    });

    testWidgets('Guard prevents browser back and restores URL', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Setup stack: Home -> Guarded(allowPop: false)
      coordinator.replace(HomeRoute());
      coordinator.push(GuardedRoute(allowPop: false));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 2);
      expect(find.text('Guarded'), findsOneWidget);

      // Listen for notification (URL restoration)
      bool capturedNotification = false;
      coordinator.addListener(() {
        capturedNotification = true;
      });

      // Simulate back button to Home
      coordinator.routerDelegate.setNewRoutePath(Uri.parse('/'));
      await tester.pumpAndSettle();

      // Should NOT pop
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, isA<GuardedRoute>());
      expect(find.text('Guarded'), findsOneWidget);

      // Should have notified listeners to restore URL
      expect(capturedNotification, isTrue);
    });

    testWidgets('IndexedStackPath switches tabs', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Initial state: Home Tab
      await coordinator.recover(HomeTab());
      await tester.pumpAndSettle();

      expect(find.text('Home Tab'), findsOneWidget);
      expect(coordinator.tabStack.activeRoute, isA<HomeTab>());

      // Simulate navigation to Search Tab
      await coordinator.routerDelegate.setNewRoutePath(
        Uri.parse('/tabs/search'),
      );
      await tester.pumpAndSettle();

      // Should switch to Search Tab
      expect(find.text('Search Tab'), findsOneWidget);
      expect(coordinator.tabStack.activeRoute, isA<SearchTab>());
    });

    testWidgets('Complex pop: Back multiple steps', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Home -> Settings -> Profile 1 -> Profile 2
      coordinator.replace(HomeRoute());
      coordinator.push(SettingsRoute());
      coordinator.push(ProfileRoute('1'));
      coordinator.push(ProfileRoute('2'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 4);

      // Go back to Settings (pop 2 routes)
      await coordinator.routerDelegate.setNewRoutePath(Uri.parse('/settings'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, isA<SettingsRoute>());
      expect(find.text('Settings'), findsOneWidget);
    });
  });

  group('Coordinator.navigator', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    testWidgets('provides access to navigator state', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // Should be able to access navigator
      final navigator = coordinator.navigator;
      expect(navigator, isNotNull);
      expect(navigator, isA<NavigatorState>());
    });

    testWidgets('can use navigator to push routes directly', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      final navigator = coordinator.navigator;

      // Push a route using the navigator directly
      navigator.push(
        MaterialPageRoute(
          builder: (context) => const Scaffold(body: Text('Direct Push')),
        ),
      );
      await tester.pumpAndSettle();

      // Should show the directly pushed route
      expect(find.text('Direct Push'), findsOneWidget);
    });

    testWidgets('navigator is consistent across multiple accesses', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      final navigator1 = coordinator.navigator;
      final navigator2 = coordinator.navigator;

      // Should return the same instance
      expect(navigator1, same(navigator2));
    });
  });

  group('CoordinatorRouterDelegate.setNewRoutePath with deeplinks', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    testWidgets('custom deeplink strategy calls recover', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 1);
      expect(find.text('Home'), findsOneWidget);

      // Navigate to custom deeplink route
      await coordinator.routerDelegate.setNewRoutePath(
        Uri.parse('/deeplink/custom-handler'),
      );
      await tester.pumpAndSettle();

      // Custom handler should push ProfileRoute with the path
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, isA<ProfileRoute>());
      expect(
        (coordinator.root.stack.last as ProfileRoute).id,
        'custom-handler',
      );
      expect(find.text('Profile custom-handler'), findsOneWidget);
    });

    testWidgets('non-custom deeplink uses navigate', (tester) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // Navigate to regular route (not deeplink)
      await coordinator.routerDelegate.setNewRoutePath(Uri.parse('/settings'));
      await tester.pumpAndSettle();

      // Should use navigate (push to stack)
      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack.last, isA<SettingsRoute>());
      expect(find.text('Settings'), findsOneWidget);
    });

    testWidgets('multiple custom deeplinks are handled correctly', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      // First deeplink
      await coordinator.routerDelegate.setNewRoutePath(
        Uri.parse('/deeplink/first'),
      );
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 2);
      expect(find.text('Profile first'), findsOneWidget);

      // Second deeplink
      await coordinator.routerDelegate.setNewRoutePath(
        Uri.parse('/deeplink/second'),
      );
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 3);
      expect(find.text('Profile second'), findsOneWidget);
    });
  });

  group('Coordinator.dispose', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('removes listeners from all paths', () async {
      // Track coordinator notifications
      int coordinatorNotifyCount = 0;
      coordinator.addListener(() => coordinatorNotifyCount++);

      // Trigger a notification via replace (await to ensure microtasks complete)
      await coordinator.replace(HomeRoute());

      // Coordinator should have been notified (replace triggers notifyListeners)
      final countBefore = coordinatorNotifyCount;
      expect(countBefore, greaterThan(0));

      // Dispose coordinator
      coordinator.dispose();

      // After dispose, the root path should still exist
      expect(coordinator.root.stack.length, greaterThan(0));
    });

    test('disposes routerDelegate', () async {
      // Get reference to routerDelegate before dispose
      final routerDelegate = coordinator.routerDelegate;

      // Dispose coordinator (which should dispose routerDelegate)
      coordinator.dispose();

      // After dispose, routerDelegate should throw when adding listeners
      expect(
        () => routerDelegate.addListener(() {}),
        throwsA(isA<FlutterError>()),
      );
    });

    test('disposes root NavigationPath', () async {
      // Get the root path
      final root = coordinator.root;

      // Verify root has routes
      await coordinator.replace(HomeRoute());
      expect(root.stack, isNotEmpty);

      // Dispose coordinator
      coordinator.dispose();

      // After dispose, the root path should still exist
      // (dispose doesn't delete the path, just removes listeners)
      expect(root, isNotNull);
    });

    test('coordinator cannot add listeners after dispose', () {
      coordinator.dispose();

      // Attempting to add a listener after dispose should throw
      expect(
        () => coordinator.addListener(() {}),
        throwsA(isA<FlutterError>()),
      );
    });

    test('coordinator cannot notify listeners after dispose', () {
      coordinator.dispose();

      // Attempting to notify after dispose should throw
      expect(() => coordinator.notifyListeners(), throwsA(isA<FlutterError>()));
    });

    testWidgets('disposed coordinator cleans up widget tree properly', (
      tester,
    ) async {
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.replace(HomeRoute());
      await tester.pumpAndSettle();

      expect(find.text('Home'), findsOneWidget);

      // Dispose coordinator
      coordinator.dispose();

      // Note: In a real app, disposing the coordinator while it's still
      // mounted would cause issues - this test verifies the disposal itself works
    });

    test('root path is disposed after coordinator dispose', () {
      final root = coordinator.root;

      // Dispose coordinator (which should dispose root)
      coordinator.dispose();

      // Verify root path is disposed by checking if adding listeners throws
      expect(() => root.addListener(() {}), throwsA(isA<FlutterError>()));
    });

    test('all paths have listeners removed', () async {
      // Replace to set initial route
      await coordinator.replace(HomeRoute());

      // Add our own listener to coordinator
      int coordinatorNotifyCount = 0;
      coordinator.addListener(() => coordinatorNotifyCount++);

      final countBefore = coordinatorNotifyCount;

      // pushOrMoveToTop triggers synchronous notification via notifyListeners
      await coordinator.root.pushOrMoveToTop(SettingsRoute());

      // Verify listener was called
      expect(coordinatorNotifyCount, greaterThan(countBefore));
    });

    test('dispose removes coordinator listener from paths', () async {
      // Before dispose, path notifications should trigger coordinator notifications
      int coordinatorNotifyCount = 0;
      coordinator.addListener(() => coordinatorNotifyCount++);

      await coordinator.replace(HomeRoute());
      final countAfterReplace = coordinatorNotifyCount;
      expect(countAfterReplace, greaterThan(0));

      // Dispose removes coordinators listeners from paths
      coordinator.dispose();

      // Accessing disposed coordinator should throw
      expect(
        () => coordinator.addListener(() {}),
        throwsA(isA<FlutterError>()),
      );
    });
  });

  group('CoordinatorRouterDelegate.dispose', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('removes listener from coordinator', () async {
      final routerDelegate = coordinator.routerDelegate;

      // Add our own listener to coordinator to track notification count
      int coordinatorNotifyCount = 0;
      coordinator.addListener(() => coordinatorNotifyCount++);

      // Replace to trigger notification
      await coordinator.replace(HomeRoute());
      final countAfterReplace = coordinatorNotifyCount;
      expect(countAfterReplace, greaterThan(0));

      // Dispose routerDelegate directly
      routerDelegate.dispose();

      // Replace again - coordinator still works
      await coordinator.replace(SettingsRoute());

      // Coordinator still notifies its other listeners
      expect(coordinatorNotifyCount, greaterThan(countAfterReplace));
    });

    test('routerDelegate cannot add listeners after dispose', () {
      final routerDelegate = coordinator.routerDelegate;
      routerDelegate.dispose();

      // Attempting to add a listener after dispose should throw
      expect(
        () => routerDelegate.addListener(() {}),
        throwsA(isA<FlutterError>()),
      );
    });

    test('routerDelegate cannot notify listeners after dispose', () {
      final routerDelegate = coordinator.routerDelegate;
      routerDelegate.dispose();

      // Attempting to notify after dispose should throw
      expect(
        () => routerDelegate.notifyListeners(),
        throwsA(isA<FlutterError>()),
      );
    });

    test(
      'disposing coordinator disposes routerDelegate (idempotent dispose)',
      () {
        final routerDelegate = coordinator.routerDelegate;

        // Dispose coordinator (which internally disposes routerDelegate)
        coordinator.dispose();

        // Verify routerDelegate is disposed by checking if adding listeners throws
        expect(
          () => routerDelegate.addListener(() {}),
          throwsA(isA<FlutterError>()),
        );
      },
    );

    test('routerDelegate can be disposed independently', () async {
      final routerDelegate = coordinator.routerDelegate;

      // Dispose only the routerDelegate
      routerDelegate.dispose();

      // Coordinator should still work for adding listeners
      int count = 0;
      coordinator.addListener(() => count++);

      // Verify coordinator is still functional
      await coordinator.replace(HomeRoute());
      expect(count, greaterThan(0));
    });
  });
}



================================================
FILE: packages/zenrouter/test/coordinator/transition_strategy_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup
// ============================================================================

abstract class AppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Home'));
  }

  @override
  List<Object?> get props => [];
}

class SettingsRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/settings');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Scaffold(body: Text('Settings'));
  }

  @override
  List<Object?> get props => [];
}

class TestCoordinator extends Coordinator<AppRoute> {
  TestCoordinator({this.strategy = DefaultTransitionStrategy.material});

  final DefaultTransitionStrategy strategy;

  @override
  DefaultTransitionStrategy get transitionStrategy => strategy;

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.path) {
      '/settings' => SettingsRoute(),
      _ => HomeRoute(),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('DefaultTransitionStrategy enum', () {
    test('has correct values', () {
      expect(DefaultTransitionStrategy.values, [
        DefaultTransitionStrategy.material,
        DefaultTransitionStrategy.cupertino,
        DefaultTransitionStrategy.none,
      ]);
    });

    test('material is the first value', () {
      expect(
        DefaultTransitionStrategy.values.first,
        DefaultTransitionStrategy.material,
      );
    });
  });

  group('Coordinator.transitionStrategy', () {
    test('defaults to material', () {
      final coordinator = TestCoordinator();
      expect(
        coordinator.transitionStrategy,
        DefaultTransitionStrategy.material,
      );
    });

    test('can be overridden to cupertino', () {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.cupertino,
      );
      expect(
        coordinator.transitionStrategy,
        DefaultTransitionStrategy.cupertino,
      );
    });

    test('can be overridden to none', () {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.none,
      );
      expect(coordinator.transitionStrategy, DefaultTransitionStrategy.none);
    });

    test('maintains strategy throughout navigation', () async {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.cupertino,
      );

      // Push multiple routes
      coordinator.push(HomeRoute());
      await Future.delayed(Duration.zero);
      coordinator.push(SettingsRoute());
      await Future.delayed(Duration.zero);

      // Strategy should remain consistent
      expect(
        coordinator.transitionStrategy,
        DefaultTransitionStrategy.cupertino,
      );
    });

    test('different coordinators can have different strategies', () {
      final materialCoordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.material,
      );
      final cupertinoCoordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.cupertino,
      );
      final noneCoordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.none,
      );

      expect(
        materialCoordinator.transitionStrategy,
        DefaultTransitionStrategy.material,
      );
      expect(
        cupertinoCoordinator.transitionStrategy,
        DefaultTransitionStrategy.cupertino,
      );
      expect(
        noneCoordinator.transitionStrategy,
        DefaultTransitionStrategy.none,
      );
    });
  });

  group('Transition strategy integration', () {
    testWidgets('material strategy is used in navigation stack', (
      tester,
    ) async {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.material,
      );

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      // Initial route
      coordinator.push(HomeRoute());
      await tester.pumpAndSettle();

      expect(
        coordinator.transitionStrategy,
        DefaultTransitionStrategy.material,
      );
      expect(find.text('Home'), findsOneWidget);
    });

    testWidgets('cupertino strategy is used in navigation stack', (
      tester,
    ) async {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.cupertino,
      );

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.push(HomeRoute());
      await tester.pumpAndSettle();

      expect(
        coordinator.transitionStrategy,
        DefaultTransitionStrategy.cupertino,
      );
      expect(find.text('Home'), findsOneWidget);
    });

    testWidgets('none strategy is used in navigation stack', (tester) async {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.none,
      );

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.push(HomeRoute());
      await tester.pumpAndSettle();

      expect(coordinator.transitionStrategy, DefaultTransitionStrategy.none);
      expect(find.text('Home'), findsOneWidget);
    });

    testWidgets('transition between routes respects strategy', (tester) async {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.none,
      );

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );

      coordinator.push(HomeRoute());
      await tester.pumpAndSettle();
      expect(find.text('Home'), findsOneWidget);

      coordinator.push(SettingsRoute());
      await tester.pumpAndSettle();

      // With 'none' strategy, transition should be instant
      expect(find.text('Settings'), findsOneWidget);
      expect(find.text('Home'), findsNothing);
    });
  });

  group('DefaultTransitionStrategy edge cases', () {
    test('strategy is read-only per coordinator instance', () {
      final coordinator = TestCoordinator(
        strategy: DefaultTransitionStrategy.cupertino,
      );

      // Strategy should not change after initialization
      final initialStrategy = coordinator.transitionStrategy;
      expect(initialStrategy, DefaultTransitionStrategy.cupertino);

      // After multiple operations
      coordinator.push(HomeRoute());
      expect(coordinator.transitionStrategy, initialStrategy);
    });

    test('strategy can be different for each coordinator instance', () {
      final instances = <TestCoordinator>[
        TestCoordinator(strategy: DefaultTransitionStrategy.material),
        TestCoordinator(strategy: DefaultTransitionStrategy.cupertino),
        TestCoordinator(strategy: DefaultTransitionStrategy.none),
      ];

      expect(
        instances[0].transitionStrategy,
        DefaultTransitionStrategy.material,
      );
      expect(
        instances[1].transitionStrategy,
        DefaultTransitionStrategy.cupertino,
      );
      expect(instances[2].transitionStrategy, DefaultTransitionStrategy.none);
    });
  });
}



================================================
FILE: packages/zenrouter/test/internal/diff_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/src/internal/diff.dart';
import 'package:zenrouter/zenrouter.dart';

// Test route implementations
class TestRoute extends RouteTarget {
  TestRoute(this.id);
  final String id;

  @override
  List<Object?> get props => [id];
}

class CustomEqualsRoute extends RouteTarget {
  CustomEqualsRoute(this.value);
  final int value;
}

void main() {
  group('DiffOp classes', () {
    test('Keep has correct properties', () {
      const keep = Keep<String>(5, 3);
      expect(keep.oldIndex, 5);
      expect(keep.newIndex, 3);
      expect(keep.toString(), 'Keep(old: 5, new: 3)');
    });

    test('Insert has correct properties', () {
      const insert = Insert<String>('test', 2);
      expect(insert.element, 'test');
      expect(insert.newIndex, 2);
      expect(insert.toString(), 'Insert(test at 2)');
    });

    test('Delete has correct properties', () {
      const delete = Delete<String>(7);
      expect(delete.oldIndex, 7);
      expect(delete.toString(), 'Delete(at 7)');
    });
  });

  group('myersDiff - Edge cases', () {
    test('both lists empty returns empty operations', () {
      final ops = myersDiff<String>([], []);
      expect(ops, isEmpty);
    });

    test('old list empty returns all inserts', () {
      final ops = myersDiff<String>([], ['a', 'b', 'c']);
      expect(ops.length, 3);
      expect(ops[0], isA<Insert<String>>());
      expect(ops[1], isA<Insert<String>>());
      expect(ops[2], isA<Insert<String>>());

      expect((ops[0] as Insert<String>).element, 'a');
      expect((ops[0] as Insert<String>).newIndex, 0);
      expect((ops[1] as Insert<String>).element, 'b');
      expect((ops[1] as Insert<String>).newIndex, 1);
      expect((ops[2] as Insert<String>).element, 'c');
      expect((ops[2] as Insert<String>).newIndex, 2);
    });

    test('new list empty returns all deletes', () {
      final ops = myersDiff<String>(['a', 'b', 'c'], []);
      expect(ops.length, 3);
      expect(ops[0], isA<Delete<String>>());
      expect(ops[1], isA<Delete<String>>());
      expect(ops[2], isA<Delete<String>>());

      expect((ops[0] as Delete<String>).oldIndex, 0);
      expect((ops[1] as Delete<String>).oldIndex, 1);
      expect((ops[2] as Delete<String>).oldIndex, 2);
    });

    test('identical lists return all keeps', () {
      final ops = myersDiff<String>(['a', 'b', 'c'], ['a', 'b', 'c']);
      expect(ops.length, 3);
      expect(ops.every((op) => op is Keep), isTrue);
    });
  });

  group('myersDiff - Basic operations', () {
    test('single insert', () {
      final ops = myersDiff<String>(['a', 'c'], ['a', 'b', 'c']);
      expect(ops.length, 3);
      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Insert<String>>());
      expect(ops[2], isA<Keep<String>>());

      expect((ops[1] as Insert<String>).element, 'b');
      expect((ops[1] as Insert<String>).newIndex, 1);
    });

    test('single delete', () {
      final ops = myersDiff<String>(['a', 'b', 'c'], ['a', 'c']);
      expect(ops.length, 3);
      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Delete<String>>());
      expect(ops[2], isA<Keep<String>>());

      expect((ops[1] as Delete<String>).oldIndex, 1);
    });

    test('single replace (delete + insert)', () {
      final ops = myersDiff<String>(['a', 'b', 'c'], ['a', 'd', 'c']);
      expect(ops.length, 4);
      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Delete<String>>());
      expect(ops[2], isA<Insert<String>>());
      expect(ops[3], isA<Keep<String>>());

      expect((ops[1] as Delete<String>).oldIndex, 1);
      expect((ops[2] as Insert<String>).element, 'd');
    });
  });

  group('myersDiff - Complex scenarios', () {
    test('multiple inserts', () {
      final ops = myersDiff<String>(['a', 'd'], ['a', 'b', 'c', 'd']);
      expect(ops.length, 4);
      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Insert<String>>());
      expect(ops[2], isA<Insert<String>>());
      expect(ops[3], isA<Keep<String>>());
    });

    test('multiple deletes', () {
      final ops = myersDiff<String>(['a', 'b', 'c', 'd'], ['a', 'd']);
      expect(ops.length, 4);
      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Delete<String>>());
      expect(ops[2], isA<Delete<String>>());
      expect(ops[3], isA<Keep<String>>());
    });

    test('interleaved operations', () {
      final ops = myersDiff<String>(['a', 'b', 'c', 'd'], ['a', 'x', 'c', 'y']);

      // Should have: Keep(a), Delete(b), Insert(x), Keep(c), Delete(d), Insert(y)
      expect(ops.any((op) => op is Keep), isTrue);
      expect(ops.any((op) => op is Delete), isTrue);
      expect(ops.any((op) => op is Insert), isTrue);
    });

    test('completely different lists', () {
      final ops = myersDiff<String>(['a', 'b', 'c'], ['x', 'y', 'z']);

      // Should delete all old and insert all new
      final deletes = ops.whereType<Delete<String>>().toList();
      final inserts = ops.whereType<Insert<String>>().toList();

      expect(deletes.length, 3);
      expect(inserts.length, 3);
    });

    test('reordering elements', () {
      final ops = myersDiff<String>(['a', 'b', 'c'], ['c', 'b', 'a']);

      // Reordering requires deletes and inserts, should have no keeps
      // or different keeps depending on algorithm path
      expect(ops, isNotEmpty);
      expect(ops.any((op) => op is Delete || op is Insert), isTrue);
    });
  });

  group('myersDiff - Custom equality', () {
    test('uses custom equality function', () {
      final old = [
        CustomEqualsRoute(1),
        CustomEqualsRoute(2),
        CustomEqualsRoute(3),
      ];
      final newList = [
        CustomEqualsRoute(1),
        CustomEqualsRoute(4), // Different from 2
        CustomEqualsRoute(3),
      ];

      // With custom equality based on value
      final ops = myersDiff<CustomEqualsRoute>(
        old,
        newList,
        equals: (a, b) => a.value == b.value,
      );

      // Should detect change at index 1
      expect(ops.any((op) => op is Delete || op is Insert), isTrue);
    });

    test('custom equality for modulo comparison', () {
      final ops = myersDiff<int>(
        [1, 2, 3],
        [11, 12, 13],
        equals: (a, b) => a % 10 == b % 10,
      );

      // All should be kept since they match under modulo 10
      expect(ops.length, 3);
      expect(ops.every((op) => op is Keep), isTrue);
    });

    test('default equality when not provided', () {
      final ops = myersDiff<String>(['hello', 'world'], ['hello', 'world']);

      expect(ops.length, 2);
      expect(ops.every((op) => op is Keep), isTrue);
    });
  });

  group('myersDiff - Large lists', () {
    test('handles 50 element list efficiently', () {
      final old = List.generate(50, (i) => 'item_$i');
      final newList = List.generate(50, (i) => 'item_$i');

      final ops = myersDiff<String>(old, newList);

      expect(ops.length, 50);
      expect(ops.every((op) => op is Keep), isTrue);
    });

    test('handles 50 element list with changes', () {
      final old = List.generate(50, (i) => 'item_$i');
      final newList = List.generate(50, (i) {
        if (i == 25) return 'modified_$i';
        return 'item_$i';
      });

      final ops = myersDiff<String>(old, newList);

      expect(ops, isNotEmpty);
      expect(ops.whereType<Keep<String>>().length, greaterThan(40));
    });
  });

  group('myersDiff - Specific patterns', () {
    test('append to end', () {
      final ops = myersDiff<String>(['a', 'b'], ['a', 'b', 'c', 'd']);

      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Keep<String>>());
      expect(ops[2], isA<Insert<String>>());
      expect(ops[3], isA<Insert<String>>());
    });

    test('prepend to beginning', () {
      final ops = myersDiff<String>(['c', 'd'], ['a', 'b', 'c', 'd']);

      expect(ops[0], isA<Insert<String>>());
      expect(ops[1], isA<Insert<String>>());
      expect(ops[2], isA<Keep<String>>());
      expect(ops[3], isA<Keep<String>>());
    });

    test('insert in middle', () {
      final ops = myersDiff<String>(['a', 'd'], ['a', 'b', 'c', 'd']);

      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Insert<String>>());
      expect(ops[2], isA<Insert<String>>());
      expect(ops[3], isA<Keep<String>>());
    });

    test('remove from end', () {
      final ops = myersDiff<String>(['a', 'b', 'c', 'd'], ['a', 'b']);

      expect(ops[0], isA<Keep<String>>());
      expect(ops[1], isA<Keep<String>>());
      expect(ops[2], isA<Delete<String>>());
      expect(ops[3], isA<Delete<String>>());
    });

    test('remove from beginning', () {
      final ops = myersDiff<String>(['a', 'b', 'c', 'd'], ['c', 'd']);

      expect(ops[0], isA<Delete<String>>());
      expect(ops[1], isA<Delete<String>>());
      expect(ops[2], isA<Keep<String>>());
      expect(ops[3], isA<Keep<String>>());
    });
  });

  group('applyDiff', () {
    test('handles empty operations', () {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
      ]);

      applyDiff(path, <DiffOp<TestRoute>>[]);

      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'b');
    });

    test('applies only deletes', () {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
        TestRoute('c'),
      ]);

      final ops = [
        const Keep<TestRoute>(0, 0),
        const Delete<TestRoute>(1),
        const Keep<TestRoute>(2, 1),
      ];

      applyDiff(path, ops);

      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'c');
    });

    test('applies only inserts', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('c'),
      ]);

      final ops = [
        const Keep<TestRoute>(0, 0),
        Insert<TestRoute>(TestRoute('b'), 1),
        const Keep<TestRoute>(1, 2),
      ];

      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 3);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'b');
      expect(path.stack[2].id, 'c');
    });

    test('applies mixed operations', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
        TestRoute('c'),
      ]);

      final ops = [
        const Keep<TestRoute>(0, 0),
        const Delete<TestRoute>(1),
        Insert<TestRoute>(TestRoute('x'), 1),
        const Keep<TestRoute>(2, 2),
      ];

      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 3);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'x');
      expect(path.stack[2].id, 'c');
    });

    test('applies multiple deletes in reverse order', () {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
        TestRoute('c'),
        TestRoute('d'),
      ]);

      final ops = [
        const Keep<TestRoute>(0, 0),
        const Delete<TestRoute>(1),
        const Delete<TestRoute>(2),
        const Keep<TestRoute>(3, 1),
      ];

      applyDiff(path, ops);

      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'd');
    });

    test('applies multiple inserts', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('d'),
      ]);

      final ops = [
        const Keep<TestRoute>(0, 0),
        Insert<TestRoute>(TestRoute('b'), 1),
        Insert<TestRoute>(TestRoute('c'), 2),
        const Keep<TestRoute>(1, 3),
      ];

      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 4);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'b');
      expect(path.stack[2].id, 'c');
      expect(path.stack[3].id, 'd');
    });

    test('handles complete replacement', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
      ]);

      final ops = [
        const Delete<TestRoute>(0),
        const Delete<TestRoute>(1),
        Insert<TestRoute>(TestRoute('x'), 0),
        Insert<TestRoute>(TestRoute('y'), 1),
      ];

      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'x');
      expect(path.stack[1].id, 'y');
    });
  });

  group('applyDiff - Edge cases', () {
    test('handles delete with out-of-bounds index gracefully', () {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
      ]);

      final ops = [
        const Delete<TestRoute>(5), // Out of bounds
      ];

      applyDiff(path, ops);

      // Should not crash, original stack unchanged
      expect(path.stack.length, 1);
      expect(path.stack[0].id, 'a');
    });

    test('handles insert beyond stack length', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
      ]);

      final ops = [
        Insert<TestRoute>(TestRoute('b'), 10), // Beyond length
      ];

      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      // Should append to end
      expect(path.stack.length, 2);
      expect(path.stack[1].id, 'b');
    });

    test('preserves Keep operations as no-op', () {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
      ]);

      final ops = [const Keep<TestRoute>(0, 0), const Keep<TestRoute>(1, 1)];

      applyDiff(path, ops);

      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'b');
    });
  });

  group('Integration - myersDiff + applyDiff', () {
    test('correctly transforms stack from old to new state', () async {
      final oldRoutes = <TestRoute>[
        TestRoute('home'),
        TestRoute('profile'),
        TestRoute('settings'),
      ];
      final newRoutes = <TestRoute>[
        TestRoute('home'),
        TestRoute('about'),
        TestRoute('settings'),
      ];

      final path = StackPath.navigationStack('test', oldRoutes.toList());

      final ops = myersDiff<TestRoute>(oldRoutes, newRoutes);
      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 3);
      expect(path.stack[0].id, 'home');
      expect(path.stack[1].id, 'about');
      expect(path.stack[2].id, 'settings');
    });

    test('handles complex transformation', () async {
      final oldRoutes = <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
        TestRoute('c'),
        TestRoute('d'),
      ];
      final newRoutes = <TestRoute>[
        TestRoute('a'),
        TestRoute('x'),
        TestRoute('c'),
        TestRoute('y'),
        TestRoute('z'),
      ];

      final path = StackPath.navigationStack('test', oldRoutes.toList());

      final ops = myersDiff<TestRoute>(oldRoutes, newRoutes);
      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 5);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'x');
      expect(path.stack[2].id, 'c');
      expect(path.stack[3].id, 'y');
      expect(path.stack[4].id, 'z');
    });

    test('handles empty to populated', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[]);

      final newRoutes = <TestRoute>[TestRoute('a'), TestRoute('b')];

      final ops = myersDiff<TestRoute>([], newRoutes);
      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'b');
    });

    test('handles populated to empty', () {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
        TestRoute('b'),
      ]);

      final ops = myersDiff<TestRoute>([TestRoute('a'), TestRoute('b')], []);
      applyDiff(path, ops);

      expect(path.stack, isEmpty);
    });

    test('notifications are triggered', () async {
      final path = StackPath.navigationStack('test', <TestRoute>[
        TestRoute('a'),
      ]);

      var notified = false;
      path.addListener(() {
        notified = true;
      });

      final ops = [Insert<TestRoute>(TestRoute('b'), 1)];
      applyDiff(path, ops);
      await Future.delayed(Duration.zero);

      expect(notified, isTrue);
    });
  });
}



================================================
FILE: packages/zenrouter/test/internal/equaltable_utils_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/src/internal/equatable.dart' as eq;
import 'package:zenrouter/zenrouter.dart';

// Test route implementations
class TestRoute extends RouteTarget {
  TestRoute(this.id);
  final String id;

  @override
  List<Object?> get props => [id];
}

class MultiPropRoute extends RouteTarget {
  MultiPropRoute(this.id, this.value);
  final String id;
  final int value;

  @override
  List<Object?> get props => [id, value];
}

void main() {
  group('mapPropsToHashCode', () {
    test('returns consistent hash for null', () {
      final hash1 = eq.mapPropsToHashCode(null);
      final hash2 = eq.mapPropsToHashCode(null);
      expect(hash1, equals(hash2));
    });

    test('returns consistent hash for empty list', () {
      final hash1 = eq.mapPropsToHashCode([]);
      final hash2 = eq.mapPropsToHashCode([]);
      expect(hash1, equals(hash2));
    });

    test('returns consistent hash for same props', () {
      final props = ['a', 'b', 'c'];
      final hash1 = eq.mapPropsToHashCode(props);
      final hash2 = eq.mapPropsToHashCode(props);
      expect(hash1, equals(hash2));
    });

    test('returns different hash for different props', () {
      final hash1 = eq.mapPropsToHashCode(['a', 'b', 'c']);
      final hash2 = eq.mapPropsToHashCode(['a', 'b', 'd']);
      expect(hash1, isNot(equals(hash2)));
    });

    test('returns different hash for different order', () {
      final hash1 = eq.mapPropsToHashCode(['a', 'b', 'c']);
      final hash2 = eq.mapPropsToHashCode(['c', 'b', 'a']);
      expect(hash1, isNot(equals(hash2)));
    });

    test('handles nested lists', () {
      final hash1 = eq.mapPropsToHashCode([
        'a',
        ['b', 'c'],
      ]);
      final hash2 = eq.mapPropsToHashCode([
        'a',
        ['b', 'c'],
      ]);
      expect(hash1, equals(hash2));
    });

    test('handles maps with consistent ordering', () {
      final hash1 = eq.mapPropsToHashCode([
        {'key1': 'value1', 'key2': 'value2'},
      ]);
      final hash2 = eq.mapPropsToHashCode([
        {'key2': 'value2', 'key1': 'value1'},
      ]);
      // Maps should have same hash regardless of insertion order
      expect(hash1, equals(hash2));
    });

    test('handles sets with consistent ordering', () {
      final hash1 = eq.mapPropsToHashCode([
        {1, 2, 3},
      ]);
      final hash2 = eq.mapPropsToHashCode([
        {3, 2, 1},
      ]);
      // Sets should have same hash regardless of insertion order
      expect(hash1, equals(hash2));
    });

    test('handles mixed types', () {
      final hash = eq.mapPropsToHashCode([
        'string',
        42,
        true,
        null,
        [1, 2, 3],
        {'key': 'value'},
      ]);
      expect(hash, isA<int>());
    });

    test('handles numbers', () {
      final hash1 = eq.mapPropsToHashCode([1, 2, 3]);
      final hash2 = eq.mapPropsToHashCode([1, 2, 3]);
      expect(hash1, equals(hash2));
    });
  });

  group('equals', () {
    test('returns true for identical lists', () {
      final list = ['a', 'b', 'c'];
      expect(eq.equals(list, list), isTrue);
    });

    test('returns true for equal lists', () {
      expect(eq.equals(['a', 'b', 'c'], ['a', 'b', 'c']), isTrue);
    });

    test('returns false for different lists', () {
      expect(eq.equals(['a', 'b', 'c'], ['a', 'b', 'd']), isFalse);
    });

    test('returns false for different lengths', () {
      expect(eq.equals(['a', 'b'], ['a', 'b', 'c']), isFalse);
    });

    test('returns false when first is null', () {
      expect(eq.equals(null, ['a', 'b']), isFalse);
    });

    test('returns false when second is null', () {
      expect(eq.equals(['a', 'b'], null), isFalse);
    });

    test('returns true when both are null', () {
      expect(eq.equals(null, null), isTrue);
    });

    test('handles empty lists', () {
      expect(eq.equals([], []), isTrue);
    });

    test('handles nested lists', () {
      expect(
        eq.equals(
          [
            'a',
            ['b', 'c'],
          ],
          [
            'a',
            ['b', 'c'],
          ],
        ),
        isTrue,
      );
    });

    test('returns false for different nested lists', () {
      expect(
        eq.equals(
          [
            'a',
            ['b', 'c'],
          ],
          [
            'a',
            ['b', 'd'],
          ],
        ),
        isFalse,
      );
    });
  });

  group('iterableEquals', () {
    test('returns true for identical iterables', () {
      final iterable = [1, 2, 3];
      expect(eq.iterableEquals(iterable, iterable), isTrue);
    });

    test('returns true for equal iterables', () {
      expect(eq.iterableEquals([1, 2, 3], [1, 2, 3]), isTrue);
    });

    test('returns false for different iterables', () {
      expect(eq.iterableEquals([1, 2, 3], [1, 2, 4]), isFalse);
    });

    test('returns false for different lengths', () {
      expect(eq.iterableEquals([1, 2], [1, 2, 3]), isFalse);
    });

    test('handles empty iterables', () {
      expect(eq.iterableEquals([], []), isTrue);
    });

    test('handles nested iterables', () {
      expect(
        eq.iterableEquals(
          [
            1,
            [2, 3],
          ],
          [
            1,
            [2, 3],
          ],
        ),
        isTrue,
      );
    });

    test('throws assertion error for sets', () {
      expect(
        () => eq.iterableEquals({1, 2, 3}, {1, 2, 3}),
        throwsA(isA<AssertionError>()),
      );
    });

    test('works with different iterable types', () {
      expect(eq.iterableEquals([1, 2, 3], [1, 2, 3].map((e) => e)), isTrue);
    });
  });

  group('numEquals', () {
    test('returns true for equal integers', () {
      expect(eq.numEquals(42, 42), isTrue);
    });

    test('returns true for equal doubles', () {
      expect(eq.numEquals(3.14, 3.14), isTrue);
    });

    test('returns true for int and double with same value', () {
      expect(eq.numEquals(3, 3.0), isTrue);
    });

    test('returns false for different numbers', () {
      expect(eq.numEquals(42, 43), isFalse);
    });

    test('returns false for different doubles', () {
      expect(eq.numEquals(3.14, 3.15), isFalse);
    });

    test('handles negative numbers', () {
      expect(eq.numEquals(-42, -42), isTrue);
      expect(eq.numEquals(-42, 42), isFalse);
    });

    test('handles zero', () {
      expect(eq.numEquals(0, 0), isTrue);
      expect(eq.numEquals(0.0, 0), isTrue);
    });
  });

  group('setEquals', () {
    test('returns true for identical sets', () {
      final set = {1, 2, 3};
      expect(eq.setEquals(set, set), isTrue);
    });

    test('returns true for equal sets', () {
      expect(eq.setEquals({1, 2, 3}, {1, 2, 3}), isTrue);
    });

    test('returns true for sets with different insertion order', () {
      expect(eq.setEquals({1, 2, 3}, {3, 2, 1}), isTrue);
    });

    test('returns false for different sets', () {
      expect(eq.setEquals({1, 2, 3}, {1, 2, 4}), isFalse);
    });

    test('returns false for different lengths', () {
      expect(eq.setEquals({1, 2}, {1, 2, 3}), isFalse);
    });

    test('handles empty sets', () {
      expect(eq.setEquals({}, {}), isTrue);
    });

    test('handles sets with complex objects', () {
      expect(
        eq.setEquals(
          {
            [1, 2],
            [3, 4],
          },
          {
            [3, 4],
            [1, 2],
          },
        ),
        isTrue,
      );
    });

    test('handles sets with nested collections', () {
      expect(
        eq.setEquals(
          {
            {'a': 1},
            {'b': 2},
          },
          {
            {'b': 2},
            {'a': 1},
          },
        ),
        isTrue,
      );
    });
  });

  group('mapEquals', () {
    test('returns true for identical maps', () {
      final map = {'a': 1, 'b': 2};
      expect(eq.mapEquals(map, map), isTrue);
    });

    test('returns true for equal maps', () {
      expect(eq.mapEquals({'a': 1, 'b': 2}, {'a': 1, 'b': 2}), isTrue);
    });

    test('returns true for maps with different insertion order', () {
      expect(eq.mapEquals({'a': 1, 'b': 2}, {'b': 2, 'a': 1}), isTrue);
    });

    test('returns false for different maps', () {
      expect(eq.mapEquals({'a': 1, 'b': 2}, {'a': 1, 'b': 3}), isFalse);
    });

    test('returns false for different keys', () {
      expect(eq.mapEquals({'a': 1, 'b': 2}, {'a': 1, 'c': 2}), isFalse);
    });

    test('returns false for different lengths', () {
      expect(eq.mapEquals({'a': 1}, {'a': 1, 'b': 2}), isFalse);
    });

    test('handles empty maps', () {
      expect(eq.mapEquals({}, {}), isTrue);
    });

    test('handles nested maps', () {
      expect(
        eq.mapEquals(
          {
            'a': {'x': 1},
          },
          {
            'a': {'x': 1},
          },
        ),
        isTrue,
      );
    });

    test('handles maps with list values', () {
      expect(
        eq.mapEquals(
          {
            'a': [1, 2, 3],
          },
          {
            'a': [1, 2, 3],
          },
        ),
        isTrue,
      );
    });

    test('returns false for maps with different nested values', () {
      expect(
        eq.mapEquals(
          {
            'a': [1, 2, 3],
          },
          {
            'a': [1, 2, 4],
          },
        ),
        isFalse,
      );
    });
  });

  group('objectsEquals', () {
    test('returns true for identical objects', () {
      final obj = Object();
      expect(eq.objectsEquals(obj, obj), isTrue);
    });

    test('returns true for equal primitives', () {
      expect(eq.objectsEquals('hello', 'hello'), isTrue);
      expect(eq.objectsEquals(42, 42), isTrue);
      expect(eq.objectsEquals(true, true), isTrue);
    });

    test('returns false for different primitives', () {
      expect(eq.objectsEquals('hello', 'world'), isFalse);
      expect(eq.objectsEquals(42, 43), isFalse);
      expect(eq.objectsEquals(true, false), isFalse);
    });

    test('returns true for null values', () {
      expect(eq.objectsEquals(null, null), isTrue);
    });

    test('returns false when one is null', () {
      expect(eq.objectsEquals(null, 'hello'), isFalse);
      expect(eq.objectsEquals('hello', null), isFalse);
    });

    test('handles numbers correctly', () {
      expect(eq.objectsEquals(42, 42), isTrue);
      expect(eq.objectsEquals(3.14, 3.14), isTrue);
      expect(eq.objectsEquals(3, 3.0), isTrue);
    });

    test('handles RouteTarget objects', () {
      final route1 = TestRoute('a');
      final route2 = TestRoute('a');
      final route3 = TestRoute('b');

      expect(eq.objectsEquals(route1, route2), isTrue);
      expect(eq.objectsEquals(route1, route3), isFalse);
    });

    test('handles sets', () {
      expect(eq.objectsEquals({1, 2, 3}, {3, 2, 1}), isTrue);
      expect(eq.objectsEquals({1, 2, 3}, {1, 2, 4}), isFalse);
    });

    test('handles iterables', () {
      expect(eq.objectsEquals([1, 2, 3], [1, 2, 3]), isTrue);
      expect(eq.objectsEquals([1, 2, 3], [1, 2, 4]), isFalse);
    });

    test('handles maps', () {
      expect(eq.objectsEquals({'a': 1}, {'a': 1}), isTrue);
      expect(eq.objectsEquals({'a': 1}, {'a': 2}), isFalse);
    });

    test('returns false for different runtime types', () {
      expect(eq.objectsEquals('42', 42), isFalse);
      // Note: comparing list to set is handled correctly by objectsEquals
      // It checks if both are sets first, then if both are iterables
    });

    test('handles complex nested structures', () {
      final obj1 = {
        'list': [1, 2, 3],
        'map': {'a': 1},
        'set': {1, 2},
      };
      final obj2 = {
        'list': [1, 2, 3],
        'map': {'a': 1},
        'set': {2, 1},
      };
      expect(eq.objectsEquals(obj1, obj2), isTrue);
    });

    test('handles deeply nested structures', () {
      final obj1 = [
        {
          'a': [
            {1, 2},
            {'x': 'y'},
          ],
        },
      ];
      final obj2 = [
        {
          'a': [
            {2, 1},
            {'x': 'y'},
          ],
        },
      ];
      expect(eq.objectsEquals(obj1, obj2), isTrue);
    });
  });

  group('mapPropsToString', () {
    test('returns string representation for empty props', () {
      final result = eq.mapPropsToString(TestRoute, []);
      expect(result, equals('TestRoute()'));
    });

    test('returns string representation for single prop', () {
      final result = eq.mapPropsToString(TestRoute, ['value']);
      expect(result, equals('TestRoute(value)'));
    });

    test('returns string representation for multiple props', () {
      final result = eq.mapPropsToString(MultiPropRoute, ['id', 42]);
      expect(result, equals('MultiPropRoute(id, 42)'));
    });

    test('handles null values', () {
      final result = eq.mapPropsToString(TestRoute, [null]);
      expect(result, equals('TestRoute(null)'));
    });

    test('handles mixed types', () {
      final result = eq.mapPropsToString(TestRoute, ['string', 42, true, null]);
      expect(result, equals('TestRoute(string, 42, true, null)'));
    });

    test('handles lists', () {
      final result = eq.mapPropsToString(TestRoute, [
        [1, 2, 3],
      ]);
      expect(result, equals('TestRoute([1, 2, 3])'));
    });

    test('handles maps', () {
      final result = eq.mapPropsToString(TestRoute, [
        {'key': 'value'},
      ]);
      expect(result, contains('TestRoute({key: value})'));
    });

    test('handles sets', () {
      final result = eq.mapPropsToString(TestRoute, [
        {1, 2, 3},
      ]);
      expect(result, contains('TestRoute({'));
      expect(result, contains('1'));
      expect(result, contains('2'));
      expect(result, contains('3'));
    });
  });

  group('Integration tests', () {
    test('RouteTarget equality uses objectsEquals', () {
      final route1 = TestRoute('home');
      final route2 = TestRoute('home');
      final route3 = TestRoute('profile');

      expect(route1 == route2, isTrue);
      expect(route1 == route3, isFalse);
    });

    test('RouteTarget hashCode uses mapPropsToHashCode', () {
      final route1 = TestRoute('home');
      final route2 = TestRoute('home');

      // Hash codes include instance-specific fields (_path, _onResult)
      // so different instances will have different hash codes
      expect(route1 == route2, isTrue);
      // Different props should contribute to different hashes
      expect(route1.hashCode, isNot(equals(route2.hashCode)));
    });

    test('MultiPropRoute equality works correctly', () {
      final route1 = MultiPropRoute('home', 1);
      final route2 = MultiPropRoute('home', 1);
      final route3 = MultiPropRoute('home', 2);
      final route4 = MultiPropRoute('profile', 1);

      expect(route1 == route2, isTrue);
      expect(route1 == route3, isFalse);
      expect(route1 == route4, isFalse);
    });

    test('Routes with same props are equal', () {
      final route1 = TestRoute('home');
      final route2 = TestRoute('home');

      // Both routes have the same props
      expect(route1 == route2, isTrue);
    });

    test('Hash codes are consistent across multiple calls', () {
      final props = ['a', 'b', 'c', 1, 2, 3];
      final hash1 = eq.mapPropsToHashCode(props);
      final hash2 = eq.mapPropsToHashCode(props);
      final hash3 = eq.mapPropsToHashCode(props);

      expect(hash1, equals(hash2));
      expect(hash2, equals(hash3));
    });

    test('Different prop orders produce different hashes', () {
      final hash1 = eq.mapPropsToHashCode(['a', 'b', 'c']);
      final hash2 = eq.mapPropsToHashCode(['c', 'b', 'a']);

      expect(hash1, isNot(equals(hash2)));
    });

    test('Set and map ordering does not affect hash', () {
      final hash1 = eq.mapPropsToHashCode([
        {1, 2, 3},
        {'a': 1, 'b': 2},
      ]);
      final hash2 = eq.mapPropsToHashCode([
        {3, 2, 1},
        {'b': 2, 'a': 1},
      ]);

      expect(hash1, equals(hash2));
    });
  });

  group('Edge cases', () {
    test('handles very large lists', () {
      final list1 = List.generate(1000, (i) => i);
      final list2 = List.generate(1000, (i) => i);

      expect(eq.iterableEquals(list1, list2), isTrue);
      expect(
        eq.mapPropsToHashCode(list1),
        equals(eq.mapPropsToHashCode(list2)),
      );
    });

    test('handles very large sets', () {
      final set1 = Set.from(List.generate(1000, (i) => i));
      final set2 = Set.from(List.generate(1000, (i) => i).reversed);

      expect(eq.setEquals(set1, set2), isTrue);
    });

    test('handles very large maps', () {
      final map1 = Map.fromEntries(
        List.generate(1000, (i) => MapEntry('key$i', i)),
      );
      final map2 = Map.fromEntries(
        List.generate(1000, (i) => MapEntry('key$i', i)),
      );

      expect(eq.mapEquals(map1, map2), isTrue);
    });

    test('handles deeply nested structures', () {
      dynamic createNested(int depth) {
        if (depth == 0) return 'leaf';
        return [createNested(depth - 1)];
      }

      final obj1 = createNested(10);
      final obj2 = createNested(10);

      expect(eq.objectsEquals(obj1, obj2), isTrue);
    });

    test('handles nested maps in hash', () {
      // Test that deeply nested maps work correctly
      final map = <String, Object?>{
        'nested': {
          'inner': {'deep': 'value'},
        },
      };

      expect(() => eq.mapPropsToHashCode([map]), returnsNormally);
    });

    test('handles special number values', () {
      expect(eq.numEquals(double.infinity, double.infinity), isTrue);
      expect(
        eq.numEquals(double.negativeInfinity, double.negativeInfinity),
        isTrue,
      );
      // Note: NaN != NaN per IEEE 754 standard
      expect(eq.numEquals(double.nan, double.nan), isFalse);
    });

    test('handles empty collections in complex structures', () {
      final obj1 = {
        'emptyList': [],
        'emptySet': <int>{},
        'emptyMap': <String, int>{},
      };
      final obj2 = {
        'emptyList': [],
        'emptySet': <int>{},
        'emptyMap': <String, int>{},
      };

      expect(eq.objectsEquals(obj1, obj2), isTrue);
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/combined_mixin_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'mixin_test_utils.dart';

void main() {
  group('Combined Mixins Tests', () {
    testWidgets('TransitionGuardRoute respects both transition and guard', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push route that blocks popping
      coordinator.push(TransitionGuardRoute(allowPop: false));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('transition-guard')), findsOneWidget);
      final stackLengthBefore = coordinator.root.stack.length;

      // Try pop - should be blocked
      await tester.tap(find.byKey(const ValueKey('try-pop')));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, stackLengthBefore);
      expect(find.byKey(const ValueKey('transition-guard')), findsOneWidget);
    });

    testWidgets('TransitionGuardRoute allows pop when guard returns true', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push route that allows popping
      coordinator.push(TransitionGuardRoute(allowPop: true));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('transition-guard')), findsOneWidget);

      // Try pop - should succeed
      await tester.tap(find.byKey(const ValueKey('try-pop')));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);
    });

    testWidgets('RedirectGuardRoute combines redirect and guard', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push route that redirects
      coordinator.push(
        RedirectGuardRoute(shouldRedirect: true, allowPop: false),
      );
      await tester.pumpAndSettle();

      // Should redirect to SimpleRoute
      expect(find.byKey(const ValueKey('simple-redirected')), findsOneWidget);
    });

    testWidgets('DeeplinkGuardRoute combines deeplink and guard', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push deeplink guard route
      coordinator.push(DeeplinkGuardRoute(path: 'test', allowPop: false));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('deeplink-guard-test')), findsOneWidget);
      final stackLengthBefore = coordinator.root.stack.length;

      // Try pop - should be blocked
      coordinator.pop();
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, stackLengthBefore);
    });

    testWidgets('TransitionDeeplinkRoute combines transition and deeplink', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Use recover to trigger custom deep link handling
      coordinator.recover(TransitionDeeplinkRoute(path: 'combo'));
      await tester.pumpAndSettle();

      // Custom handler navigates to different route
      expect(
        find.byKey(const ValueKey('simple-transition-deeplink-handled')),
        findsOneWidget,
      );
    });

    testWidgets('FullMixinRoute works with all mixins together', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push full mixin route that doesn't redirect and allows pop
      coordinator.push(
        FullMixinRoute(id: 'full', allowPop: true, shouldRedirect: false),
      );
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('full-mixin-full')), findsOneWidget);
      expect(find.text('Allow Pop: true'), findsOneWidget);

      // Pop should work
      await tester.tap(find.byKey(const ValueKey('try-pop')));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);
    });

    testWidgets('FullMixinRoute redirect takes priority', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push full mixin route that redirects
      coordinator.push(FullMixinRoute(id: 'redirecting', shouldRedirect: true));
      await tester.pumpAndSettle();

      // Should redirect
      expect(
        find.byKey(const ValueKey('simple-full-mixin-redirected')),
        findsOneWidget,
      );
    });

    testWidgets('FullMixinRoute deeplink handler works with recover', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Use recover to trigger custom deep link handling
      coordinator.recover(FullMixinRoute(id: 'deeplink-test'));
      await tester.pumpAndSettle();

      // Custom handler navigates to deeplink route
      expect(
        find.byKey(const ValueKey('simple-full-mixin-deeplink-deeplink-test')),
        findsOneWidget,
      );
    });

    testWidgets('FullMixinRoute guard blocks pop when configured', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push full mixin route that blocks pop
      coordinator.push(
        FullMixinRoute(id: 'blocked', allowPop: false, shouldRedirect: false),
      );
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('full-mixin-blocked')), findsOneWidget);
      final stackLengthBefore = coordinator.root.stack.length;

      // Pop should be blocked
      await tester.tap(find.byKey(const ValueKey('try-pop')));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, stackLengthBefore);
      expect(find.byKey(const ValueKey('full-mixin-blocked')), findsOneWidget);
    });
  });

  group('Edge Cases', () {
    testWidgets('Multiple guards in stack are checked correctly', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push multiple guarded routes
      coordinator.push(GuardedPopRoute(allowPop: true));
      await tester.pumpAndSettle();
      coordinator.push(GuardedPopRoute(allowPop: false));
      await tester.pumpAndSettle();

      final stackLengthBefore = coordinator.root.stack.length;

      // Pop should be blocked by second guard
      coordinator.pop();
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, stackLengthBefore);
    });

    testWidgets('Redirect returning null stays on current route', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push redirect that returns null (authenticated)
      coordinator.push(AuthRedirectRoute(isAuthenticated: true));
      await tester.pumpAndSettle();

      // Should stay on auth redirect route, not redirect
      expect(find.byKey(const ValueKey('auth-redirect')), findsOneWidget);
    });

    testWidgets('Transition types are correctly applied', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Test each transition type is rendered
      for (final route in [
        MaterialTransitionRoute(),
        CupertinoTransitionRoute(),
        DialogTransitionRoute(),
        SheetTransitionRoute(),
      ]) {
        coordinator.push(route);
        await tester.pumpAndSettle();

        // Pop and reset
        coordinator.pop();
        await tester.pumpAndSettle();
      }

      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/deep_link_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'mixin_test_utils.dart';

void main() {
  group('RouteDeeplink Mixin Tests', () {
    testWidgets('Push strategy adds to existing stack', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push some routes first
      coordinator.push(SimpleRoute(id: 'first'));
      await tester.pumpAndSettle();

      final stackLengthBefore = coordinator.root.stack.length;

      // Push deeplink
      coordinator.push(PushDeeplinkRoute(path: 'test'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, greaterThan(stackLengthBefore));
      expect(find.byKey(const ValueKey('push-deeplink-test')), findsOneWidget);
    });

    testWidgets('Navigate strategy navigates to new stack', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push some routes first
      coordinator.push(SimpleRoute(id: 'first'));
      await tester.pumpAndSettle();

      final stackLengthBefore = coordinator.root.stack.length;

      // Push deeplink
      coordinator.recover(NavigateDeeplinkRoute(path: 'test'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, greaterThan(stackLengthBefore));
      expect(
        find.byKey(const ValueKey('navigate-deeplink-test')),
        findsOneWidget,
      );
    });

    testWidgets('Replace strategy clears and replaces stack', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push some routes first
      coordinator.push(SimpleRoute(id: 'one'));
      await tester.pumpAndSettle();
      coordinator.push(SimpleRoute(id: 'two'));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, greaterThan(1));

      // Use recoverRouteFromUri for replace behavior
      await coordinator.recoverRouteFromUri(
        Uri.parse('/deeplink/replace/replaced'),
      );
      await tester.pumpAndSettle();

      // Stack should be cleared
      expect(coordinator.root.stack.length, 1);
      expect(
        find.byKey(const ValueKey('replace-deeplink-replaced')),
        findsOneWidget,
      );
    });

    testWidgets('Custom strategy calls deeplinkHandler', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      final customRoute = CustomDeeplinkRoute(path: 'handled');
      coordinator.recover(customRoute);
      await tester.pumpAndSettle();

      // Handler should navigate to custom handled route
      expect(
        find.byKey(const ValueKey('simple-custom-handled-handled')),
        findsOneWidget,
      );
    });

    testWidgets('Async custom handler completes', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      final asyncRoute = AsyncCustomDeeplinkRoute(path: 'async');

      await tester.runAsync(() async {
        await coordinator.recover(asyncRoute);

        // The recover method doesn't await async deeplinkHandler,
        // so we need to wait for it manually (50ms delay in handler + buffer)
        await tester.pumpAndSettle();

        expect(asyncRoute.handlerCompleted, isTrue);
        expect(coordinator.root.activeRoute, isA<SimpleRoute>());
        expect(
          (coordinator.root.activeRoute as SimpleRoute).id,
          'async-custom-async',
        );
      });
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/guard_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'mixin_test_utils.dart';

void main() {
  group('RouteGuard Mixin Tests', () {
    testWidgets('Guard prevents pop when allowPop is false', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(GuardedPopRoute(allowPop: false));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('guarded-pop')), findsOneWidget);
      final stackLengthBefore = coordinator.root.stack.length;

      // Try to pop
      await tester.tap(find.byKey(const ValueKey('try-pop')));
      await tester.pumpAndSettle();

      // Should still be on guarded page
      expect(find.byKey(const ValueKey('guarded-pop')), findsOneWidget);
      expect(coordinator.root.stack.length, stackLengthBefore);
    });

    testWidgets('Guard allows pop when allowPop is true', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(GuardedPopRoute(allowPop: true));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('guarded-pop')), findsOneWidget);

      // Try to pop
      await tester.tap(find.byKey(const ValueKey('try-pop')));
      await tester.pumpAndSettle();

      // Should be back to home
      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);
    });

    testWidgets('Guard is called during pop', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      final guardRoute = ConfirmationGuardRoute(showConfirmation: true);
      coordinator.push(guardRoute);
      await tester.pumpAndSettle();

      expect(guardRoute.wasConfirmationShown, isFalse);

      // Try to pop - this will trigger the guard
      coordinator.pop();
      await tester.pumpAndSettle();

      expect(guardRoute.wasConfirmationShown, isTrue);
    });

    testWidgets('Async guard waits for completion', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push guard with delay
      coordinator.push(
        GuardedPopRoute(
          allowPop: true,
          popDelay: const Duration(milliseconds: 100),
        ),
      );
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('guarded-pop')), findsOneWidget);

      // Pop - await the guard
      coordinator.pop();
      await tester.pumpAndSettle();

      // Should eventually return to home
      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/layout_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Layout Test Routes & Coordinator
// ============================================================================

abstract class LayoutTestRoute extends RouteTarget with RouteUnique {}

class HomeRoute extends LayoutTestRoute {
  @override
  Uri toUri() => Uri.parse('/home');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(key: const ValueKey('home'));
  }

  @override
  List<Object?> get props => [];
}

class SettingRoute extends LayoutTestRoute {
  @override
  Uri toUri() => Uri.parse('/setting');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(
      key: const ValueKey('setting'),
      body: Center(
        child: ElevatedButton(
          key: const ValueKey('go-back-setting'),
          onPressed: () => coordinator.pop(),
          child: const Text('Go back'),
        ),
      ),
    );
  }

  @override
  List<Object?> get props => [];
}

class AllowPopLayoutChildRoute extends LayoutTestRoute {
  AllowPopLayoutChildRoute({this.id = '1'});
  final String id;

  @override
  Type get layout => AllowPopLayout;

  @override
  Uri toUri() => Uri.parse('/allow-pop/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(
      key: ValueKey('child-$id'),
      appBar: AppBar(
        title: Text('Child $id'),
        leading: IconButton(
          key: ValueKey('back-button-$id'),
          icon: const Icon(Icons.arrow_back),
          onPressed: () => coordinator.pop(),
        ),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Child Page $id'),
            ElevatedButton(
              key: const ValueKey('push-child-2'),
              onPressed: () =>
                  coordinator.push(AllowPopLayoutChildRoute(id: '2')),
              child: const Text('Push Child 2'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  List<Object?> get props => [id];
}

class NotAllowPopLayoutChildRoute extends LayoutTestRoute {
  NotAllowPopLayoutChildRoute({this.id = '1'});
  final String id;

  @override
  Type get layout => NotAllowPopLayout;

  @override
  Uri toUri() => Uri.parse('/not-allow/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(
      key: ValueKey('child-$id'),
      appBar: AppBar(
        title: Text('Child $id'),
        leading: IconButton(
          key: ValueKey('back-button-$id'),
          icon: const Icon(Icons.arrow_back),
          onPressed: () => coordinator.pop(),
        ),
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Child Page $id'),
            ElevatedButton(
              key: const ValueKey('push-child-2'),
              onPressed: () =>
                  coordinator.push(NotAllowPopLayoutChildRoute(id: '2')),
              child: const Text('Push Child 2'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  List<Object?> get props => [id];
}

class AllowPopLayout extends LayoutTestRoute
    with RouteLayout<LayoutTestRoute>, RouteGuard {
  @override
  StackPath<RouteUnique> resolvePath(
    covariant LayoutTestCoordinator coordinator,
  ) => coordinator.allowPopPath;

  @override
  Future<bool> popGuard() async => true;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(
      key: const ValueKey('layout-scaffold'),
      body: Row(
        children: [
          const SizedBox(width: 50, child: Text('Sidebar (allow pop)')),
          Expanded(child: buildPath(coordinator)),
        ],
      ),
    );
  }
}

class NotAllowPopLayout extends LayoutTestRoute
    with RouteLayout<LayoutTestRoute>, RouteGuard {
  @override
  StackPath<RouteUnique> resolvePath(
    covariant LayoutTestCoordinator coordinator,
  ) => coordinator.notAllowPopPath;

  @override
  Future<bool> popGuard() async => false;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(
      key: const ValueKey('layout-scaffold'),
      body: Row(
        children: [
          const SizedBox(width: 50, child: Text('Sidebar')),
          Expanded(child: buildPath(coordinator)),
        ],
      ),
    );
  }
}

class LayoutTestCoordinator extends Coordinator<LayoutTestRoute> {
  late final allowPopPath = NavigationPath<LayoutTestRoute>.create(
    label: 'nested',
    coordinator: this,
  );
  late final notAllowPopPath = NavigationPath<LayoutTestRoute>.create(
    label: 'nested',
    coordinator: this,
  );

  @override
  void defineLayout() {
    RouteLayout.defineLayout(AllowPopLayout, AllowPopLayout.new);
    RouteLayout.defineLayout(NotAllowPopLayout, NotAllowPopLayout.new);
  }

  @override
  List<StackPath> get paths => [...super.paths, allowPopPath];

  @override
  LayoutTestRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['allow-pop', final id] => AllowPopLayoutChildRoute(id: id),
      ['not-allow-pop', final id] => NotAllowPopLayoutChildRoute(id: id),
      ['setting'] => SettingRoute(),
      _ => HomeRoute(),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('RouteLayout Mixin Tests', () {
    testWidgets('Layout renders correctly with child', (tester) async {
      final coordinator = LayoutTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push child into nested path manually for this test case (normally coordinator logic would do this)
      coordinator.push(AllowPopLayoutChildRoute(id: '1'));
      await tester.pumpAndSettle();

      // Verify layout structure
      expect(find.byKey(const ValueKey('layout-scaffold')), findsOneWidget);
      expect(find.text('Sidebar (allow pop)'), findsOneWidget);

      // Verify child content
      expect(find.byKey(const ValueKey('child-1')), findsOneWidget);
    });

    testWidgets('Layout guard prevents pop from nested child', (tester) async {
      final coordinator = LayoutTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Start at home
      expect(find.byKey(const ValueKey('home')), findsOneWidget);

      // Push child in TestLayout
      coordinator.push(NotAllowPopLayoutChildRoute(id: '1'));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('child-1')), findsOneWidget);

      // Try to pop using system back button (simulated)
      // This should hit the layout's route guard because the active route in the root stack is the layout
      await tester.tap(
        find.byKey(const ValueKey('back-button-1')),
      ); // AppBar back button of child
      await tester.pumpAndSettle();

      // Should still be on Layout/Child1
      expect(find.byKey(const ValueKey('layout-scaffold')), findsOneWidget);
      expect(find.byKey(const ValueKey('child-1')), findsOneWidget);

      coordinator.push(SettingRoute());
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('setting')), findsOneWidget);

      /// Try to navigate back to home but since the TestLayout has a guard it will not allow it
      coordinator.navigate(HomeRoute());
      await tester.pumpAndSettle();

      // Should still be on Layout/Child1
      expect(find.byKey(const ValueKey('layout-scaffold')), findsOneWidget);
      expect(find.byKey(const ValueKey('child-1')), findsOneWidget);
    });

    testWidgets('Layout guard allows pop to home', (tester) async {
      final coordinator = LayoutTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Push child in TestLayout
      coordinator.push(AllowPopLayoutChildRoute(id: '1'));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('layout-scaffold')), findsOneWidget);

      // Pop root stack
      coordinator.pop();
      await tester.pumpAndSettle();

      // Should be back at home
      expect(find.byKey(const ValueKey('home')), findsOneWidget);
    });

    testWidgets('Nested navigation within layout', (tester) async {
      final coordinator = LayoutTestCoordinator();
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(AllowPopLayoutChildRoute(id: '1'));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('child-1')), findsOneWidget);

      // Push another child to nested stack
      coordinator.push(AllowPopLayoutChildRoute(id: '2'));
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('child-2')), findsOneWidget);
      expect(find.byKey(const ValueKey('child-1')), findsNothing); // Covered

      // Pop child 2
      coordinator.allowPopPath.pop();
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('child-1')), findsOneWidget);
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/mixin_test_utils.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Application Setup
// ============================================================================

/// Base route for all test routes
abstract class TestAppRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

/// Simple route for navigation testing
class SimpleRoute extends TestAppRoute {
  SimpleRoute({this.id = 'default'});
  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(key: ValueKey('simple-$id'), body: Text('Simple: $id'));
  }

  @override
  List<Object?> get props => [id];
}

// ============================================================================
// RouteTransition Tests
// ============================================================================

/// Route with Material transition
class MaterialTransitionRoute extends TestAppRoute with RouteTransition {
  @override
  Uri toUri() => Uri.parse('/material-transition');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.material(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('material-transition'),
      appBar: AppBar(title: const Text('Material Transition')),
      body: const Center(child: Text('Material Page')),
    );
  }

  @override
  List<Object?> get props => [];
}

/// Route with Cupertino transition
class CupertinoTransitionRoute extends TestAppRoute with RouteTransition {
  @override
  Uri toUri() => Uri.parse('/cupertino-transition');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.cupertino(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('cupertino-transition'),
      appBar: AppBar(title: const Text('Cupertino Transition')),
      body: const Center(child: Text('Cupertino Page')),
    );
  }

  @override
  List<Object?> get props => [];
}

/// Route with Dialog transition
class DialogTransitionRoute extends TestAppRoute with RouteTransition {
  @override
  Uri toUri() => Uri.parse('/dialog-transition');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.dialog(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return AlertDialog(
      key: const ValueKey('dialog-transition'),
      title: const Text('Dialog Transition'),
      content: const Text('Dialog Content'),
      actions: [
        TextButton(
          key: const ValueKey('dialog-close'),
          onPressed: () => coordinator.pop(),
          child: const Text('Close'),
        ),
      ],
    );
  }

  @override
  List<Object?> get props => [];
}

/// Route with Sheet transition
class SheetTransitionRoute extends TestAppRoute with RouteTransition {
  @override
  Uri toUri() => Uri.parse('/sheet-transition');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.sheet(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Container(
      key: const ValueKey('sheet-transition'),
      height: 400,
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: const Center(child: Text('Sheet Content')),
    );
  }

  @override
  List<Object?> get props => [];
}

// ============================================================================
// RouteGuard Tests
// ============================================================================

/// Route with configurable pop guard
class GuardedPopRoute extends TestAppRoute with RouteGuard {
  GuardedPopRoute({this.allowPop = false, this.popDelay = Duration.zero});
  final bool allowPop;
  final Duration popDelay;

  @override
  Uri toUri() => Uri.parse('/guarded-pop');

  @override
  Future<bool> popGuard() async {
    if (popDelay > Duration.zero) {
      await Future.delayed(popDelay);
    }
    return allowPop;
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('guarded-pop'),
      appBar: AppBar(title: const Text('Guarded Page')),
      body: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text('Allow Pop: $allowPop'),
          ElevatedButton(
            key: const ValueKey('try-pop'),
            onPressed: () => coordinator.pop(),
            child: const Text('Try Pop'),
          ),
        ],
      ),
    );
  }

  @override
  List<Object?> get props => [allowPop, popDelay];
}

/// Route with guard that shows confirmation dialog
class ConfirmationGuardRoute extends TestAppRoute with RouteGuard {
  ConfirmationGuardRoute({this.showConfirmation = true});
  final bool showConfirmation;
  bool _wasConfirmationShown = false;

  bool get wasConfirmationShown => _wasConfirmationShown;

  @override
  Uri toUri() => Uri.parse('/confirmation-guard');

  @override
  Future<bool> popGuard() async {
    if (showConfirmation) {
      _wasConfirmationShown = true;
      // Simulate showing a confirmation dialog
      return false;
    }
    return true;
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('confirmation-guard'),
      body: const Text('Confirmation Guard'),
    );
  }

  @override
  List<Object?> get props => [showConfirmation];
}

// ============================================================================
// RouteRedirect Tests
// ============================================================================

/// Route that redirects to another route
class BasicRedirectRoute extends TestAppRoute with RouteRedirect<TestAppRoute> {
  BasicRedirectRoute({required this.targetId});
  final String targetId;

  @override
  Uri toUri() => Uri.parse('/redirect/$targetId');

  @override
  FutureOr<TestAppRoute> redirect() => SimpleRoute(id: targetId);

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return const SizedBox.shrink(); // Should never be shown
  }

  @override
  List<Object?> get props => [targetId];
}

/// Route that redirects asynchronously
class AsyncRedirectRoute extends TestAppRoute with RouteRedirect<TestAppRoute> {
  AsyncRedirectRoute({
    required this.targetId,
    this.delay = const Duration(milliseconds: 50),
  });
  final String targetId;
  final Duration delay;

  @override
  Uri toUri() => Uri.parse('/async-redirect/$targetId');

  @override
  Future<TestAppRoute> redirect() async {
    await Future.delayed(delay);
    return SimpleRoute(id: targetId);
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return const SizedBox.shrink(); // Should never be shown
  }

  @override
  List<Object?> get props => [targetId, delay];
}

/// Route that conditionally redirects based on auth state
class AuthRedirectRoute extends TestAppRoute with RouteRedirect<TestAppRoute> {
  AuthRedirectRoute({required this.isAuthenticated});
  final bool isAuthenticated;

  @override
  Uri toUri() => Uri.parse('/auth-redirect');

  @override
  TestAppRoute redirect() {
    if (!isAuthenticated) {
      return LoginRoute();
    }
    return this; // Stay on current route
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('auth-redirect'),
      body: const Text('Protected Content'),
    );
  }

  @override
  List<Object?> get props => [isAuthenticated];
}

/// Login route for auth redirect testing
class LoginRoute extends TestAppRoute {
  @override
  Uri toUri() => Uri.parse('/login');

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('login'),
      body: const Text('Login Page'),
    );
  }

  @override
  List<Object?> get props => [];
}

/// Route that redirects in a chain
class ChainRedirectRoute extends TestAppRoute with RouteRedirect<TestAppRoute> {
  ChainRedirectRoute({required this.step});
  final int step;

  @override
  Uri toUri() => Uri.parse('/chain-redirect/$step');

  @override
  FutureOr<TestAppRoute> redirect() {
    if (step < 3) {
      return ChainRedirectRoute(step: step + 1);
    }
    return SimpleRoute(id: 'final');
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [step];
}

// ============================================================================
// RouteDeeplink Tests
// ============================================================================

/// Route with push deep link strategy
class PushDeeplinkRoute extends TestAppRoute with RouteDeepLink {
  PushDeeplinkRoute({required this.path});
  final String path;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.push;

  @override
  Uri toUri() => Uri.parse('/deeplink/push/$path');

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('push-deeplink-$path'),
      body: Text('Push Deeplink: $path'),
    );
  }

  @override
  List<Object?> get props => [path];
}

class NavigateDeeplinkRoute extends TestAppRoute with RouteDeepLink {
  NavigateDeeplinkRoute({required this.path});
  final String path;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.navigate;

  @override
  Uri toUri() => Uri.parse('/deeplink/push/$path');

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('navigate-deeplink-$path'),
      body: Text('Navigate Deeplink: $path'),
    );
  }

  @override
  List<Object?> get props => [path];
}

/// Route with replace deep link strategy
class ReplaceDeeplinkRoute extends TestAppRoute with RouteDeepLink {
  ReplaceDeeplinkRoute({required this.path});
  final String path;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.replace;

  @override
  Uri toUri() => Uri.parse('/deeplink/replace/$path');

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('replace-deeplink-$path'),
      body: Text('Replace Deeplink: $path'),
    );
  }

  @override
  List<Object?> get props => [path];
}

/// Route with custom deep link strategy
class CustomDeeplinkRoute extends TestAppRoute with RouteDeepLink {
  CustomDeeplinkRoute({required this.path});
  final String path;
  bool handlerCalled = false;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  Uri toUri() => Uri.parse('/deeplink/custom/$path');

  @override
  void deeplinkHandler(covariant MixinTestCoordinator coordinator, Uri uri) {
    handlerCalled = true;
    // Custom handling: navigate to a profile instead
    coordinator.push(SimpleRoute(id: 'custom-handled-$path'));
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('custom-deeplink-$path'),
      body: Text('Custom Deeplink: $path'),
    );
  }

  @override
  List<Object?> get props => [path];
}

/// Route with async custom deep link handler
class AsyncCustomDeeplinkRoute extends TestAppRoute with RouteDeepLink {
  AsyncCustomDeeplinkRoute({required this.path});
  final String path;
  bool handlerCompleted = false;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  Uri toUri() => Uri.parse('/deeplink/async-custom/$path');

  @override
  Future<void> deeplinkHandler(
    covariant MixinTestCoordinator coordinator,
    Uri uri,
  ) async {
    await Future.delayed(const Duration(milliseconds: 50));
    handlerCompleted = true;
    coordinator.push(SimpleRoute(id: 'async-custom-$path'));
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('async-custom-deeplink-$path'),
      body: Text('Async Custom Deeplink: $path'),
    );
  }

  @override
  List<Object?> get props => [path];
}

// ============================================================================
// Combined Mixins Tests
// ============================================================================

/// Route with RouteTransition + RouteGuard
class TransitionGuardRoute extends TestAppRoute
    with RouteTransition, RouteGuard {
  TransitionGuardRoute({this.allowPop = false});
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/transition-guard');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.cupertino(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('transition-guard'),
      appBar: AppBar(title: const Text('Transition + Guard')),
      body: Column(
        children: [
          Text('Allow Pop: $allowPop'),
          ElevatedButton(
            key: const ValueKey('try-pop'),
            onPressed: () => coordinator.pop(),
            child: const Text('Try Pop'),
          ),
        ],
      ),
    );
  }

  @override
  List<Object?> get props => [allowPop];
}

/// Route with RouteRedirect + RouteGuard
class RedirectGuardRoute extends TestAppRoute
    with RouteRedirect<TestAppRoute>, RouteGuard {
  RedirectGuardRoute({required this.shouldRedirect, this.allowPop = false});
  final bool shouldRedirect;
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/redirect-guard');

  @override
  TestAppRoute redirect() {
    if (shouldRedirect) {
      return SimpleRoute(id: 'redirected');
    }
    return this;
  }

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: const ValueKey('redirect-guard'),
      body: const Text('Redirect + Guard'),
    );
  }

  @override
  List<Object?> get props => [shouldRedirect, allowPop];
}

/// Route with RouteDeeplink + RouteGuard
class DeeplinkGuardRoute extends TestAppRoute with RouteDeepLink, RouteGuard {
  DeeplinkGuardRoute({required this.path, this.allowPop = false});
  final String path;
  final bool allowPop;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.push;

  @override
  Uri toUri() => Uri.parse('/deeplink-guard/$path');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('deeplink-guard-$path'),
      body: Text('Deeplink + Guard: $path'),
    );
  }

  @override
  List<Object?> get props => [path, allowPop];
}

/// Route with RouteTransition + RouteDeeplink
class TransitionDeeplinkRoute extends TestAppRoute
    with RouteTransition, RouteDeepLink {
  TransitionDeeplinkRoute({required this.path});
  final String path;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  Uri toUri() => Uri.parse('/transition-deeplink/$path');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.sheet(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  void deeplinkHandler(covariant MixinTestCoordinator coordinator, Uri uri) {
    coordinator.push(SimpleRoute(id: 'transition-deeplink-handled'));
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Container(
      key: ValueKey('transition-deeplink-$path'),
      height: 300,
      color: Colors.blue,
      child: Text('Transition + Deeplink: $path'),
    );
  }

  @override
  List<Object?> get props => [path];
}

/// Route with all mixins: RouteTransition + RouteGuard + RouteRedirect + RouteDeeplink
class FullMixinRoute extends TestAppRoute
    with
        RouteTransition,
        RouteGuard,
        RouteRedirect<TestAppRoute>,
        RouteDeepLink {
  FullMixinRoute({
    required this.id,
    this.allowPop = true,
    this.shouldRedirect = false,
  });
  final String id;
  final bool allowPop;
  final bool shouldRedirect;

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  Uri toUri() => Uri.parse('/full-mixin/$id');

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    covariant MixinTestCoordinator coordinator,
  ) {
    return StackTransition.cupertino(
      Builder(builder: (context) => build(coordinator, context)),
    );
  }

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  TestAppRoute redirect() {
    if (shouldRedirect) {
      return SimpleRoute(id: 'full-mixin-redirected');
    }
    return this;
  }

  @override
  void deeplinkHandler(covariant MixinTestCoordinator coordinator, Uri uri) {
    coordinator.push(SimpleRoute(id: 'full-mixin-deeplink-$id'));
  }

  @override
  Widget build(
    covariant MixinTestCoordinator coordinator,
    BuildContext context,
  ) {
    return Scaffold(
      key: ValueKey('full-mixin-$id'),
      appBar: AppBar(title: Text('Full Mixin: $id')),
      body: Column(
        children: [
          Text('Allow Pop: $allowPop'),
          Text('Should Redirect: $shouldRedirect'),
          ElevatedButton(
            key: const ValueKey('try-pop'),
            onPressed: () => coordinator.pop(),
            child: const Text('Try Pop'),
          ),
        ],
      ),
    );
  }

  @override
  List<Object?> get props => [id, allowPop, shouldRedirect];
}

// ============================================================================
// Test Coordinator
// ============================================================================

class MixinTestCoordinator extends Coordinator<TestAppRoute> {
  @override
  void defineLayout() {}

  @override
  List<StackPath> get paths => [...super.paths];

  @override
  TestAppRoute parseRouteFromUri(Uri uri) {
    final segments = uri.pathSegments;
    if (segments.isEmpty) return SimpleRoute(id: 'home');

    return switch (segments) {
      ['simple', final id] => SimpleRoute(id: id),
      ['material-transition'] => MaterialTransitionRoute(),
      ['cupertino-transition'] => CupertinoTransitionRoute(),
      ['dialog-transition'] => DialogTransitionRoute(),
      ['sheet-transition'] => SheetTransitionRoute(),
      ['guarded-pop'] => GuardedPopRoute(),
      ['confirmation-guard'] => ConfirmationGuardRoute(),
      ['redirect', final targetId] => BasicRedirectRoute(targetId: targetId),
      ['async-redirect', final targetId] => AsyncRedirectRoute(
        targetId: targetId,
      ),
      ['auth-redirect'] => AuthRedirectRoute(isAuthenticated: false),
      ['login'] => LoginRoute(),
      ['chain-redirect', final step] => ChainRedirectRoute(
        step: int.parse(step),
      ),
      ['deeplink', 'push', final path] => PushDeeplinkRoute(path: path),
      ['deeplink', 'replace', final path] => ReplaceDeeplinkRoute(path: path),
      ['deeplink', 'custom', final path] => CustomDeeplinkRoute(path: path),
      ['deeplink', 'async-custom', final path] => AsyncCustomDeeplinkRoute(
        path: path,
      ),
      ['transition-guard'] => TransitionGuardRoute(),
      ['redirect-guard'] => RedirectGuardRoute(shouldRedirect: false),
      ['deeplink-guard', final path] => DeeplinkGuardRoute(path: path),
      ['transition-deeplink', final path] => TransitionDeeplinkRoute(
        path: path,
      ),
      ['full-mixin', final id] => FullMixinRoute(id: id),
      _ => SimpleRoute(id: 'home'),
    };
  }
}



================================================
FILE: packages/zenrouter/test/mixin/query_parameters_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// Use a simple concrete implementation for testing
class TestRoute extends RouteTarget with RouteUnique, RouteQueryParameters {
  TestRoute({Map<String, String>? initialQueries})
    : queryNotifier = ValueNotifier(initialQueries ?? {});

  @override
  final ValueNotifier<Map<String, String>> queryNotifier;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return ValueListenableBuilder(
      valueListenable: queryNotifier,
      builder: (context, queries, _) {
        return Text('Queries: ${queries.toString()}');
      },
    );
  }

  @override
  Uri toUri() {
    return Uri(path: '/test', queryParameters: queries);
  }

  @override
  List<Object?> get props => [];
}

class TabLayout extends TestRoute with RouteLayout {
  @override
  IndexedStackPath<TestRoute> resolvePath(
    covariant TestCoordinator coordinator,
  ) => coordinator.tabIndexed;
}

class FirstTab extends TestRoute {
  FirstTab({super.initialQueries});

  @override
  Type? get layout => TabLayout;

  @override
  Uri toUri() => Uri(path: '/test', queryParameters: queries);

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return ValueListenableBuilder(
      valueListenable: queryNotifier,
      builder: (context, queries, _) => Column(
        children: [Text('FirstTab'), Text('Queries: ${queries.toString()}')],
      ),
    );
  }
}

class SecondTab extends TestRoute {
  @override
  Type? get layout => TabLayout;
}

class TestCoordinator extends Coordinator<RouteUnique> {
  RouteUnique? _parsedRoute;

  late final tabIndexed = IndexedStackPath.createWith(
    [FirstTab(), SecondTab()],
    coordinator: this,
    label: 'tab',
  );

  void setParsedRoute(RouteUnique route) {
    _parsedRoute = route;
  }

  @override
  void defineLayout() {
    RouteLayout.defineLayout(TabLayout, TabLayout.new);
  }

  @override
  RouteUnique parseRouteFromUri(Uri uri) {
    return _parsedRoute ?? TestRoute(initialQueries: uri.queryParameters);
  }
}

void main() {
  group('RouteQueryParameters Mixin', () {
    late TestRoute route;
    late TestCoordinator coordinator;

    setUp(() {
      route = TestRoute();
      coordinator = TestCoordinator();
    });

    test('initializes with empty queries', () {
      expect(route.queries, isEmpty);
      expect(route.queryNotifier.value, isEmpty);
    });

    test('update queries via property setter', () {
      route.queries = {'foo': 'bar'};
      expect(route.queries, {'foo': 'bar'});
      expect(route.queryNotifier.value, {'foo': 'bar'});
      expect(route.query('foo'), 'bar');
    });

    test('query() returns value or null', () {
      route.queries = {'a': '1', 'b': '2'};
      expect(route.query('a'), '1');
      expect(route.query('b'), '2');
      expect(route.query('c'), isNull);
    });

    test('updateQueries updates notifier', () {
      route.updateQueries(coordinator, queries: {'x': 'y'});
      expect(route.queries, {'x': 'y'});
    });

    testWidgets('active route does not trigger navigation on updateQueries', (
      tester,
    ) async {
      // Setup coordinator with the route active
      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.root.push(route);
      await tester.pumpAndSettle();

      // Verify initial state
      expect(find.text('Queries: {}'), findsOneWidget);

      // Update queries
      route.updateQueries(coordinator, queries: {'updated': 'true'});
      await tester.pump(); // Rebuild from ValueListenable

      // Verify updated state
      expect(find.text('Queries: {updated: true}'), findsOneWidget);
    });

    testWidgets('Route identity remains same when queries change', (
      tester,
    ) async {
      final route1 = TestRoute();
      final route2 = TestRoute(initialQueries: {'a': 'b'});

      // Since props excludes queries, they should be equal if props are empty
      expect(route1, route2);

      route1.queries = {'c': 'd'};
      expect(route1, route2);
    });

    testWidgets('selectorBuilder rebuilds only when selected value changes', (
      tester,
    ) async {
      final route = TestRoute(initialQueries: {'page': '1', 'sort': 'asc'});
      int buildCount = 0;

      await tester.pumpWidget(
        MaterialApp(
          home: route.selectorBuilder<String>(
            selector: (queries) => queries['page'] ?? '',
            builder: (context, page) {
              buildCount++;
              return Text('Page: $page');
            },
          ),
        ),
      );

      expect(find.text('Page: 1'), findsOneWidget);
      expect(buildCount, 1);

      // Update unrelated query
      route.queries = {'page': '1', 'sort': 'desc'};
      await tester.pump();

      expect(buildCount, 1);
      expect(find.text('Page: 1'), findsOneWidget);

      // Update related query
      route.queries = {'page': '2', 'sort': 'desc'};
      await tester.pump();

      expect(buildCount, 2);
      expect(find.text('Page: 2'), findsOneWidget);
    });

    testWidgets('updateQueries calls navigate if route is not active', (
      tester,
    ) async {
      final routeA = TestRoute()..queries = {'id': 'A'};

      // Need a second route type or property to distinguish them for navigation stack
      // Since props implies equality, we need to distinct them?
      // No, we can just push two instances. If they are equal, `navigate` is tricky.
      // Let's make TestRoute have an ID in props for this test.

      final routeB = TestRoute2(); // Different type or ID

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.root.push(routeA);
      await tester.pumpAndSettle();

      coordinator.root.push(routeB);
      await tester.pumpAndSettle();

      // Now RouteB is active. RouteA is in stack but inactive.
      expect(find.text('RouteB'), findsOneWidget);
      expect(coordinator.activePath.activeRoute, routeB);

      // Update queries on RouteA
      routeA.updateQueries(coordinator, queries: {'id': 'A', 'updated': 'yes'});

      await tester.pumpAndSettle();

      // Should have navigated to RouteA and updated text
      expect(find.text('Queries: {id: A, updated: yes}'), findsOneWidget);
      expect(coordinator.activePath.activeRoute, routeA);
    });

    testWidgets('updateQueries work in IndexedStackPath with navigate', (
      tester,
    ) async {
      final route = FirstTab(initialQueries: {'id': 'A'});

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(route);
      await tester.pumpAndSettle();

      expect(find.text('FirstTab'), findsOneWidget);
      expect(coordinator.activePath.activeRoute, route);
      expect(
        (coordinator.activePath.activeRoute as TestRoute).queryNotifier.value,
        {'id': 'A'},
      );

      final newRoute = FirstTab(initialQueries: {'id': 'A', 'updated': 'yes'});
      expect(newRoute.queryNotifier.value, {'id': 'A', 'updated': 'yes'});
      coordinator.navigate(newRoute);
      await tester.pumpAndSettle();

      expect(find.text('FirstTab'), findsOneWidget);
      expect(coordinator.activePath.activeRoute, route);
      expect(
        (coordinator.activePath.activeRoute as TestRoute).queryNotifier.value,
        {'id': 'A', 'updated': 'yes'},
      );
      // Completed the previous route
      expect(newRoute.onResult.isCompleted, true);
      expect(
        () => newRoute.queryNotifier.addListener(() {}),
        throwsA(isA<FlutterError>()),
      );
    });

    test('disposes notifier on didPop', () {
      route.onDidPop(null, coordinator);
      expect(
        () => route.queryNotifier.addListener(() {}),
        throwsA(
          isA<FlutterError>().having(
            (e) => e.message,
            'message',
            contains('disposed'),
          ),
        ),
      );
    });
  });
}

class TestRoute2 extends RouteTarget with RouteUnique {
  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return const Text('RouteB');
  }

  @override
  List<Object?> get props => ['B'];

  @override
  Uri toUri() => Uri(path: '/b');
}



================================================
FILE: packages/zenrouter/test/mixin/redirect_rule_test.dart
================================================
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

void main() {
  group('RedirectResult Classes Tests', () {
    test('StopRedirect factory creates correct instance', () {
      const result = StopRedirect<RouteTarget>();
      expect(result, isA<StopRedirect<RouteTarget>>());
      expect(result, isA<RedirectResult<RouteTarget>>());
    });

    test('ContinueRedirect factory creates correct instance', () {
      const result = ContinueRedirect<RouteTarget>();
      expect(result, isA<ContinueRedirect<RouteTarget>>());
      expect(result, isA<RedirectResult<RouteTarget>>());
    });

    test('RedirectTo factory creates correct instance with route', () {
      final testRoute = SimpleRoute(id: 'test');
      final result = RedirectResult<RedirectRuleTestRoute>.redirectTo(
        testRoute,
      );
      expect(result, isA<RedirectTo<RedirectRuleTestRoute>>());
      expect(result, isA<RedirectResult<RedirectRuleTestRoute>>());
      expect((result as RedirectTo).route, equals(testRoute));
    });

    test('StopRedirect is const and can be reused', () {
      const result1 = StopRedirect<RouteTarget>();
      const result2 = StopRedirect<RouteTarget>();
      expect(identical(result1, result2), isTrue);
    });

    test('ContinueRedirect is const and can be reused', () {
      const result1 = ContinueRedirect<RouteTarget>();
      const result2 = ContinueRedirect<RouteTarget>();
      expect(identical(result1, result2), isTrue);
    });

    test('RedirectTo stores the route correctly', () {
      final route1 = SimpleRoute(id: 'route1');
      final route2 = SimpleRoute(id: 'route2');

      final result1 = RedirectTo(route1);
      final result2 = RedirectTo(route2);

      expect(result1.route, equals(route1));
      expect(result2.route, equals(route2));
      expect(result1.route, isNot(equals(result2.route)));
    });

    test('All RedirectResult types are sealed class variants', () {
      const stop = RedirectResult<RouteTarget>.stop();
      const continueResult = RedirectResult<RouteTarget>.continueRedirect();
      final redirect = RedirectResult<RedirectRuleTestRoute>.redirectTo(
        SimpleRoute(id: 'test'),
      );

      expect(stop, isA<RedirectResult<RouteTarget>>());
      expect(continueResult, isA<RedirectResult<RouteTarget>>());
      expect(redirect, isA<RedirectResult<RedirectRuleTestRoute>>());
    });
  });

  group('RouteRedirectRule Tests', () {
    testWidgets('Redirect rule can stop navigation', (tester) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // StopRule will prevent navigation
      coordinator.push(RuleRoute(id: '1', rules: [StopRule()]));
      await tester.pumpAndSettle();

      // Should not navigate, still on initial route
      expect(find.text('Rule Route: 1'), findsNothing);
    });

    testWidgets('Redirect rule can continue to next rule', (tester) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // ContinueRule will pass through, final rule returns the route itself
      coordinator.push(RuleRoute(id: '2', rules: [ContinueRule()]));
      await tester.pumpAndSettle();

      // Should navigate successfully
      expect(find.text('Rule Route: 2'), findsOneWidget);
    });

    testWidgets('Redirect rule can redirect to another route', (tester) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // RedirectToTargetRule will redirect to target route
      coordinator.push(
        RuleRoute(
          id: '3',
          rules: [RedirectToTargetRule(targetId: 'redirected')],
        ),
      );
      await tester.pumpAndSettle();

      // Should show redirected route, not original
      expect(find.text('Rule Route: 3'), findsNothing);
      expect(find.text('Simple: redirected'), findsOneWidget);
    });

    testWidgets('Multiple redirect rules are processed in sequence', (
      tester,
    ) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // First rule continues, second rule redirects
      coordinator.push(
        RuleRoute(
          id: '4',
          rules: [
            ContinueRule(),
            ContinueRule(),
            RedirectToTargetRule(targetId: 'final'),
          ],
        ),
      );
      await tester.pumpAndSettle();

      expect(find.text('Rule Route: 4'), findsNothing);
      expect(find.text('Simple: final'), findsOneWidget);
    });

    testWidgets('Stop rule prevents subsequent rules from running', (
      tester,
    ) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Stop rule prevents redirect rule from running
      coordinator.push(
        RuleRoute(
          id: '5',
          rules: [
            ContinueRule(),
            StopRule(),
            RedirectToTargetRule(targetId: 'should-not-reach'),
          ],
        ),
      );
      await tester.pumpAndSettle();

      // Should not navigate at all
      expect(find.text('Rule Route: 5'), findsNothing);
      expect(find.text('Simple: should-not-reach'), findsNothing);
    });

    testWidgets('Auth redirect rule blocks unauthenticated access', (
      tester,
    ) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Unauthenticated user redirected to login
      coordinator.push(
        RuleRoute(id: '6', rules: [AuthRedirectRule(isAuthenticated: false)]),
      );
      await tester.pumpAndSettle();

      expect(find.text('Rule Route: 6'), findsNothing);
      expect(find.text('Login Page'), findsOneWidget);
    });

    testWidgets('Auth redirect rule allows authenticated access', (
      tester,
    ) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Authenticated user proceeds
      coordinator.push(
        RuleRoute(id: '7', rules: [AuthRedirectRule(isAuthenticated: true)]),
      );
      await tester.pumpAndSettle();

      expect(find.text('Rule Route: 7'), findsOneWidget);
    });

    testWidgets('Async redirect rules work correctly', (tester) async {
      final coordinator = RedirectRuleTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Async rule that redirects after delay
      coordinator.push(
        RuleRoute(
          id: '8',
          rules: [
            AsyncRedirectRule(
              targetId: 'async-result',
              delay: const Duration(milliseconds: 50),
            ),
          ],
        ),
      );
      await tester.pumpAndSettle();

      expect(find.text('Rule Route: 8'), findsNothing);
      expect(find.text('Simple: async-result'), findsOneWidget);
    });

    testWidgets(
      'Indexed stack should not redirect if redirect rule route return itself',
      (tester) async {
        final coordinator = RedirectRuleTestCoordinator();

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        coordinator.push(FirstTab());
        await tester.pumpAndSettle();

        coordinator.indexedStackPath.goToIndexed(1);
        final second = coordinator.indexedStackPath.stack[1] as SecondTab;

        expect(second.redirectRules.first is RedirectCountingRule, true);
        expect((second.redirectRules.first as RedirectCountingRule).count, 1);
      },
    );
  });
}

// ============================================================================
// Test Routes
// ============================================================================

abstract class RedirectRuleTestRoute extends RouteTarget with RouteUnique {}

class RuleRoute extends RedirectRuleTestRoute
    with RouteRedirect, RouteRedirectRule {
  RuleRoute({required this.id, required this.rules});

  final String id;
  final List<RedirectRule> rules;

  @override
  List<RedirectRule> get redirectRules => rules;

  @override
  Uri toUri() => Uri.parse('/rule/$id');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return Scaffold(body: Center(child: Text('Rule Route: $id')));
  }

  @override
  List<Object?> get props => [id, ...rules];
}

class SimpleRoute extends RedirectRuleTestRoute {
  SimpleRoute({required this.id});

  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return Scaffold(body: Center(child: Text('Simple: $id')));
  }

  @override
  List<Object?> get props => [id];
}

class LoginRoute extends RedirectRuleTestRoute {
  @override
  Uri toUri() => Uri.parse('/login');

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return Scaffold(body: Center(child: Text('Login Page')));
  }
}

// ============================================================================
// Test Redirect Rules
// ============================================================================

class StopRule extends RedirectRule<RedirectRuleTestRoute> {
  @override
  FutureOr<RedirectResult<RedirectRuleTestRoute>> redirectResult(
    covariant Coordinator coordinator,
    covariant RedirectRuleTestRoute route,
  ) {
    return const RedirectResult.stop();
  }
}

class ContinueRule extends RedirectRule<RedirectRuleTestRoute> {
  @override
  FutureOr<RedirectResult<RedirectRuleTestRoute>> redirectResult(
    covariant Coordinator coordinator,
    covariant RedirectRuleTestRoute route,
  ) {
    return const RedirectResult.continueRedirect();
  }
}

class RedirectToTargetRule extends RedirectRule<RedirectRuleTestRoute> {
  RedirectToTargetRule({required this.targetId});

  final String targetId;

  @override
  FutureOr<RedirectResult<RedirectRuleTestRoute>> redirectResult(
    covariant Coordinator coordinator,
    covariant RedirectRuleTestRoute route,
  ) {
    return RedirectResult.redirectTo(SimpleRoute(id: targetId));
  }
}

class AuthRedirectRule extends RedirectRule<RedirectRuleTestRoute> {
  AuthRedirectRule({required this.isAuthenticated});

  final bool isAuthenticated;

  @override
  FutureOr<RedirectResult<RedirectRuleTestRoute>> redirectResult(
    covariant Coordinator coordinator,
    covariant RedirectRuleTestRoute route,
  ) {
    if (!isAuthenticated) {
      return RedirectResult.redirectTo(LoginRoute());
    }
    return const RedirectResult.continueRedirect();
  }
}

class RedirectCountingRule extends RedirectRule<RedirectRuleTestRoute> {
  RedirectCountingRule();

  int count = 0;

  @override
  FutureOr<RedirectResult<RedirectRuleTestRoute>> redirectResult(
    covariant Coordinator coordinator,
    covariant RedirectRuleTestRoute route,
  ) {
    count += 1;
    return RedirectResult.continueRedirect();
  }
}

class AsyncRedirectRule extends RedirectRule<RedirectRuleTestRoute> {
  AsyncRedirectRule({required this.targetId, required this.delay});

  final String targetId;
  final Duration delay;

  @override
  FutureOr<RedirectResult<RedirectRuleTestRoute>> redirectResult(
    covariant Coordinator coordinator,
    covariant RedirectRuleTestRoute route,
  ) async {
    await Future.delayed(delay);
    return RedirectResult.redirectTo(SimpleRoute(id: targetId));
  }
}

class TestIndexedStackLayout extends RedirectRuleTestRoute with RouteLayout {
  @override
  StackPath<RouteUnique> resolvePath(
    covariant RedirectRuleTestCoordinator coordinator,
  ) => coordinator.indexedStackPath;
}

class FirstTab extends RedirectRuleTestRoute {
  @override
  Type get layout => TestIndexedStackLayout;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Center(child: Text('First Tab'));
  }

  @override
  Uri toUri() => Uri.parse('/first-tab');
}

class SecondTab extends RedirectRuleTestRoute
    with RouteRedirect, RouteRedirectRule {
  @override
  Type get layout => TestIndexedStackLayout;

  @override
  final List<RedirectRule> redirectRules = [RedirectCountingRule()];

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const Center(child: Text('Second Tab'));
  }

  @override
  Uri toUri() => Uri.parse('/second-tab');
}

// ============================================================================
// Test Coordinator
// ============================================================================

class RedirectRuleTestCoordinator extends Coordinator<RedirectRuleTestRoute> {
  late final indexedStackPath = IndexedStackPath.createWith(
    [FirstTab(), SecondTab()],
    coordinator: this,
    label: 'IndexedStackPath',
  )..bindLayout(TestIndexedStackLayout.new);

  @override
  List<StackPath> get paths => [...super.paths, indexedStackPath];

  @override
  RedirectRuleTestRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['rule', final id] => RuleRoute(id: id, rules: []),
      ['simple', final id] => SimpleRoute(id: id),
      ['login'] => LoginRoute(),
      _ => SimpleRoute(id: 'not-found'),
    };
  }
}



================================================
FILE: packages/zenrouter/test/mixin/redirect_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'mixin_test_utils.dart';

void main() {
  group('RouteRedirect Mixin Tests', () {
    testWidgets('Basic redirect navigates to target route', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(BasicRedirectRoute(targetId: 'redirected-target'));
      await tester.pumpAndSettle();

      // Should show target route, not redirect route
      expect(
        find.byKey(const ValueKey('simple-redirected-target')),
        findsOneWidget,
      );
      expect(find.text('Simple: redirected-target'), findsOneWidget);
    });

    testWidgets('Async redirect waits and navigates', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(
        AsyncRedirectRoute(
          targetId: 'async-target',
          delay: const Duration(milliseconds: 50),
        ),
      );
      await tester.pumpAndSettle();

      // Should show target route after async delay
      expect(find.byKey(const ValueKey('simple-async-target')), findsOneWidget);
    });

    testWidgets('Auth redirect redirects unauthenticated users', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(AuthRedirectRoute(isAuthenticated: false));
      await tester.pumpAndSettle();

      // Should redirect to login page
      expect(find.byKey(const ValueKey('login')), findsOneWidget);
    });

    testWidgets('Auth redirect allows authenticated users', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(AuthRedirectRoute(isAuthenticated: true));
      await tester.pumpAndSettle();

      // Should show protected content
      expect(find.byKey(const ValueKey('auth-redirect')), findsOneWidget);
      expect(find.text('Protected Content'), findsOneWidget);
    });

    testWidgets('Chain redirect follows through multiple redirects', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(ChainRedirectRoute(step: 1));
      await tester.pumpAndSettle();

      // Should resolve to final route after chain: 1 -> 2 -> 3 -> SimpleRoute('final')
      expect(find.byKey(const ValueKey('simple-final')), findsOneWidget);
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/restoration_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Setup
// ============================================================================

abstract class TestRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

// Simple route with RouteUnique only
class SimpleRoute extends TestRoute {
  SimpleRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Simple $id'));
  }

  @override
  List<Object?> get props => [id];
}

// Route with RouteRestorable using converter strategy
class ComplexRoute extends TestRoute with RouteRestorable<ComplexRoute> {
  ComplexRoute({required this.id, required this.data, this.metadata});

  final String id;
  final Map<String, dynamic> data;
  final String? metadata;

  @override
  String get restorationId => 'complex_$id';

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.converter;

  @override
  RestorableConverter<ComplexRoute> get converter =>
      const ComplexRouteConverter();

  @override
  Uri toUri() => Uri.parse('/complex/$id');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Complex $id'));
  }

  @override
  List<Object?> get props => [id, data, metadata];
}

class ComplexRouteConverter extends RestorableConverter<ComplexRoute> {
  const ComplexRouteConverter();

  @override
  String get key => 'test_complex_route';

  @override
  Map<String, dynamic> serialize(ComplexRoute route) {
    return {'id': route.id, 'data': route.data, 'metadata': route.metadata};
  }

  @override
  ComplexRoute deserialize(Map<String, dynamic> data) {
    return ComplexRoute(
      id: data['id'] as String,
      data: (data['data'] as Map).cast<String, dynamic>(),
      metadata: data['metadata'] as String?,
    );
  }
}

// Route with RouteRestorable using unique strategy
class UniqueRestorableRoute extends TestRoute
    with RouteRestorable<UniqueRestorableRoute> {
  UniqueRestorableRoute(this.id);
  final String id;

  @override
  String get restorationId => 'unique_$id';

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.unique;

  @override
  RestorableConverter<UniqueRestorableRoute> get converter =>
      throw UnimplementedError();

  @override
  Uri toUri() => Uri.parse('/unique/$id');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Unique $id'));
  }

  @override
  List<Object?> get props => [id];
}

// Coordinator for testing
class TestCoordinator extends Coordinator<TestRoute> {
  @override
  void defineConverter() {
    RestorableConverter.defineConverter(
      'test_complex_route',
      () => const ComplexRouteConverter(),
    );
  }

  @override
  TestRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['simple', final id] => SimpleRoute(id),
      ['complex', final id] => ComplexRoute(id: id, data: {}),
      ['unique', final id] => UniqueRestorableRoute(id),
      _ => SimpleRoute('default'),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('RestorationStrategy Enum', () {
    test('has unique and converter values', () {
      expect(RestorationStrategy.values, hasLength(2));
      expect(RestorationStrategy.values, contains(RestorationStrategy.unique));
      expect(
        RestorationStrategy.values,
        contains(RestorationStrategy.converter),
      );
    });

    test('can be retrieved by name', () {
      final strategy = RestorationStrategy.values.asNameMap()['unique'];
      expect(strategy, equals(RestorationStrategy.unique));

      final converterStrategy = RestorationStrategy.values
          .asNameMap()['converter'];
      expect(converterStrategy, equals(RestorationStrategy.converter));
    });
  });

  group('RouteRestorable Mixin - Serialization', () {
    test('serializes route with converter strategy correctly', () {
      final route = ComplexRoute(
        id: '123',
        data: {'key': 'value', 'count': 42},
        metadata: 'test metadata',
      );

      final serialized = route.serialize();

      expect(serialized, isA<Map<String, dynamic>>());
      expect(serialized['strategy'], equals('converter'));
      expect(serialized['converter'], equals('test_complex_route'));
      expect(serialized['value'], isA<Map>());
      expect(serialized['value']['id'], equals('123'));
      expect(serialized['value']['data']['key'], equals('value'));
      expect(serialized['value']['data']['count'], equals(42));
      expect(serialized['value']['metadata'], equals('test metadata'));
    });

    test('serializes route with unique strategy correctly', () {
      final route = UniqueRestorableRoute('456');

      final serialized = route.serialize();

      expect(serialized, isA<Map<String, dynamic>>());
      expect(serialized['strategy'], equals('unique'));
      expect(serialized['value'], equals('/unique/456'));
      expect(serialized.containsKey('converter'), isFalse);
    });

    test('handles null metadata in serialization', () {
      final route = ComplexRoute(
        id: '789',
        data: {'test': 'data'},
        metadata: null,
      );

      final serialized = route.serialize();

      expect(serialized['value']['metadata'], isNull);
    });

    test('preserves complex nested data structures', () {
      final route = ComplexRoute(
        id: '999',
        data: {
          'nested': {'deep': 'value'},
          'list': [1, 2, 3],
          'mixed': {
            'items': [1, 'two', 3.0],
          },
        },
      );

      final serialized = route.serialize();
      final data = serialized['value']['data'] as Map;

      expect(data['nested']['deep'], equals('value'));
      expect(data['list'], equals([1, 2, 3]));
      expect(data['mixed']['items'], equals([1, 'two', 3.0]));
    });
  });

  group('RouteRestorable Mixin - Deserialization', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('deserializes route with converter strategy correctly', () {
      final data = {
        'strategy': 'converter',
        'converter': 'test_complex_route',
        'value': {
          'id': '123',
          'data': {'key': 'value', 'count': 42},
          'metadata': 'restored metadata',
        },
      };

      final route = RouteRestorable.deserialize<TestRoute>(
        data,
        parseRouteFromUri: coordinator.parseRouteFromUriSync,
      );

      expect(route, isA<ComplexRoute>());
      final complexRoute = route as ComplexRoute;
      expect(complexRoute.id, equals('123'));
      expect(complexRoute.data['key'], equals('value'));
      expect(complexRoute.data['count'], equals(42));
      expect(complexRoute.metadata, equals('restored metadata'));
    });

    test('deserializes route with unique strategy correctly', () {
      final data = {'strategy': 'unique', 'value': '/unique/456'};

      final route = RouteRestorable.deserialize<TestRoute>(
        data,
        parseRouteFromUri: coordinator.parseRouteFromUriSync,
      );

      expect(route, isA<UniqueRestorableRoute>());
      expect((route as UniqueRestorableRoute).id, equals('456'));
    });

    test('handles null metadata in deserialization', () {
      final data = {
        'strategy': 'converter',
        'converter': 'test_complex_route',
        'value': {
          'id': '789',
          'data': {'test': 'data'},
          'metadata': null,
        },
      };

      final route = RouteRestorable.deserialize<TestRoute>(
        data,
        parseRouteFromUri: coordinator.parseRouteFromUriSync,
      );

      expect(route, isA<ComplexRoute>());
      expect((route as ComplexRoute).metadata, isNull);
    });

    test('throws on null strategy', () {
      final data = {'strategy': null, 'value': '/test'};

      expect(
        () => RouteRestorable.deserialize<TestRoute>(
          data,
          parseRouteFromUri: coordinator.parseRouteFromUriSync,
        ),
        throwsA(isA<UnimplementedError>()),
      );
    });

    test('throws on invalid strategy type', () {
      final data = {
        'strategy': 123, // Not a string
        'value': '/test',
      };

      expect(
        () => RouteRestorable.deserialize<TestRoute>(
          data,
          parseRouteFromUri: coordinator.parseRouteFromUriSync,
        ),
        throwsA(isA<UnimplementedError>()),
      );
    });

    test('throws on unregistered converter key', () {
      final data = {
        'strategy': 'converter',
        'converter': 'unregistered_converter',
        'value': {'data': 'test'},
      };

      expect(
        () => RouteRestorable.deserialize<TestRoute>(
          data,
          parseRouteFromUri: coordinator.parseRouteFromUriSync,
        ),
        throwsA(isA<UnimplementedError>()),
      );
    });

    test('requires parseRouteFromUri for unique strategy', () {
      final data = {'strategy': 'unique', 'value': '/unique/123'};

      // Without parseRouteFromUri, should fail assertion
      expect(
        () => RouteRestorable.deserialize<TestRoute>(
          data,
          parseRouteFromUri: null,
        ),
        throwsAssertionError,
      );
    });
  });

  group('RouteRestorable Mixin - Round Trip', () {
    late TestCoordinator coordinator;

    setUp(() {
      coordinator = TestCoordinator();
    });

    test('converter strategy round-trip preserves all data', () {
      final original = ComplexRoute(
        id: '123',
        data: {
          'key': 'value',
          'nested': {'deep': 'data'},
        },
        metadata: 'test',
      );

      final serialized = original.serialize();
      final restored =
          RouteRestorable.deserialize<TestRoute>(
                serialized,
                parseRouteFromUri: coordinator.parseRouteFromUriSync,
              )
              as ComplexRoute;

      expect(restored.id, equals(original.id));
      expect(restored.data, equals(original.data));
      expect(restored.metadata, equals(original.metadata));
    });

    test('unique strategy round-trip preserves route identity', () {
      final original = UniqueRestorableRoute('456');

      final serialized = original.serialize();
      final restored =
          RouteRestorable.deserialize<TestRoute>(
                serialized,
                parseRouteFromUri: coordinator.parseRouteFromUriSync,
              )
              as UniqueRestorableRoute;

      expect(restored.id, equals(original.id));
      expect(restored.toUri(), equals(original.toUri()));
    });
  });

  group('RestorableConverter - Registry', () {
    test('registers converter successfully', () {
      // Converter should already be registered in setUp
      final converter = RestorableConverter.buildConverter(
        'test_complex_route',
      );

      expect(converter, isNotNull);
      expect(converter, isA<ComplexRouteConverter>());
    });

    test('returns null for unregistered key', () {
      final converter = RestorableConverter.buildConverter('non_existent_key');

      expect(converter, isNull);
    });

    test('can register multiple converters', () {
      // Register a second converter
      RestorableConverter.defineConverter(
        'test_converter_2',
        () => const ComplexRouteConverter(),
      );

      final converter1 = RestorableConverter.buildConverter(
        'test_complex_route',
      );
      final converter2 = RestorableConverter.buildConverter('test_converter_2');

      expect(converter1, isNotNull);
      expect(converter2, isNotNull);
    });

    test('overwrites converter with same key', () {
      // Register with same key
      RestorableConverter.defineConverter(
        'test_complex_route',
        () => const ComplexRouteConverter(),
      );

      final converter = RestorableConverter.buildConverter(
        'test_complex_route',
      );

      expect(converter, isNotNull);
      expect(converter, isA<ComplexRouteConverter>());
    });
  });

  group('RestorableConverter - Implementation', () {
    test('converter key is stable', () {
      final converter = const ComplexRouteConverter();

      expect(converter.key, equals('test_complex_route'));
      expect(converter.key, equals(converter.key)); // Same instance
    });

    test('converter serializes correctly', () {
      final converter = const ComplexRouteConverter();
      final route = ComplexRoute(
        id: '123',
        data: {'test': 'value'},
        metadata: 'meta',
      );

      final serialized = converter.serialize(route);

      expect(serialized['id'], equals('123'));
      expect(serialized['data']['test'], equals('value'));
      expect(serialized['metadata'], equals('meta'));
    });

    test('converter deserializes correctly', () {
      final converter = const ComplexRouteConverter();
      final data = {
        'id': '456',
        'data': {'key': 'value'},
        'metadata': 'restored',
      };

      final route = converter.deserialize(data);

      expect(route.id, equals('456'));
      expect(route.data['key'], equals('value'));
      expect(route.metadata, equals('restored'));
    });

    test('converter round-trip preserves data', () {
      final converter = const ComplexRouteConverter();
      final original = ComplexRoute(
        id: '789',
        data: {
          'complex': {'nested': 'structure'},
        },
        metadata: 'preserve this',
      );

      final serialized = converter.serialize(original);
      final restored = converter.deserialize(serialized);

      expect(restored.id, equals(original.id));
      expect(restored.data, equals(original.data));
      expect(restored.metadata, equals(original.metadata));
    });
  });

  group('RouteRestorable - Properties', () {
    test('default strategy is unique', () {
      // Create a minimal implementation to test default
      final route = UniqueRestorableRoute('123');

      expect(route.restorationStrategy, equals(RestorationStrategy.unique));
    });

    test('converter throws UnimplementedError for unique strategy', () {
      final route = UniqueRestorableRoute('123');

      expect(() => route.converter, throwsUnimplementedError);
    });

    test('restorationId is required', () {
      final route = ComplexRoute(id: '123', data: {});

      expect(route.restorationId, isNotNull);
      expect(route.restorationId, equals('complex_123'));
    });

    test('restorationId should be stable', () {
      final route1 = ComplexRoute(id: '123', data: {});
      final route2 = ComplexRoute(id: '123', data: {});

      expect(route1.restorationId, equals(route2.restorationId));
    });

    test('restorationId should be unique per instance', () {
      final route1 = ComplexRoute(id: '123', data: {});
      final route2 = ComplexRoute(id: '456', data: {});

      expect(route1.restorationId, isNot(equals(route2.restorationId)));
    });
  });
}



================================================
FILE: packages/zenrouter/test/mixin/transition_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'mixin_test_utils.dart';

void main() {
  group('RouteTransition Mixin Tests', () {
    testWidgets('Material transition route renders correctly', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(MaterialTransitionRoute());
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('material-transition')), findsOneWidget);
      expect(find.text('Material Page'), findsOneWidget);
    });

    testWidgets('Cupertino transition route renders correctly', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(CupertinoTransitionRoute());
      await tester.pumpAndSettle();

      expect(
        find.byKey(const ValueKey('cupertino-transition')),
        findsOneWidget,
      );
      expect(find.text('Cupertino Page'), findsOneWidget);
    });

    testWidgets('Dialog transition route renders as dialog', (tester) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(DialogTransitionRoute());
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('dialog-transition')), findsOneWidget);
      expect(find.text('Dialog Content'), findsOneWidget);
      expect(find.byType(AlertDialog), findsOneWidget);
    });

    testWidgets('Sheet transition route renders as bottom sheet', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(SheetTransitionRoute());
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('sheet-transition')), findsOneWidget);
      expect(find.text('Sheet Content'), findsOneWidget);
    });

    testWidgets('Dialog transition can be closed and returns to previous', (
      tester,
    ) async {
      final coordinator = MixinTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      // Should start with home
      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);

      coordinator.push(DialogTransitionRoute());
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('dialog-transition')), findsOneWidget);

      // Close the dialog
      await tester.tap(find.byKey(const ValueKey('dialog-close')));
      await tester.pumpAndSettle();

      // Should be back to home
      expect(find.byKey(const ValueKey('simple-home')), findsOneWidget);
    });
  });
}



================================================
FILE: packages/zenrouter/test/path/indexed_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Routes
// ============================================================================

abstract class IndexedTestRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

class SimpleIndexedRoute extends IndexedTestRoute {
  SimpleIndexedRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Simple: $id');
  }

  @override
  List<Object?> get props => [id];
}

class RedirectNullRoute extends IndexedTestRoute
    with RouteRedirect<IndexedTestRoute> {
  @override
  Type? get layout => IndexedStackLayout;

  @override
  Uri toUri() => Uri.parse('/redirect');

  @override
  IndexedTestRoute? redirectWith(Coordinator coordinator) => null;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [];
}

class GuardedIndexedRoute extends IndexedTestRoute with RouteGuard {
  GuardedIndexedRoute({this.allowPop = false});
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guarded');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Guarded: $allowPop');
  }

  @override
  List<Object?> get props => [allowPop];
}

class RedirectIndexedRoute extends IndexedTestRoute
    with RouteRedirect<IndexedTestRoute> {
  RedirectIndexedRoute({required this.target});
  final IndexedTestRoute target;

  @override
  Uri toUri() => Uri.parse('/redirect');

  @override
  FutureOr<IndexedTestRoute> redirect() => target;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [target];
}

class NullRedirectIndexedRoute extends IndexedTestRoute
    with RouteRedirect<IndexedTestRoute> {
  NullRedirectIndexedRoute({required this.target});
  final IndexedTestRoute target;

  @override
  Uri toUri() => Uri.parse('/redirect');

  @override
  FutureOr<IndexedTestRoute> redirect() => target;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [target];
}

class IndexedStackLayout extends IndexedTestRoute
    with RouteLayout<IndexedTestRoute> {
  @override
  StackPath<RouteUnique> resolvePath(
    covariant IndexedTestCoordinator coordinator,
  ) => coordinator.indexed;
}

class CoordinatorFirstTab extends IndexedTestRoute {
  @override
  Type? get layout => IndexedStackLayout;

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) => const Text('First Tab', key: ValueKey('first-tab'));

  @override
  Uri toUri() => Uri.parse('/first-tab');
}

class CoordinatorSecondTab extends IndexedTestRoute
    with RouteRedirect<IndexedTestRoute> {
  @override
  Type? get layout => IndexedStackLayout;

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) => const Text('Second Tab', key: ValueKey('second-tab'));

  @override
  Uri toUri() => Uri.parse('/second-tab');

  @override
  IndexedTestRoute? redirectWith(Coordinator<RouteUnique> coordinator) {
    return null;
  }
}

class CoordinatorThirdTab extends IndexedTestRoute
    with RouteRedirect<IndexedTestRoute> {
  @override
  Type? get layout => IndexedStackLayout;

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) => const Text('Third Tab', key: ValueKey('third-tab'));

  @override
  Uri toUri() => Uri.parse('/third-tab');

  @override
  IndexedTestRoute redirect() => HomeRoute();
}

class HomeRoute extends IndexedTestRoute with RouteDeepLink {
  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) => Text('Home', key: ValueKey('home'));

  @override
  Uri toUri() => Uri.parse('/home');

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  FutureOr<void> deeplinkHandler(IndexedTestCoordinator coordinator, Uri uri) {
    coordinator.navigate(this);
  }
}

class IndexedTestCoordinator extends Coordinator<IndexedTestRoute> {
  late final indexed = IndexedStackPath<IndexedTestRoute>.create(
    [
      CoordinatorFirstTab(),
      CoordinatorSecondTab(),
      CoordinatorThirdTab(),
      RedirectNullRoute(),
    ],
    coordinator: this,
    label: 'indexed',
  );

  @override
  List<StackPath<RouteTarget>> get paths => [...super.paths, indexed];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(IndexedStackLayout, IndexedStackLayout.new);
  }

  @override
  FutureOr<IndexedTestRoute> parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      ['first-tab'] => CoordinatorFirstTab(),
      ['second-tab'] => CoordinatorSecondTab(),
      ['third-tab'] => CoordinatorThirdTab(),
      _ => HomeRoute(),
    };
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('IndexedStackPath Tests', () {
    test('Initialization with routes', () {
      final routes = [SimpleIndexedRoute('1'), SimpleIndexedRoute('2')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      expect(path.activeIndex, 0);
      expect(path.activeRoute, routes[0]);
    });

    test('goToIndexed switches index', () async {
      final routes = [SimpleIndexedRoute('1'), SimpleIndexedRoute('2')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      await path.goToIndexed(1);

      expect(path.activeIndex, 1);
      expect(path.activeRoute, routes[1]);
    });

    test('activateRoute switches index', () async {
      final routes = [SimpleIndexedRoute('1'), SimpleIndexedRoute('2')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      await path.activateRoute(routes[1]);

      expect(path.activeIndex, 1);
      expect(path.activeRoute, routes[1]);
    });

    test('Guard prevents index change', () async {
      final guardedRoute = GuardedIndexedRoute(allowPop: false);
      final routes = [guardedRoute, SimpleIndexedRoute('2')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      // Verify we are on guarded route
      expect(path.activeIndex, 0);

      // Try to switch index
      await path.goToIndexed(1);

      // Should still be on index 0
      expect(path.activeIndex, 0);
      expect(path.activeRoute, guardedRoute);
    });

    test('Guard allows index change', () async {
      final guardedRoute = GuardedIndexedRoute(allowPop: true);
      final routes = [guardedRoute, SimpleIndexedRoute('2')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      // Try to switch index
      await path.goToIndexed(1);

      // Should switch to index 1
      expect(path.activeIndex, 1);
    });

    test('Redirect works within stack', () async {
      final target = SimpleIndexedRoute('Target');
      final redirectRoute = RedirectIndexedRoute(target: target);

      final routes = [SimpleIndexedRoute('Start'), redirectRoute, target];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      // Switch to redirect route (index 1)
      await path.goToIndexed(1);

      // Should redirect resolved target (index 2)
      expect(path.activeIndex, 2);
      expect(path.activeRoute, target);
    });

    test('Error on invalid index', () {
      final routes = [SimpleIndexedRoute('1')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      expect(() => path.goToIndexed(99), throwsA(isA<StateError>()));
    });

    test('Error on activateRoute with untracked route', () {
      final routes = [SimpleIndexedRoute('1')];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      expect(
        () async => await path.activateRoute(SimpleIndexedRoute('2')),
        throwsA(isA<StateError>()),
      );
    });

    testWidgets('Coordinator will do nothing when redirect return null', (
      tester,
    ) async {
      final coordinator = IndexedTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(CoordinatorFirstTab());
      await tester.pumpAndSettle();

      expect(find.byKey(const ValueKey('first-tab')), findsOneWidget);

      coordinator.push(CoordinatorSecondTab());
      await tester.pumpAndSettle();

      // Do nothing
      expect(find.byKey(const ValueKey('first-tab')), findsOneWidget);
    });

    testWidgets(
      'Coordinator will switch to resolved route when redirect to outside stack route',
      (tester) async {
        final coordinator = IndexedTestCoordinator();

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );
        await tester.pumpAndSettle();

        coordinator.push(CoordinatorFirstTab());
        await tester.pumpAndSettle();

        expect(find.byKey(const ValueKey('first-tab')), findsOneWidget);

        coordinator.indexed.goToIndexed(2);
        await tester.pumpAndSettle();

        // Do nothing
        expect(find.byKey(const ValueKey('first-tab')), findsOneWidget);
      },
    );

    test('navigate to non-existent route does not throw error', () async {
      final route1 = SimpleIndexedRoute('1');
      final route2 = SimpleIndexedRoute('2');
      final routes = [route1, route2];
      final path = IndexedStackPath<IndexedTestRoute>.create(routes);

      // Set initial state to route1 (index 0)
      expect(path.activeIndex, 0);
      expect(path.activeRoute, route1);

      // Try to navigate to a route that doesn't exist in the stack
      final nonExistentRoute = SimpleIndexedRoute('999');

      // This should not throw an error
      await path.navigate(nonExistentRoute);

      // Should remain on the original route
      expect(path.activeIndex, 0);
      expect(path.activeRoute, route1);
    });

    test('do nothing when redirectWith return null', () async {
      final path = IndexedStackPath<IndexedTestRoute>.createWith(
        [SimpleIndexedRoute('tab1'), RedirectNullRoute()],
        coordinator: IndexedTestCoordinator(),
        label: 'test-navigation',
      );

      path.navigate(RedirectNullRoute());
      await Future.delayed(Duration.zero);

      expect(path.activeIndex, 0);
    });

    test('coordinator do nothing when redirectWith return null', () async {
      final coordinator = IndexedTestCoordinator();

      coordinator.navigate(RedirectNullRoute());
      await Future.delayed(Duration.zero);
      coordinator.recover(RedirectNullRoute());
      await Future.delayed(Duration.zero);
      coordinator.push(RedirectNullRoute());
      await Future.delayed(Duration.zero);
      coordinator.pushOrMoveToTop(RedirectNullRoute());
      await Future.delayed(Duration.zero);
      coordinator.replace(RedirectNullRoute());
      await Future.delayed(Duration.zero);

      expect(coordinator.indexed.activeIndex, 0);
    });
  });
}



================================================
FILE: packages/zenrouter/test/path/mutatable_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Routes
// ============================================================================

abstract class MutatablePathRoute extends RouteTarget {
  Widget build();
}

class SimplePathRoute extends MutatablePathRoute {
  SimplePathRoute(this.id);

  final String id;

  @override
  List<Object?> get props => [id];

  @override
  Widget build() => Text('Simple route: $id');
}

class RedirectPathRoute extends MutatablePathRoute
    with RouteRedirect<MutatablePathRoute> {
  RedirectPathRoute(this.target);

  final MutatablePathRoute target;

  @override
  FutureOr<MutatablePathRoute> redirect() => target;

  @override
  Widget build() => SizedBox();
}

class GuardedPathRoute extends MutatablePathRoute with RouteGuard {
  GuardedPathRoute(this.poppable);

  final bool poppable;

  @override
  List<Object?> get props => [poppable];

  @override
  Widget build() => Text('Guarded route: $poppable');

  @override
  FutureOr<bool> popGuard() => poppable;
}

abstract class MutatableTestRoute extends RouteTarget with RouteUnique {}

/// Simple route for basic testing
class SimpleRoute extends MutatableTestRoute {
  SimpleRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Simple: $id');
  }

  @override
  List<Object?> get props => [id];
}

class RedirectNullRoute extends MutatableTestRoute
    with RouteRedirect<MutatableTestRoute> {
  RedirectNullRoute();

  @override
  Uri toUri() => Uri.parse('/redirect-null');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('RedirectNull');
  }

  @override
  FutureOr<MutatableTestRoute?> redirectWith(
    covariant Coordinator<RouteUnique> coordinator,
  ) => null;
}

/// Route with query parameters for testing parameter updates
class QueryRoute extends MutatableTestRoute with RouteQueryParameters {
  QueryRoute(this.id, [Map<String, String>? queries]) {
    if (queries != null) this.queries = queries;
  }
  final String id;

  @override
  final ValueNotifier<Map<String, String>> queryNotifier = ValueNotifier({});

  @override
  Uri toUri() => Uri.parse('/query/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Query: $id');
  }

  @override
  List<Object?> get props => [id];
}

/// Route with guard for testing pop protection
class GuardedRoute extends MutatableTestRoute with RouteGuard {
  GuardedRoute(this.id, {this.allowPop = false});
  final String id;
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guarded/$id');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Guarded: $id');
  }

  @override
  List<Object?> get props => [id, allowPop];
}

/// Route with coordinator-aware guard
class CoordinatorGuardedRoute extends MutatableTestRoute with RouteGuard {
  CoordinatorGuardedRoute(this.id, {this.allowPop = false});
  final String id;
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/coord-guarded/$id');

  @override
  Future<bool> popGuardWith(Coordinator coordinator) async {
    // Verify coordinator is passed correctly
    expect(coordinator, isNotNull);
    return allowPop;
  }

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('CoordGuarded: $id');
  }

  @override
  List<Object?> get props => [id, allowPop];
}

/// Route that redirects to another route
class RedirectRoute extends MutatableTestRoute
    with RouteRedirect<MutatableTestRoute> {
  RedirectRoute(this.id, this.target);
  final String id;
  final MutatableTestRoute target;

  @override
  Uri toUri() => Uri.parse('/redirect/$id');

  @override
  MutatableTestRoute redirect() => target;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [id, target];
}

/// Route that redirects asynchronously
class AsyncRedirectRoute extends MutatableTestRoute
    with RouteRedirect<MutatableTestRoute> {
  AsyncRedirectRoute(this.id, this.target, {this.delay = 10});
  final String id;
  final MutatableTestRoute target;
  final int delay;

  @override
  Uri toUri() => Uri.parse('/async-redirect/$id');

  @override
  Future<MutatableTestRoute> redirect() async {
    await Future.delayed(Duration(milliseconds: delay));
    return target;
  }

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [id, target, delay];
}

/// Custom test coordinator
class MutatableTestCoordinator extends Coordinator<MutatableTestRoute> {
  late final navigation = NavigationPath<MutatableTestRoute>.create(
    coordinator: this,
    label: 'test-navigation',
  );

  @override
  List<StackPath<RouteTarget>> get paths => [...super.paths, navigation];

  @override
  FutureOr<MutatableTestRoute> parseRouteFromUri(Uri uri) {
    return SimpleRoute('fallback');
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('StackMutatable - push()', () {
    test('do nothing when redirectWith return null', () {
      final path = NavigationPath<MutatableTestRoute>.createWith(
        coordinator: MutatableTestCoordinator(),
        label: 'test-navigation',
      );

      path.push(RedirectNullRoute());

      expect(path.stack.isEmpty, true);
    });

    test('pushes a simple route to empty stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack.first, route);
      expect(route.stackPath, path);
      expect(route.isPopByPath, false);
    });

    test('pushes multiple routes to stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 3);
      expect(path.stack[0], route1);
      expect(path.stack[1], route2);
      expect(path.stack[2], route3);
    });

    test('follows redirect when pushing redirect route', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final target = SimpleRoute('target');
      final redirect = RedirectRoute('redirect', target);

      path.push(redirect);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack.first, target);
      expect(path.stack.first, isNot(redirect));
    });

    test('handles async redirect', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final target = SimpleRoute('target');
      final redirect = AsyncRedirectRoute('redirect', target, delay: 50);

      path.push(redirect);
      await Future.delayed(Duration(milliseconds: 100));

      expect(path.stack.length, 1);
      expect(path.stack.first, target);
    });

    test('binds stack path to route', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);
      await Future.delayed(Duration.zero);

      expect(route.stackPath, path);
    });

    test('sets isPopByPath to false', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);

      expect(route.isPopByPath, false);
    });

    test('notifies listeners when route is pushed', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      var notified = false;
      path.addListener(() => notified = true);

      path.push(route);
      await Future.delayed(Duration.zero);

      expect(notified, true);
    });

    test('works with coordinator', () async {
      final coordinator = MutatableTestCoordinator();
      final route = SimpleRoute('1');

      coordinator.push(route);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack.first, route);
    });
  });

  group('StackMutatable - pushReplacement()', () {
    testWidgets('pushes to empty stack', (tester) async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<MutatableTestRoute>(
            path: path,
            resolver: (route) => StackTransition.cupertino(
              Builder(
                builder: (context) =>
                    route.build(MutatableTestCoordinator(), context),
              ),
            ),
          ),
        ),
      );

      // pushReplacement on empty stack should just push
      final future = path.pushReplacement(route);
      await tester.pumpAndSettle();

      expect(path.stack.length, 1);
      expect(path.stack.first, route);
      expect(route.stackPath, path);

      // Complete the route to avoid hanging future
      route.completeOnResult(null, null);
      await future;
    });

    testWidgets('replaces single element stack and completes result', (
      tester,
    ) async {
      final path = NavigationPath<MutatablePathRoute>.create();
      final route1 = SimplePathRoute('1');
      final route2 = SimplePathRoute('2');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<MutatablePathRoute>(
            path: path,
            resolver: (route) => StackTransition.none(route.build()),
          ),
        ),
      );

      // Push first route and capture its result
      final route1Result = path.push(route1);
      await tester.pumpAndSettle();

      expect(path.stack.length, 1);
      expect(path.stack.first, route1);

      // Push replacement with result
      path.pushReplacement<String, String>(route2, result: 'replaced');
      await tester.pumpAndSettle();

      // Stack should now have only route2
      expect(path.stack.length, 1);
      expect(path.stack.first, route2);

      // route1 should have received the result
      expect(await route1Result, 'replaced');
      expect(route1.onResult.isCompleted, true);
    });

    testWidgets(
      'replaces top route when stack has multiple elements and completes result',
      (tester) async {
        final path = NavigationPath<MutatablePathRoute>.create();
        final route1 = SimplePathRoute('1');
        final route2 = SimplePathRoute('2');
        final route3 = SimplePathRoute('3');

        await tester.pumpWidget(
          MaterialApp(
            home: NavigationStack<MutatablePathRoute>(
              path: path,
              resolver: (route) => StackTransition.none(route.build()),
            ),
          ),
        );

        // Push routes
        path.push(route1);
        await tester.pumpAndSettle();
        final route2Result = path.push(route2);
        await tester.pumpAndSettle();

        expect(path.stack.length, 2);

        // Push replacement - should pop route2 and push route3
        path.pushReplacement<String, String>(route3, result: 'popped');
        await tester.pumpAndSettle();

        // Stack should have route1 and route3
        expect(path.stack.length, 2);
        expect(path.stack[0], route1);
        expect(path.stack[1], route3);

        // route2 should have received the result
        expect(await route2Result, 'popped');
        expect(route2.onResult.isCompleted, true);
      },
    );

    testWidgets('handles redirect and replaces correctly', (tester) async {
      final path = NavigationPath<MutatablePathRoute>.create();
      final route1 = SimplePathRoute('1');
      final target = SimplePathRoute('target');
      final redirect = RedirectPathRoute(target);

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<MutatablePathRoute>(
            path: path,
            resolver: (route) => StackTransition.none(route.build()),
          ),
        ),
      );

      // Push first route
      final route1Result = path.push(route1);
      await tester.pumpAndSettle();

      // Push replacement with redirect - should redirect to target
      path.pushReplacement(redirect);
      await tester.pumpAndSettle();

      // Stack should have only the target (not the redirect)
      expect(path.stack.length, 1);
      expect(path.stack.first, target);
      expect(path.stack.first, isNot(redirect));
      expect(await route1Result, null);
    });

    testWidgets('respects guard that blocks pop during replacement', (
      tester,
    ) async {
      final path = NavigationPath<MutatablePathRoute>.create();
      final route1 = SimplePathRoute('1');
      final guardedRoute = GuardedPathRoute(false);
      final route3 = SimplePathRoute('3');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<MutatablePathRoute>(
            path: path,
            resolver: (route) => StackTransition.none(route.build()),
          ),
        ),
      );

      // Push routes
      path.push(route1);
      await tester.pumpAndSettle();
      path.push(guardedRoute);
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);

      // Push replacement - should be blocked by guard
      final result = await path.pushReplacement(route3);
      await tester.pumpAndSettle();

      // Guard blocked pop, so replacement should fail
      expect(result, isNull);
      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], guardedRoute);
    });

    testWidgets('respects guard that allows pop during replacement', (
      tester,
    ) async {
      final path = NavigationPath<MutatablePathRoute>.create();
      final route1 = SimplePathRoute('1');
      final guardedRoute = GuardedPathRoute(true);
      final route3 = SimplePathRoute('3');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<MutatablePathRoute>(
            path: path,
            resolver: (route) => StackTransition.none(route.build()),
          ),
        ),
      );

      // Push routes
      path.push(route1);
      await tester.pumpAndSettle();
      final guardedRouteResult = path.push(guardedRoute);
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);

      // Push replacement - guard should allow pop
      path.pushReplacement(route3, result: 'popped');
      await tester.pumpAndSettle();

      // Guard allowed, replacement should succeed
      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], route3);
      expect(await guardedRouteResult, 'popped');
    });
  });

  group('StackMutatable - pushOrMoveToTop()', () {
    test('do nothing when redirectWith return null', () {
      final path = NavigationPath<MutatableTestRoute>.createWith(
        coordinator: MutatableTestCoordinator(),
        label: 'test-navigation',
      );

      path.pushOrMoveToTop(RedirectNullRoute());

      expect(path.stack.isEmpty, true);
    });

    test('pushes new route to top when not in stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      await path.pushOrMoveToTop(route2);

      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], route2);
    });

    test('moves existing route to top', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);

      await path.pushOrMoveToTop(route1);

      expect(path.stack.length, 3);
      expect(path.stack[0], route2);
      expect(path.stack[1], route3);
      expect(path.stack[2], route1);
    });

    test('does nothing when route is already at top', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      var notifyCount = 0;
      path.addListener(() => notifyCount++);

      await path.pushOrMoveToTop(route2);
      await Future.delayed(Duration.zero);

      // Should not notify because no change occurred
      expect(notifyCount, 0);
      expect(path.stack.length, 2);
      expect(path.stack.last, route2);
    });

    test('updates queries when same route is already at top', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = QueryRoute('1', {'key': 'value1'});

      path.push(route);
      await Future.delayed(Duration.zero);

      final updatedRoute = QueryRoute('1', {'key': 'value2', 'new': 'param'});
      await path.pushOrMoveToTop(updatedRoute);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(route.queries['key'], 'value2');
      expect(route.queries['new'], 'param');
    });

    test('discards incoming route when already at top', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);

      // Create a new instance that equals the existing route
      final duplicateRoute = SimpleRoute('1');

      // We can't directly override onDiscard, but we can verify behavior
      // by checking that the original route is still bound
      await path.pushOrMoveToTop(duplicateRoute);

      expect(route.stackPath, path);
      expect(duplicateRoute.stackPath, isNull);
    });

    test('clears stack path from removed route when moving to top', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      expect(route1.stackPath, path);

      // Move route1 to top - a new instance should be created
      // The old instance should have its stack path cleared
      await path.pushOrMoveToTop(route1);
      await Future.delayed(Duration.zero);

      // After moving, route1 should still be bound
      expect(route1.stackPath, path);
    });

    test('follows redirect', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final target = SimpleRoute('target');
      final redirect = RedirectRoute('redirect', target);

      await path.pushOrMoveToTop(redirect);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack.first, target);
    });

    test('notifies listeners when route is moved', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);

      var notified = false;
      path.addListener(() => notified = true);

      await path.pushOrMoveToTop(route1);

      expect(notified, true);
    });

    test('notifies listeners when new route is pushed', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      var notified = false;
      path.addListener(() => notified = true);

      await path.pushOrMoveToTop(route);

      expect(notified, true);
    });

    test('handles empty stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      await path.pushOrMoveToTop(route);

      expect(path.stack.length, 1);
      expect(path.stack.first, route);
    });
  });

  group('StackMutatable - pop()', () {
    test('pops the last route from stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      final result = await path.pop('result');

      expect(result, true);
      expect(path.stack.length, 1);
      expect(path.stack.first, route1);
      expect(route2.resultValue, 'result');
    });

    test('returns null when stack is empty', () async {
      final path = NavigationPath<MutatableTestRoute>.create();

      final result = await path.pop();

      expect(result, null);
      expect(path.stack.length, 0);
    });

    test('sets isPopByPath to true on popped route', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);
      await Future.delayed(Duration.zero);
      await path.pop();

      expect(route.isPopByPath, true);
    });

    test('respects guard that blocks pop', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: false);

      path.push(route1);
      path.push(guardedRoute);
      await Future.delayed(Duration.zero);

      final result = await path.pop();

      expect(result, false);
      expect(path.stack.length, 2);
      expect(path.stack.last, guardedRoute);
    });

    test('respects guard that allows pop', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: true);

      path.push(route1);
      path.push(guardedRoute);
      await Future.delayed(Duration.zero);

      final result = await path.pop();

      expect(result, true);
      expect(path.stack.length, 1);
      expect(path.stack.first, route1);
    });

    test('calls popGuard when no coordinator', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final guardedRoute = GuardedRoute('1', allowPop: false);

      path.push(guardedRoute);
      await Future.delayed(Duration.zero);

      final result = await path.pop();

      expect(result, false);
    });

    test('calls popGuardWith when coordinator exists', () async {
      final coordinator = MutatableTestCoordinator();
      final guardedRoute = CoordinatorGuardedRoute('1', allowPop: true);

      coordinator.push(guardedRoute);
      await Future.delayed(Duration.zero);

      final result = await coordinator.tryPop();

      /// Cannot pop since the route stack is has only one element
      expect(result, false);
    });

    test('notifies listeners after successful pop', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);

      var notified = false;
      path.addListener(() => notified = true);

      await path.pop();

      expect(notified, true);
    });

    test('does not notify listeners when guard blocks pop', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final guardedRoute = GuardedRoute('1', allowPop: false);

      path.push(SimpleRoute('2'));
      path.push(guardedRoute);
      await Future.delayed(Duration.zero);

      var notified = false;
      path.addListener(() => notified = true);

      await path.pop();

      expect(notified, false);
    });

    test('pops all routes sequentially', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      path.push(SimpleRoute('1'));
      path.push(SimpleRoute('2'));
      path.push(SimpleRoute('3'));
      await Future.delayed(Duration.zero);

      expect(await path.pop(), true);
      expect(path.stack.length, 2);

      expect(await path.pop(), true);
      expect(path.stack.length, 1);

      expect(await path.pop(), true);
      expect(path.stack.length, 0);

      expect(await path.pop(), null);
    });
  });

  group('StackMutatable - remove()', () {
    test('removes route from stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      await Future.delayed(Duration.zero);

      path.remove(route2);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(route2.onResult.isCompleted, isTrue);
      expect(path.stack[0], route1);
      expect(path.stack[1], route3);
    });

    test('removes last route from stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      path.remove(route2);

      expect(path.stack.length, 1);
      expect(path.stack.first, route1);
    });

    test('removes first route from stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      path.remove(route1);

      expect(path.stack.length, 1);
      expect(path.stack.first, route2);
    });

    test('bypasses guard', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final guardedRoute = GuardedRoute('1', allowPop: false);

      path.push(guardedRoute);

      path.remove(guardedRoute);

      expect(path.stack.length, 0);
    });

    test('clears stack path from removed route', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);
      await Future.delayed(Duration.zero);

      expect(route.stackPath, path);

      path.remove(route);

      expect(route.stackPath, null);
    });

    test('notifies listeners when route is removed', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.push(route);
      await Future.delayed(Duration.zero);

      var notified = false;
      path.addListener(() => notified = true);

      path.remove(route);

      expect(notified, true);
    });

    test('does not notify listeners when route not in stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      await Future.delayed(Duration.zero);

      var notified = false;
      path.addListener(() => notified = true);

      path.remove(route2);

      expect(notified, false);
    });

    test('handles removing from empty stack gracefully', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      // Should not throw
      path.remove(route);

      expect(path.stack.length, 0);
    });

    test('removes multiple routes', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      await Future.delayed(Duration.zero);

      path.remove(route1);
      path.remove(route3);

      expect(path.stack.length, 1);
      expect(path.stack.first, route2);
    });
  });

  group('StackMutatable - navigate()', () {
    test('do nothing when redirectWith return null', () {
      final path = NavigationPath<MutatableTestRoute>.createWith(
        coordinator: MutatableTestCoordinator(),
        label: 'test-navigation',
      );

      path.navigate(RedirectNullRoute());

      expect(path.stack.isEmpty, true);
    });

    test('pushes new route when not in stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], route2);
    });

    test('pops to existing route in stack', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      path.navigate(route1);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack.first, route1);
    });

    test('pops multiple routes to reach target', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');
      final route4 = SimpleRoute('4');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      path.push(route4);
      path.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], route2);
    });

    test('updates query parameters when navigating to same route', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = QueryRoute('1', {'key': 'value1'});
      final route2 = QueryRoute('2');

      path.push(route1);
      path.push(route2);

      final updatedRoute1 = QueryRoute('1', {'key': 'value2', 'new': 'param'});
      await path.navigate(updatedRoute1);

      expect(path.stack.length, 1);
      expect(route1.queries['key'], 'value2');
      expect(route1.queries['new'], 'param');
    });

    test('stops popping when guard blocks', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: false);
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(guardedRoute);
      path.push(route3);

      await path.navigate(route1);

      // Should stop at guarded route due to guard blocking
      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], guardedRoute);
    });

    test('notifies listeners after navigation', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      await Future.delayed(Duration.zero);

      var notifyCount = 0;
      path.addListener(() => notifyCount++);

      path.navigate(route2);
      await Future.delayed(Duration.zero);

      // Should notify: once for push
      expect(notifyCount, greaterThan(0));
    });

    test('follows redirect before navigating', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final target = SimpleRoute('target');
      final redirect = RedirectRoute('redirect', target);

      path.navigate(redirect);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack.first, target);
    });

    test('discards incoming route when hash differs but equals', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');

      path.push(route1);

      // Create a route that equals route1
      final route1Copy = SimpleRoute('1');

      await path.navigate(route1Copy);

      // Should stay at route1
      expect(path.stack.length, 1);
      expect(path.stack.first, route1);
    });

    test('handles navigating to currently active route', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = QueryRoute('1', {'key': 'value1'});

      path.push(route1);

      final updatedRoute1 = QueryRoute('1', {'key': 'value2'});
      await path.navigate(updatedRoute1);

      expect(path.stack.length, 1);
      expect(route1.queries['key'], 'value2');
    });

    test('notifies listeners when guard blocks during navigate', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: false);

      path.push(route1);
      path.push(guardedRoute);

      var notified = false;
      path.addListener(() => notified = true);

      await path.navigate(route1);

      // Should still notify even when blocked
      expect(notified, true);
    });

    test('handles empty stack during navigate', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      path.navigate(route);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack.first, route);
    });
  });

  group('StackMutatable - Edge Cases', () {
    test('handles rapid push operations', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final futures = <Future>[];

      for (int i = 0; i < 10; i++) {
        futures.add(path.push(SimpleRoute('$i')));
      }

      await Future.delayed(Duration(milliseconds: 10));

      expect(path.stack.length, 10);
    });

    test('handles rapid pop operations', () async {
      final path = NavigationPath<MutatableTestRoute>.create();

      for (int i = 0; i < 5; i++) {
        path.push(SimpleRoute('$i'));
      }
      await Future.delayed(Duration.zero);

      for (int i = 0; i < 3; i++) {
        path.pop();
      }

      expect(path.stack.length, 2);
    });

    test('handles mixed push/pop/remove operations', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');
      final route4 = SimpleRoute('4');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);
      await path.pop();
      path.push(route3);
      await Future.delayed(Duration.zero);
      path.remove(route1);
      path.push(route4);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0], route3);
      expect(path.stack[1], route4);
    });

    test('handles pushOrMoveToTop with redirect', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final target = SimpleRoute('target');
      final redirect = RedirectRoute('redirect', target);

      path.push(SimpleRoute('1'));
      await path.pushOrMoveToTop(redirect);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack.last, target);
    });

    test('handles navigate with async redirect', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final target = SimpleRoute('target');
      final redirect = AsyncRedirectRoute('redirect', target, delay: 50);

      path.navigate(redirect);
      await Future.delayed(Duration(milliseconds: 100));

      expect(path.stack.length, 1);
      expect(path.stack.first, target);
    });

    test('handles removing route while pop is in progress', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: false);

      path.push(route1);
      path.push(guardedRoute);
      await Future.delayed(Duration.zero);

      // Start pop (will be blocked by guard)
      path.pop();

      // Remove the route instead
      path.remove(guardedRoute);

      await Future.delayed(Duration(milliseconds: 10));

      expect(path.stack.length, 1);
      expect(path.stack.first, route1);
    });

    test('handles concurrent navigate operations', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);

      // Concurrent navigate calls
      path.navigate(route1);
      await path.navigate(route2);

      // Last navigation should win
      expect(path.stack.length, 2);
      expect(path.stack.last, route2);
    });

    test('maintains stack integrity with query parameter updates', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route1 = QueryRoute('1', {'a': '1'});
      final route2 = QueryRoute('2', {'b': '2'});

      path.push(route1);
      path.push(route2);

      await path.navigate(QueryRoute('1', {'a': '1-updated', 'c': '3'}));

      expect(path.stack.length, 1);
      expect(route1.queries['a'], '1-updated');
      expect(route1.queries['c'], '3');
    });

    test('handles empty stack pop gracefully', () async {
      final path = NavigationPath<MutatableTestRoute>.create();

      final result = await path.pop();

      expect(result, null);
      expect(path.stack.length, 0);
    });

    test('handles multiple listeners on same path', () async {
      final path = NavigationPath<MutatableTestRoute>.create();
      final route = SimpleRoute('1');

      var listener1Called = 0;
      var listener2Called = 0;
      var listener3Called = 0;

      path.addListener(() => listener1Called++);
      path.addListener(() => listener2Called++);
      path.addListener(() => listener3Called++);

      path.push(route);
      await Future.delayed(Duration.zero);
      await path.pop();

      expect(listener1Called, 2);
      expect(listener2Called, 2);
      expect(listener3Called, 2);
    });

    test('handles large stack operations', () async {
      final path = NavigationPath<MutatableTestRoute>.create();

      // Push 100 routes
      for (int i = 0; i < 100; i++) {
        path.push(SimpleRoute('$i'));
      }
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 100);

      // Pop 50 routes
      for (int i = 0; i < 50; i++) {
        await path.pop();
      }

      expect(path.stack.length, 50);

      // Navigate to first route
      path.navigate(SimpleRoute('0'));
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect((path.stack.first as SimpleRoute).id, '0');
    });

    testWidgets('pushReplacement() should discard RouteQueryParameters', (
      tester,
    ) async {
      final route1 = QueryRoute('1', {'a': '1'});
      final route2 = QueryRoute('2', {'b': '2'});
      final coordinator = MutatableTestCoordinator();

      await tester.pumpWidget(
        MaterialApp.router(
          routerDelegate: coordinator.routerDelegate,
          routeInformationParser: coordinator.routeInformationParser,
        ),
      );
      await tester.pumpAndSettle();

      coordinator.push(route1);
      coordinator.push(route2);
      await tester.pumpAndSettle();

      coordinator.pushReplacement(QueryRoute('2', {'b': '3'}));
      await tester.pumpAndSettle();

      expect(coordinator.root.stack.length, 3);
      expect((coordinator.root.stack[1] as QueryRoute).queries['a'], '1');
      expect((coordinator.root.stack[2] as QueryRoute).queries['b'], '3');
      expect(() => route2.queryNotifier.addListener(() {}), throwsFlutterError);
    });
  });
}



================================================
FILE: packages/zenrouter/test/path/navigatable_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Routes
// ============================================================================

abstract class NavigatableTestRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

/// Simple route for basic testing
class SimpleRoute extends NavigatableTestRoute {
  SimpleRoute(this.id);
  final String id;

  @override
  Uri toUri() => Uri.parse('/simple/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Simple: $id');
  }

  @override
  List<Object?> get props => [id];
}

/// Route with query parameters for testing parameter updates
class QueryRoute extends NavigatableTestRoute with RouteQueryParameters {
  QueryRoute(this.id, [Map<String, String>? queries]) {
    if (queries != null) this.queries = queries;
  }
  final String id;

  @override
  final ValueNotifier<Map<String, String>> queryNotifier = ValueNotifier({});

  @override
  Uri toUri() => Uri.parse('/query/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Query: $id');
  }

  @override
  List<Object?> get props => [id];
}

/// Route with guard for testing pop protection
class GuardedRoute extends NavigatableTestRoute with RouteGuard {
  GuardedRoute(this.id, {this.allowPop = false});
  final String id;
  final bool allowPop;

  @override
  Uri toUri() => Uri.parse('/guarded/$id');

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Text('Guarded: $id');
  }

  @override
  List<Object?> get props => [id, allowPop];
}

/// Route that redirects to another route
class RedirectRoute extends NavigatableTestRoute
    with RouteRedirect<NavigatableTestRoute> {
  RedirectRoute(this.id, this.target);
  final String id;
  final NavigatableTestRoute target;

  @override
  Uri toUri() => Uri.parse('/redirect/$id');

  @override
  NavigatableTestRoute redirect() => target;

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return const SizedBox.shrink();
  }

  @override
  List<Object?> get props => [id, target];
}

// ============================================================================
// Custom StackPath WITHOUT StackNavigatable
// ============================================================================

/// A custom stack path that does NOT implement StackNavigatable
/// to test the debug warning fallback in Coordinator.navigate()
class BasicStackPath<T extends RouteTarget> extends StackPath<T> {
  BasicStackPath({super.debugLabel, super.coordinator}) : super([]);

  @override
  T? get activeRoute => stack.isEmpty ? null : stack.last;

  void addRoute(T route) {
    final currentStack = List<T>.from(stack);
    currentStack.add(route);
    bindStack(currentStack);
    notifyListeners();
  }

  @override
  Future<void> activateRoute(T route) async {
    // Just add it for simplicity
    if (!stack.contains(route)) {
      addRoute(route);
    }
  }

  @override
  void reset() {
    clear();
    notifyListeners();
  }

  @override
  PathKey get pathKey => const PathKey('BasicStackPath');
}

class BasicLayout extends NavigatableTestRoute
    with RouteLayout<NavigatableTestRoute> {
  @override
  StackPath<RouteUnique> resolvePath(
    covariant BasicPathCoordinator coordinator,
  ) => coordinator.basic;

  @override
  Widget buildPath(BasicPathCoordinator coordinator) => Builder(
    builder: (context) => Stack(
      children: [
        for (final route in coordinator.basic.stack)
          route.build(coordinator, context),
      ],
    ),
  );
}

class BasicRouteId extends NavigatableTestRoute {
  BasicRouteId(this.id);

  final String id;

  @override
  Type get layout => BasicLayout;

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    return Text('BasicRouteId: $id');
  }

  @override
  Uri toUri() => Uri.parse('/basic/$id');
}

// ============================================================================
// Test Coordinators
// ============================================================================

/// Coordinator with NavigationPath
class NavigationTestCoordinator extends Coordinator<NavigatableTestRoute> {
  @override
  FutureOr<NavigatableTestRoute> parseRouteFromUri(Uri uri) {
    return SimpleRoute('fallback');
  }
}

/// Coordinator with IndexedStackPath
class IndexedTestCoordinator extends Coordinator<NavigatableTestRoute> {
  late final IndexedStackPath<NavigatableTestRoute> indexed =
      IndexedStackPath.createWith(
        [SimpleRoute('tab1'), SimpleRoute('tab2'), SimpleRoute('tab3')],
        coordinator: this,
        label: 'indexed',
      );

  @override
  List<StackPath<RouteTarget>> get paths => [...super.paths, indexed];

  @override
  FutureOr<NavigatableTestRoute> parseRouteFromUri(Uri uri) {
    return SimpleRoute('fallback');
  }
}

/// Coordinator with BasicStackPath (no StackNavigatable)
class BasicPathCoordinator extends Coordinator<NavigatableTestRoute> {
  late final BasicStackPath<NavigatableTestRoute> basic = BasicStackPath(
    coordinator: this,
    debugLabel: 'basic',
  );

  @override
  List<StackPath<RouteTarget>> get paths => [...super.paths, basic];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(BasicLayout, BasicLayout.new);
  }

  @override
  FutureOr<NavigatableTestRoute> parseRouteFromUri(Uri uri) {
    return SimpleRoute('fallback');
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('NavigationPath (StackMutatable) - navigate()', () {
    test('pushes new route when not in stack', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], route2);
    });

    test('pops to existing route when in stack', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      await Future.delayed(Duration.zero);

      path.navigate(route1);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(path.stack[0], route1);
    });

    test('pops multiple routes to reach target route', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');
      final route4 = SimpleRoute('4');

      path.push(route1);
      path.push(route2);
      path.push(route3);
      path.push(route4);
      await Future.delayed(Duration.zero);

      path.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], route2);
    });

    test('updates query parameters when navigating to same route', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = QueryRoute('1', {'key': 'value1'});
      final route2 = QueryRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      final updatedRoute1 = QueryRoute('1', {'key': 'value2', 'new': 'param'});
      path.navigate(updatedRoute1);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 1);
      expect(route1.queries['key'], 'value2');
      expect(route1.queries['new'], 'param');
    });

    test('stops navigating when guard blocks pop', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: false);
      final route3 = SimpleRoute('3');

      path.push(route1);
      path.push(guardedRoute);
      path.push(route3);

      path.navigate(route1);
      await Future.delayed(Duration.zero);

      // Should stop at guarded route because guard blocked further popping
      expect(path.stack.length, 2);
      expect(path.stack[0], route1);
      expect(path.stack[1], guardedRoute);
    });

    test('follows redirect when navigating', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final target = SimpleRoute('target');
      final redirect = RedirectRoute('redirect', target);

      path.push(route1);
      await Future.delayed(Duration.zero);

      path.navigate(redirect);
      await Future.delayed(Duration.zero);

      expect(path.stack.length, 2);
      expect(path.stack[1], target);
      expect(path.stack[1], isNot(redirect));
    });

    test('notifies listeners when route is pushed', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      await Future.delayed(Duration.zero);

      var notified = false;
      path.addListener(() => notified = true);

      path.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(notified, true);
    });

    test('notifies listeners when routes are popped', () async {
      final path = NavigationPath<NavigatableTestRoute>.create();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      path.push(route1);
      path.push(route2);
      await Future.delayed(Duration.zero);

      var notified = false;
      path.addListener(() => notified = true);

      path.navigate(route1);
      await Future.delayed(Duration.zero);

      expect(notified, true);
    });
  });

  group('IndexedStackPath - navigate()', () {
    test('switches to route when found in stack', () async {
      final route1 = SimpleRoute('tab1');
      final route2 = SimpleRoute('tab2');
      final route3 = SimpleRoute('tab3');

      final path = IndexedStackPath<NavigatableTestRoute>.create([
        route1,
        route2,
        route3,
      ]);

      expect(path.activeIndex, 0);

      path.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(path.activeIndex, 1);
      expect(path.activeRoute, route2);
    });

    test('switches to last route when navigating', () async {
      final route1 = SimpleRoute('tab1');
      final route2 = SimpleRoute('tab2');
      final route3 = SimpleRoute('tab3');

      final path = IndexedStackPath<NavigatableTestRoute>.create([
        route1,
        route2,
        route3,
      ]);

      path.navigate(route3);
      await Future.delayed(Duration.zero);

      expect(path.activeIndex, 2);
      expect(path.activeRoute, route3);
    });

    test('does nothing and notifies when route not found', () async {
      final route1 = SimpleRoute('tab1');
      final route2 = SimpleRoute('tab2');
      final routeNotInStack = SimpleRoute('not-in-stack');

      final path = IndexedStackPath<NavigatableTestRoute>.create([
        route1,
        route2,
      ]);

      var notified = false;
      path.addListener(() => notified = true);

      path.navigate(routeNotInStack);
      await Future.delayed(Duration.zero);

      // Should restore URL by calling notifyListeners
      expect(notified, true);
      // Active index should not change
      expect(path.activeIndex, 0);
      expect(path.activeRoute, route1);
    });

    test(
      'updates query parameters when navigating to already active route',
      () async {
        final route1 = QueryRoute('tab1', {'key': 'value1'});
        final route2 = QueryRoute('tab2', {'key': 'value1'});

        final path = IndexedStackPath<NavigatableTestRoute>.create([
          route1,
          route2,
        ]);

        // Navigate to route2 first
        path.navigate(route2);
        await Future.delayed(Duration.zero);

        expect(path.activeIndex, 1);

        // Navigate to same route with updated queries
        final updatedRoute2 = QueryRoute('tab2', {'key': 'value2'});
        path.navigate(updatedRoute2);
        await Future.delayed(Duration.zero);

        // Should update queries on the existing route
        expect(path.activeIndex, 1);
        expect(route2.queries['key'], 'value2');
      },
    );

    test('no change when navigating to already active route', () async {
      final route1 = SimpleRoute('tab1');
      final route2 = SimpleRoute('tab2');

      final path = IndexedStackPath<NavigatableTestRoute>.create([
        route1,
        route2,
      ]);

      var notifyCount = 0;
      path.addListener(() => notifyCount++);

      // Second call should not notify
      path.navigate(route1);
      await Future.delayed(Duration.zero);

      // activateRoute returns early when index matches
      expect(notifyCount, 0);
    });
  });

  group('Coordinator.navigate() - NavigationPath integration', () {
    test('delegates to NavigationPath.navigate() for new route', () async {
      final coordinator = NavigationTestCoordinator();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      coordinator.push(route1);
      coordinator.navigate(route2);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack[0], route1);
      expect(coordinator.root.stack[1], route2);
    });

    test('delegates to NavigationPath.navigate() to pop to existing', () async {
      final coordinator = NavigationTestCoordinator();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');
      final route3 = SimpleRoute('3');

      coordinator.push(route1);
      coordinator.push(route2);
      coordinator.push(route3);
      await Future.delayed(Duration.zero);

      coordinator.navigate(route1);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 1);
      expect(coordinator.root.stack[0], route1);
    });

    test('respects guards during navigation', () async {
      final coordinator = NavigationTestCoordinator();
      final route1 = SimpleRoute('1');
      final guardedRoute = GuardedRoute('2', allowPop: false);
      final route3 = SimpleRoute('3');

      coordinator.push(route1);
      coordinator.push(guardedRoute);
      coordinator.push(route3);
      await Future.delayed(Duration.zero);

      coordinator.navigate(route1);
      await Future.delayed(Duration.zero);

      // Guard should block, keeping all routes
      expect(coordinator.root.stack.length, 2);
    });
  });

  group('Coordinator.navigate() - IndexedStackPath integration', () {
    test('handles route not found in indexed stack', () async {
      final coordinator = IndexedTestCoordinator();
      final routeNotInStack = SimpleRoute('not-in-stack');

      var notifyCount = 0;
      coordinator.addListener(() => notifyCount++);

      coordinator.navigate(routeNotInStack);
      await Future.delayed(Duration.zero);

      // Should call notifyListeners to restore URL
      expect(notifyCount, greaterThan(0));
      // Active index should remain 0
      expect(coordinator.indexed.activeIndex, 0);
    });
  });

  group('Coordinator.navigate() - Non-StackNavigatable path', () {
    test('prints debug message when path lacks StackNavigatable', () async {
      final coordinator = BasicPathCoordinator();
      final route2 = BasicRouteId('2');

      // The navigate() call should trigger an assertion error because
      // BasicStackPath does not implement StackNavigatable
      expect(() async {
        await coordinator.navigate(route2);
      }, throwsA(isA<AssertionError>()));
    });

    test('does not throw error for non-navigatable path', () async {
      final coordinator = BasicPathCoordinator();
      final route = SimpleRoute('basic-route');

      coordinator.basic.addRoute(route);
      await Future.delayed(Duration.zero);

      // This should not throw
      expect(
        () => coordinator.navigate(SimpleRoute('basic-route')),
        returnsNormally,
      );
    });

    test('no navigation occurs on non-navigatable path', () async {
      final coordinator = BasicPathCoordinator();
      final route1 = SimpleRoute('1');
      final route2 = SimpleRoute('2');

      coordinator.basic.addRoute(route1);
      await Future.delayed(Duration.zero);

      final initialLength = coordinator.basic.stack.length;

      // Navigate should have no effect
      coordinator.navigate(route2);
      await Future.delayed(Duration.zero);

      // Stack should not change
      expect(coordinator.basic.stack.length, initialLength);
      expect(coordinator.basic.activeRoute, route1);
    });
  });

  group('Coordinator.navigate() - Redirects', () {
    test('follows redirects before navigating', () async {
      final coordinator = NavigationTestCoordinator();
      final route1 = SimpleRoute('1');
      final target = SimpleRoute('target');
      final redirect = RedirectRoute('redirect', target);

      coordinator.push(route1);
      await Future.delayed(Duration.zero);

      coordinator.navigate(redirect);
      await Future.delayed(Duration.zero);

      expect(coordinator.root.stack.length, 2);
      expect(coordinator.root.stack[1], target);
    });
  });
}



================================================
FILE: packages/zenrouter/test/path/restoration_test.dart
================================================
// ignore_for_file: invalid_use_of_protected_member

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Definitions
// ============================================================================

abstract class BaseTestRoute extends RouteTarget {
  // Inherits abstract build from RouteUnique:
  // Widget build(covariant Coordinator coordinator, BuildContext context);

  Widget buildWidget(BuildContext context);
}

class TestRoute extends BaseTestRoute with RouteUnique {
  TestRoute(this.path);
  final String path;

  @override
  Uri toUri() => Uri.parse(path);

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Route: $path', key: ValueKey(path)));
  }

  @override
  Widget buildWidget(BuildContext context) =>
      build(DummyCoordinator(), context);

  @override
  List<Object?> get props => [path];
}

class RestorableTestRoute extends BaseTestRoute
    with RouteUnique, RouteRestorable<RestorableTestRoute> {
  RestorableTestRoute(this.id, {this.data});
  final String id;
  final String? data;

  @override
  String get restorationId => id;

  @override
  RestorationStrategy get restorationStrategy => RestorationStrategy.converter;

  @override
  RestorableConverter<RestorableTestRoute> get converter =>
      const TestRouteConverter();

  @override
  Uri toUri() => Uri.parse('/restorable/$id');

  @override
  Widget build(covariant Coordinator coordinator, BuildContext context) {
    return Scaffold(body: Text('Restorable: $id', key: ValueKey(id)));
  }

  @override
  Widget buildWidget(BuildContext context) =>
      build(DummyCoordinator(), context);

  @override
  List<Object?> get props => [id, data];
}

class TestRouteConverter extends RestorableConverter<RestorableTestRoute> {
  const TestRouteConverter();

  @override
  String get key => 'test_path_converter';

  @override
  RestorableTestRoute deserialize(Map<String, dynamic> data) {
    return RestorableTestRoute(
      data['id'] as String,
      data: data['data'] as String?,
    );
  }

  @override
  Map<String, dynamic> serialize(RestorableTestRoute route) {
    return {'id': route.id, 'data': route.data};
  }
}

class UnimplementedRoute extends BaseTestRoute {
  @override
  Widget buildWidget(BuildContext context) {
    return SizedBox();
  }
}

class DummyCoordinator extends Coordinator<RouteUnique> {
  @override
  void defineConverter() {}

  @override
  void defineLayout() {}

  @override
  RouteUnique parseRouteFromUri(Uri uri) => TestRoute(uri.path);

  @override
  // ignore: must_call_super
  List<StackPath<RouteTarget>> get paths => [];
}

class DummyContext extends Fake implements BuildContext {}

// ============================================================================
// Tests
// ============================================================================

void main() {
  RestorableConverter.defineConverter(
    'test_path_converter',
    () => const TestRouteConverter(),
  );

  group('NavigationStack Standalone Restoration', () {
    testWidgets('restores routes provided manually (String/Unique)', (
      tester,
    ) async {
      final path = NavigationPath<BaseTestRoute>.create();
      TestRoute parseRoute(Uri uri) => TestRoute(uri.toString());

      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'app',
          home: NavigationStack(
            path: path,
            resolver: (route) => StackTransition.material(
              Builder(builder: (context) => route.buildWidget(context)),
            ),
            restorationId: 'main_stack',
            parseRouteFromUri: parseRoute,
          ),
        ),
      );
      await tester.pumpAndSettle();

      path.push(TestRoute('/home'));
      path.push(TestRoute('/details'));
      await tester.pumpAndSettle();

      expect(find.text('Route: /home'), findsNothing);
      expect(find.text('Route: /details'), findsOneWidget);

      final future = tester.restartAndRestore();

      // Clear manual reference to simulate clean start logic on restoration
      path.reset();
      await future;

      await tester.pumpAndSettle();

      expect(path.stack[1], isA<TestRoute>());
      expect(path.stack.length, 2);
    });

    testWidgets('restores complex routes (RouteRestorable/Map)', (
      tester,
    ) async {
      final path = NavigationPath<BaseTestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'app',
          home: NavigationStack(
            path: path,
            resolver: (route) => StackTransition.material(
              Builder(builder: (context) => route.buildWidget(context)),
            ),
            restorationId: 'main_stack',
            parseRouteFromUri: (uri) => TestRoute('/dummy'),
          ),
        ),
      );
      await tester.pumpAndSettle();

      path.push(RestorableTestRoute('123', data: 'Secret Data'));
      await tester.pumpAndSettle();

      expect(find.text('Restorable: 123'), findsOneWidget);

      final future = tester.restartAndRestore();
      path.reset();
      await future;
      await tester.pumpAndSettle();

      expect(path.stack.length, 1);
      final restored = path.stack.first as RestorableTestRoute;
      expect(restored.id, '123');
      expect(restored.data, 'Secret Data');
    });

    testWidgets('restores unimplemented route throw error', (tester) async {
      final path = NavigationPath<BaseTestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          restorationScopeId: 'app',
          home: NavigationStack(
            path: path,
            resolver: (route) => StackTransition.material(
              Builder(builder: (context) => route.buildWidget(context)),
            ),
            restorationId: 'main_stack',
            parseRouteFromUri: (uri) => TestRoute('/dummy'),
          ),
        ),
      );
      await tester.pumpAndSettle();

      path.push(UnimplementedRoute());
      await tester.pumpAndSettle();

      final future = tester.restartAndRestore();
      path.reset();
      await future;
      await tester.pumpAndSettle();

      expect(tester.takeException(), isUnimplementedError);
    });

    test(
      'throws assertion error if restoration configured without parser/coordinator',
      () {
        final path = NavigationPath<BaseTestRoute>.create();
        expect(
          () => NavigationStack(
            path: path,
            resolver: (_) => throw UnimplementedError(),
            restorationId: 'main_stack',
          ),
          throwsAssertionError,
        );
      },
    );
  });

  group('IndexedStackPathBuilder Restoration Limitation', () {
    testWidgets(
      'verifies IndexedStackPathBuilder does NOT restore state autonomously',
      (tester) async {
        final coordinator = DummyCoordinator();
        final path = IndexedStackPath<RouteUnique>.createWith(
          [TestRoute('/tab1'), TestRoute('/tab2')],
          coordinator: coordinator,
          label: 'tabs',
        );

        await tester.pumpWidget(
          MaterialApp(
            restorationScopeId: 'app',
            home: Scaffold(
              body: IndexedStackPathBuilder(
                path: path,
                coordinator: coordinator,
                restorationId: 'tabs',
              ),
            ),
          ),
        );

        await path.goToIndexed(1);
        await tester.pumpAndSettle();
        expect(path.activeIndex, 1);

        final future = tester.restartAndRestore();
        path.reset();
        await future;
        await tester.pumpAndSettle();

        expect(path.activeIndex, equals(0));
      },
    );
  });
}



================================================
FILE: packages/zenrouter/test/stack/layout_creation_test.dart
================================================
// ignore_for_file: avoid_print

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Layout Creation Tracking
// ============================================================================

/// Tracks layout creation counts for testing
class LayoutCreationTracker {
  static final Map<Type, int> _creationCounts = {};
  static final Map<Type, List<Object>> _instances = {};

  static void reset() {
    _creationCounts.clear();
    _instances.clear();
  }

  static void recordCreation(Type type, Object instance) {
    _creationCounts[type] = (_creationCounts[type] ?? 0) + 1;
    _instances[type] = _instances[type] ?? [];
    _instances[type]!.add(instance);
  }

  static int getCount(Type type) => _creationCounts[type] ?? 0;

  static List<Object> getInstances(Type type) => _instances[type] ?? [];

  static void printCounts() {
    print('\n=== Layout Creation Counts ===');
    _creationCounts.forEach((type, count) {
      print('$type: $count');
    });
    print('==============================\n');
  }
}

// ============================================================================
// Test Route Definitions
// ============================================================================

abstract class TestRoute extends RouteTarget with RouteUnique {
  @override
  Uri toUri();
}

/// Home layout - root level layout
class TestHomeLayout extends TestRoute with RouteLayout<TestRoute> {
  TestHomeLayout() {
    LayoutCreationTracker.recordCreation(TestHomeLayout, this);
  }

  @override
  NavigationPath<TestRoute> resolvePath(TestCoordinator coordinator) =>
      coordinator.homeStack;

  @override
  Uri toUri() => Uri.parse('/home');

  @override
  Widget build(TestCoordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Settings layout - standalone layout
class TestSettingsLayout extends TestRoute with RouteLayout<TestRoute> {
  TestSettingsLayout() {
    LayoutCreationTracker.recordCreation(TestSettingsLayout, this);
  }

  @override
  NavigationPath<TestRoute> resolvePath(TestCoordinator coordinator) =>
      coordinator.settingsStack;
}

/// TabBar layout - nested in HomeLayout
class TestTabBarLayout extends TestRoute with RouteLayout<TestRoute> {
  TestTabBarLayout() {
    LayoutCreationTracker.recordCreation(TestTabBarLayout, this);
  }

  @override
  Type get layout => TestHomeLayout;

  @override
  IndexedStackPath<TestRoute> resolvePath(TestCoordinator coordinator) =>
      coordinator.tabIndexed;

  @override
  Uri toUri() => Uri.parse('/home/tabs');
}

/// Feed tab layout - nested in TabBarLayout
class TestFeedTabLayout extends TestRoute with RouteLayout<TestRoute> {
  TestFeedTabLayout() {
    LayoutCreationTracker.recordCreation(TestFeedTabLayout, this);
  }

  @override
  Type get layout => TestTabBarLayout;

  @override
  NavigationPath<TestRoute> resolvePath(TestCoordinator coordinator) =>
      coordinator.feedTabStack;

  @override
  Uri toUri() => Uri.parse('/home/tabs/feed');

  @override
  Widget build(TestCoordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Simple route inside FeedTabLayout
class TestFeedRoute extends TestRoute {
  TestFeedRoute({required this.id});

  final String id;

  @override
  Type get layout => TestFeedTabLayout;

  @override
  Uri toUri() => Uri.parse('/home/tabs/feed/$id');

  @override
  Widget build(TestCoordinator coordinator, BuildContext context) {
    return const Placeholder();
  }

  @override
  List<Object?> get props => [id];
}

/// Profile tab route
class TestProfileTab extends TestRoute {
  @override
  Type get layout => TestTabBarLayout;

  @override
  Uri toUri() => Uri.parse('/home/tabs/profile');

  @override
  Widget build(TestCoordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Settings route inside SettingsLayout
class TestSettingsRoute extends TestRoute {
  @override
  Type get layout => TestSettingsLayout;

  @override
  Uri toUri() => Uri.parse('/settings/general');

  @override
  Widget build(TestCoordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Profile detail route in HomeLayout
class TestProfileDetail extends TestRoute {
  @override
  Type get layout => TestHomeLayout;

  @override
  Uri toUri() => Uri.parse('/home/profile/detail');

  @override
  Widget build(TestCoordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

// ============================================================================
// Test Coordinator
// ============================================================================

class TestCoordinator extends Coordinator<TestRoute> {
  late final NavigationPath<TestRoute> homeStack = NavigationPath.createWith(
    coordinator: this,
    label: 'home',
  );
  late final NavigationPath<TestRoute> settingsStack =
      NavigationPath.createWith(coordinator: this, label: 'settings');
  late final IndexedStackPath<TestRoute> tabIndexed =
      IndexedStackPath<TestRoute>.createWith(
        [TestFeedTabLayout(), TestProfileTab()],
        coordinator: this,
        label: 'tabs',
      );
  late final NavigationPath<TestRoute> feedTabStack = NavigationPath.createWith(
    coordinator: this,
    label: 'feed',
  );

  @override
  void defineLayout() {
    RouteLayout.defineLayout(TestHomeLayout, TestHomeLayout.new);
    RouteLayout.defineLayout(TestSettingsLayout, TestSettingsLayout.new);
    RouteLayout.defineLayout(TestTabBarLayout, TestTabBarLayout.new);
    RouteLayout.defineLayout(TestFeedTabLayout, TestFeedTabLayout.new);
  }

  @override
  List<StackPath> get paths => [
    ...super.paths,
    homeStack,
    settingsStack,
    tabIndexed,
    feedTabStack,
  ];

  @override
  TestRoute parseRouteFromUri(Uri uri) {
    return TestFeedRoute(id: '1');
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  setUp(() {
    LayoutCreationTracker.reset();
  });

  group('Layout Creation - Initial Creation', () {
    test('HomeLayout is created once on first navigation', () async {
      final coordinator = TestCoordinator();

      // Account for any layouts created during coordinator initialization
      final initialHomeCount = LayoutCreationTracker.getCount(TestHomeLayout);

      // Navigate to a route that requires HomeLayout
      coordinator.push(TestProfileDetail());
      await Future.delayed(Duration.zero);

      final finalHomeCount = LayoutCreationTracker.getCount(TestHomeLayout);

      expect(
        finalHomeCount - initialHomeCount,
        1,
        reason: 'HomeLayout should be created exactly once on first navigation',
      );
    });

    test('SettingsLayout is created once on first navigation', () async {
      final coordinator = TestCoordinator();

      final initialCount = LayoutCreationTracker.getCount(TestSettingsLayout);

      coordinator.push(TestSettingsRoute());
      await Future.delayed(Duration.zero);

      expect(
        LayoutCreationTracker.getCount(TestSettingsLayout) - initialCount,
        1,
        reason: 'SettingsLayout should be created exactly once',
      );
    });

    test('Nested layouts are created on navigation path setup', () async {
      final coordinator = TestCoordinator();

      // FeedTabLayout is created during IndexedStackPath initialization
      final initialFeedTabCount = LayoutCreationTracker.getCount(
        TestFeedTabLayout,
      );
      expect(
        initialFeedTabCount,
        greaterThan(0),
        reason:
            'FeedTabLayout is created during IndexedStackPath initialization',
      );

      // Navigate to a route deep in the hierarchy
      coordinator.push(TestFeedRoute(id: '1'));
      await Future.delayed(Duration.zero);

      final feedTabCountAfterFirstPush = LayoutCreationTracker.getCount(
        TestFeedTabLayout,
      );

      // May create one more instance during navigation (acceptable behavior)
      // The key is that it doesn't keep creating new ones

      // Navigate again - should NOT create more instances
      coordinator.push(TestFeedRoute(id: '2'));
      await Future.delayed(Duration.zero);

      expect(
        LayoutCreationTracker.getCount(TestFeedTabLayout),
        feedTabCountAfterFirstPush,
        reason:
            'FeedTabLayout should not be recreated on subsequent navigation',
      );

      LayoutCreationTracker.printCounts();
    });

    test(
      'Layout is not recreated when pushing multiple routes within it',
      () async {
        final coordinator = TestCoordinator();

        // Navigate to first feed route
        coordinator.push(TestFeedRoute(id: '1'));
        await Future.delayed(Duration.zero);

        final homeCount = LayoutCreationTracker.getCount(TestHomeLayout);
        final tabBarCount = LayoutCreationTracker.getCount(TestTabBarLayout);
        final feedTabCount = LayoutCreationTracker.getCount(TestFeedTabLayout);

        // Push more routes within the same layout
        coordinator.push(TestFeedRoute(id: '2'));
        await Future.delayed(Duration.zero);

        coordinator.push(TestFeedRoute(id: '3'));
        await Future.delayed(Duration.zero);

        expect(
          LayoutCreationTracker.getCount(TestHomeLayout),
          homeCount,
          reason: 'HomeLayout should not be recreated',
        );
        expect(
          LayoutCreationTracker.getCount(TestTabBarLayout),
          tabBarCount,
          reason: 'TabBarLayout should not be recreated',
        );
        expect(
          LayoutCreationTracker.getCount(TestFeedTabLayout),
          feedTabCount,
          reason: 'FeedTabLayout should not be recreated',
        );
      },
    );
  });

  group('Layout Creation - Re-use Within Session', () {
    test('Layout is reused when navigating within tabs', () async {
      final coordinator = TestCoordinator();

      // Navigate to feed
      coordinator.push(TestFeedRoute(id: '1'));
      await Future.delayed(Duration.zero);

      final homeCountAfterFirst = LayoutCreationTracker.getCount(
        TestHomeLayout,
      );
      final tabBarCountAfterFirst = LayoutCreationTracker.getCount(
        TestTabBarLayout,
      );

      // Navigate to profile tab (same HomeLayout, same TabBarLayout)
      coordinator.push(TestProfileTab());
      await Future.delayed(Duration.zero);

      expect(
        LayoutCreationTracker.getCount(TestHomeLayout),
        homeCountAfterFirst,
        reason: 'HomeLayout should be reused within same session',
      );
      expect(
        LayoutCreationTracker.getCount(TestTabBarLayout),
        tabBarCountAfterFirst,
        reason: 'TabBarLayout should be reused within same session',
      );
    });

    test('Layout count increases only when navigating to new layout type', () async {
      final coordinator = TestCoordinator();

      final initialSettingsCount = LayoutCreationTracker.getCount(
        TestSettingsLayout,
      );

      // Navigate to settings for the first time
      coordinator.push(TestSettingsRoute());
      await Future.delayed(Duration.zero);

      expect(
        LayoutCreationTracker.getCount(TestSettingsLayout),
        initialSettingsCount + 1,
        reason: 'SettingsLayout should be created once',
      );

      final settingsCountAfterFirst = LayoutCreationTracker.getCount(
        TestSettingsLayout,
      );

      // Navigate to home (different layout)
      coordinator.push(TestProfileDetail());
      await Future.delayed(Duration.zero);

      // Navigate back to settings
      coordinator.push(TestSettingsRoute());
      await Future.delayed(Duration.zero);

      // Settings layout should be reused if still in stack, or recreated if popped
      // The key is: if we used push (not replace), the layout should still exist
      final settingsCountFinal = LayoutCreationTracker.getCount(
        TestSettingsLayout,
      );

      print(
        'Settings count: initial=$initialSettingsCount, afterFirst=$settingsCountAfterFirst, final=$settingsCountFinal',
      );
      // This is the current behavior - may create a new one depending on stack state
    });
  });

  group('Layout Creation - Re-creation After Pop', () {
    test(
      'Layout is recreated after being completely popped from root stack',
      () async {
        final coordinator = TestCoordinator();

        // Navigate to settings
        coordinator.push(TestSettingsLayout());
        await Future.delayed(Duration.zero);
        coordinator.push(TestSettingsRoute());
        await Future.delayed(Duration.zero);

        final settingsCountAfterFirst = LayoutCreationTracker.getCount(
          TestSettingsLayout,
        );

        // Pop back (but SettingsLayout might still be in the stack)
        coordinator.pop(); // Pop TestSettingsRoute
        await Future.delayed(Duration.zero);

        // The exact count here depends on whether pop removes the layout or just the route
        // Let's navigate to settings again to see if it's recreated
        coordinator.push(TestSettingsRoute());
        await Future.delayed(Duration.zero);

        // Could be same count if layout wasn't removed, or +1 if it was
        final settingsCountAfterRepush = LayoutCreationTracker.getCount(
          TestSettingsLayout,
        );

        print(
          'SettingsLayout: afterFirst=$settingsCountAfterFirst, afterRepush=$settingsCountAfterRepush',
        );

        LayoutCreationTracker.printCounts();
      },
    );

    test('Replace creates new layout instances', () async {
      final coordinator = TestCoordinator();

      // Navigate deep into nested layouts
      coordinator.push(TestFeedRoute(id: '1'));
      await Future.delayed(Duration.zero);

      final homeCountAfterPush = LayoutCreationTracker.getCount(TestHomeLayout);
      final tabBarCountAfterPush = LayoutCreationTracker.getCount(
        TestTabBarLayout,
      );
      final feedTabCountAfterPush = LayoutCreationTracker.getCount(
        TestFeedTabLayout,
      );

      // Replace resets everything and creates new instances
      coordinator.replace(TestFeedRoute(id: '2'));
      await Future.delayed(Duration.zero);

      expect(
        LayoutCreationTracker.getCount(TestHomeLayout),
        greaterThan(homeCountAfterPush),
        reason: 'HomeLayout should be recreated after replace',
      );
      expect(
        LayoutCreationTracker.getCount(TestTabBarLayout),
        greaterThan(tabBarCountAfterPush),
        reason: 'TabBarLayout should be recreated after replace',
      );
      expect(
        LayoutCreationTracker.getCount(TestFeedTabLayout),
        greaterThan(feedTabCountAfterPush),
        reason: 'FeedTabLayout should be recreated after replace',
      );

      LayoutCreationTracker.printCounts();
    });
  });

  group('Layout Creation - Replace Operation', () {
    test('replace() creates new layout instances', () async {
      final coordinator = TestCoordinator();

      // Navigate to feed
      coordinator.push(TestFeedRoute(id: '1'));
      await Future.delayed(Duration.zero);

      final homeCountAfterPush = LayoutCreationTracker.getCount(TestHomeLayout);

      // Replace with settings
      coordinator.replace(TestSettingsRoute());
      await Future.delayed(Duration.zero);

      final settingsCountAfterReplace = LayoutCreationTracker.getCount(
        TestSettingsLayout,
      );
      expect(settingsCountAfterReplace, greaterThan(0));

      // Replace back to feed - should create new HomeLayout
      coordinator.replace(TestFeedRoute(id: '2'));
      await Future.delayed(Duration.zero);

      expect(
        LayoutCreationTracker.getCount(TestHomeLayout),
        greaterThan(homeCountAfterPush),
        reason: 'replace() should create new layout instances',
      );

      LayoutCreationTracker.printCounts();
    });

    test('replace() resets all paths', () async {
      final coordinator = TestCoordinator();

      // Build up a deep stack
      coordinator.push(TestFeedRoute(id: '1'));
      await Future.delayed(Duration.zero);
      coordinator.push(TestFeedRoute(id: '2'));
      await Future.delayed(Duration.zero);

      // Replace should reset everything
      coordinator.replace(TestSettingsRoute());
      await Future.delayed(Duration.zero);

      // Root stack should be reset to just one route (and its layouts)
      expect(
        coordinator.root.stack.length,
        lessThanOrEqualTo(2),
        reason: 'replace() should reset root stack',
      );
    });
  });

  group('Layout Creation - Summary', () {
    test('Complete navigation flow shows expected behavior', () async {
      final coordinator = TestCoordinator();
      LayoutCreationTracker.printCounts();

      print('\n--- Initial state (after coordinator creation) ---');
      final initialCounts = {
        'Home': LayoutCreationTracker.getCount(TestHomeLayout),
        'Settings': LayoutCreationTracker.getCount(TestSettingsLayout),
        'TabBar': LayoutCreationTracker.getCount(TestTabBarLayout),
        'FeedTab': LayoutCreationTracker.getCount(TestFeedTabLayout),
      };
      print(initialCounts);

      print('\n--- After push(FeedRoute(1)) ---');
      coordinator.push(TestFeedRoute(id: '1'));
      await Future.delayed(Duration.zero);
      LayoutCreationTracker.printCounts();

      print('\n--- After push(FeedRoute(2)) - should reuse layouts ---');
      coordinator.push(TestFeedRoute(id: '2'));
      await Future.delayed(Duration.zero);
      LayoutCreationTracker.printCounts();

      print(
        '\n--- After replace(SettingsRoute) - should create Settings layout ---',
      );
      coordinator.replace(TestSettingsRoute());
      await Future.delayed(Duration.zero);
      LayoutCreationTracker.printCounts();

      print(
        '\n--- After replace(FeedRoute(3)) - should create new Home/TabBar/FeedTab ---',
      );
      coordinator.replace(TestFeedRoute(id: '3'));
      await Future.delayed(Duration.zero);
      LayoutCreationTracker.printCounts();

      print('\n--- Final verification ---');
      expect(
        LayoutCreationTracker.getCount(TestHomeLayout),
        greaterThan(initialCounts['Home']!),
        reason: 'HomeLayout created at least once during navigation',
      );
      expect(
        LayoutCreationTracker.getCount(TestSettingsLayout),
        greaterThan(initialCounts['Settings']!),
        reason: 'SettingsLayout created when navigated to',
      );
    });
  });
}



================================================
FILE: packages/zenrouter/test/stack/navigation_stack_test.dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// Test route implementation
class TestRoute extends RouteTarget {
  TestRoute(this.id);
  final String id;

  @override
  List<Object?> get props => [id];
}

// Track widget builds for verification
class BuildTracker {
  static final Map<String, int> _buildCounts = {};
  static final Set<String> _activeWidgets = {};

  static void reset() {
    _buildCounts.clear();
    _activeWidgets.clear();
  }

  static void recordBuild(String id) {
    _buildCounts[id] = (_buildCounts[id] ?? 0) + 1;
    _activeWidgets.add(id);
  }

  static void recordDispose(String id) {
    _activeWidgets.remove(id);
  }

  static int getBuildCount(String id) => _buildCounts[id] ?? 0;
  static bool isActive(String id) => _activeWidgets.contains(id);
  static int get totalBuilds =>
      _buildCounts.values.fold(0, (sum, count) => sum + count);
}

// Stateful widget that tracks builds
class TrackedWidget extends StatefulWidget {
  const TrackedWidget({super.key, required this.routeId});

  final String routeId;

  @override
  State<TrackedWidget> createState() => _TrackedWidgetState();
}

class _TrackedWidgetState extends State<TrackedWidget> {
  @override
  void initState() {
    super.initState();
    BuildTracker.recordBuild(widget.routeId);
  }

  @override
  void dispose() {
    BuildTracker.recordDispose(widget.routeId);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Text('Route: ${widget.routeId}');
  }
}

// Simple destination resolver
StackTransition<TestRoute> testResolver(TestRoute route) {
  return StackTransition.material(TrackedWidget(routeId: route.id));
}

void main() {
  setUp(() {
    BuildTracker.reset();
  });

  group('NavigationStack - Diff-based page updates', () {
    testWidgets('creates pages for initial routes', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      // Push initial route using push (not pushOrMoveToTop)
      path.push(TestRoute('home'));
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('home'), 1);
      expect(find.text('Route: home'), findsOneWidget);
    });

    testWidgets('reuses pages when routes are unchanged', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      path.push(TestRoute('home'));
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('home'), 1);

      // Push and pop a route to trigger _updatePages without changing the stack
      // Don't await push - it returns a Future that completes on pop
      path.push(TestRoute('temp'));
      await tester.pumpAndSettle();
      path.pop();
      await tester.pumpAndSettle();

      // Home page should still only have been built once (reused via Keep)
      expect(BuildTracker.getBuildCount('home'), 1);
    });

    testWidgets('creates new page on push', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      path.push(TestRoute('home'));
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('home'), 1);
      expect(BuildTracker.getBuildCount('profile'), 0);

      // Push a new route (don't await - completes on pop)
      path.push(TestRoute('profile'));
      await tester.pumpAndSettle();

      // Home should be reused, profile should be new
      expect(BuildTracker.getBuildCount('home'), 1);
      expect(BuildTracker.getBuildCount('profile'), 1);
      expect(find.text('Route: profile'), findsOneWidget);
    });

    testWidgets('removes page on pop', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      path.push(TestRoute('home'));
      await tester.pumpAndSettle();

      path.push(TestRoute('profile'));
      await tester.pumpAndSettle();

      expect(BuildTracker.isActive('profile'), isTrue);

      // Pop the route
      path.pop();
      await tester.pumpAndSettle();

      // Profile widget should be disposed
      expect(BuildTracker.isActive('profile'), isFalse);
      expect(find.text('Route: profile'), findsNothing);
      expect(find.text('Route: home'), findsOneWidget);
    });

    testWidgets('preserves existing pages when pushing multiple routes', (
      tester,
    ) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      path.push(TestRoute('home'));
      await tester.pumpAndSettle();

      // Push multiple routes (don't await)
      path.push(TestRoute('profile'));
      await tester.pumpAndSettle();
      path.push(TestRoute('settings'));
      await tester.pumpAndSettle();
      path.push(TestRoute('about'));
      await tester.pumpAndSettle();

      // Each page should only be built once
      expect(BuildTracker.getBuildCount('home'), 1);
      expect(BuildTracker.getBuildCount('profile'), 1);
      expect(BuildTracker.getBuildCount('settings'), 1);
      expect(BuildTracker.getBuildCount('about'), 1);
    });

    testWidgets('handles empty stack gracefully', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );
      await tester.pumpAndSettle();

      // Should render empty container for empty stack
      expect(find.byType(SizedBox), findsOneWidget);
    });

    testWidgets('handles push after empty stack', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );
      await tester.pumpAndSettle();

      // Push to empty stack (don't await)
      path.push(TestRoute('first'));
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('first'), 1);
      expect(find.text('Route: first'), findsOneWidget);
    });

    testWidgets('correctly applies diff for complex stack changes', (
      tester,
    ) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      // Build initial stack: [a, b, c, d]
      path.push(TestRoute('a'));
      await tester.pumpAndSettle();
      path.push(TestRoute('b'));
      await tester.pumpAndSettle();
      path.push(TestRoute('c'));
      await tester.pumpAndSettle();
      path.push(TestRoute('d'));
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('a'), 1);
      expect(BuildTracker.getBuildCount('b'), 1);
      expect(BuildTracker.getBuildCount('c'), 1);
      expect(BuildTracker.getBuildCount('d'), 1);

      // Pop 'd' and 'c'
      path.pop();
      await tester.pumpAndSettle();
      path.pop();
      await tester.pumpAndSettle();

      // Stack is now [a, b]
      expect(path.stack.length, 2);
      expect(path.stack[0].id, 'a');
      expect(path.stack[1].id, 'b');

      // 'a' and 'b' should still only have been built once
      expect(BuildTracker.getBuildCount('a'), 1);
      expect(BuildTracker.getBuildCount('b'), 1);
    });

    testWidgets('pages maintain correct order after diff operations', (
      tester,
    ) async {
      final path = NavigationPath<TestRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path, resolver: testResolver),
        ),
      );

      path.push(TestRoute('1'));
      await tester.pumpAndSettle();
      path.push(TestRoute('2'));
      await tester.pumpAndSettle();
      path.push(TestRoute('3'));
      await tester.pumpAndSettle();

      expect(path.stack.map((r) => r.id).toList(), ['1', '2', '3']);

      // Pop and push different route
      path.pop();
      await tester.pumpAndSettle();
      path.push(TestRoute('4'));
      await tester.pumpAndSettle();

      expect(path.stack.map((r) => r.id).toList(), ['1', '2', '4']);

      // '1' and '2' should be reused
      expect(BuildTracker.getBuildCount('1'), 1);
      expect(BuildTracker.getBuildCount('2'), 1);
      expect(BuildTracker.getBuildCount('3'), 1);
      expect(BuildTracker.getBuildCount('4'), 1);
    });

    testWidgets('works correctly when path is swapped', (tester) async {
      final path1 = NavigationPath<TestRoute>.create();
      final path2 = NavigationPath<TestRoute>.create();

      // Don't await push - it returns a Future that completes on pop
      path1.push(TestRoute('path1-home'));
      path2.push(TestRoute('path2-home'));

      // Start with path1
      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path1, resolver: testResolver),
        ),
      );
      await tester.pumpAndSettle();

      expect(find.text('Route: path1-home'), findsOneWidget);
      expect(BuildTracker.getBuildCount('path1-home'), 1);

      // Swap to path2
      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(path: path2, resolver: testResolver),
        ),
      );
      await tester.pumpAndSettle();

      expect(find.text('Route: path2-home'), findsOneWidget);
      expect(BuildTracker.getBuildCount('path2-home'), 1);
    });
  });

  group('NavigationStack - Page preservation', () {
    testWidgets('state is preserved when page is kept', (tester) async {
      final path = NavigationPath<TestRoute>.create();

      // Use a stateful counter widget
      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<TestRoute>(
            path: path,
            resolver: (route) => StackTransition.material(
              _CounterWidget(key: ValueKey(route.id)),
            ),
          ),
        ),
      );

      // Push initial route using push (not pushOrMoveToTop via defaultRoute)
      path.push(TestRoute('counter'));
      await tester.pumpAndSettle();

      // Increment counter
      await tester.tap(find.byType(ElevatedButton));
      await tester.pumpAndSettle();

      expect(find.text('Count: 1'), findsOneWidget);

      // Push new route (don't await)
      path.push(TestRoute('other'));
      await tester.pumpAndSettle();

      // Pop back
      path.pop();
      await tester.pumpAndSettle();

      // Counter state should be preserved (still 1)
      expect(find.text('Count: 1'), findsOneWidget);
    });
  });

  group('NavigationStack - RouteGuard behavior', () {
    testWidgets('Explicit guard in StackTransition', (tester) async {
      final path = NavigationPath<_NormalRoute>.create();
      final navigatorKey = GlobalKey<NavigatorState>(debugLabel: 'navigator');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<_NormalRoute>(
            path: path,
            navigatorKey: navigatorKey,
            defaultRoute: _NormalRoute('home'),
            resolver: (route) => StackTransition.material(
              Scaffold(body: Column(children: [Text('Route: ${route.id}')])),
              guard: _GuardInternal(route.id),
            ),
          ),
        ),
      );
      await tester.pumpAndSettle();

      path.push(_NormalRoute('guarded'));
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'guarded');

      // Tap the pop button - Navigator.pop will be called but guard rejects
      navigatorKey.currentState!.maybePop('result');
      await tester.pumpAndSettle();

      // Path should NOT be updated (guard rejected)
      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'guarded');
    });

    testWidgets('Navigator.maybePop updates path when guard allows', (
      tester,
    ) async {
      final path = NavigationPath<_GuardedRoute>.create();
      final navigatorKey = GlobalKey<NavigatorState>(debugLabel: 'navigator');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<_GuardedRoute>(
            path: path,
            navigatorKey: navigatorKey,
            defaultRoute: _GuardedRoute('home', allowPop: true),
            resolver: (route) => StackTransition.material(
              Scaffold(body: Column(children: [Text('Route: ${route.id}')])),
            ),
          ),
        ),
      );
      await tester.pumpAndSettle();

      path.push(_GuardedRoute('guarded', allowPop: true));
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'guarded');

      // Tap the pop button - Navigator.pop will be called
      navigatorKey.currentState!.maybePop();
      await tester.pumpAndSettle();

      // Path should be updated (popped)
      expect(path.stack.length, 1);
      expect(path.stack.last.id, 'home');
    });

    testWidgets(
      'prevents Navigator.maybePop and does not update path when guard rejects',
      (tester) async {
        final path = NavigationPath<_GuardedRoute>.create();
        final navigatorKey = GlobalKey<NavigatorState>(debugLabel: 'navigator');

        await tester.pumpWidget(
          MaterialApp(
            home: NavigationStack<_GuardedRoute>(
              path: path,
              navigatorKey: navigatorKey,
              defaultRoute: _GuardedRoute('home', allowPop: true),
              resolver: (route) => StackTransition.material(
                Scaffold(body: Column(children: [Text('Route: ${route.id}')])),
              ),
            ),
          ),
        );
        await tester.pumpAndSettle();

        path.push(_GuardedRoute('guarded', allowPop: false));
        await tester.pumpAndSettle();

        expect(path.stack.length, 2);
        expect(path.stack.last.id, 'guarded');

        // Tap the pop button - Navigator.pop will be called but guard rejects
        navigatorKey.currentState!.maybePop();
        await tester.pumpAndSettle();

        // Path should NOT be updated (guard rejected)
        expect(path.stack.length, 2);
        expect(path.stack.last.id, 'guarded');
      },
    );

    testWidgets('ignore RouteGuard when receive a force pop from Navigator', (
      tester,
    ) async {
      final path = NavigationPath<_GuardedRoute>.create();
      final navigatorKey = GlobalKey<NavigatorState>(debugLabel: 'navigator');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<_GuardedRoute>(
            path: path,
            navigatorKey: navigatorKey,
            defaultRoute: _GuardedRoute('home', allowPop: true),
            resolver: (route) => StackTransition.material(
              Scaffold(body: Column(children: [Text('Route: ${route.id}')])),
            ),
          ),
        ),
      );
      await tester.pumpAndSettle();

      path.push(_GuardedRoute('guarded', allowPop: false));
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'guarded');

      // Tap the pop button - Navigator.pop will be called but guard rejects
      navigatorKey.currentState!.pop();
      await tester.pumpAndSettle();

      // Path should NOT be updated (guard rejected)
      expect(path.stack.length, 1);
      expect(path.stack.last.id, 'home');
    });

    testWidgets('Route receive a result from Navigator.pop', (tester) async {
      final path = NavigationPath<_GuardedRoute>.create();
      final navigatorKey = GlobalKey<NavigatorState>(debugLabel: 'navigator');

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<_GuardedRoute>(
            path: path,
            navigatorKey: navigatorKey,
            defaultRoute: _GuardedRoute('home', allowPop: true),
            resolver: (route) => StackTransition.material(
              Scaffold(body: Column(children: [Text('Route: ${route.id}')])),
            ),
          ),
        ),
      );
      await tester.pumpAndSettle();

      final guard = _GuardedRoute('guarded', allowPop: false);
      final future = path.push(guard);
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'guarded');

      // Tap the pop button - Navigator.pop will be called but guard rejects
      navigatorKey.currentState!.pop('result');
      await tester.pumpAndSettle();

      // Path should NOT be updated (guard rejected)
      expect(path.stack.length, 1);
      expect(path.stack.last.id, 'home');
      expect(await future, 'result');
    });

    testWidgets('path.pop() respects RouteGuard when guard allows', (
      tester,
    ) async {
      final path = NavigationPath<_GuardedRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<_GuardedRoute>(
            path: path,
            resolver: (route) =>
                StackTransition.material(Text('Route: ${route.id}')),
          ),
        ),
      );

      path.push(_GuardedRoute('home', allowPop: true));
      await tester.pumpAndSettle();
      path.push(_GuardedRoute('guarded', allowPop: true));
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);

      // Pop via path - guard should allow
      final result = await path.pop();
      await tester.pumpAndSettle();

      expect(result, isTrue);
      expect(path.stack.length, 1);
      expect(path.stack.last.id, 'home');
    });

    testWidgets('path.pop() respects RouteGuard when guard rejects', (
      tester,
    ) async {
      final path = NavigationPath<_GuardedRoute>.create();

      await tester.pumpWidget(
        MaterialApp(
          home: NavigationStack<_GuardedRoute>(
            path: path,
            resolver: (route) =>
                StackTransition.material(Text('Route: ${route.id}')),
          ),
        ),
      );

      path.push(_GuardedRoute('home', allowPop: true));
      await tester.pumpAndSettle();
      path.push(_GuardedRoute('guarded', allowPop: false));
      await tester.pumpAndSettle();

      expect(path.stack.length, 2);

      // Pop via path - guard should reject
      final result = await path.pop();
      await tester.pumpAndSettle();

      expect(result, isFalse);
      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'guarded');
    });
  });

  group('DeclarativeNavigationStack - Diff-based updates', () {
    testWidgets('updates pages using diff when routes change', (tester) async {
      var routes = [TestRoute('a'), TestRoute('b')];

      await tester.pumpWidget(
        MaterialApp(
          home: StatefulBuilder(
            builder: (context, setState) {
              return Column(
                children: [
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        routes = [
                          TestRoute('a'),
                          TestRoute('c'),
                          TestRoute('b'),
                        ];
                      });
                    },
                    child: const Text('Update'),
                  ),
                  Expanded(
                    child: NavigationStack.declarative<TestRoute>(
                      routes: routes,
                      resolver: testResolver,
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      );
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('a'), 1);
      expect(BuildTracker.getBuildCount('b'), 1);
      expect(BuildTracker.getBuildCount('c'), 0);

      // Update routes
      await tester.tap(find.text('Update'));
      await tester.pumpAndSettle();

      // 'a' and 'b' should be reused, 'c' is new
      expect(BuildTracker.getBuildCount('a'), 1);
      expect(BuildTracker.getBuildCount('b'), 1);
      expect(BuildTracker.getBuildCount('c'), 1);
    });

    testWidgets('handles complete route replacement', (tester) async {
      var routes = [TestRoute('old1'), TestRoute('old2')];

      await tester.pumpWidget(
        MaterialApp(
          home: StatefulBuilder(
            builder: (context, setState) {
              return Column(
                children: [
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        routes = [TestRoute('new1'), TestRoute('new2')];
                      });
                    },
                    child: const Text('Replace'),
                  ),
                  Expanded(
                    child: NavigationStack.declarative<TestRoute>(
                      routes: routes,
                      resolver: testResolver,
                    ),
                  ),
                ],
              );
            },
          ),
        ),
      );
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('old1'), 1);
      expect(BuildTracker.getBuildCount('old2'), 1);

      // Replace all routes
      await tester.tap(find.text('Replace'));
      await tester.pumpAndSettle();

      expect(BuildTracker.getBuildCount('new1'), 1);
      expect(BuildTracker.getBuildCount('new2'), 1);

      // Old routes should be disposed
      expect(BuildTracker.isActive('old1'), isFalse);
      expect(BuildTracker.isActive('old2'), isFalse);
    });
  });
}

// Helper widget for testing state preservation
class _CounterWidget extends StatefulWidget {
  const _CounterWidget({super.key});

  @override
  State<_CounterWidget> createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<_CounterWidget> {
  int _count = 0;

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        Text('Count: $_count'),
        ElevatedButton(
          onPressed: () => setState(() => _count++),
          child: const Text('Increment'),
        ),
      ],
    );
  }
}

// Helper route with RouteGuard for testing
class _GuardedRoute extends RouteTarget with RouteGuard {
  _GuardedRoute(this.id, {this.allowPop = true});

  final String id;
  final bool allowPop;

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  List<Object?> get props => [id, allowPop];
}

class _NormalRoute extends RouteTarget {
  _NormalRoute(this.id);

  final String id;

  @override
  List<Object?> get props => [id];
}

class _GuardInternal extends RouteTarget with RouteGuard {
  _GuardInternal(this.id);

  final String id;

  @override
  FutureOr<bool> popGuard() {
    if (id == 'guarded') return false;
    return true;
  }
}



================================================
FILE: packages/zenrouter/test/stack/route_completion_test.dart
================================================
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter/zenrouter.dart';

// ============================================================================
// Test Coordinator
// ============================================================================

/// Minimal coordinator for testing
class TestCoordinator extends Coordinator<TestRoute> {
  @override
  void defineLayout() {}

  @override
  List<StackPath> get paths => [...super.paths];

  @override
  TestRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [final id] => TestRoute(id),
      _ => TestRoute('default'),
    };
  }
}

// ============================================================================
// Test Route Definitions
// ============================================================================

/// Test route with tracking for result completion
class TestRoute extends RouteTarget with RouteUnique {
  TestRoute(this.id);
  final String id;

  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  List<Object?> get props => [id];

  @override
  Uri toUri() => Uri.parse('/$id');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

class TestQueryRoute extends RouteTarget
    with RouteUnique, RouteQueryParameters {
  TestQueryRoute(this.id, {Map<String, String>? queryParameters}) {
    queryNotifier.value = queryParameters ?? {};
  }

  @override
  final ValueNotifier<Map<String, String>> queryNotifier = ValueNotifier({});

  final String id;

  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  List<Object?> get props => [id];

  @override
  Uri toUri() => Uri.parse('/$id').replace(queryParameters: queries);

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Test route that redirects to another route
class RedirectRoute extends RouteTarget
    with RouteUnique, RouteRedirect<TestRoute> {
  RedirectRoute({required this.redirectToId});

  final String redirectToId;
  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  TestRoute redirect() => TestRoute(redirectToId);

  @override
  List<Object?> get props => [redirectToId];

  @override
  Uri toUri() => Uri.parse('/redirect/$redirectToId');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Test route that chains to another redirect
class ChainedRedirectRoute extends RouteTarget
    with RouteUnique, RouteRedirect<RouteTarget> {
  ChainedRedirectRoute({required this.nextRedirect});

  final RedirectRoute nextRedirect;
  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  RouteTarget redirect() => nextRedirect;

  @override
  Uri toUri() => Uri.parse('/chained');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Test route that redirects to null (stays on current route)
class NullRedirectRoute extends RouteTarget
    with RouteUnique, RouteRedirect<RouteTarget> {
  NullRedirectRoute();

  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  TestRoute? redirectWith(covariant Coordinator<RouteUnique> coordinator) =>
      null;

  @override
  Uri toUri() => Uri.parse('/null-redirect');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

/// Test route that redirects to itself
class SelfRedirectRoute extends RouteTarget
    with RouteUnique, RouteRedirect<SelfRedirectRoute> {
  SelfRedirectRoute();

  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  SelfRedirectRoute redirect() => this;

  @override
  Uri toUri() => Uri.parse('/self-redirect');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

class MultiPropsRoute extends RouteTarget with RouteUnique {
  MultiPropsRoute(this.prop1, this.prop2);
  final String prop1;
  final String prop2;

  @override
  List<Object?> get props => [prop1, prop2];

  @override
  Uri toUri() => Uri.parse('/multi-props/$prop1/$prop2');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}

// ============================================================================
// Tests
// ============================================================================

void main() {
  group('Route creation', () {
    test('toString()', () {
      expect(TestRoute('test').toString(), equals('TestRoute[test]'));
      expect(
        MultiPropsRoute('a', 'b').toString(),
        equals('MultiPropsRoute[a,b]'),
      );
    });
  });

  group('pushOrMoveToTop - Route Completion', () {
    test('completes result future when moving existing route to top', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final routeA = TestRoute('a');
      final routeB = TestRoute('b');
      final routeADuplicate = TestRoute('a'); // Same id, equals routeA

      // Push initial routes
      path.push(routeA);
      path.push(routeB);

      await Future.delayed(const Duration(milliseconds: 100));

      expect(path.stack.length, 2);
      expect(routeA.resultCompleted, isFalse);

      // Push or move to top - routeA should be moved, its future should be completed
      await path.pushOrMoveToTop(routeADuplicate);

      expect(path.stack.length, 2);
      expect(path.stack.last.id, 'a');
      expect(routeA.resultCompleted, isTrue);
      expect(routeA.resultValue, isNull);
    });

    test('does not complete result future when pushing new route', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final routeA = TestRoute('a');
      final routeB = TestRoute('b');

      path.push(routeA);
      path.pushOrMoveToTop(routeB);
      await Future.delayed(const Duration(milliseconds: 100));

      expect(path.stack.length, 2);
      expect(routeA.resultCompleted, isFalse);
      expect(routeB.resultCompleted, isFalse);
    });

    test('completes removed route future with null result', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final routeA = TestRoute('a');
      final routeB = TestRoute('b');
      final routeC = TestRoute('c');

      path.push(routeA);
      path.push(routeB);
      path.push(routeC);
      await Future.delayed(const Duration(milliseconds: 100));

      expect(path.stack.length, 3);

      // Move routeB to top
      path.pushOrMoveToTop(TestRoute('b'));
      await Future.delayed(const Duration(milliseconds: 100));

      expect(path.stack.length, 3);
      expect(path.stack.map((r) => r.id).toList(), ['a', 'c', 'b']);
      expect(routeB.resultCompleted, isTrue);
    });

    test('handles multiple moveToTop operations correctly', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final routes = [TestRoute('a'), TestRoute('b'), TestRoute('c')];

      for (final route in routes) {
        path.push(route);
      }
      await Future.delayed(const Duration(milliseconds: 100));

      // Move 'a' to top
      path.pushOrMoveToTop(TestRoute('a'));
      await Future.delayed(const Duration(milliseconds: 100));
      expect(routes[0].resultCompleted, isTrue);
      expect(path.stack.map((r) => r.id).toList(), ['b', 'c', 'a']);

      // Move 'b' to top
      path.pushOrMoveToTop(TestRoute('b'));
      await Future.delayed(const Duration(milliseconds: 100));
      expect(routes[1].resultCompleted, isTrue);
      expect(path.stack.map((r) => r.id).toList(), ['c', 'a', 'b']);
    });

    test('pushOrMoveToTop on empty stack adds route', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final route = TestRoute('a');
      path.pushOrMoveToTop(route);
      await Future.delayed(const Duration(milliseconds: 100));

      expect(path.stack.length, 1);
      expect(path.stack.first.id, 'a');
      expect(route.resultCompleted, isFalse);
    });

    test('pushing same route that is already on top still moves it', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final routeA = TestRoute('a');
      path.push(routeA);

      // Push same route again via pushOrMoveToTop
      final newRouteA = TestRoute('a');
      path.pushOrMoveToTop(newRouteA);
      await Future.delayed(const Duration(milliseconds: 100));

      // The orginal route should remain but the new route should be completed
      expect(routeA.resultCompleted, isFalse);
      expect(newRouteA.resultCompleted, isTrue);
      expect(path.stack.length, 1);
    });

    test(
      'pushing RouteQueryParameters will update the existing route',
      () async {
        final path = NavigationPath<TestQueryRoute>.create(label: 'test');

        final routeA = TestQueryRoute('a');
        path.push(routeA);

        // Push same route again via pushOrMoveToTop
        final newRouteA = TestQueryRoute('a', queryParameters: {'a': 'b'});
        path.pushOrMoveToTop(newRouteA);
        await Future.delayed(const Duration(milliseconds: 100));

        expect(routeA.resultCompleted, isFalse);
        expect(path.stack.length, 1);
        expect(routeA.queryNotifier.value, {'a': 'b'});
        // Check the newRouteA queryNotifier is disposed
        expect(newRouteA.resultCompleted, isTrue);
        expect(newRouteA.stackPath, isNull);
        expect(
          () => newRouteA.queryNotifier.addListener(() {}),
          throwsFlutterError,
        );
      },
    );
  });

  group('RouteRedirect.resolve - Route Completion', () {
    test('completes original route when redirect is resolved', () async {
      final redirectRoute = RedirectRoute(redirectToId: 'target');

      // Must use RouteTarget as type parameter since RedirectRoute.redirect()
      // returns TestRoute which is not a subtype of RedirectRoute
      final result = await RouteRedirect.resolve<RouteTarget>(
        redirectRoute,
        null,
      );

      expect(result, isA<TestRoute>());
      expect((result as TestRoute).id, 'target');
      expect(redirectRoute.resultCompleted, isTrue);
      expect(redirectRoute.resultValue, isNull);
    });

    test('does not complete route when redirect returns null', () async {
      final nullRedirect = NullRedirectRoute();

      final result = await RouteRedirect.resolve<RouteTarget>(
        nullRedirect,
        TestCoordinator(),
      );

      // Should return original route
      expect(result, null);
      expect(nullRedirect.resultCompleted, isTrue);
    });

    test('does not complete route when redirect returns itself', () async {
      final selfRedirect = SelfRedirectRoute();

      final result = await RouteRedirect.resolve<RouteTarget>(
        selfRedirect,
        null,
      );

      // Should return the same route, no completion
      expect(result, same(selfRedirect));
      expect(selfRedirect.resultCompleted, isFalse);
    });

    test('completes all intermediate routes in redirect chain', () async {
      final innerRedirect = RedirectRoute(redirectToId: 'final');
      final outerRedirect = ChainedRedirectRoute(nextRedirect: innerRedirect);

      final result = await RouteRedirect.resolve<RouteTarget>(
        outerRedirect,
        null,
      );

      expect(result, isA<TestRoute>());
      expect((result as TestRoute).id, 'final');
      expect(outerRedirect.resultCompleted, isTrue);
      expect(innerRedirect.resultCompleted, isTrue);
    });
  });

  group('pushOrMoveToTop with RouteRedirect', () {
    test('handles redirect in pushOrMoveToTop', () async {
      final path = NavigationPath<RouteTarget>.create(label: 'test');

      final routeA = TestRoute('a');
      path.push(routeA);

      // Push redirect that resolves to a new route
      final redirect = RedirectRoute(redirectToId: 'b');
      path.pushOrMoveToTop(redirect);
      await Future.delayed(const Duration(milliseconds: 100));

      expect(path.stack.length, 2);
      expect((path.stack.last as TestRoute).id, 'b');
      expect(redirect.resultCompleted, isTrue);
    });

    test('pushOrMoveToTop with redirect to existing route moves it', () async {
      final path = NavigationPath<RouteTarget>.create(label: 'test');

      final routeA = TestRoute('a');
      final routeB = TestRoute('b');
      path.push(routeA);
      path.push(routeB);
      await Future.delayed(const Duration(milliseconds: 100));

      // Push redirect that resolves to 'a' (already in stack)
      final redirect = RedirectRoute(redirectToId: 'a');
      path.pushOrMoveToTop(redirect);
      await Future.delayed(const Duration(milliseconds: 100));

      // Redirect completes, original 'a' completes, new 'a' on top
      expect(redirect.resultCompleted, isTrue);
      expect(routeA.resultCompleted, isTrue);
      expect(path.stack.length, 2);
      expect((path.stack.last as TestRoute).id, 'a');
    });
  });

  group('NavigationPath.reset - Route Completion', () {
    test('completes all routes when path is reset', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      final routes = [TestRoute('a'), TestRoute('b'), TestRoute('c')];

      for (final route in routes) {
        path.push(route);
      }
      await Future.delayed(const Duration(milliseconds: 100));

      path.reset();

      for (final route in routes) {
        expect(route.resultCompleted, isTrue);
      }
      expect(path.stack, isEmpty);
    });
  });

  group('Memory leak prevention', () {
    testWidgets(
      'route completer does not hold reference after pop with result',
      (tester) async {
        final coordinator = TestCoordinator();
        final route = TestRoute('a');
        final routeTwo = TestRoute('b');

        await tester.pumpWidget(
          MaterialApp.router(
            routerDelegate: coordinator.routerDelegate,
            routeInformationParser: coordinator.routeInformationParser,
          ),
        );

        coordinator.push(route);
        final future = coordinator.push(routeTwo);

        await tester.pumpAndSettle(); // Fast-forwards the push animation

        // Pop the route with result
        coordinator.pop('result');

        // Fast-forwards the pop animation.
        // This ensures the animation completes and the route future resolves.
        await tester.pumpAndSettle();

        // Now the future is guaranteed to be complete in the FakeAsync zone
        final result = await future;

        expect(result, 'result');
        expect(route.resultCompleted, isFalse);
        expect(routeTwo.resultCompleted, isTrue);
      },
    );

    test('pushOrMoveToTop completes old route allowing GC', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');

      // Push route and hold reference to its future
      final route = TestRoute('a');
      final routeFuture = path.push(route);

      // Push another route
      path.push(TestRoute('b'));
      await Future.delayed(const Duration(milliseconds: 100));

      // Move original route to top (creates new instance)
      path.pushOrMoveToTop(TestRoute('a'));
      await Future.delayed(const Duration(milliseconds: 100));

      // Original route's future should be completed
      expect(route.resultCompleted, isTrue);

      // Future should resolve with null (not hang forever)
      final result = await routeFuture;
      expect(result, isNull);
    });

    test('chained redirects complete all intermediate futures', () async {
      // This tests that we don't leak completers in redirect chains
      final innerRedirect = RedirectRoute(redirectToId: 'final');
      final outerRedirect = ChainedRedirectRoute(nextRedirect: innerRedirect);

      final result = await RouteRedirect.resolve<RouteTarget>(
        outerRedirect,
        null,
      );

      // All intermediate routes should have their completers resolved
      expect(outerRedirect.resultCompleted, isTrue);
      expect(innerRedirect.resultCompleted, isTrue);

      // Final route should not be completed (it's the active route)
      expect((result as TestRoute).resultCompleted, isFalse);
    });

    test('remove() completes removed route future', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');
      final route = TestRoute('a');
      final route1 = TestRoute('b');

      path.push(route);
      path.push(route1);
      await Future.delayed(Duration.zero);

      path.remove(route);
      await Future.delayed(Duration.zero);
      path.remove(route1, discard: false);

      expect(path.stack, isEmpty);
      expect(route.resultCompleted, isTrue);
      // route1 is not completed because discard was set to false
      expect(route1.resultCompleted, isFalse);
      route1.onDiscard();
    });

    test('stress test: push multiple routes and reset cleans up all', () async {
      final path = NavigationPath<TestRoute>.create(label: 'test');
      final routes = List.generate(50, (i) => TestRoute('route_$i'));

      for (final route in routes) {
        path.push(route);
      }
      await Future.delayed(const Duration(milliseconds: 10)); // minimal delay

      expect(path.stack.length, 50);

      path.reset();

      for (final route in routes) {
        expect(route.resultCompleted, isTrue);
      }
      expect(path.stack, isEmpty);
    });
  });

  group('Route Guards - Edge Cases', () {
    test('pop() with guard rejection does not complete future', () async {
      final path = NavigationPath<RouteTarget>.create(label: 'test');

      // Route that refuses to pop
      final guardRoute = GuardRoute(allowPop: false);

      path.push(guardRoute);
      await Future.delayed(const Duration(milliseconds: 50));

      final popResult = await path.pop('result');

      expect(popResult, isFalse); // Pop rejected
      expect(guardRoute.resultCompleted, isFalse);
      expect(path.stack, contains(guardRoute));

      // Cleanup
      guardRoute.allowPop = true;
      path.pop();
    });
  });
}

class GuardRoute extends RouteTarget with RouteUnique, RouteGuard {
  GuardRoute({this.allowPop = false});
  bool allowPop;

  bool resultCompleted = false;

  @override
  void completeOnResult(
    Object? result,
    Coordinator<RouteUnique>? coordinator, [
    bool failSilent = false,
  ]) {
    resultCompleted = true;
    super.completeOnResult(result, coordinator, failSilent);
  }

  @override
  Future<bool> popGuard() async => allowPop;

  @override
  List<Object?> get props => [allowPop];

  @override
  Uri toUri() => Uri.parse('/guard');

  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return const Placeholder();
  }
}



================================================
FILE: packages/zenrouter_devtools/README.md
================================================
<div align="center">

<img alt="ZenRouter Logo" src="https://raw.githubusercontent.com/definev/zenrouter/main/assets/zenrouter_light_solid.png">

# ZenRouter DevTools

A powerful debugging tool for [ZenRouter](https://pub.dev/packages/zenrouter), providing a visual overlay to inspect navigation stacks, test deep links, and manage routes.

[![pub package](https://img.shields.io/pub/v/zenrouter_devtools.svg)](https://pub.dev/packages/zenrouter_devtools)
[![Codecov - zenrouter](https://codecov.io/gh/definev/zenrouter/branch/main/graph/badge.svg?flag=zenrouter)](https://app.codecov.io/gh/definev/zenrouter?branch=main&flags=zenrouter)

</div>

## Features

- **Visual Stack Inspection**: View the current navigation hierarchy, including active paths, nested routers, and their stack history.
- **Deep Link Testing**: Push or replace routes directly by entering a URI, making it easy to test deep linking logic.
- **Quick Actions**: Define common debug routes (e.g., specific screens, edge cases) and access them with a single click.
- **Route Management**: Pop routes from the stack or remove specific entries from history directly from the UI.
- **Stateful Shell Support**: Identify and navigate between stateful shell branches.

## Getting started

Add `zenrouter_devtools` to your `pubspec.yaml`:

```yaml
dev_dependencies:
  zenrouter_devtools: ^latest_version
```

## Usage

To enable the devtools, mix `CoordinatorDebug` into your `Coordinator` class.

### 1. Mixin `CoordinatorDebug`

```dart
class AppCoordinator extends Coordinator<AppRoute> with CoordinatorDebug<AppRoute> {
  // ... your existing coordinator implementation
}
```

### 2. Configure Debug Features (Optional)

You can customize the devtools by overriding properties in your coordinator:

```dart
class AppCoordinator extends Coordinator<AppRoute> with CoordinatorDebug<AppRoute> {
  
  // Only enable in debug mode
  @override
  bool get debugEnabled => kDebugMode;

  // Add quick-access debug routes
  @override
  List<AppRoute> get debugRoutes => [
    const LoginRoute(),
    const UserProfileRoute(id: '123'),
    const SettingsRoute(),
  ];

  // Customize how paths are labeled in the inspector
  @override
  String debugLabel(StackPath path) {
    if (path is NavigationPath) return 'Main Stack';
    return super.debugLabel(path);
  }
}
```

### 3. Accessing the Overlay

Once integrated, a floating action button (FAB) with a bug icon will appear in your app (by default). Click it to open the debug overlay.

- **Inspect Tab**: Shows the current navigation tree. You can see active paths, pop routes, and switch between stateful shell branches.
- **Routes Tab**: Lists your `debugRoutes` for quick navigation.
- **Input Area**: Type a URI (e.g., `/user/123`) and click "Push" or "Replace" to navigate.



================================================
FILE: packages/zenrouter_devtools/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options



================================================
FILE: packages/zenrouter_devtools/CHANGELOG.md
================================================
## 1.1.1
- **Feat**: Display correct `url` for each `RouteUnique`
- **Feat**: Display better type of `StackPath`
- **Feat**: Display `RouteLayout` in `Inspect Tab`

## 1.1.0
- **BREAKING**: Update dependency to `zenrouter: ^1.2.0`
- **Feat**: New sub module `Coordinator` aware in `Inspect Tab 
- **Feat**: Add `navigate` method
- **Fix**: Fix Increase close button size in `DebugOverlay`

## 1.0.0
- **BREAKING**: Update dependency to `zenrouter: ^1.0.0`
- Support for new `RouteRedirectRule` feature
- Compatible with zenrouter's modular coordinator architecture

## 0.4.5
- Add dependency on `cupertino_icons` fix blank icon in debug overlay

## 0.4.4
- Update `zenrouter` version

## 0.4.3 
- Remove toast notifications

## 0.4.2
- **Docs**: Update README

## 0.4.1
- **Docs**: Update README and add screenshots

## 0.4.0
- Create `example` app
- Update README.md

## 0.3.1
- Bump zenrouter version to 0.4.0

## 0.3.0

- Modularize `DebugOverlay` into separate tabs for better maintainability.
- Add **Problems** tab for detecting layout configuration issues (missing, duplicated, unknown paths).
- Add **Active** tab for visualizing the active layout hierarchy.
- UI improvements: standardized theming, better header, and tab reordering.
- Add support for `recover` function

## 0.2.0

- Bump `zenrouter` version

## 0.1.1

- Fix broken homepage link

## 0.1.0

- Initial release of ZenRouter DevTools.
- Visual debug overlay for inspecting navigation stacks.
- Deep link testing: Push or replace routes by URI.
- Quick access to predefined debug routes.
- Visual stack inspection with support for nested and stateful shells.



================================================
FILE: packages/zenrouter_devtools/LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Bui Dai Duong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: packages/zenrouter_devtools/pubspec.yaml
================================================
name: zenrouter_devtools
description: "Deeplink, Inspection, and Debugging Devtools for ZenRouter"
version: 1.2.0
homepage: https://github.com/definev/zenrouter/tree/main/packages/zenrouter_devtools

environment:
  sdk: ^3.7.0
  flutter: ">=3.0.0"

topics:
  - router
  - navigation
  - routing
  - deep-linking
  - web

resolution: workspace

dependencies:
  cupertino_icons: ^1.0.8
  flutter:
    sdk: flutter
  zenrouter: ^1.2.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:
  uses-material-design: true

  # To add assets to your package, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg
  #
  # For details regarding assets in packages, see
  # https://flutter.dev/to/asset-from-package
  #
  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # To add custom fonts to your package, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts in packages, see
  # https://flutter.dev/to/font-from-package



================================================
FILE: packages/zenrouter_devtools/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: package



================================================
FILE: packages/zenrouter_devtools/example/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml



================================================
FILE: packages/zenrouter_devtools/example/pubspec.lock
================================================
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: faf38497bda5ead2a8c7615f4f7939df04333478bf32e4173fcb06d428b5716b
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "3105dc8492f6183fb076ccf1f351ac3d60564bff92e20bfc4af9cc1651f4e7e1"
      url: "https://pub.dev"
    source: hosted
    version: "6.0.0"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "33e2e26bdd85a0112ec15400c8cbffea70d0f9c3407491f672a2fad47915e2de"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.2"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: "12f842a479589fea194fe5c5a3095abc7be0c1f2ddfa9a0e76aed1dbd26a87df"
      url: "https://pub.dev"
    source: hosted
    version: "6.1.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: "12956d0ad8390bbcc63ca2e1469c0619946ccb52809807067a7020d57e647aa6"
      url: "https://pub.dev"
    source: hosted
    version: "0.12.18"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: "9c337007e82b1889149c82ed242ed1cb24a66044e30979c44912381e9be4c48b"
      url: "https://pub.dev"
    source: hosted
    version: "0.13.0"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: "1741988757a65eb6b36abe716829688cf01910bbf91c34354ff7ec1c3de2b349"
      url: "https://pub.dev"
    source: hosted
    version: "1.18.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "56a02f1f4cd1a2d96303c0144c93bd6d909eea6bee6bf5a0e0b685edbd4c47ab"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.2"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "93167629bfc610f71560ab9312acdda4959de4df6fac7492c89ff0d3886f6636"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.9"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  zenrouter:
    dependency: "direct main"
    description:
      name: zenrouter
      sha256: "912641a603b28630f03a2ec5a4882cebf123d43f1d9de2ce0f3f83ea5604eb7d"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  zenrouter_devtools:
    dependency: "direct main"
    description:
      name: zenrouter_devtools
      sha256: "39b8baa1a3966115c10e4148ec008d6aabcc3c17f3044d8795879f49a7883549"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
sdks:
  dart: ">=3.9.0-0 <4.0.0"
  flutter: ">=3.18.0-18.0.pre.54"



================================================
FILE: packages/zenrouter_devtools/example/pubspec.yaml
================================================
name: example
description: "A new Flutter project."
publish_to: 'none'
version: 0.1.0+1

environment:
  sdk: ^3.8.0

dependencies:
  flutter:
    sdk: flutter
  zenrouter:
  zenrouter_devtools:
  
  cupertino_icons: ^1.0.8

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

flutter:
  uses-material-design: true



================================================
FILE: packages/zenrouter_devtools/example/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: android
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: ios
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: linux
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: macos
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: web
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: windows
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
FILE: packages/zenrouter_devtools/example/android/build.gradle.kts
================================================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}



================================================
FILE: packages/zenrouter_devtools/example/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true



================================================
FILE: packages/zenrouter_devtools/example/android/settings.gradle.kts
================================================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.11.1" apply false
    id("org.jetbrains.kotlin.android") version "2.2.20" apply false
}

include(":app")



================================================
FILE: packages/zenrouter_devtools/example/android/app/build.gradle.kts
================================================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "dev.zennn.router.example.example"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "dev.zennn.router.example.example"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/main/kotlin/dev/zennn/router/example/example/MainActivity.kt
================================================
package dev.zennn.router.example.example

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter_devtools/example/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter_devtools/example/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-all.zip



================================================
FILE: packages/zenrouter_devtools/example/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter_devtools/example/ios/Flutter/Debug.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter_devtools/example/ios/Flutter/Release.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Example</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>example</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
FILE: packages/zenrouter_devtools/example/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
FILE: packages/zenrouter_devtools/example/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter_devtools/example/lib/main.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';

void main() {
  runApp(MainApp());
}

class MainApp extends StatelessWidget {
  const MainApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: appCoordinator.routerDelegate,
      routeInformationParser: appCoordinator.routeInformationParser,
    );
  }
}

final appCoordinator = AppCoordinator();

abstract class AppRoute extends RouteTarget with RouteUnique {}

class CustomLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  StackPath<RouteUnique> resolvePath(AppCoordinator coordinator) =>
      coordinator.customIndexed;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);
    final size = MediaQuery.sizeOf(context);
    return Scaffold(
      body: switch (size.width) {
        < 600 => Column(
          children: [
            Expanded(child: buildPath(coordinator)),
            Container(
              height: 60,
              color: Colors.yellow,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  ElevatedButton(
                    child: Text('One'),
                    onPressed: () => coordinator.push(FirstLayout()),
                  ),
                  ElevatedButton(
                    child: Text('Two'),
                    onPressed: () => coordinator.push(SecondTab()),
                  ),
                  ElevatedButton(
                    child: Text('Three'),
                    onPressed: () => coordinator.push(ThirdTab()),
                  ),
                ],
              ),
            ),
          ],
        ),
        _ => Column(
          children: [
            Expanded(
              child: switch (path.activeRoute) {
                ThirdTab() => path.activeRoute!.build(coordinator, context),
                _ => Row(
                  children: [
                    Expanded(child: path.stack[0].build(coordinator, context)),
                    VerticalDivider(width: 1, color: Colors.amber),
                    Expanded(child: path.stack[1].build(coordinator, context)),
                  ],
                ),
              },
            ),
            Container(
              height: 60,
              color: Colors.yellow,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  ElevatedButton(
                    child: Text('One/Two'),
                    onPressed: () {
                      if (path.activeRoute is FirstLayout) {
                        coordinator.push(SecondTab());
                      } else {
                        coordinator.push(FirstLayout());
                      }
                    },
                  ),
                  ElevatedButton(
                    child: Text('Three'),
                    onPressed: () => coordinator.push(ThirdTab()),
                  ),
                ],
              ),
            ),
          ],
        ),
      },
    );
  }
}

class FirstLayout extends AppRoute with RouteLayout {
  @override
  Uri toUri() => Uri.parse('/first');

  @override
  Type get layout => CustomLayout;

  @override
  NavigationPath<AppRoute> resolvePath(AppCoordinator coordinator) =>
      coordinator.firstStack;
}

class FirstTab extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/first');

  @override
  Type get layout => FirstLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final activeIndex = coordinator.customIndexed.activeIndex;
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          spacing: 8,
          children: [
            Text(
              'First page ${activeIndex == 0 ? '(Focused)' : '(No focused)'}',
            ),
            FilledButton(
              onPressed: () =>
                  coordinator.push(FirstTabChild(message: "Hello")),
              child: Text('Go "Hello"'),
            ),
            FilledButton(
              onPressed: () => coordinator.push(FirstTabChild(message: "Ciao")),
              child: Text('Go "Ciao"'),
            ),
          ],
        ),
      ),
    );
  }
}

class FirstTabChild extends AppRoute {
  FirstTabChild({required this.message});

  final String message;

  @override
  Uri toUri() => Uri.parse('/first/$message');

  @override
  Type get layout => FirstLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('First Message: $message'),
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: Text('Go back'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  List<Object?> get props => [message];
}

class SecondTab extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/second');

  @override
  Type get layout => CustomLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final activeIndex = coordinator.customIndexed.activeIndex;
    return Scaffold(
      backgroundColor: Colors.red.shade100,
      body: Center(
        child: Text(
          'Second tab (${activeIndex == 1 ? 'Focused' : 'No focused'})',
        ),
      ),
    );
  }
}

class ThirdTab extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/third');

  @override
  Type get layout => CustomLayout;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final activeIndex = coordinator.customIndexed.activeIndex;
    return Scaffold(
      backgroundColor: Colors.blue.shade100,
      body: Center(
        child: Text(
          'Third tab (${activeIndex == 2 ? 'Focused' : 'No focused'})',
        ),
      ),
    );
  }
}

class NotFound extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(body: Center(child: Text('Not found')));
  }
}

class AppCoordinator extends Coordinator<AppRoute> with CoordinatorDebug {
  late final customIndexed = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'CustomIndexed',
    [FirstLayout(), SecondTab(), ThirdTab()],
  );
  late final firstStack = NavigationPath<AppRoute>.createWith(
    label: 'FirstStack',
    coordinator: this,
  );

  @override
  List<AppRoute> get debugRoutes => [
    FirstTab(),
    FirstTabChild(message: 'Hello'),
    FirstTabChild(message: 'Ciao'),
    SecondTab(),
    ThirdTab(),
    NotFound(),
  ];

  @override
  List<StackPath<RouteTarget>> get paths => [
    ...super.paths,
    customIndexed,
    firstStack,
  ];

  @override
  void defineLayout() {
    RouteLayout.defineLayout(CustomLayout, CustomLayout.new);
    RouteLayout.defineLayout(FirstLayout, FirstLayout.new);
  }

  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => FirstTab(),
      ['first'] => FirstTab(),
      ['first', final message] => FirstTabChild(message: message),
      ['second'] => SecondTab(),
      ['third'] => ThirdTab(),
      _ => NotFound(),
    };
  }
}



================================================
FILE: packages/zenrouter_devtools/example/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "dev.zennn.router.example.example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
FILE: packages/zenrouter_devtools/example/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
FILE: packages/zenrouter_devtools/example/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void fl_register_plugins(FlPluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter_devtools/example/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter_devtools/example/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter_devtools/example/linux/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")



================================================
FILE: packages/zenrouter_devtools/example/linux/runner/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
FILE: packages/zenrouter_devtools/example/linux/runner/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView* view) {
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "example");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "example");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(
      project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000
  // for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb),
                           self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application,
                                                  gchar*** arguments,
                                                  int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
    g_warning("Failed to register: %s", error->message);
    *exit_status = 1;
    return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line =
      my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID, "flags",
                                     G_APPLICATION_NON_UNIQUE, nullptr));
}



================================================
FILE: packages/zenrouter_devtools/example/linux/runner/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication,
                     my_application,
                     MY,
                     APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
FILE: packages/zenrouter_devtools/example/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter_devtools/example/macos/Flutter/Flutter-Release.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter_devtools/example/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation


func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
}



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = example

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = dev.zennn.router.example.example

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2025 dev.zennn.router.example. All rights reserved.



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter_devtools/example/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
FILE: packages/zenrouter_devtools/example/macos/RunnerTests/RunnerTests.swift
================================================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter_devtools/example/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>example</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <!--
    You can customize the "flutter_bootstrap.js" script.
    This is useful to provide a custom configuration to the Flutter loader
    or to give the user feedback during the initialization process.

    For more details:
    * https://docs.flutter.dev/platform-integration/web/initialization
  -->
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>



================================================
FILE: packages/zenrouter_devtools/example/web/manifest.json
================================================
{
    "name": "example",
    "short_name": "example",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}



================================================
FILE: packages/zenrouter_devtools/example/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
FILE: packages/zenrouter_devtools/example/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
FILE: packages/zenrouter_devtools/example/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void RegisterPlugins(flutter::PluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter_devtools/example/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter_devtools/example/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "dev.zennn.router.example" "\0"
            VALUE "FileDescription", "example" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "example" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 dev.zennn.router.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "example.exe" "\0"
            VALUE "ProductName", "example" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
FILE: packages/zenrouter_devtools/example/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_



================================================
FILE: packages/zenrouter_devtools/lib/zenrouter_devtools.dart
================================================
/// ZenRouter DevTools - Debug utilities for ZenRouter.
///
/// This library provides debugging tools for the ZenRouter navigation library.
/// The main feature is the [CoordinatorDebug] mixin that adds a debug overlay
/// to your app for inspecting and manipulating the navigation state.
library;

export 'src/coordinator_debug.dart';



================================================
FILE: packages/zenrouter_devtools/lib/src/coordinator_debug.dart
================================================
import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

import 'debug_overlay.dart';

/// Mixin to add debug capabilities to a [Coordinator].
///
/// This adds a floating debug button that opens an overlay showing:
/// - Current navigation stacks for all paths
/// - Ability to push routes by URI
/// - Ability to push pre-defined debug routes
///
/// ## Usage
///
/// ```dart
/// class AppCoordinator extends Coordinator<AppRoute> with CoordinatorDebug<AppRoute> {
///   @override
///   bool get debugEnabled => kDebugMode;
///
///   @override
///   List<AppRoute> get debugRoutes => [
///     AppRoute.home(),
///     AppRoute.settings(),
///     AppRoute.profile(userId: 'test'),
///   ];
///
///   @override
///   String debugLabel(StackPath path) {
///     // Return human-readable labels for paths
///     return path.toString();
///   }
/// }
/// ```
mixin CoordinatorDebug<T extends RouteUnique> on Coordinator<T> {
  // ===========================================================================
  // CONFIGURATION
  // ===========================================================================

  /// Toggle debug overlay visibility.
  ///
  /// Defaults to `true`. Override this to conditionally enable/disable
  /// the debug overlay (e.g., only in debug mode).
  bool get debugEnabled => true;

  /// Override this to provide a list of routes that can be quickly pushed
  /// from the debug overlay.
  ///
  /// This is useful for testing specific screens or flows without navigating
  /// through the app manually.
  List<T> get debugRoutes => [];

  /// Override this to provide a custom label for a navigation path.
  ///
  /// By default, it returns `path.toString()`. You can override this to
  /// provide more human-readable names for your paths in the debug overlay.
  String debugLabel(StackPath path) => path.debugLabel ?? path.toString();

  // ===========================================================================
  // STATE
  // ===========================================================================

  bool _debugOverlayOpen = false;

  /// Whether the debug overlay is currently open.
  bool get debugOverlayOpen => _debugOverlayOpen;

  /// Returns the number of "problems" or items that need attention.
  ///
  /// Currently, this counts the number of [debugRoutes] that fail to convert
  /// to a URI (i.e., [toUri] throws an exception). This helps identify
  /// routes that might be missing proper URI generation logic.
  int get problems =>
      debugRoutes.where((r) {
        try {
          r.toUri();
          return false;
        } catch (_) {
          return true;
        }
      }).length;

  // ===========================================================================
  // METHODS
  // ===========================================================================

  /// Toggles the visibility of the debug overlay.
  ///
  /// This method notifies listeners, which triggers a rebuild of the
  /// [layoutBuilder] to show or hide the overlay.
  void toggleDebugOverlay() {
    _debugOverlayOpen = !_debugOverlayOpen;
    notifyListeners();
  }

  // ===========================================================================
  // LAYOUT BUILDER OVERRIDE
  // ===========================================================================

  @override
  /// Wraps the application layout with the debug overlay.
  ///
  /// If [debugEnabled] is `false`, it simply returns the result of
  /// `super.layoutBuilder(context)`. Otherwise, it wraps the layout with
  /// a [ToastProvider] and an [Overlay] containing the [DebugOverlay].
  Widget layoutBuilder(BuildContext context) {
    if (!debugEnabled) return super.layoutBuilder(context);

    return Stack(
      children: [
        Builder(builder: (context) => super.layoutBuilder(context)),
        Overlay(
          initialEntries: [
            OverlayEntry(
              builder:
                  (context) => MediaQuery.fromView(
                    view: View.of(context),
                    child: DefaultTextStyle(
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.w400,
                        fontFamily: 'Inter',
                        height: 1.4,
                        decoration: TextDecoration.none,
                      ),
                      child: Builder(
                        builder: (context) {
                          final viewInsets = MediaQuery.viewInsetsOf(context);
                          final viewPadding = MediaQuery.viewPaddingOf(context);
                          return Padding(
                            padding: EdgeInsets.only(
                              bottom: switch (viewInsets.bottom) {
                                > 0 => viewInsets.bottom,
                                _ => viewPadding.bottom,
                              },
                            ),
                            child: DebugOverlay(coordinator: this),
                          );
                        },
                      ),
                    ),
                  ),
            ),
          ],
        ),
      ],
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/debug_overlay.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:zenrouter/zenrouter.dart';

import 'coordinator_debug.dart';
import 'tabs/tabs.dart';
import 'widgets/widgets.dart';

// =============================================================================
// DEBUG OVERLAY WIDGET
// =============================================================================

/// The main debug overlay widget that displays the debugging panel.
class DebugOverlay<T extends RouteUnique> extends StatefulWidget {
  /// Creates a debug overlay for the given [coordinator].
  const DebugOverlay({super.key, required this.coordinator});

  final CoordinatorDebug<T> coordinator;

  @override
  State<DebugOverlay<T>> createState() => _DebugOverlayState<T>();
}

class _DebugOverlayState<T extends RouteUnique> extends State<DebugOverlay<T>> {
  final TextEditingController _uriController = TextEditingController();

  // 0: Inspect, 1: Routes
  int _selectedTabIndex = 0;

  void _handleUriChanged() {
    final newPath = widget.coordinator.currentUri.toString();
    if (newPath != _uriController.text) {
      _uriController.text = newPath;
    }
  }

  @override
  void initState() {
    super.initState();
    widget.coordinator.addListener(_handleUriChanged);
  }

  @override
  void dispose() {
    _uriController.dispose();
    widget.coordinator.removeListener(_handleUriChanged);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (!widget.coordinator.debugOverlayOpen) {
      return _buildCollapsedView();
    }
    return _buildExpandedView();
  }

  // ===========================================================================
  // COLLAPSED VIEW
  // ===========================================================================

  Widget _buildCollapsedView() {
    return Align(
      alignment: Alignment.bottomRight,
      child: SafeArea(
        child: IntrinsicWidth(
          child: Padding(
            padding: const EdgeInsets.all(DebugTheme.spacingLg),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                ListenableBuilder(
                  listenable: _uriController,
                  builder:
                      (context, child) => Expanded(
                        child: Container(
                          decoration: BoxDecoration(
                            color: Color(0xFF000000).withValues(alpha: 0.6),
                            borderRadius: BorderRadius.circular(
                              DebugTheme.radiusFull,
                            ),
                          ),
                          height: 40,
                          margin: const EdgeInsets.only(
                            right: DebugTheme.spacingXs,
                          ),
                          padding: const EdgeInsets.symmetric(
                            horizontal: DebugTheme.spacingMd,
                          ),
                          child: Center(
                            child: Text(
                              _uriController.text,
                              style: const TextStyle(
                                color: Color(0xFFFFFFFF),
                                decoration: TextDecoration.none,
                                fontWeight: FontWeight.normal,
                                fontSize: DebugTheme.fontSizeMd,
                              ),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ),
                      ),
                ),
                _DebugFab(
                  problems: widget.coordinator.problems,
                  onTap: widget.coordinator.toggleDebugOverlay,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  // ===========================================================================
  // EXPANDED VIEW
  // ===========================================================================

  Widget _buildExpandedView() {
    return LayoutBuilder(
      builder: (context, constraints) {
        final isMobile = constraints.maxWidth < 600;
        final width = isMobile ? constraints.maxWidth : 420.0;
        final height = isMobile ? 400.0 : 500.0;
        final bottom = isMobile ? 0.0 : 16.0;
        final horizontal = isMobile ? 0.0 : 16.0;

        return Align(
          alignment: Alignment.bottomRight,
          child: Container(
            height: height,
            width: width,
            padding: EdgeInsets.only(
              bottom: bottom,
              right: horizontal,
              left: horizontal,
            ),
            child: Container(
              clipBehavior: Clip.antiAlias,
              decoration: BoxDecoration(
                color: DebugTheme.background,
                borderRadius: BorderRadius.circular(
                  isMobile ? 0 : DebugTheme.radiusLg,
                ),
                border: Border.all(color: DebugTheme.border),
                boxShadow: [
                  BoxShadow(
                    color: const Color(0xFF000000).withAlpha(50),
                    blurRadius: 24,
                    offset: const Offset(0, 8),
                  ),
                ],
              ),
              child: Column(
                children: [
                  _buildHeader(),
                  const _Divider(),
                  _buildTabBar(),
                  const _Divider(),
                  Expanded(
                    child: switch (_selectedTabIndex) {
                      0 => ProblemsTab<T>(coordinator: widget.coordinator),
                      1 => PathListView<T>(coordinator: widget.coordinator),
                      2 => ActiveLayoutsListView<T>(
                        coordinator: widget.coordinator,
                      ),
                      _ => DebugRoutesListView<T>(
                        coordinator: widget.coordinator,
                      ),
                    },
                  ),
                  const _Divider(),
                  _buildInputArea(),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  // ===========================================================================
  // HEADER
  // ===========================================================================

  Widget _buildHeader() {
    return Container(
      height: 40,
      color: DebugTheme.backgroundDark,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Row(
            children: [
              SizedBox(width: DebugTheme.spacing),
              ConnectionIndicator(),
              SizedBox(width: DebugTheme.spacing),
              Text(
                'ZenRouter Devtools',
                style: TextStyle(
                  color: DebugTheme.textPrimary,
                  fontSize: DebugTheme.fontSizeLg,
                  fontWeight: FontWeight.w600,
                  decoration: TextDecoration.none,
                ),
              ),
            ],
          ),
          GestureDetector(
            onTap: widget.coordinator.toggleDebugOverlay,
            child: Container(
              height: 32,
              width: 32,
              alignment: Alignment.center,
              color: DebugTheme.backgroundDark,
              margin: EdgeInsets.only(right: DebugTheme.spacing),
              child: const Icon(
                CupertinoIcons.xmark,
                color: DebugTheme.textDisabled,
                size: 16,
              ),
            ),
          ),
        ],
      ),
    );
  }

  // ===========================================================================
  // TAB BAR
  // ===========================================================================

  Widget _buildTabBar() {
    return Container(
      height: 36,
      color: DebugTheme.background,
      child: Row(
        children: [
          Expanded(
            child: TabButton(
              label: 'Problems',
              count: widget.coordinator.problems,
              isSelected: _selectedTabIndex == 0,
              onTap: () => setState(() => _selectedTabIndex = 0),
            ),
          ),
          const _VerticalDivider(),
          Expanded(
            child: TabButton(
              label: 'Inspect',
              isSelected: _selectedTabIndex == 1,
              onTap: () => setState(() => _selectedTabIndex = 1),
            ),
          ),
          const _VerticalDivider(),
          Expanded(
            child: TabButton(
              label: 'Active',
              isSelected: _selectedTabIndex == 2,
              onTap: () => setState(() => _selectedTabIndex = 2),
            ),
          ),
          if (widget.coordinator.debugRoutes.isNotEmpty) ...[
            const _VerticalDivider(),
            Expanded(
              child: TabButton(
                label: 'Routes',
                isSelected: _selectedTabIndex == 3,
                onTap: () => setState(() => _selectedTabIndex = 3),
              ),
            ),
          ],
        ],
      ),
    );
  }

  // ===========================================================================
  // INPUT AREA
  // ===========================================================================

  Widget _buildInputArea() {
    return Container(
      padding: const EdgeInsets.all(DebugTheme.spacingMd),
      color: DebugTheme.background,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            height: 36,
            decoration: BoxDecoration(
              color: DebugTheme.backgroundDark,
              borderRadius: BorderRadius.circular(DebugTheme.radius),
              border: Border.all(color: DebugTheme.border),
            ),
            child: Row(
              children: [
                Expanded(
                  child: CupertinoTextField(
                    controller: _uriController,
                    style: const TextStyle(
                      color: DebugTheme.textPrimary,
                      fontSize: DebugTheme.fontSizeLg,
                    ),
                    cursorColor: DebugTheme.textPrimary,
                    placeholder: 'Current path',
                    placeholderStyle: const TextStyle(
                      color: DebugTheme.textPlaceholder,
                    ),
                    decoration: const BoxDecoration(),
                    padding: const EdgeInsets.symmetric(
                      horizontal: DebugTheme.spacingMd,
                      vertical: 10,
                    ),
                    onSubmitted: _navigateUri,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: DebugTheme.spacing),
          Row(
            children: [
              Expanded(
                child: ActionButton(
                  label: 'Navigate',
                  icon: CupertinoIcons.arrow_right,
                  color: DebugTheme.textPrimary,
                  backgroundColor: const Color(0xFF222222),
                  onTap: () => _navigateUri(_uriController.text),
                ),
              ),
              const SizedBox(width: DebugTheme.spacing),
              Expanded(
                child: ActionButton(
                  label: 'Push',
                  icon: CupertinoIcons.arrow_up,
                  color: DebugTheme.textPrimary,
                  backgroundColor: const Color(0xFF222222),
                  onTap: () => _pushUri(_uriController.text),
                ),
              ),
              const SizedBox(width: DebugTheme.spacing),
              Expanded(
                child: ActionButton(
                  label: 'Replace',
                  icon: CupertinoIcons.arrow_swap,
                  color: DebugTheme.textPrimary,
                  backgroundColor: const Color(0xFF222222),
                  onTap: () => _replaceUri(_uriController.text),
                ),
              ),
              const SizedBox(width: DebugTheme.spacing),
              Expanded(
                child: ActionButton(
                  label: 'Recover',
                  icon: CupertinoIcons.link,
                  color: DebugTheme.textPrimary,
                  backgroundColor: const Color(0xFF222222),
                  onTap: () => _recoverUri(_uriController.text),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  // ===========================================================================
  // URI NAVIGATION METHODS
  // ===========================================================================

  void _navigateUri(String uriString) async {
    if (uriString.isEmpty) return;
    final uri = Uri.parse(uriString);
    final route = await widget.coordinator.parseRouteFromUri(uri);
    widget.coordinator.navigate(route!);
  }

  void _pushUri(String uriString) async {
    if (uriString.isEmpty) return;
    final uri = Uri.parse(uriString);
    final route = await widget.coordinator.parseRouteFromUri(uri);
    widget.coordinator.push(route!);
  }

  void _replaceUri(String uriString) async {
    if (uriString.isEmpty) return;
    final uri = Uri.parse(uriString);
    final route = await widget.coordinator.parseRouteFromUri(uri);
    widget.coordinator.replace(route!);
  }

  void _recoverUri(String uriString) async {
    if (uriString.isEmpty) return;
    final uri = Uri.parse(uriString);
    final route = await widget.coordinator.parseRouteFromUri(uri);
    widget.coordinator.recover(route!);
  }
}

// =============================================================================
// DEBUG FAB (Custom, no Material)
// =============================================================================

class _DebugFab extends StatefulWidget {
  const _DebugFab({required this.problems, required this.onTap});

  final int problems;
  final VoidCallback onTap;

  @override
  State<_DebugFab> createState() => _DebugFabState();
}

class _DebugFabState extends State<_DebugFab> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          width: 40,
          height: 40,
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color:
                _isHovered ? const Color(0xFF222222) : const Color(0xFF000000),
            shape: BoxShape.circle,
            border: Border.all(color: const Color(0x3DFFFFFF)),
            boxShadow: [
              BoxShadow(
                color: const Color(0xFF000000).withAlpha(100),
                blurRadius: 8,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: CountBadge(
            count: widget.problems,
            child: const Icon(
              CupertinoIcons.ant,
              color: Color(0xFFFFFFFF),
              size: 20,
            ),
          ),
        ),
      ),
    );
  }
}

// =============================================================================
// HELPER WIDGETS
// =============================================================================

class _Divider extends StatelessWidget {
  const _Divider();

  @override
  Widget build(BuildContext context) {
    return Container(height: 1, color: DebugTheme.border);
  }
}

class _VerticalDivider extends StatelessWidget {
  const _VerticalDivider();

  @override
  Widget build(BuildContext context) {
    return Container(width: 1, color: DebugTheme.border);
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/tabs/active_tab.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:zenrouter/zenrouter.dart';

import '../coordinator_debug.dart';
import '../widgets/badges.dart';
import '../widgets/debug_theme.dart';

class ActiveLayoutsListView<T extends RouteUnique> extends StatelessWidget {
  const ActiveLayoutsListView({super.key, required this.coordinator});

  final CoordinatorDebug<T> coordinator;

  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: coordinator,
      builder: (context, _) {
        final activeLayouts = coordinator.activeLayouts;
        final activeLayoutPaths = coordinator.activeLayoutPaths;

        if (activeLayouts.isEmpty) {
          return const Center(
            child: Text(
              'No active layouts.\nRoot path is the current active path.',
              style: TextStyle(
                color: DebugTheme.textDisabled,
                fontSize: DebugTheme.fontSizeMd,
                decoration: TextDecoration.none,
              ),
              textAlign: TextAlign.center,
            ),
          );
        }

        return ListView.builder(
          padding: const EdgeInsets.symmetric(vertical: DebugTheme.spacingXs),
          itemCount: activeLayouts.length,
          itemBuilder: (context, index) {
            final layout = activeLayouts[index];
            // activeLayoutPaths[0] is root, so layout at index 0 corresponds to path at index 1
            final path = activeLayoutPaths[index + 1];
            final isDeepest = index == activeLayouts.length - 1;

            return ActiveLayoutItem(
              layout: layout,
              path: path,
              depth: index,
              isDeepest: isDeepest,
            );
          },
        );
      },
    );
  }
}

class ActiveLayoutItem extends StatelessWidget {
  const ActiveLayoutItem({
    super.key,
    required this.layout,
    required this.path,
    required this.depth,
    required this.isDeepest,
  });

  final RouteLayout layout;
  final StackPath path;
  final int depth;
  final bool isDeepest;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: DebugTheme.spacingMd,
        vertical: DebugTheme.spacing,
      ),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: DebugTheme.borderDark)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Layout info row
          Row(
            children: [
              // Depth indicator
              ...List.generate(
                depth,
                (_) => Container(
                  width: 2,
                  height: 24,
                  margin: const EdgeInsets.only(right: DebugTheme.spacing),
                  color: DebugTheme.border,
                ),
              ),
              Icon(
                isDeepest
                    ? CupertinoIcons.layers_alt_fill
                    : CupertinoIcons.layers_alt,
                color:
                    isDeepest
                        ? const Color(0xFF2196F3)
                        : DebugTheme.textSecondary,
                size: 16,
              ),
              const SizedBox(width: DebugTheme.spacing),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Text(
                          layout.runtimeType.toString(),
                          style: TextStyle(
                            color:
                                isDeepest
                                    ? DebugTheme.textPrimary
                                    : DebugTheme.textSecondary,
                            fontSize: DebugTheme.fontSizeMd,
                            fontWeight: FontWeight.w600,
                            decoration: TextDecoration.none,
                          ),
                        ),
                        if (isDeepest) ...[
                          const SizedBox(width: DebugTheme.spacing),
                          const ActiveBadge(),
                        ],
                      ],
                    ),
                    const SizedBox(height: 2),
                    Text(
                      'Path: ${path.runtimeType}',
                      style: const TextStyle(
                        color: DebugTheme.textMuted,
                        fontSize: DebugTheme.fontSize,
                        decoration: TextDecoration.none,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          // Active route in this path
          if (path.activeRoute != null)
            Padding(
              padding: EdgeInsets.only(
                left: (depth * (2 + DebugTheme.spacing)) + 24,
                top: DebugTheme.spacingSm,
              ),
              child: Row(
                children: [
                  const Icon(
                    CupertinoIcons.arrow_turn_down_right,
                    color: DebugTheme.textDisabled,
                    size: 12,
                  ),
                  const SizedBox(width: DebugTheme.spacingXs),
                  Expanded(
                    child: Text(
                      path.activeRoute.toString(),
                      style: const TextStyle(
                        color: DebugTheme.textSecondary,
                        fontSize: DebugTheme.fontSize,
                        decoration: TextDecoration.none,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ),
            ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/tabs/inspect_tab.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:zenrouter/zenrouter.dart';

import '../coordinator_debug.dart';
import '../widgets/badges.dart';
import '../widgets/buttons.dart';
import '../widgets/debug_theme.dart';

class PathListView<T extends RouteUnique> extends StatelessWidget {
  const PathListView({super.key, required this.coordinator});

  final CoordinatorDebug<T> coordinator;

  @override
  Widget build(BuildContext context) {
    final groupedPaths = <Coordinator?, List<StackPath>>{};
    for (final path in coordinator.paths) {
      final key = path.proxyCoordinator;
      if (!groupedPaths.containsKey(key)) {
        groupedPaths[key] = [];
      }
      groupedPaths[key]!.add(path);
    }

    // Sort to ensure root (null) or specific order if needed.
    // Putting null (Root) first usually makes sense.
    final sortedKeys =
        groupedPaths.keys.toList()..sort((a, b) {
          if (a == null) return -1;
          if (b == null) return 1;
          return a.runtimeType.toString().compareTo(b.runtimeType.toString());
        });

    return ListenableBuilder(
      listenable: coordinator,
      builder: (context, _) {
        return _PathTabs<T>(
          coordinator: coordinator,
          groupedPaths: groupedPaths,
          sortedKeys: sortedKeys,
        );
      },
    );
  }
}

class _PathTabs<T extends RouteUnique> extends StatefulWidget {
  const _PathTabs({
    required this.coordinator,
    required this.groupedPaths,
    required this.sortedKeys,
  });

  final CoordinatorDebug<T> coordinator;
  final Map<Coordinator?, List<StackPath>> groupedPaths;
  final List<Coordinator?> sortedKeys;

  @override
  State<_PathTabs<T>> createState() => _PathTabsState<T>();
}

class _PathTabsState<T extends RouteUnique> extends State<_PathTabs<T>> {
  late PageController _pageController;
  int _selectedIndex = 0;
  StackPath? _lastActivePath;
  List<GlobalKey> _tabKeys = [];

  @override
  void initState() {
    super.initState();
    _updateTabKeys();
    _lastActivePath = widget.coordinator.activeLayoutPaths.lastOrNull;

    int initialIndex = 0;
    if (_lastActivePath != null) {
      final key = _lastActivePath!.proxyCoordinator;
      final index = widget.sortedKeys.indexOf(key);
      if (index != -1) initialIndex = index;
    }

    _selectedIndex = initialIndex;
    _pageController = PageController(initialPage: initialIndex);

    // Ensure initial tab is visible after build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) _ensureTabVisible(initialIndex);
    });
  }

  @override
  void didUpdateWidget(_PathTabs<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.sortedKeys.length != oldWidget.sortedKeys.length) {
      _updateTabKeys();
    }

    final newActivePath = widget.coordinator.activeLayoutPaths.lastOrNull;
    if (newActivePath != _lastActivePath) {
      _lastActivePath = newActivePath;
      _syncWithActivePath();
    }
  }

  void _updateTabKeys() {
    if (_tabKeys.length != widget.sortedKeys.length) {
      _tabKeys = List.generate(widget.sortedKeys.length, (_) => GlobalKey());
    }
  }

  void _ensureTabVisible(int index) {
    if (index < 0 || index >= _tabKeys.length) return;

    final context = _tabKeys[index].currentContext;
    if (context != null) {
      Scrollable.ensureVisible(
        context,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
        alignment: 0.5, // Center the tab
      );
    }
  }

  void _syncWithActivePath() {
    final activePath = _lastActivePath;
    if (activePath == null) return;

    final key = activePath.proxyCoordinator;
    final index = widget.sortedKeys.indexOf(key);

    if (index != -1 && index != _selectedIndex) {
      setState(() {
        _selectedIndex = index;
      });
      if (_pageController.hasClients) {
        _pageController.animateToPage(
          index,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
        );
      }
      _ensureTabVisible(index);
    }
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    if (widget.sortedKeys.isEmpty) {
      return const Center(
        child: Text(
          'No paths found',
          style: TextStyle(color: DebugTheme.textDisabled),
        ),
      );
    }

    return Column(
      children: [
        LayoutBuilder(
          builder:
              (context, constraints) => Container(
                width: constraints.maxWidth,
                decoration: const BoxDecoration(
                  border: Border(
                    bottom: BorderSide(color: DebugTheme.borderDark),
                  ),
                ),
                child: SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  child: Row(
                    children: [
                      for (int i = 0; i < widget.sortedKeys.length; i++)
                        _TabButton(
                          key: _tabKeys[i],
                          label:
                              widget.sortedKeys[i]?.toString() ??
                              widget.coordinator.toString(),
                          isSelected: i == _selectedIndex,
                          onTap: () {
                            setState(() {
                              _selectedIndex = i;
                            });
                            _pageController.jumpToPage(i);
                            _ensureTabVisible(i);
                          },
                        ),
                    ],
                  ),
                ),
              ),
        ),
        Expanded(
          child: PageView.builder(
            controller: _pageController,
            itemCount: widget.sortedKeys.length,
            onPageChanged: (index) {
              setState(() {
                _selectedIndex = index;
              });
              _ensureTabVisible(index);
            },
            itemBuilder: (context, index) {
              final key = widget.sortedKeys[index];
              final paths = widget.groupedPaths[key]!;
              return ListView.builder(
                padding: EdgeInsets.zero,
                itemCount: paths.length,
                itemBuilder: (context, pathIndex) {
                  final path = paths[pathIndex];
                  final isActiveLayout = widget.coordinator.activeLayoutPaths
                      .contains(path);
                  final isActive =
                      path == widget.coordinator.activeLayoutPaths.last;

                  final isReadOnly = path is IndexedStackPath;

                  return _PathItemView<T>(
                    coordinator: widget.coordinator,
                    path: path,
                    isActiveLayout: isActiveLayout,
                    isActive: isActive,
                    isReadOnly: isReadOnly,
                  );
                },
              );
            },
          ),
        ),
      ],
    );
  }
}

class _TabButton extends StatelessWidget {
  const _TabButton({
    super.key,
    required this.label,
    required this.isSelected,
    required this.onTap,
  });

  final String label;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: DebugTheme.spacingMd,
          vertical: DebugTheme.spacing,
        ),
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color:
                  isSelected ? DebugTheme.textPrimary : const Color(0x00000000),
              width: 2,
            ),
          ),
        ),
        child: Text(
          label,
          style: TextStyle(
            color:
                isSelected ? DebugTheme.textPrimary : DebugTheme.textDisabled,
            fontSize: DebugTheme.fontSizeXs,
            fontWeight: FontWeight.w600,
            letterSpacing: 0.5,
          ),
        ),
      ),
    );
  }
}

class _PathItemView<T extends RouteUnique> extends StatelessWidget {
  const _PathItemView({
    required this.coordinator,
    required this.path,
    required this.isActive,
    required this.isReadOnly,
    required this.isActiveLayout,
  });

  final CoordinatorDebug<T> coordinator;
  final StackPath path;
  final bool isActive;
  final bool isReadOnly;
  final bool isActiveLayout;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: DebugTheme.borderDark)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildPathHeader(),
          if (path.stack.isEmpty)
            Container(
              height: 52,
              decoration: BoxDecoration(
                border: Border(top: BorderSide(color: DebugTheme.borderDark)),
              ),
              child: Center(
                child: Text(
                  'No active route in this path',
                  style: TextStyle(
                    color: DebugTheme.textDisabled,
                    fontSize: DebugTheme.fontSizeSm,
                  ),
                ),
              ),
            ),
          if (path.stack.isNotEmpty) ..._buildRouteItems(),
        ],
      ),
    );
  }

  Widget _buildPathHeader() {
    return Container(
      padding: const EdgeInsets.only(
        left: DebugTheme.spacing,
        right: DebugTheme.spacing,
        top: DebugTheme.spacing,
        bottom: DebugTheme.spacing,
      ),
      color: isActive ? DebugTheme.backgroundLight : const Color(0x00000000),
      child: Row(
        children: [
          Expanded(
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        coordinator.debugLabel(path),
                        style: TextStyle(
                          color:
                              isActive
                                  ? DebugTheme.textPrimary
                                  : DebugTheme.textMuted,
                          fontSize: DebugTheme.fontSizeMd,
                          fontWeight: FontWeight.w500,
                          decoration: TextDecoration.none,
                        ),
                      ),
                      Text(
                        path.pathKey.key,
                        style: TextStyle(
                          color: DebugTheme.textMuted,
                          fontSize: DebugTheme.fontSizeSm,
                          fontFamily: 'monospace',
                          fontWeight: FontWeight.normal,
                          decoration: TextDecoration.none,
                          fontStyle: FontStyle.italic,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                  ),
                ),
                if (isActive) ...[
                  const SizedBox(width: DebugTheme.spacing),
                  const ActiveBadge(),
                ],
                const SizedBox(width: DebugTheme.spacing),
              ],
            ),
          ),
          // Only show pop button for non-read-only paths
          if (path.stack.isNotEmpty && path is NavigationPath)
            SmallIconButton(
              icon: CupertinoIcons.arrow_left,
              onTap:
                  path.stack.length > 1
                      ? () async {
                        await (path as NavigationPath).pop();
                      }
                      : null,
              color:
                  path.stack.length > 1
                      ? DebugTheme.textPrimary
                      : DebugTheme.textDisabled,
            ),
        ],
      ),
    );
  }

  List<Widget> _buildRouteItems() {
    if (isReadOnly && path is IndexedStackPath) {
      final indexedPath = path as IndexedStackPath;
      return path.stack.indexed.map((data) {
        final (routeIndex, route) = data;
        final isRouteActive =
            (isActive || isActiveLayout) &&
            routeIndex == indexedPath.activeIndex;

        return _ReadOnlyRouteItem(
          route: route as RouteUnique,
          routeIndex: routeIndex,
          isRouteActive: isRouteActive,
          readOnlyPath: indexedPath,
        );
      }).toList();
    }

    return path.stack.reversed.indexed.map((data) {
      final (index, route) = data;
      final isTop = index == 0;
      final isRouteActive = isActive && isTop;

      return _NavigationRouteItem(
        route: route as RouteUnique,
        isTop: isTop,
        isRouteActive: isRouteActive,
        path: path,
      );
    }).toList();
  }
}

class _ReadOnlyRouteItem extends StatefulWidget {
  const _ReadOnlyRouteItem({
    required this.route,
    required this.routeIndex,
    required this.isRouteActive,
    required this.readOnlyPath,
  });

  final RouteUnique route;
  final int routeIndex;
  final bool isRouteActive;
  final IndexedStackPath readOnlyPath;

  @override
  State<_ReadOnlyRouteItem> createState() => _ReadOnlyRouteItemState();
}

class _ReadOnlyRouteItemState extends State<_ReadOnlyRouteItem> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: () async {
          await widget.readOnlyPath.goToIndexed(widget.routeIndex);
        },
        child: Container(
          padding: const EdgeInsets.only(
            left: DebugTheme.spacing,
            right: DebugTheme.spacing,
            top: DebugTheme.spacingSm,
            bottom: DebugTheme.spacingSm,
          ),
          color:
              widget.isRouteActive || _isHovered
                  ? DebugTheme.backgroundDark
                  : const Color(0x00000000),
          child: Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.route.toString(),
                      style: TextStyle(
                        color:
                            widget.isRouteActive
                                ? DebugTheme.textPrimary
                                : DebugTheme.textSecondary,
                        fontSize: DebugTheme.fontSize,
                        fontWeight:
                            widget.isRouteActive
                                ? FontWeight.w600
                                : FontWeight.normal,
                        decoration: TextDecoration.none,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                    Text(
                      widget.route.toUri().toString(),
                      style: TextStyle(
                        color: DebugTheme.textMuted,
                        fontSize: DebugTheme.fontSizeSm,
                        fontFamily: 'monospace',
                        fontWeight:
                            widget.isRouteActive
                                ? FontWeight.w600
                                : FontWeight.normal,
                        decoration: TextDecoration.none,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              Icon(
                widget.isRouteActive
                    ? CupertinoIcons.circle_fill
                    : CupertinoIcons.circle,
                size: 16,
                color:
                    widget.isRouteActive
                        ? const Color(0xFF2196F3)
                        : DebugTheme.textDisabled,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _NavigationRouteItem extends StatelessWidget {
  const _NavigationRouteItem({
    required this.route,
    required this.isTop,
    required this.isRouteActive,
    required this.path,
  });

  final RouteUnique route;
  final bool isTop;
  final bool isRouteActive;
  final StackPath path;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.only(
        left: DebugTheme.spacing,
        right: DebugTheme.spacing,
        top: DebugTheme.spacingSm,
        bottom: DebugTheme.spacingSm,
      ),
      color: isTop ? DebugTheme.backgroundDark : const Color(0x00000000),
      child: Row(
        children: [
          Expanded(
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        route.toString(),
                        style: TextStyle(
                          color:
                              isTop
                                  ? DebugTheme.textPrimary
                                  : DebugTheme.textSecondary,
                          fontSize: DebugTheme.fontSize,
                          fontFamily: 'monospace',
                          fontWeight:
                              isTop ? FontWeight.w600 : FontWeight.normal,
                          decoration: TextDecoration.none,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                      if (route is! RouteLayout)
                        Text(
                          route.toUri().toString(),
                          style: TextStyle(
                            color: DebugTheme.textMuted,
                            fontSize: DebugTheme.fontSizeSm,
                            fontFamily: 'monospace',
                            fontWeight:
                                isTop ? FontWeight.w600 : FontWeight.normal,
                            decoration: TextDecoration.none,
                          ),
                          overflow: TextOverflow.ellipsis,
                        ),
                    ],
                  ),
                ),
                if (route is RouteLayout) ...[const LayoutBadge()],
                if (isRouteActive) ...[
                  const SizedBox(width: DebugTheme.spacing),
                  const ActiveIndicator(),
                ],
                const SizedBox(width: DebugTheme.spacing),
              ],
            ),
          ),
          if (path case StackMutatable path)
            SmallIconButton(
              icon: CupertinoIcons.xmark,
              onTap: path.stack.length > 1 ? () => path.remove(route) : null,
              color: const Color(0xFFEF9A9A),
            ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/tabs/problems_tab.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_devtools/src/widgets/debug_theme.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';

class ProblemsTab<T extends RouteUnique> extends StatelessWidget {
  const ProblemsTab({super.key, required this.coordinator});

  final CoordinatorDebug<T> coordinator;

  @override
  Widget build(BuildContext context) {
    // 1. Get all paths known to coordinator (excluding root)
    final userPaths =
        coordinator.paths.where((p) => p != coordinator.root).toSet();

    // 2. Instantiate all registered layouts
    final layouts =
        RouteLayout.layoutConstructorTable.values
            .map((constructor) => constructor())
            .toList();

    // 3. Map paths to the layouts that claim them
    final pathLayoutMap = <StackPath, List<RouteLayout>>{};
    for (final layout in layouts) {
      final path = layout.resolvePath(coordinator);
      pathLayoutMap.putIfAbsent(path, () => []).add(layout);
    }

    final problems = <Widget>[];

    // CHECK 1: Duplicated Paths (Multiple layouts claim the same path)
    pathLayoutMap.forEach((path, layouts) {
      if (layouts.length > 1) {
        problems.add(
          _LayoutProblem(
            path: path,
            type: _LayoutProblemType.duplicatedPath,
            relatedLayouts: layouts,
            coordinator: coordinator,
          ),
        );
      }
    });

    // CHECK 2: Layout Missing (Path exists in coordinator but no layout claims it)
    for (final path in userPaths) {
      if (!pathLayoutMap.containsKey(path)) {
        problems.add(
          _LayoutProblem(
            path: path,
            type: _LayoutProblemType.missingLayout,
            coordinator: coordinator,
          ),
        );
      }
    }

    // CHECK 3: Unknown Path (Layout claims a path not in coordinator)
    for (final path in pathLayoutMap.keys) {
      if (!userPaths.contains(path) && path != coordinator.root) {
        problems.add(
          _LayoutProblem(
            path: path,
            type: _LayoutProblemType.unknownPath,
            coordinator: coordinator,
          ),
        );
      }
    }

    if (problems.isEmpty) {
      return const Center(
        child: Text(
          'No problems found.',
          style: TextStyle(
            color: DebugTheme.textDisabled,
            fontSize: DebugTheme.fontSizeMd,
            decoration: TextDecoration.none,
          ),
          textAlign: TextAlign.center,
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: DebugTheme.spacingXs),
      itemCount: problems.length,
      itemBuilder: (context, index) {
        return problems[index];
      },
    );
  }
}

enum _LayoutProblemType { missingLayout, duplicatedPath, unknownPath }

class _LayoutProblem extends StatelessWidget {
  const _LayoutProblem({
    required this.path,
    required this.type,
    required this.coordinator,
    this.relatedLayouts = const [],
  });

  final StackPath path;
  final _LayoutProblemType type;
  final CoordinatorDebug coordinator;
  final List<RouteLayout> relatedLayouts;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: DebugTheme.spacingMd,
        vertical: DebugTheme.spacing,
      ),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: DebugTheme.borderDark)),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            CupertinoIcons.exclamationmark_triangle_fill,
            color:
                type == _LayoutProblemType.duplicatedPath
                    ? const Color(0xFFEF5350) // Red for duplicate (critical)
                    : const Color(0xFFE85600), // Orange for others
            size: 16,
          ),
          const SizedBox(width: DebugTheme.spacing),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  switch (type) {
                    _LayoutProblemType.missingLayout => 'Layout Missing',
                    _LayoutProblemType.duplicatedPath => 'Duplicated Layouts',
                    _LayoutProblemType.unknownPath => 'Unknown Path',
                  },
                  style: const TextStyle(
                    color: DebugTheme.textPrimary,
                    fontSize: DebugTheme.fontSizeMd,
                    fontWeight: FontWeight.w600,
                    decoration: TextDecoration.none,
                  ),
                ),
                const SizedBox(height: 2),
                _buildMessage(),
                const SizedBox(height: 4),
                Text.rich(
                  TextSpan(
                    text: 'Path: ',
                    style: const TextStyle(
                      color: DebugTheme.textMuted,
                      fontSize: DebugTheme.fontSize,
                      decoration: TextDecoration.none,
                    ),
                    children: [_codeSpan(coordinator.debugLabel(path))],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMessage() {
    switch (type) {
      case _LayoutProblemType.missingLayout:
        return Text.rich(
          TextSpan(
            text: 'Forget to bind layout, you must use ',
            style: const TextStyle(
              color: DebugTheme.textSecondary,
              fontSize: DebugTheme.fontSize,
              decoration: TextDecoration.none,
            ),
            children: [
              _codeSpan('defineLayout'),
              const TextSpan(text: ' to define associated '),
              _codeSpan('RouteLayout'),
              const TextSpan(text: ' that owns '),
              _codeSpan(path.toString()),
            ],
          ),
        );
      case _LayoutProblemType.duplicatedPath:
        final layoutNames = relatedLayouts
            .map((l) => l.runtimeType.toString())
            .join(', ');
        return Text.rich(
          TextSpan(
            text: 'Multiple layouts are claiming the same path ',
            style: const TextStyle(
              color: DebugTheme.textSecondary,
              fontSize: DebugTheme.fontSize,
              decoration: TextDecoration.none,
            ),
            children: [
              _codeSpan(path.toString()),
              const TextSpan(text: '. Layouts found: '),
              _codeSpan(layoutNames),
            ],
          ),
        );
      case _LayoutProblemType.unknownPath:
        return Text.rich(
          TextSpan(
            text: 'Layout maps to path ',
            style: const TextStyle(
              color: DebugTheme.textSecondary,
              fontSize: DebugTheme.fontSize,
              decoration: TextDecoration.none,
            ),
            children: [
              _codeSpan(path.toString()),
              const TextSpan(text: ' but this path is not registered in '),
              _codeSpan('AppCoordinator.paths'),
            ],
          ),
        );
    }
  }

  TextSpan _codeSpan(String text) {
    return TextSpan(
      text: text,
      style: const TextStyle(
        color: DebugTheme.textPrimary,
        backgroundColor: Color(0xFF333333),
        fontFamily: 'monospace',
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/tabs/routes_tab.dart
================================================
import 'package:flutter/cupertino.dart';
import 'package:zenrouter/zenrouter.dart';

import '../coordinator_debug.dart';
import '../widgets/buttons.dart';
import '../widgets/debug_theme.dart';

class DebugRoutesListView<T extends RouteUnique> extends StatelessWidget {
  const DebugRoutesListView({super.key, required this.coordinator});

  final CoordinatorDebug<T> coordinator;

  @override
  Widget build(BuildContext context) {
    if (coordinator.debugRoutes.isEmpty) {
      return const Center(
        child: Text(
          'No debug routes defined.\nOverride debugRoutes in your coordinator.',
          style: TextStyle(
            color: DebugTheme.textDisabled,
            fontSize: DebugTheme.fontSizeMd,
            decoration: TextDecoration.none,
          ),
          textAlign: TextAlign.center,
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: DebugTheme.spacingXs),
      itemCount: coordinator.debugRoutes.length,
      itemBuilder: (context, index) {
        final route = coordinator.debugRoutes[index];
        return DebugRouteItem<T>(route: route, coordinator: coordinator);
      },
    );
  }
}

class DebugRouteItem<T extends RouteUnique> extends StatelessWidget {
  const DebugRouteItem({
    super.key,
    required this.route,
    required this.coordinator,
  });

  final T route;
  final CoordinatorDebug<T> coordinator;

  String get _status {
    try {
      return route.toUri().toString();
    } catch (_) {
      return 'needs implementation [toUri]';
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: DebugTheme.spacingMd,
        vertical: DebugTheme.spacingSm,
      ),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: DebugTheme.borderDark)),
      ),
      child: Row(
        children: [
          Expanded(
            child: Text.rich(
              TextSpan(
                text: route.toString(),
                style: const TextStyle(
                  color: DebugTheme.textPrimary,
                  fontSize: DebugTheme.fontSizeMd,
                  decoration: TextDecoration.none,
                ),
                children: [
                  TextSpan(
                    text: ' $_status',
                    style: TextStyle(
                      color: switch (_status) {
                        'needs implementation [toUri]' => const Color(
                          0xFFE85600,
                        ),
                        _ => DebugTheme.textSecondary,
                      },
                      fontSize: DebugTheme.fontSizeMd,
                      decoration: TextDecoration.none,
                    ),
                  ),
                ],
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          const SizedBox(width: DebugTheme.spacingXs),
          SmallIconButton(
            icon: CupertinoIcons.arrow_right,
            onTap: () {
              coordinator.navigate(route);
            },
          ),
          const SizedBox(width: DebugTheme.spacingXs),
          SmallIconButton(
            icon: CupertinoIcons.add,
            onTap: () {
              coordinator.push(route);
            },
          ),
          const SizedBox(width: DebugTheme.spacingXs),
          SmallIconButton(
            icon: CupertinoIcons.arrow_swap,
            onTap: () {
              coordinator.replace(route);
            },
          ),
          const SizedBox(width: DebugTheme.spacingXs),
          SmallIconButton(
            icon: CupertinoIcons.link,
            onTap: () {
              coordinator.recover(route);
            },
          ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/tabs/tabs.dart
================================================
export 'active_tab.dart';
export 'inspect_tab.dart';
export 'routes_tab.dart';
export 'problems_tab.dart';



================================================
FILE: packages/zenrouter_devtools/lib/src/widgets/badges.dart
================================================
import 'package:flutter/widgets.dart';

import 'debug_theme.dart';

// =============================================================================
// STATUS BADGES
// =============================================================================

/// A badge indicating the "active" status of a path or route.
class ActiveBadge extends StatelessWidget {
  const ActiveBadge({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: DebugTheme.spacingXs,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: const Color(0xFF2196F3),
        borderRadius: BorderRadius.circular(DebugTheme.radiusSm),
      ),
      child: const Text(
        'ACTIVE',
        style: TextStyle(
          color: Color(0xFFFFFFFF),
          fontSize: DebugTheme.fontSizeXs,
          fontWeight: FontWeight.bold,
          decoration: TextDecoration.none,
        ),
      ),
    );
  }
}

/// A badge indicating a layout route.
class LayoutBadge extends StatelessWidget {
  const LayoutBadge({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: DebugTheme.spacingXs,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: const Color(0xFF9C27B0).withAlpha(100),
        borderRadius: BorderRadius.circular(DebugTheme.radiusSm),
      ),
      child: const Text(
        'LAYOUT',
        style: TextStyle(
          color: Color(0xFF9C27B0),
          fontSize: DebugTheme.fontSizeXs,
          fontWeight: FontWeight.bold,
          decoration: TextDecoration.none,
        ),
      ),
    );
  }
}

/// A small indicator dot showing active status.
class ActiveIndicator extends StatelessWidget {
  const ActiveIndicator({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 6,
      height: 6,
      decoration: const BoxDecoration(
        color: Color(0xFF2196F3),
        shape: BoxShape.circle,
      ),
    );
  }
}

/// A small indicator dot showing connection status.
class ConnectionIndicator extends StatelessWidget {
  const ConnectionIndicator({super.key, this.isConnected = true});

  final bool isConnected;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 8,
      height: 8,
      decoration: BoxDecoration(
        color: isConnected ? const Color(0xFF4CAF50) : const Color(0xFFF44336),
        shape: BoxShape.circle,
      ),
    );
  }
}

/// A badge that shows a count on top of an icon.
class CountBadge extends StatelessWidget {
  const CountBadge({super.key, required this.count, required this.child});

  final int count;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Stack(
      clipBehavior: Clip.none,
      children: [
        child,
        if (count > 0)
          Positioned(
            right: -6,
            top: -6,
            child: Container(
              padding: const EdgeInsets.all(4),
              decoration: const BoxDecoration(
                color: Color(0xFFF44336),
                shape: BoxShape.circle,
              ),
              constraints: const BoxConstraints(minWidth: 16, minHeight: 16),
              child: Text(
                count.toString(),
                style: const TextStyle(
                  color: Color(0xFFFFFFFF),
                  fontSize: 10,
                  fontWeight: FontWeight.bold,
                  decoration: TextDecoration.none,
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ),
      ],
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/widgets/buttons.dart
================================================
import 'package:flutter/widgets.dart';

import 'debug_theme.dart';

// =============================================================================
// SMALL ICON BUTTON
// =============================================================================

/// A small icon button used in the debug overlay for actions like
/// pop, remove, and navigation.
class SmallIconButton extends StatefulWidget {
  const SmallIconButton({
    super.key,
    required this.icon,
    required this.onTap,
    this.color,
  });

  final IconData icon;
  final VoidCallback? onTap;
  final Color? color;

  @override
  State<SmallIconButton> createState() => _SmallIconButtonState();
}

class _SmallIconButtonState extends State<SmallIconButton> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          width: 20,
          height: 20,
          alignment: Alignment.center,
          decoration: BoxDecoration(
            border: Border.all(color: DebugTheme.border),
            borderRadius: BorderRadius.circular(DebugTheme.radiusSm),
            color:
                _isHovered && widget.onTap != null
                    ? DebugTheme.backgroundLight
                    : DebugTheme.backgroundDark,
          ),
          child: Icon(
            widget.icon,
            size: 11,
            color:
                widget.onTap != null
                    ? (widget.color ?? DebugTheme.textPrimary)
                    : DebugTheme.textPlaceholder,
          ),
        ),
      ),
    );
  }
}

// =============================================================================
// ACTION BUTTON
// =============================================================================

/// A styled action button used for Push, Replace, and Recover actions.
class ActionButton extends StatefulWidget {
  const ActionButton({
    super.key,
    required this.label,
    required this.onTap,
    required this.color,
    required this.backgroundColor,
    this.icon,
  });

  final IconData? icon;
  final String label;
  final VoidCallback onTap;
  final Color color;
  final Color backgroundColor;

  @override
  State<ActionButton> createState() => _ActionButtonState();
}

class _ActionButtonState extends State<ActionButton> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          height: 28,
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color:
                _isHovered
                    ? DebugTheme.backgroundLight
                    : widget.backgroundColor,
            borderRadius: BorderRadius.circular(DebugTheme.radius),
            border: Border.all(color: DebugTheme.border),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                widget.label,
                style: TextStyle(
                  color: widget.color,
                  fontSize: DebugTheme.fontSize,
                  fontWeight: FontWeight.w500,
                  decoration: TextDecoration.none,
                ),
              ),
              if (widget.icon != null) ...[
                const SizedBox(width: DebugTheme.spacing),
                Icon(widget.icon, color: widget.color, size: 11),
              ],
            ],
          ),
        ),
      ),
    );
  }
}

// =============================================================================
// TAB BUTTON
// =============================================================================

/// A tab button used in the debug overlay's tab bar.
class TabButton extends StatefulWidget {
  const TabButton({
    super.key,
    required this.label,
    required this.isSelected,
    required this.onTap,
    this.count = 0,
  });

  final String label;
  final bool isSelected;
  final VoidCallback onTap;
  final int count;

  @override
  State<TabButton> createState() => _TabButtonState();
}

class _TabButtonState extends State<TabButton> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTap: widget.onTap,
        child: Container(
          alignment: Alignment.center,
          decoration: BoxDecoration(
            color:
                widget.isSelected || _isHovered
                    ? DebugTheme.backgroundLight
                    : const Color(0x00000000),
            border:
                widget.isSelected
                    ? const Border(
                      bottom: BorderSide(color: Color(0xFFFFFFFF), width: 2),
                    )
                    : null,
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                widget.label,
                style: TextStyle(
                  color:
                      widget.isSelected
                          ? DebugTheme.textPrimary
                          : DebugTheme.textDisabled,
                  fontSize: DebugTheme.fontSizeMd,
                  fontWeight:
                      widget.isSelected ? FontWeight.w600 : FontWeight.w500,
                  decoration: TextDecoration.none,
                ),
              ),
              if (widget.count > 0) ...[
                const SizedBox(width: DebugTheme.spacingSm),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: DebugTheme.spacingXs,
                    vertical: 1,
                  ),
                  decoration: BoxDecoration(
                    color: const Color(0xFFB71C1C).withAlpha(150),
                    borderRadius: BorderRadius.circular(DebugTheme.radiusSm),
                  ),
                  child: Text(
                    widget.count.toString(),
                    style: const TextStyle(
                      color: Color(0xFFFFCDD2),
                      fontSize: DebugTheme.fontSizeSm,
                      fontWeight: FontWeight.bold,
                      decoration: TextDecoration.none,
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_devtools/lib/src/widgets/debug_theme.dart
================================================
import 'package:flutter/material.dart';

/// Theme constants for the debug overlay UI.
///
/// Centralizes all color and style constants to ensure consistency
/// across the debug overlay components.
abstract final class DebugTheme {
  // Background colors
  static const Color background = Color(0xFF0A0A0A);
  static const Color backgroundDark = Color(0xFF111111);
  static const Color backgroundLight = Color(0xFF1A1A1A);

  // Border colors
  static const Color border = Color(0xFF333333);
  static const Color borderDark = Color(0xFF222222);
  static const Color borderLight = Color(0xFF2A2A2A);

  // Text colors
  static const Color textPrimary = Color(0xFFEDEDED);
  static const Color textSecondary = Color(0xFF999999);
  static const Color textMuted = Color(0xFF888888);
  static const Color textDisabled = Color(0xFF666666);
  static const Color textPlaceholder = Color(0xFF444444);

  // Font sizes
  static const double fontSizeXs = 8.0;
  static const double fontSizeSm = 10.0;
  static const double fontSize = 11.0;
  static const double fontSizeMd = 12.0;
  static const double fontSizeLg = 13.0;
  static const double fontSizeXl = 14.0;

  // Spacing
  static const double spacingXs = 4.0;
  static const double spacingSm = 6.0;
  static const double spacing = 8.0;
  static const double spacingMd = 12.0;
  static const double spacingLg = 16.0;

  // Border radius
  static const double radiusSm = 4.0;
  static const double radius = 6.0;
  static const double radiusMd = 8.0;
  static const double radiusLg = 12.0;
  static const double radiusFull = 100.0;
}



================================================
FILE: packages/zenrouter_devtools/lib/src/widgets/widgets.dart
================================================
/// Barrel file exporting all widget components.
library;

export 'badges.dart';
export 'buttons.dart';
export 'debug_theme.dart';



================================================
FILE: packages/zenrouter_docs/README.md
================================================
# ZenRouter Documentation

Interactive documentation application for ZenRouter - teaching the Coordinator pattern and file-based routing by embodying these patterns in its own architecture.

## Overview

This Flutter web application serves as the official documentation for ZenRouter, demonstrating best practices and patterns through its own implementation.

## Development

### Running the App

```bash
flutter run -d chrome
```

### Building for Web

```bash
flutter build web
```

## Assets & Icons

### Logo Files

The project includes two logo variants:
- `assets/logo_light.png` - Light theme logo (512x512)
- `assets/logo_dark.png` - Dark theme logo (512x512)

### Generating App Icons & Favicons

This project uses [`icons_launcher`](https://pub.dev/packages/icons_launcher) to automatically generate app icons and favicons for all platforms from the logo.

To regenerate icons after updating the logo:

```bash
dart run icons_launcher:create
```

This will generate:
- **Android**: App icons for all densities (mdpi, hdpi, xhdpi, xxhdpi, xxxhdpi)
- **iOS**: App icons for all required sizes (iPhone, iPad, App Store)
- **Web**: Favicons (16x16, 32x32, 48x48) and PWA icons (192x192, 512x512)

### Icon Configuration

The icon configuration is defined in `pubspec.yaml`:

```yaml
icons_launcher:
  image_path: "assets/logo_light.png"
  platforms:
    android:
      enable: true
    ios:
      enable: true
    web:
      enable: true
      favicon:
        enable: true
```

## Architecture

This documentation app practices what it preaches by using:
- **ZenRouter** for file-based routing
- **Coordinator Pattern** for navigation flow management
- **Literary Programming Style** inspired by Trollope and Knuth

## Related Packages

- [zenrouter](../zenrouter) - Core routing package
- [zenrouter_file_generator](../zenrouter_file_generator) - Code generation for file-based routes
- [zenrouter_devtools](../zenrouter_devtools) - DevTools extension for debugging

## License

See [LICENSE](LICENSE) file for details.



================================================
FILE: packages/zenrouter_docs/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

linter:
  rules:
    - prefer_const_constructors
    - prefer_const_declarations
    - avoid_print
    - prefer_single_quotes

analyzer:
  errors:
    file_names: ignore
    invalid_annotation_target: ignore
  exclude:
    - "**/*.g.dart"
    - "**/*.zen.dart"



================================================
FILE: packages/zenrouter_docs/build.yaml
================================================
# Build configuration for zenrouter_docs
# 
# This configuration enables deferred imports for optimal performance,
# demonstrating the very feature we document.

targets:
  $default:
    builders:
      zenrouter_file_generator|zen_coordinator:
        options:
          deferredImport: true




================================================
FILE: packages/zenrouter_docs/pubspec.yaml
================================================
name: zenrouter_docs
description: >
  An interactive documentation application for ZenRouter - teaching the Coordinator 
  pattern and file-based routing by embodying these patterns in its own architecture.
  Written in the thoughtful prose style of Trollope and Knuth.
publish_to: 'none'
version: 0.1.0+1

resolution: workspace

environment:
  sdk: ^3.8.0

dependencies:
  flutter:
    sdk: flutter
  
  # ZenRouter ecosystem
  zenrouter:
  zenrouter_file_annotation:
  
  # Syntax highlighting for code examples
  syntax_highlight: ^0.5.0
  
  # URL launcher for external links
  url_launcher: ^6.2.0
  
  # Google Fonts for literary aesthetic
  google_fonts: ^6.2.1
  
  # Markdown rendering for documentation
  flutter_markdown_plus: ^1.0.7
  markdown: ^7.3.0

  # SEO for web
  meta_seo: ^3.0.9
  dynamic_path_url_strategy: ^1.0.0

  # Sliver tools for multi-sliver support
  sliver_tools: ^0.2.12

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0
  
  # Code generation
  build_runner: ^2.4.13
  zenrouter_file_generator:
  
  # Icon and favicon generation
  icons_launcher: ^3.0.3

flutter:
  uses-material-design: true
  
  assets:
    - assets/logo_dark.png
    - assets/logo_light.png

icons_launcher:
  image_path: "assets/logo_light.png"
  platforms:
    android:
      enable: true
    ios:
      enable: true
    web:
      enable: true
      image_path: "assets/logo_light.png"
      favicon_path: "assets/logo_light.png"


================================================
FILE: packages/zenrouter_docs/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "688d0c18ec86df87bc952a7bac72f59fbe94846d"
  channel: "master"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
    - platform: android
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
    - platform: ios
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
    - platform: linux
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
    - platform: macos
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
    - platform: web
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
    - platform: windows
      create_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d
      base_revision: 688d0c18ec86df87bc952a7bac72f59fbe94846d

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
FILE: packages/zenrouter_docs/android/build.gradle.kts
================================================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}



================================================
FILE: packages/zenrouter_docs/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true



================================================
FILE: packages/zenrouter_docs/android/settings.gradle.kts
================================================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.11.1" apply false
    id("org.jetbrains.kotlin.android") version "2.2.20" apply false
}

include(":app")



================================================
FILE: packages/zenrouter_docs/android/app/build.gradle.kts
================================================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.zenrouter_docs"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.zenrouter_docs"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}



================================================
FILE: packages/zenrouter_docs/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter_docs/android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="zenrouter_docs"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>



================================================
FILE: packages/zenrouter_docs/android/app/src/main/kotlin/com/example/zenrouter_docs/MainActivity.kt
================================================
package com.example.zenrouter_docs

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()



================================================
FILE: packages/zenrouter_docs/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter_docs/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter_docs/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter_docs/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter_docs/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter_docs/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-all.zip



================================================
FILE: packages/zenrouter_docs/ios/Podfile
================================================
# Uncomment this line to define a global platform for your project
# platform :ios, '13.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
  end
end



================================================
FILE: packages/zenrouter_docs/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter_docs/ios/Flutter/Debug.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter_docs/ios/Flutter/Release.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter_docs/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate, FlutterImplicitEngineDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  func didInitializeImplicitFlutterEngine(_ engineBridge: FlutterImplicitEngineBridge) {
    GeneratedPluginRegistrant.register(with: engineBridge.pluginRegistry)
  }
}



================================================
FILE: packages/zenrouter_docs/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Zenrouter Docs</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>zenrouter_docs</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneClassName</key>
					<string>UIWindowScene</string>
					<key>UISceneConfigurationName</key>
					<string>flutter</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
					<key>UISceneStoryboardFile</key>
					<string>Main</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>



================================================
FILE: packages/zenrouter_docs/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
FILE: packages/zenrouter_docs/ios/Runner/SceneDelegate.swift
================================================
import Flutter
import UIKit

class SceneDelegate: FlutterSceneDelegate {

}



================================================
FILE: packages/zenrouter_docs/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images": [
    {
      "filename": "Icon-App-20x20@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "20x20",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-20x20@3x.png",
      "idiom": "universal",
      "scale": "3x",
      "size": "20x20",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-29x29@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "29x29",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-29x29@3x.png",
      "idiom": "universal",
      "scale": "3x",
      "size": "29x29",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-38x38@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "38x38",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-38x38@3x.png",
      "idiom": "universal",
      "scale": "3x",
      "size": "38x38",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-40x40@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "40x40",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-40x40@3x.png",
      "idiom": "universal",
      "scale": "3x",
      "size": "40x40",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-60x60@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "60x60",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-60x60@3x.png",
      "idiom": "universal",
      "scale": "3x",
      "size": "60x60",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-64x64@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "64x64",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-64x64@3x.png",
      "idiom": "universal",
      "scale": "3x",
      "size": "64x64",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-68x68@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "68x68",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-76x76@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "76x76",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-83.5x83.5@2x.png",
      "idiom": "universal",
      "scale": "2x",
      "size": "83.5x83.5",
      "platform": "ios"
    },
    {
      "filename": "Icon-App-1024x1024@1x.png",
      "idiom": "universal",
      "scale": "1x",
      "size": "1024x1024",
      "platform": "ios"
    }
  ],
  "info": {
    "author": "icons_launcher",
    "version": 1
  }
}


================================================
FILE: packages/zenrouter_docs/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
FILE: packages/zenrouter_docs/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_docs/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
FILE: packages/zenrouter_docs/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
FILE: packages/zenrouter_docs/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter_docs/lib/main.dart
================================================
/// # ZenRouter Documentation
///
/// *A Self-Referential Guide to Navigation in Flutter*
///
/// ---
///
/// Dear Reader,
///
/// You hold before you not merely a documentation application, but a living
/// demonstration of the very principles it seeks to explain. In the tradition
/// of Knuth's literate programs, where code and explanation interweave as
/// threads in a tapestry, this application teaches the Coordinator pattern
/// by *being* a Coordinator-based application.
///
/// The routes you shall navigate mirror the concepts you shall learn. The
/// layouts that wrap your journey demonstrate the layouts we document. Even
/// the deferred imports that speed your initial load are themselves a feature
/// we shall explain in due course.
///
/// We begin, as all journeys must, at the beginning.
///
/// ---
library;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:meta_seo/meta_seo.dart';
import 'package:dynamic_path_url_strategy/dynamic_path_url_strategy.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';

import 'package:zenrouter_docs/theme/app_theme.dart';

/// The coordinator that shall guide us through this documentation.
///
/// Observe: we instantiate it once, at the root of our application.
/// It shall manage all navigation state, parse all URIs, and orchestrate
/// all transitions. A single point of truth for a single concern.
final docsCoordinator = CustomDocsCoordinator();

void main() {
  setPathUrlStrategy();
  WidgetsFlutterBinding.ensureInitialized();
  if (kIsWeb) MetaSEO().config();
  runApp(const ZenRouterDocsApp());
}

/// The root of our documentation application.
///
/// Here we see the Coordinator pattern in its simplest integration:
/// `MaterialApp.router` accepts our coordinator's delegate and parser,
/// and from that point forward, all navigation flows through our
/// centralized system.
class ZenRouterDocsApp extends StatelessWidget {
  const ZenRouterDocsApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter Documentation',
      debugShowCheckedModeBanner: false,
      theme: AppTheme.light,
      darkTheme: AppTheme.dark,
      themeMode: ThemeMode.system,
      routerDelegate: docsCoordinator.routerDelegate,
      routeInformationParser: docsCoordinator.routeInformationParser,
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/constants/app_constants.dart
================================================
/// App-wide constants for navigation and external links.
library;

/// External URLs for navigation and social media links.
class AppConstants {
  AppConstants._();

  /// GitHub repository URL
  static const String githubUrl = 'https://github.com/definev/zenrouter';

  /// Blog URL (placeholder - update with actual URL)
  static const String blogUrl = 'https://github.com/definev/zenrouter/wiki';

  /// X (Twitter) profile URL (placeholder - update with actual URL)
  static const String twitterUrl = 'https://twitter.com/definev';

  /// Navigation link labels
  static const String docsLabel = 'Docs';
  static const String blogLabel = 'Blog';

  /// Icon sizes
  static const double iconButtonSize = 20.0;
  static const double logoHeight = 32.0;

  /// Spacing constants
  static const double headerSpacing = 12.0;
  static const double navItemSpacing = 8.0;
}



================================================
FILE: packages/zenrouter_docs/lib/routes/_coordinator.dart
================================================
/// # Coordinator Configuration
///
/// Here we configure the generated coordinator. The `@ZenCoordinator`
/// annotation tells the generator what to name our coordinator and
/// route base class.
///
/// This file is discovered by zenrouter_file_generator and influences
/// the generated `routes.zen.dart` file.
library;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:meta_seo/meta_seo.dart';
import 'package:zenrouter_docs/routes/docs/_configuration/seo_title.dart';
import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_docs/widgets/mardown_section.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

@ZenCoordinator(name: 'DocsCoordinator', routeBase: 'DocsRoute')
class CoordinatorConfig {}

class CustomDocsCoordinator extends DocsCoordinator {
  @override
  DefaultTransitionStrategy get transitionStrategy =>
      DefaultTransitionStrategy.none;
}

mixin RouteToc on RouteUnique {
  TocController? tocController;
  ValueNotifier<List<TocItem>?> tocItems = ValueNotifier<List<TocItem>?>(null);

  @override
  void onUpdate(covariant RouteTarget newRoute) {
    super.onUpdate(newRoute);
    if (tocItems.value != null && tocController != null) {
      tocController!.clearItems();
      for (var item in tocItems.value!) {
        tocController!.addItem(item);
      }
    }
  }

  @override
  void onDiscard() {
    super.onDiscard();
    tocItems.dispose();
  }

  @override
  @mustCallSuper
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    tocController = DocsTocScope.of(context);
    tocController?.clearItems();
    tocItems.value = null;
    return super.build(coordinator, context);
  }
}

mixin RouteSeo on RouteUnique {
  String get title;
  String get description;
  String get keywords;
  // Optional meta tags with defaults
  String get author => 'Dai Duong';
  String? get ogImage => null; // URL to social media preview image
  String get ogType => 'website';
  TwitterCard? get twitterCard => TwitterCard.summaryLargeImage;
  String? get twitterSite => null; // e.g., '@yourusername'
  String? get canonicalUrl => null; // Canonical URL for this page
  String get language => 'en';
  String? get robots => null; // e.g., 'index, follow'

  final meta = MetaSEO();

  @override
  void onUpdate(covariant RouteTarget newRoute) {
    super.onUpdate(newRoute);
    buildSeo();
  }

  @override
  Widget build(
    covariant Coordinator<RouteUnique> coordinator,
    BuildContext context,
  ) {
    buildSeo();
    return const SizedBox.shrink();
  }

  void buildSeo() {
    // Add MetaSEO just into Web platform condition
    if (kIsWeb) {
      // Basic meta tags
      meta.author(author: author);
      meta.description(description: description);
      meta.keywords(keywords: keywords);
      // Open Graph meta tags (for Facebook, LinkedIn, etc.)
      setWebTitle(title);
      meta.ogTitle(ogTitle: title);
      meta.ogDescription(ogDescription: description);
      if (ogImage != null) {
        meta.ogImage(ogImage: ogImage!);
      }
      // Twitter Card meta tags
      if (twitterCard != null) {
        meta.twitterCard(twitterCard: twitterCard!);
      }
      meta.twitterTitle(twitterTitle: title);
      meta.twitterDescription(twitterDescription: description);
      if (ogImage != null) {
        meta.twitterImage(twitterImage: ogImage!);
      }
      if (twitterSite != null) {
        // Note: You may need to add this manually if MetaSEO doesn't support it
        // or use meta.config() for custom tags
      }
      // Additional SEO tags
      if (robots != null) {
        // Use meta.config() for custom tags
        meta.robots(robotsName: RobotsName.robots, content: robots!);
      }
    }
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/_layout.dart
================================================
/// # Root Layout
///
/// The foundational layout that wraps the entire documentation site.
/// It provides the header with branding and the main scaffold structure.
library;

import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:zenrouter_docs/constants/app_constants.dart';
import 'package:zenrouter_docs/routes/docs/index.dart';
import 'package:zenrouter_docs/routes/index.dart';
import 'package:zenrouter_docs/theme/app_theme.dart';
import 'package:zenrouter_docs/widgets/breadcrumb.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_docs/routes/routes.zen.dart';

part '_layout.g.dart';

/// The root layout for the entire ZenRouter documentation site.
///
/// This layout provides:
/// - A persistent header with the ZenRouter logo
/// - Theme toggle functionality
/// - Responsive layout structure
@ZenLayout(type: LayoutType.stack)
class RootLayout extends _$RootLayout {
  @override
  Type? get layout => null;

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    return RootLayoutBuilder(child: buildPath(coordinator));
  }
}

class RootLayoutBuilder extends StatelessWidget {
  final Widget child;

  const RootLayoutBuilder({super.key, required this.child});

  PreferredSizeWidget _buildAppBar(
    Coordinator coordinator,
    BuildContext context,
  ) {
    final theme = Theme.of(context);
    final docs = theme.docs;
    final isDark = theme.brightness == Brightness.dark;

    // Get current route for breadcrumbs
    final breadcrumbItems = _getBreadcrumbs(coordinator);
    final showBreadcrumbs = breadcrumbItems.length > 1;

    return PreferredSize(
      preferredSize: Size.fromHeight(showBreadcrumbs ? 100 : 64),
      child: AppBar(
        flexibleSpace: Center(
          child: ConstrainedBox(
            constraints: BoxConstraints(maxWidth: docs.proseMaxWidth * 1.8),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Main header row
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  child: Row(
                    children: [
                      // Logo and Title
                      GestureDetector(
                        onTap: () => coordinator.navigate(IndexRoute()),
                        child: Row(
                          children: [
                            ClipRSuperellipse(
                              borderRadius: BorderRadius.circular(8),
                              child: Image.asset(
                                isDark
                                    ? 'assets/logo_dark.png'
                                    : 'assets/logo_light.png',
                                height: 32,
                                fit: BoxFit.contain,
                              ),
                            ),
                            const SizedBox(width: 12),
                            Text.rich(
                              TextSpan(
                                children: [
                                  TextSpan(
                                    text: 'ZEN',
                                    style: theme.textTheme.titleLarge?.merge(
                                      GoogleFonts.aboreto(
                                        fontWeight: FontWeight.bold,
                                        color: theme.colorScheme.primary,
                                      ),
                                    ),
                                  ),
                                  TextSpan(
                                    text: 'Router',
                                    style: theme.textTheme.titleLarge?.merge(
                                      GoogleFonts.aboreto(
                                        fontWeight: FontWeight.bold,
                                        color: theme.colorScheme.secondary,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                      const Spacer(),
                      // Navigation Links
                      _buildNavigationLinks(coordinator, theme),
                    ],
                  ),
                ),
                // Breadcrumb row
                if (showBreadcrumbs)
                  Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 16,
                      vertical: 4,
                    ),
                    child: Breadcrumb(items: breadcrumbItems),
                  ),
              ],
            ),
          ),
        ),
        centerTitle: false,
      ),
    );
  }

  /// Builds the navigation links row with Docs, Blog, GitHub, and X links
  Widget _buildNavigationLinks(Coordinator coordinator, ThemeData theme) {
    return Row(
      spacing: 12,
      children: [
        _NavLink(
          label: AppConstants.docsLabel,
          onTap: () => coordinator.navigate(DocsIndexRoute()),
        ),
        _NavLink(
          label: AppConstants.blogLabel,
          onTap: () => _launchUrl(AppConstants.blogUrl),
        ),
        _IconNavButton(
          icon: Icons.code,
          tooltip: 'GitHub',
          onTap: () => _launchUrl(AppConstants.githubUrl),
        ),
        _IconNavButton(
          icon: Icons.close, // X icon for Twitter/X
          tooltip: 'X (Twitter)',
          onTap: () => _launchUrl(AppConstants.twitterUrl),
        ),
      ],
    );
  }

  /// Extracts breadcrumb items from the current route
  List<BreadcrumbItem> _getBreadcrumbs(Coordinator coordinator) {
    final items = <BreadcrumbItem>[
      BreadcrumbItem(label: 'Home', route: IndexRoute()),
    ];

    // Get the current route from the path
    if (coordinator is! DocsCoordinator) return items;
    if (coordinator.rootPath.stack.isEmpty) return items;
    final currentRoute = coordinator.rootPath.stack.last;

    // Parse route type to build breadcrumbs
    final routeType = currentRoute.runtimeType.toString();

    // Handle docs routes
    if (routeType.contains('Docs') || routeType.contains('Route')) {
      if (routeType != 'IndexRoute') {
        items.add(BreadcrumbItem(label: 'Docs', route: DocsIndexRoute()));
      }

      // Add specific doc sections
      if (routeType.contains('Paradigm')) {
        items.add(const BreadcrumbItem(label: 'Paradigms'));
        if (routeType.contains('Imperative')) {
          items.add(const BreadcrumbItem(label: 'Imperative'));
        } else if (routeType.contains('Declarative')) {
          items.add(const BreadcrumbItem(label: 'Declarative'));
        } else if (routeType.contains('Coordinator')) {
          items.add(const BreadcrumbItem(label: 'Coordinator'));
        } else if (routeType.contains('Choosing')) {
          items.add(const BreadcrumbItem(label: 'Choosing'));
        }
      } else if (routeType.contains('Concept')) {
        items.add(const BreadcrumbItem(label: 'Concepts'));
        if (routeType.contains('RoutesAndPaths')) {
          items.add(const BreadcrumbItem(label: 'Routes and Paths'));
        } else if (routeType.contains('StackManagement')) {
          items.add(const BreadcrumbItem(label: 'Stack Management'));
        } else if (routeType.contains('UriParsing')) {
          items.add(const BreadcrumbItem(label: 'URI Parsing'));
        }
      } else if (routeType.contains('Pattern')) {
        items.add(const BreadcrumbItem(label: 'Patterns'));
        if (routeType.contains('Layout')) {
          items.add(const BreadcrumbItem(label: 'Layouts'));
        } else if (routeType.contains('Guards')) {
          items.add(const BreadcrumbItem(label: 'Guards & Redirects'));
        } else if (routeType.contains('DeepLinking')) {
          items.add(const BreadcrumbItem(label: 'Deep Linking'));
        } else if (routeType.contains('QueryParameters')) {
          items.add(const BreadcrumbItem(label: 'Query Parameters'));
        }
      } else if (routeType.contains('FileRouting') ||
          routeType.contains('GettingStarted') ||
          routeType.contains('Convention') ||
          routeType.contains('Dynamic') ||
          routeType.contains('Deferred')) {
        items.add(const BreadcrumbItem(label: 'File-Based Routing'));
        if (routeType.contains('GettingStarted')) {
          items.add(const BreadcrumbItem(label: 'Getting Started'));
        } else if (routeType.contains('Convention')) {
          items.add(const BreadcrumbItem(label: 'Conventions'));
        } else if (routeType.contains('DynamicRoutes')) {
          items.add(const BreadcrumbItem(label: 'Dynamic Routes'));
        } else if (routeType.contains('DeferredImports')) {
          items.add(const BreadcrumbItem(label: 'Deferred Imports'));
        }
      } else if (routeType.contains('Examples')) {
        items.add(const BreadcrumbItem(label: 'Examples'));
      }
    }

    return items;
  }

  /// Launches an external URL
  Future<void> _launchUrl(String url) async {
    final uri = Uri.parse(url);
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri);
    }
  }

  @override
  Widget build(BuildContext context) {
    final coordinator = DocsCoordinatorProvider.of(context);
    return Scaffold(appBar: _buildAppBar(coordinator, context), body: child);
  }
}

/// A text navigation link with hover effects
class _NavLink extends StatefulWidget {
  const _NavLink({required this.label, required this.onTap});

  final String label;
  final VoidCallback onTap;

  @override
  State<_NavLink> createState() => _NavLinkState();
}

class _NavLinkState extends State<_NavLink> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        onTap: widget.onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          decoration: BoxDecoration(
            color: _isHovered
                ? theme.colorScheme.primary.withValues(alpha: 0.1)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Text(
            widget.label,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: _isHovered
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface,
              fontWeight: FontWeight.w500,
            ),
          ),
        ),
      ),
    );
  }
}

/// An icon button for navigation with hover effects
class _IconNavButton extends StatefulWidget {
  const _IconNavButton({
    required this.icon,
    required this.tooltip,
    required this.onTap,
  });

  final IconData icon;
  final String tooltip;
  final VoidCallback onTap;

  @override
  State<_IconNavButton> createState() => _IconNavButtonState();
}

class _IconNavButtonState extends State<_IconNavButton> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: widget.tooltip,
      child: MouseRegion(
        onEnter: (_) => setState(() => _isHovered = true),
        onExit: (_) => setState(() => _isHovered = false),
        cursor: SystemMouseCursors.click,
        child: GestureDetector(
          onTap: widget.onTap,
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 200),
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: _isHovered
                  ? theme.colorScheme.primary.withValues(alpha: 0.1)
                  : Colors.transparent,
              shape: BoxShape.circle,
            ),
            child: Icon(
              widget.icon,
              size: AppConstants.iconButtonSize,
              color: _isHovered
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for RootLayout.
///
/// URI: /
/// Path type: stack
/// Parent layout: RootLayout
abstract class _$RootLayout extends DocsRoute with RouteLayout<DocsRoute> {
  _$RootLayout();

  @override
  Type? get layout => RootLayout;

  @override
  NavigationPath<DocsRoute> resolvePath(
    covariant DocsCoordinator coordinator,
  ) => coordinator.rootPath;

  @override
  Uri toUri() => Uri.parse('/');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/_route.dart
================================================
/// # The Base Route
///
/// Every route in our documentation shall extend this abstract class.
/// It combines `RouteTarget` (the fundamental building block) with
/// `RouteUnique` (the mixin that grants URI awareness).
///
/// This is the pattern: define your route hierarchy, then let each
/// route know how to present itself as a URI and how to build its
/// widget.
library;

import 'package:zenrouter/zenrouter.dart';

/// The foundation upon which all documentation routes are built.
///
/// By extending `RouteTarget` and mixing in `RouteUnique`, each route
/// gains two essential capabilities:
///
/// 1. **Identity**: The route knows who it is, can compare itself to others
/// 2. **URI Awareness**: The route can express itself as a URI and be
///    reconstructed from one
abstract class DocsRoute extends RouteTarget with RouteUnique {}



================================================
FILE: packages/zenrouter_docs/lib/routes/index.dart
================================================
/// # Welcome to ZenRouter
///
/// This is the landing page - the first thing our reader encounters.
/// Like the opening chapter of a well-crafted novel, it must accomplish
/// several things at once: orient the reader, establish tone, and
/// promise the value to come.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/widgets/mardown_section.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/theme/app_theme.dart';

part 'index.g.dart';

/// The home route, answering to `/`
///
/// Here we welcome the reader and present the paths available to them.
/// Each section of our documentation is a destination they may choose.
@ZenRoute()
class IndexRoute extends _$IndexRoute {
  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    final theme = Theme.of(context);
    final docs = theme.docs;

    return Scaffold(
      body: SingleChildScrollView(
        padding: docs.contentPadding,
        child: Center(
          child: ConstrainedBox(
            constraints: BoxConstraints(maxWidth: docs.proseMaxWidth),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: 48),

                // ─────────────────────────────────────────────────────────────
                // Title and Introduction
                // ─────────────────────────────────────────────────────────────
                Text('ZenRouter', style: theme.textTheme.displayLarge),
                const SizedBox(height: 8),
                Text(
                  'The Art of Navigation in Flutter',
                  style: theme.textTheme.headlineMedium?.copyWith(
                    color: theme.colorScheme.primary,
                    fontStyle: FontStyle.italic,
                  ),
                ),
                const SizedBox(height: 32),

                const MarkdownSection(
                  markdown: '''
Hello there!,

You have arrived at the documentation for `ZenRouter`, a navigation library that solves every navigation problem in Flutter.

This documentation is itself built with ZenRouter's Coordinator pattern and file-based routing. As you navigate these pages, you are experiencing the very system we document. The routes you traverse, the layouts that wrap them, the URIs in your address bar - all are demonstrations of the principles explained herein.

We shall begin with the Three Paradigms, for one cannot appreciate a solution without understanding the problem it solves.
''',
                ),

                const SizedBox(height: 48),

                // ─────────────────────────────────────────────────────────────
                // Navigation Links
                // ─────────────────────────────────────────────────────────────
                const Divider(),
                const SizedBox(height: 24),

                buildNavigationList(context, coordinator),

                const SizedBox(height: 64),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

Widget buildNavigationList(BuildContext context, DocsCoordinator coordinator) {
  final items = [
    NavigationItem(
      icon: Icons.route,
      title: 'The Three Paradigms',
      description:
          'Imperative, Declarative, and Coordinator - understand when to use each approach.',
      onTap: () => coordinator.pushImperative(),
      color: const Color(0xFF1A5F7A),
    ),
    NavigationItem(
      icon: Icons.account_tree,
      title: 'Core Concepts',
      description:
          'Routes, Paths, and the Stack - the fundamental building blocks.',
      onTap: () => coordinator.pushRoutesAndPaths(),
      color: const Color(0xFF9B6B3D),
    ),
    NavigationItem(
      icon: Icons.pattern,
      title: 'Patterns',
      description:
          'Layouts, Guards, Deep Linking - practical patterns for real applications.',
      onTap: () => coordinator.pushLayouts(),
      color: const Color(0xFF6B5B95),
    ),
    NavigationItem(
      icon: Icons.folder_special,
      title: 'File-Based Routing',
      description:
          'Let your file structure define your routes - zero boilerplate.',
      onTap: () => coordinator.pushGettingStarted(),
      color: const Color(0xFF88B04B),
    ),
    NavigationItem(
      icon: Icons.play_circle_outline,
      title: 'Live Examples',
      description: 'Interactive demonstrations you can explore and modify.',
      onTap: () => coordinator.pushExamplesSlug(slug: 'basic-navigation'),
      color: const Color(0xFFDD4124),
    ),
  ];

  return Column(
    spacing: 8,
    children: items.map((item) => NavigationLink(item: item)).toList(),
  );
}

/// A navigation item definition
class NavigationItem {
  const NavigationItem({
    required this.icon,
    required this.title,
    required this.description,
    required this.onTap,
    required this.color,
  });

  final IconData icon;
  final String title;
  final String description;
  final VoidCallback onTap;
  final Color color;
}

/// A clickable navigation link without card styling
class NavigationLink extends StatefulWidget {
  const NavigationLink({super.key, required this.item});

  final NavigationItem item;

  @override
  State<NavigationLink> createState() => _NavigationLinkState();
}

class _NavigationLinkState extends State<NavigationLink> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final item = widget.item;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: InkWell(
        onTap: item.onTap,
        borderRadius: BorderRadius.circular(12),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          padding: const EdgeInsets.only(
            left: 8,
            right: 16,
            top: 16,
            bottom: 16,
          ),
          decoration: BoxDecoration(
            color: _isHovered
                ? theme.colorScheme.primary.withValues(alpha: 0.05)
                : Colors.transparent,
            borderRadius: BorderRadius.circular(12),
          ),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            spacing: 16,
            children: [
              // Icon
              Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  color: item.color.withValues(alpha: 0.1),
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Icon(item.icon, color: item.color, size: 24),
              ),
              // Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      item.title,
                      style: theme.textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: _isHovered ? theme.colorScheme.primary : null,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Text(
                      item.description,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurface.withValues(
                          alpha: 0.7,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for IndexRoute.
///
/// URI: /
/// Layout: RootLayout
abstract class _$IndexRoute extends DocsRoute {
  _$IndexRoute();

  @override
  Type? get layout => RootLayout;

  @override
  Uri toUri() => Uri.parse('/');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/not_found.dart
================================================
/// # The Road Not Found
///
/// When a traveler ventures to an unknown destination, we must guide
/// them gracefully back to familiar ground. This route handles all
/// URIs that do not match our defined paths.
library;

import 'package:flutter/material.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';

/// A route for paths that lead nowhere - yet.
///
/// Every good application must handle the unexpected with grace.
/// When a user types an invalid URL or follows a broken link,
/// they should not be met with confusion, but with helpful guidance.
class NotFoundRoute extends DocsRoute {
  NotFoundRoute({required this.uri, this.queries = const {}});

  /// The URI that was attempted
  final Uri uri;

  /// Any query parameters that accompanied the request
  final Map<String, String> queries;

  @override
  List<Object?> get props => [uri, queries];

  @override
  Uri toUri() => uri;

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.explore_off,
                size: 80,
                color: theme.colorScheme.primary.withValues(alpha: 0.5),
              ),
              const SizedBox(height: 24),
              Text('Page Not Found', style: theme.textTheme.displaySmall),
              const SizedBox(height: 16),
              Text(
                'The path "${uri.path}" does not lead anywhere we know.',
                style: theme.textTheme.bodyLarge?.copyWith(
                  color: theme.colorScheme.onSurface.withValues(alpha: 0.7),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),
              Text(
                'Perhaps it once did, or perhaps it shall in the future.\nFor now, let us return to familiar ground.',
                style: theme.textTheme.bodyMedium?.copyWith(
                  fontStyle: FontStyle.italic,
                  color: theme.colorScheme.onSurface.withValues(alpha: 0.5),
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              FilledButton.icon(
                onPressed: () => coordinator.replaceIndex(),
                icon: const Icon(Icons.home),
                label: const Text('Return Home'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/routes.zen.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint

import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';

import '_layout.dart';
import 'docs/_layout.dart';
import 'docs/concepts/routes-and-paths.dart'
    deferred as docs_concepts_routesandpaths;
import 'docs/concepts/stack-management.dart'
    deferred as docs_concepts_stackmanagement;
import 'docs/concepts/uri-parsing.dart' deferred as docs_concepts_uriparsing;
import 'docs/examples/[slug]/index.dart' deferred as docs_examples__slug_index;
import 'docs/examples/_layout.dart';
import 'docs/file-routing/conventions.dart'
    deferred as docs_filerouting_conventions;
import 'docs/file-routing/deferred-imports.dart';
import 'docs/file-routing/dynamic-routes.dart'
    deferred as docs_filerouting_dynamicroutes;
import 'docs/file-routing/getting-started.dart'
    deferred as docs_filerouting_gettingstarted;
import 'docs/index.dart' deferred as docs_index;
import 'docs/paradigms/choosing.dart' deferred as docs_paradigms_choosing;
import 'docs/paradigms/coordinator.dart' deferred as docs_paradigms_coordinator;
import 'docs/paradigms/declarative.dart' deferred as docs_paradigms_declarative;
import 'docs/paradigms/imperative.dart' deferred as docs_paradigms_imperative;
import 'docs/patterns/deep-linking.dart' deferred as docs_patterns_deeplinking;
import 'docs/patterns/guards-redirects.dart'
    deferred as docs_patterns_guardsredirects;
import 'docs/patterns/layouts.dart' deferred as docs_patterns_layouts;
import 'docs/patterns/query-parameters.dart'
    deferred as docs_patterns_queryparameters;
import 'index.dart' deferred as index;
import 'not_found.dart';

export 'package:zenrouter/zenrouter.dart';
export '_layout.dart';
export 'docs/_layout.dart';
export 'docs/examples/_layout.dart';
export 'docs/file-routing/deferred-imports.dart';
export 'not_found.dart';

/// Base class for all routes in this application.
abstract class DocsRoute extends RouteTarget with RouteUnique {}

/// Generated coordinator managing all routes.
class DocsCoordinator extends Coordinator<DocsRoute> {
  late final rootPath = NavigationPath<DocsRoute>.createWith(
    coordinator: this,
    label: 'Root',
  )..bindLayout(RootLayout.new);
  late final docsPath = NavigationPath<DocsRoute>.createWith(
    coordinator: this,
    label: 'Docs',
  )..bindLayout(DocsLayout.new);
  late final examplesPath = NavigationPath<DocsRoute>.createWith(
    coordinator: this,
    label: 'Examples',
  )..bindLayout(ExamplesLayout.new);

  @override
  List<StackPath> get paths => [
    ...super.paths,
    rootPath,
    docsPath,
    examplesPath,
  ];

  @override
  Future<DocsRoute> parseRouteFromUri(Uri uri) async {
    return switch (uri.pathSegments) {
      [] => await () async {
        await index.loadLibrary();
        return index.IndexRoute();
      }(),
      ['docs', 'concepts', 'routes-and-paths'] => await () async {
        await docs_concepts_routesandpaths.loadLibrary();
        return docs_concepts_routesandpaths.RoutesAndPathsRoute();
      }(),
      ['docs', 'concepts', 'stack-management'] => await () async {
        await docs_concepts_stackmanagement.loadLibrary();
        return docs_concepts_stackmanagement.StackManagementRoute();
      }(),
      ['docs', 'concepts', 'uri-parsing'] => await () async {
        await docs_concepts_uriparsing.loadLibrary();
        return docs_concepts_uriparsing.UriParsingRoute();
      }(),
      ['docs', 'file-routing', 'conventions'] => await () async {
        await docs_filerouting_conventions.loadLibrary();
        return docs_filerouting_conventions.ConventionsRoute();
      }(),
      ['docs', 'file-routing', 'deferred-imports'] => DeferredImportsRoute(),
      ['docs', 'file-routing', 'dynamic-routes'] => await () async {
        await docs_filerouting_dynamicroutes.loadLibrary();
        return docs_filerouting_dynamicroutes.DynamicRoutesRoute();
      }(),
      ['docs', 'file-routing', 'getting-started'] => await () async {
        await docs_filerouting_gettingstarted.loadLibrary();
        return docs_filerouting_gettingstarted.GettingStartedRoute();
      }(),
      ['docs', 'paradigms', 'choosing'] => await () async {
        await docs_paradigms_choosing.loadLibrary();
        return docs_paradigms_choosing.ChoosingRoute();
      }(),
      ['docs', 'paradigms', 'coordinator'] => await () async {
        await docs_paradigms_coordinator.loadLibrary();
        return docs_paradigms_coordinator.CoordinatorRoute();
      }(),
      ['docs', 'paradigms', 'declarative'] => await () async {
        await docs_paradigms_declarative.loadLibrary();
        return docs_paradigms_declarative.DeclarativeRoute();
      }(),
      ['docs', 'paradigms', 'imperative'] => await () async {
        await docs_paradigms_imperative.loadLibrary();
        return docs_paradigms_imperative.ImperativeRoute();
      }(),
      ['docs', 'patterns', 'deep-linking'] => await () async {
        await docs_patterns_deeplinking.loadLibrary();
        return docs_patterns_deeplinking.DeepLinkingRoute();
      }(),
      ['docs', 'patterns', 'guards-redirects'] => await () async {
        await docs_patterns_guardsredirects.loadLibrary();
        return docs_patterns_guardsredirects.GuardsRedirectsRoute();
      }(),
      ['docs', 'patterns', 'layouts'] => await () async {
        await docs_patterns_layouts.loadLibrary();
        return docs_patterns_layouts.LayoutsRoute();
      }(),
      ['docs', 'patterns', 'query-parameters'] => await () async {
        await docs_patterns_queryparameters.loadLibrary();
        return docs_patterns_queryparameters.QueryParametersRoute(
          queries: uri.queryParameters,
        );
      }(),
      ['docs', 'examples', final slug] => await () async {
        await docs_examples__slug_index.loadLibrary();
        return docs_examples__slug_index.ExamplesSlugRoute(slug: slug);
      }(),
      ['docs'] => await () async {
        await docs_index.loadLibrary();
        return docs_index.DocsIndexRoute();
      }(),
      _ => NotFoundRoute(uri: uri, queries: uri.queryParameters),
    };
  }

  @override
  Widget layoutBuilder(BuildContext context) {
    return DocsCoordinatorProvider(
      coordinator: this,
      child: super.layoutBuilder(context),
    );
  }
}

/// Type-safe navigation extension methods.
extension DocsCoordinatorNav on DocsCoordinator {
  Future<T?> pushRoutesAndPaths<T extends Object>() async =>
      push(await () async {
        await docs_concepts_routesandpaths.loadLibrary();
        return docs_concepts_routesandpaths.RoutesAndPathsRoute();
      }());
  Future<void> replaceRoutesAndPaths() async => replace(await () async {
    await docs_concepts_routesandpaths.loadLibrary();
    return docs_concepts_routesandpaths.RoutesAndPathsRoute();
  }());
  Future<void> recoverRoutesAndPaths() async => recover(await () async {
    await docs_concepts_routesandpaths.loadLibrary();
    return docs_concepts_routesandpaths.RoutesAndPathsRoute();
  }());
  Future<T?> pushStackManagement<T extends Object>() async =>
      push(await () async {
        await docs_concepts_stackmanagement.loadLibrary();
        return docs_concepts_stackmanagement.StackManagementRoute();
      }());
  Future<void> replaceStackManagement() async => replace(await () async {
    await docs_concepts_stackmanagement.loadLibrary();
    return docs_concepts_stackmanagement.StackManagementRoute();
  }());
  Future<void> recoverStackManagement() async => recover(await () async {
    await docs_concepts_stackmanagement.loadLibrary();
    return docs_concepts_stackmanagement.StackManagementRoute();
  }());
  Future<T?> pushUriParsing<T extends Object>() async => push(await () async {
    await docs_concepts_uriparsing.loadLibrary();
    return docs_concepts_uriparsing.UriParsingRoute();
  }());
  Future<void> replaceUriParsing() async => replace(await () async {
    await docs_concepts_uriparsing.loadLibrary();
    return docs_concepts_uriparsing.UriParsingRoute();
  }());
  Future<void> recoverUriParsing() async => recover(await () async {
    await docs_concepts_uriparsing.loadLibrary();
    return docs_concepts_uriparsing.UriParsingRoute();
  }());
  Future<T?> pushExamplesSlug<T extends Object>({required String slug}) async =>
      push(await () async {
        await docs_examples__slug_index.loadLibrary();
        return docs_examples__slug_index.ExamplesSlugRoute(slug: slug);
      }());
  Future<void> replaceExamplesSlug({required String slug}) async =>
      replace(await () async {
        await docs_examples__slug_index.loadLibrary();
        return docs_examples__slug_index.ExamplesSlugRoute(slug: slug);
      }());
  Future<void> recoverExamplesSlug({required String slug}) async =>
      recover(await () async {
        await docs_examples__slug_index.loadLibrary();
        return docs_examples__slug_index.ExamplesSlugRoute(slug: slug);
      }());
  Future<T?> pushConventions<T extends Object>() async => push(await () async {
    await docs_filerouting_conventions.loadLibrary();
    return docs_filerouting_conventions.ConventionsRoute();
  }());
  Future<void> replaceConventions() async => replace(await () async {
    await docs_filerouting_conventions.loadLibrary();
    return docs_filerouting_conventions.ConventionsRoute();
  }());
  Future<void> recoverConventions() async => recover(await () async {
    await docs_filerouting_conventions.loadLibrary();
    return docs_filerouting_conventions.ConventionsRoute();
  }());
  Future<T?> pushDeferredImports<T extends Object>() =>
      push(DeferredImportsRoute());
  Future<void> replaceDeferredImports() => replace(DeferredImportsRoute());
  Future<void> recoverDeferredImports() => recover(DeferredImportsRoute());
  Future<T?> pushDynamicRoutes<T extends Object>() async =>
      push(await () async {
        await docs_filerouting_dynamicroutes.loadLibrary();
        return docs_filerouting_dynamicroutes.DynamicRoutesRoute();
      }());
  Future<void> replaceDynamicRoutes() async => replace(await () async {
    await docs_filerouting_dynamicroutes.loadLibrary();
    return docs_filerouting_dynamicroutes.DynamicRoutesRoute();
  }());
  Future<void> recoverDynamicRoutes() async => recover(await () async {
    await docs_filerouting_dynamicroutes.loadLibrary();
    return docs_filerouting_dynamicroutes.DynamicRoutesRoute();
  }());
  Future<T?> pushGettingStarted<T extends Object>() async =>
      push(await () async {
        await docs_filerouting_gettingstarted.loadLibrary();
        return docs_filerouting_gettingstarted.GettingStartedRoute();
      }());
  Future<void> replaceGettingStarted() async => replace(await () async {
    await docs_filerouting_gettingstarted.loadLibrary();
    return docs_filerouting_gettingstarted.GettingStartedRoute();
  }());
  Future<void> recoverGettingStarted() async => recover(await () async {
    await docs_filerouting_gettingstarted.loadLibrary();
    return docs_filerouting_gettingstarted.GettingStartedRoute();
  }());
  Future<T?> pushDocsIndex<T extends Object>() async => push(await () async {
    await docs_index.loadLibrary();
    return docs_index.DocsIndexRoute();
  }());
  Future<void> replaceDocsIndex() async => replace(await () async {
    await docs_index.loadLibrary();
    return docs_index.DocsIndexRoute();
  }());
  Future<void> recoverDocsIndex() async => recover(await () async {
    await docs_index.loadLibrary();
    return docs_index.DocsIndexRoute();
  }());
  Future<T?> pushChoosing<T extends Object>() async => push(await () async {
    await docs_paradigms_choosing.loadLibrary();
    return docs_paradigms_choosing.ChoosingRoute();
  }());
  Future<void> replaceChoosing() async => replace(await () async {
    await docs_paradigms_choosing.loadLibrary();
    return docs_paradigms_choosing.ChoosingRoute();
  }());
  Future<void> recoverChoosing() async => recover(await () async {
    await docs_paradigms_choosing.loadLibrary();
    return docs_paradigms_choosing.ChoosingRoute();
  }());
  Future<T?> pushCoordinator<T extends Object>() async => push(await () async {
    await docs_paradigms_coordinator.loadLibrary();
    return docs_paradigms_coordinator.CoordinatorRoute();
  }());
  Future<void> replaceCoordinator() async => replace(await () async {
    await docs_paradigms_coordinator.loadLibrary();
    return docs_paradigms_coordinator.CoordinatorRoute();
  }());
  Future<void> recoverCoordinator() async => recover(await () async {
    await docs_paradigms_coordinator.loadLibrary();
    return docs_paradigms_coordinator.CoordinatorRoute();
  }());
  Future<T?> pushDeclarative<T extends Object>() async => push(await () async {
    await docs_paradigms_declarative.loadLibrary();
    return docs_paradigms_declarative.DeclarativeRoute();
  }());
  Future<void> replaceDeclarative() async => replace(await () async {
    await docs_paradigms_declarative.loadLibrary();
    return docs_paradigms_declarative.DeclarativeRoute();
  }());
  Future<void> recoverDeclarative() async => recover(await () async {
    await docs_paradigms_declarative.loadLibrary();
    return docs_paradigms_declarative.DeclarativeRoute();
  }());
  Future<T?> pushImperative<T extends Object>() async => push(await () async {
    await docs_paradigms_imperative.loadLibrary();
    return docs_paradigms_imperative.ImperativeRoute();
  }());
  Future<void> replaceImperative() async => replace(await () async {
    await docs_paradigms_imperative.loadLibrary();
    return docs_paradigms_imperative.ImperativeRoute();
  }());
  Future<void> recoverImperative() async => recover(await () async {
    await docs_paradigms_imperative.loadLibrary();
    return docs_paradigms_imperative.ImperativeRoute();
  }());
  Future<T?> pushDeepLinking<T extends Object>() async => push(await () async {
    await docs_patterns_deeplinking.loadLibrary();
    return docs_patterns_deeplinking.DeepLinkingRoute();
  }());
  Future<void> replaceDeepLinking() async => replace(await () async {
    await docs_patterns_deeplinking.loadLibrary();
    return docs_patterns_deeplinking.DeepLinkingRoute();
  }());
  Future<void> recoverDeepLinking() async => recover(await () async {
    await docs_patterns_deeplinking.loadLibrary();
    return docs_patterns_deeplinking.DeepLinkingRoute();
  }());
  Future<T?> pushGuardsRedirects<T extends Object>() async =>
      push(await () async {
        await docs_patterns_guardsredirects.loadLibrary();
        return docs_patterns_guardsredirects.GuardsRedirectsRoute();
      }());
  Future<void> replaceGuardsRedirects() async => replace(await () async {
    await docs_patterns_guardsredirects.loadLibrary();
    return docs_patterns_guardsredirects.GuardsRedirectsRoute();
  }());
  Future<void> recoverGuardsRedirects() async => recover(await () async {
    await docs_patterns_guardsredirects.loadLibrary();
    return docs_patterns_guardsredirects.GuardsRedirectsRoute();
  }());
  Future<T?> pushLayouts<T extends Object>() async => push(await () async {
    await docs_patterns_layouts.loadLibrary();
    return docs_patterns_layouts.LayoutsRoute();
  }());
  Future<void> replaceLayouts() async => replace(await () async {
    await docs_patterns_layouts.loadLibrary();
    return docs_patterns_layouts.LayoutsRoute();
  }());
  Future<void> recoverLayouts() async => recover(await () async {
    await docs_patterns_layouts.loadLibrary();
    return docs_patterns_layouts.LayoutsRoute();
  }());
  Future<T?> pushQueryParameters<T extends Object>({
    Map<String, String> queries = const {},
  }) async => push(await () async {
    await docs_patterns_queryparameters.loadLibrary();
    return docs_patterns_queryparameters.QueryParametersRoute(queries: queries);
  }());
  Future<void> replaceQueryParameters({
    Map<String, String> queries = const {},
  }) async => replace(await () async {
    await docs_patterns_queryparameters.loadLibrary();
    return docs_patterns_queryparameters.QueryParametersRoute(queries: queries);
  }());
  Future<void> recoverQueryParameters({
    Map<String, String> queries = const {},
  }) async => recover(await () async {
    await docs_patterns_queryparameters.loadLibrary();
    return docs_patterns_queryparameters.QueryParametersRoute(queries: queries);
  }());
  Future<T?> pushIndex<T extends Object>() async => push(await () async {
    await index.loadLibrary();
    return index.IndexRoute();
  }());
  Future<void> replaceIndex() async => replace(await () async {
    await index.loadLibrary();
    return index.IndexRoute();
  }());
  Future<void> recoverIndex() async => recover(await () async {
    await index.loadLibrary();
    return index.IndexRoute();
  }());
}

/// InheritedWidget provider for accessing the coordinator from the widget tree.
class DocsCoordinatorProvider extends InheritedWidget {
  const DocsCoordinatorProvider({
    required this.coordinator,
    required super.child,
    super.key,
  });

  /// Retrieves the [DocsCoordinator] from the widget tree.
  static DocsCoordinator of(BuildContext context) => context
      .dependOnInheritedWidgetOfExactType<DocsCoordinatorProvider>()!
      .coordinator;

  final DocsCoordinator coordinator;

  @override
  bool updateShouldNotify(DocsCoordinatorProvider oldWidget) =>
      coordinator != oldWidget.coordinator;
}

/// Extension on [BuildContext] for convenient coordinator access.
extension DocsCoordinatorGetter on BuildContext {
  /// Access the [DocsCoordinator] from the widget tree.
  DocsCoordinator get docsCoordinator => DocsCoordinatorProvider.of(this);
}

/// Extension on [DocsRoute] for navigation methods.
extension DocsCoordinatorNavContext on DocsRoute {
  Future<void> navigate(BuildContext context) =>
      context.docsCoordinator.navigate(this);
  Future<T?> push<T extends Object>(BuildContext context) =>
      context.docsCoordinator.push<T>(this);
  Future<void> replace(BuildContext context) =>
      context.docsCoordinator.replace(this);
  Future<void> recover(BuildContext context) =>
      context.docsCoordinator.recover(this);
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/_layout.dart
================================================
/// # Documentation Layout
///
/// This is the grand layout that wraps all documentation sections.
/// It provides a tree view navigation for accessing all content
/// and a Table of Contents sidebar on the right.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';

part '_layout.g.dart';

/// The grand layout for all documentation content.
///
/// This layout provides:
/// - A tree view navigation sidebar (left)
/// - A Table of Contents sidebar (right)
/// - A consistent wrapper for all documentation pages
@ZenLayout(type: LayoutType.stack)
class DocsLayout extends _$DocsLayout {
  static const _navTree = [
    NavTreeNode(
      label: 'Paradigms',
      children: [
        NavTreeNode(label: 'Imperative', path: '/docs/paradigms/imperative'),
        NavTreeNode(label: 'Declarative', path: '/docs/paradigms/declarative'),
        NavTreeNode(label: 'Coordinator', path: '/docs/paradigms/coordinator'),
        NavTreeNode(label: 'Choosing', path: '/docs/paradigms/choosing'),
      ],
    ),
    NavTreeNode(
      label: 'Concepts',
      children: [
        NavTreeNode(
          label: 'Routes & Paths',
          path: '/docs/concepts/routes-and-paths',
        ),
        NavTreeNode(label: 'URI Parsing', path: '/docs/concepts/uri-parsing'),
        NavTreeNode(
          label: 'Stack Management',
          path: '/docs/concepts/stack-management',
        ),
      ],
    ),
    NavTreeNode(
      label: 'Patterns',
      children: [
        NavTreeNode(label: 'Layouts', path: '/docs/patterns/layouts'),
        NavTreeNode(
          label: 'Guards & Redirects',
          path: '/docs/patterns/guards-redirects',
        ),
        NavTreeNode(label: 'Deep Linking', path: '/docs/patterns/deep-linking'),
        NavTreeNode(
          label: 'Query Parameters',
          path: '/docs/patterns/query-parameters',
        ),
      ],
    ),
    NavTreeNode(
      label: 'File Routing',
      children: [
        NavTreeNode(
          label: 'Getting Started',
          path: '/docs/file-routing/getting-started',
        ),
        NavTreeNode(
          label: 'Conventions',
          path: '/docs/file-routing/conventions',
        ),
        NavTreeNode(
          label: 'Dynamic Routes',
          path: '/docs/file-routing/dynamic-routes',
        ),
        NavTreeNode(
          label: 'Deferred Imports',
          path: '/docs/file-routing/deferred-imports',
        ),
      ],
    ),
    NavTreeNode(
      label: 'Examples',
      children: [
        NavTreeNode(
          label: 'Basic Navigation',
          path: '/docs/examples/basic-navigation',
        ),
        NavTreeNode(label: 'Tab Bar', path: '/docs/examples/tab-bar'),
        NavTreeNode(label: 'Deep Linking', path: '/docs/examples/deep-linking'),
        NavTreeNode(label: 'Auth Flow', path: '/docs/examples/auth-flow'),
      ],
    ),
  ];

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    return ListenableBuilder(
      listenable: coordinator,
      builder: (context, _) {
        final currentPath =
            coordinator.activePath.activeRoute?.toUri().path ?? '/';
        return DocsLayoutBuilder(
          navTree: _navTree,
          currentPath: currentPath,
          onNavigate: (path) async => coordinator.navigate(
            await coordinator.parseRouteFromUri(Uri.parse(path)),
          ),
          child: buildPath(coordinator),
        );
      },
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for DocsLayout.
///
/// URI: /docs
/// Path type: stack
/// Parent layout: RootLayout
abstract class _$DocsLayout extends DocsRoute with RouteLayout<DocsRoute> {
  _$DocsLayout();

  @override
  Type? get layout => RootLayout;

  @override
  NavigationPath<DocsRoute> resolvePath(
    covariant DocsCoordinator coordinator,
  ) => coordinator.docsPath;

  @override
  Uri toUri() => Uri.parse('/docs');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/index.dart
================================================
/// # Documentation Index
///
/// The gateway to all ZenRouter documentation. Here we present
/// the structure of knowledge available to the reader, organized
/// into coherent sections that build upon one another.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/index.dart';
import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/theme/app_theme.dart';
import 'package:zenrouter_docs/widgets/mardown_section.dart';

import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

part 'index.g.dart';

/// The documentation index route, answering to `/docs`
///
/// This page serves as the entry point to all documentation,
/// presenting the reader with a clear map of available content
/// and guiding them toward the knowledge they seek.
@ZenRoute()
class DocsIndexRoute extends _$DocsIndexRoute {
  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    return const DocsIndexWidget();
  }
}

class DocsIndexWidget extends StatelessWidget {
  const DocsIndexWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final coordinator = context.docsCoordinator;

    final theme = Theme.of(context);
    final docs = theme.docs;

    return SelectionArea(
      child: Scaffold(
        body: SingleChildScrollView(
          padding: docs.contentPadding,
          child: Center(
            child: ConstrainedBox(
              constraints: BoxConstraints(maxWidth: docs.proseMaxWidth),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // ─────────────────────────────────────────────────────────────
                  // Title and Introduction
                  // ─────────────────────────────────────────────────────────────
                  Text('Documentation', style: theme.textTheme.displayMedium),
                  const SizedBox(height: 8),
                  Text(
                    'A Comprehensive Guide to ZenRouter',
                    style: theme.textTheme.headlineMedium?.copyWith(
                      color: theme.colorScheme.primary,
                      fontStyle: FontStyle.italic,
                    ),
                  ),
                  const SizedBox(height: 32),

                  const MarkdownSection(
                    markdown: '''
Welcome to the ZenRouter documentation. Here you will find everything you need to understand, implement, and master navigation in Flutter applications using ZenRouter.

This documentation is organized into five main sections, each building upon the others. Whether you are new to navigation systems or seeking to deepen your understanding, you will find content suited to your needs.

Use the navigation sidebar to explore specific topics, or begin your journey with one of the sections below.
    ''',
                  ),

                  const SizedBox(height: 48),

                  // ─────────────────────────────────────────────────────────────
                  // Navigation Cards
                  // ─────────────────────────────────────────────────────────────
                  const Divider(),
                  const SizedBox(height: 24),

                  buildNavigationList(context, coordinator),

                  const SizedBox(height: 64),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for DocsIndexRoute.
///
/// URI: /docs
/// Layout: DocsLayout
abstract class _$DocsIndexRoute extends DocsRoute {
  _$DocsIndexRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/_configuration/seo_title.dart
================================================
export 'seo_title.io.dart' if (dart.library.js_interop) 'seo_title.web.dart';



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/_configuration/seo_title.io.dart
================================================
void setWebTitle(String title) {}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/_configuration/seo_title.web.dart
================================================
// ignore: depend_on_referenced_packages
import 'package:web/web.dart';

void setWebTitle(String title) => document.title = title;



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/concepts/routes-and-paths.dart
================================================
/// # Routes and Paths
///
/// The fundamental building blocks: what is a Route, what is a Path,
/// and how do they relate to one another?
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'routes-and-paths.g.dart';

/// The Routes and Paths documentation page.
@ZenRoute()
class RoutesAndPathsRoute extends _$RoutesAndPathsRoute
    with RouteSeo, RouteToc {
  @override
  String get title => 'Routes & Paths';

  @override
  String get description => 'The Fundamental Building Blocks';

  @override
  String get keywords => 'Routes, Paths, Coordinator, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Routes & Paths',
      subtitle: 'The Fundamental Building Blocks',
      onTocItemsReady: (items) => tocItems.value = items,
      tocController: tocController,
      markdown: '''
Before we can navigate, we must understand what we are navigating *between* and what we are navigating *through*.

A Route is a destination - a thing you can go to. It is an object that knows how to build a widget and, optionally, how to express itself as a URI.

A Path is a container for routes - a stack that holds them in order, tracks which is active, and notifies listeners when anything changes.

The relationship is fundamental: routes are nouns, paths are the sentences that arrange them.

## RouteTarget: The Base Class

All routes in ZenRouter extend `RouteTarget`. This base class provides one critical capability: equality through the `props` getter.

When you override `props`, you tell ZenRouter which values define this route's identity. Two routes with the same runtime type and the same props are considered equal.

```dart
class ProfileRoute extends RouteTarget {
  ProfileRoute({required this.userId});
  
  final String userId;
  
  // These values define identity
  @override
  List<Object?> get props => [userId];
}

// These are equal:
ProfileRoute(userId: '123') == ProfileRoute(userId: '123'); // true

// These are not:
ProfileRoute(userId: '123') == ProfileRoute(userId: '456'); // false
```

## StackPath: The Container

A StackPath holds routes and notifies listeners when they change. There are two primary implementations:

**NavigationPath** - A dynamic stack where you can push, pop, and replace routes freely. Think of it as an ArrayList of routes.

**IndexedStackPath** - A fixed collection where you can only change which route is "active". Think of it as a tab bar: the tabs are predetermined, you just select between them.

```dart
final path = NavigationPath<AppRoute>.create();

// Add routes
path.push(HomeRoute());
path.push(ProfileRoute(userId: '123'));

// Remove routes
path.pop();              // Remove the top route
path.pop(HomeRoute());   // Remove specific route

// Replace
path.replace([HomeRoute()]);  // Clear and set new stack

// Query
path.stack;              // List of all routes
path.stack.last;         // Current (top) route
path.isEmpty;            // Is the stack empty?
```

## Why Equality Matters

Equality is not merely academic - it drives several critical behaviors:

1. **Duplicate Prevention**: Pushing a route equal to the current route is a no-op
2. **Declarative Diffing**: The Myers algorithm compares routes by equality to compute changes
3. **Deep Link Resolution**: The Coordinator checks if the parsed route equals the current route
4. **State Preservation**: Widget state is preserved when the route remains equal

If your routes do not implement `props` correctly, you may see routes pushed multiple times, unnecessary rebuilds, or lost widget state.

> A route without proper equality is like a person without a name - technically present, but impossible to address correctly.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/concepts/routes-and-paths.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'routes-and-paths.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for RoutesAndPathsRoute.
///
/// URI: /docs/concepts/routes-and-paths
/// Layout: DocsLayout
abstract class _$RoutesAndPathsRoute extends DocsRoute {
  _$RoutesAndPathsRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/concepts/routes-and-paths');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/concepts/stack-management.dart
================================================
/// # Stack Management
///
/// The operations that move us through our application: push, pop,
/// replace, and the subtleties that distinguish them.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'stack-management.g.dart';

/// The Stack Management documentation page.
@ZenRoute()
class StackManagementRoute extends _$StackManagementRoute
    with RouteSeo, RouteToc {
  @override
  String get description => 'Orchestrating the Navigation Stack';

  @override
  String get keywords => 'Stack Management, Coordinator, Flutter';

  @override
  String get title => 'Stack Management';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Stack Management',
      subtitle: 'Orchestrating the Navigation Stack',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
Navigation, at its core, is stack manipulation. We push routes to go forward, pop them to go back, and occasionally replace the entire stack when the user's context changes fundamentally (like after logging in or out).

The Coordinator provides several methods for stack manipulation, each with distinct semantics and use cases.

## push: Adding a Route

`push` adds a route to the top of the appropriate stack. It returns a `Future` that completes when that route is eventually popped, allowing you to receive results from child routes.

```dart
// Simple push
coordinator.push(ProfileRoute(userId: '123'));

// Push with result
final result = await coordinator.push(EditProfileRoute());
if (result == true) {
  // User saved changes
  showSnackbar('Profile updated!');
}

// In EditProfileRoute:
coordinator.pop(true);  // Pop with result
```

## pop: Removing Routes

`pop` removes the topmost route from the nearest dynamic path. You can optionally pass a result value that will be delivered to whoever pushed the route.

There's also `popTo`, which pops routes until a specific route is reached.

```dart
// Pop the top route
coordinator.pop();

// Pop with a result
coordinator.pop('success');
coordinator.pop({'saved': true});

// Pop until reaching a specific route
coordinator.popTo(HomeRoute());

// Programmatic back button
// (respects guards, see Patterns section)
coordinator.maybePop();
```

## replace: Resetting Context

`replace` clears the stack and pushes a new route. This is appropriate when the user's context changes fundamentally - after authentication, for instance.

```dart
// After successful login
void onLoginSuccess() {
  // Clear the auth flow, start fresh at home
  coordinator.replace(HomeRoute());
}

// After logout
void onLogout() {
  // Clear everything, show login
  coordinator.replace(LoginRoute());
}

// Replace doesn't trigger pop animations
// - good for context switches
// - not good for "going back"
```

## recover: Deep Link Handling

`recoverRouteFromUri` handles deep links. It parses a URI, constructs the navigation stack, and navigates to the target. This is what gets called when your app receives an external deep link.

The difference from `push` is that `recover` may reconstruct the entire navigation hierarchy to reach the target, ensuring that back navigation makes sense.

```dart
// When app receives deep link: myapp://profile/user-123
void handleDeepLink(Uri uri) {
  coordinator.recoverRouteFromUri(uri);
}

// The coordinator:
// 1. Parses the URI → ProfileRoute(userId: 'user-123')
// 2. Checks if route has custom deeplink handler
// 3. If not, builds appropriate navigation stack
// 4. Navigates to the route

// You can also recover programmatically
coordinator.recoverRouteFromUri(
  Uri.parse('/shop/product/abc123'),
);
```

## pushOrMoveToTop

Sometimes you want to navigate to a route that might already be in the stack. `pushOrMoveToTop` checks if an equal route exists in the stack; if so, it brings that route to the top. If not, it pushes the new route.

```dart
// User taps "Profile" multiple times
coordinator.pushOrMoveToTop(ProfileRoute(userId: '123'));
// First tap: pushes ProfileRoute
// Second tap: no-op (already on top)
// Tap from elsewhere: moves ProfileRoute to top

// Useful for:
// - Tab bar navigation
// - Toolbar shortcuts
// - Notifications that may be tapped multiple times
```
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/concepts/stack-management.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'stack-management.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for StackManagementRoute.
///
/// URI: /docs/concepts/stack-management
/// Layout: DocsLayout
abstract class _$StackManagementRoute extends DocsRoute {
  _$StackManagementRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/concepts/stack-management');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/concepts/uri-parsing.dart
================================================
/// # URI Parsing
///
/// The transformation at the heart of the Coordinator: turning URLs
/// into routes, and routes back into URLs.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'uri-parsing.g.dart';

/// The URI Parsing documentation page.
@ZenRoute()
class UriParsingRoute extends _$UriParsingRoute with RouteSeo, RouteToc {
  @override
  String get description => 'The Art of Address Translation';

  @override
  String get keywords => 'URI, Parsing, Coordinator, Flutter';

  @override
  String get title => 'URI Parsing';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'URI Parsing',
      subtitle: 'The Art of Address Translation',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
A URL is an address - a string of characters that identifies a resource. A route is an object - a Dart class instance that knows how to render itself. The Coordinator must translate between these two representations in both directions.

When a user navigates to a URL (by typing it, clicking a link, or using the browser's back button), the Coordinator parses that URL into a route. When the user pushes a route programmatically, the Coordinator updates the URL to match.

This bidirectional translation is what enables deep linking, browser navigation, and shareable URLs.

## parseRouteFromUri

The `parseRouteFromUri` method is the only abstract method in `Coordinator`. It receives a URI and must return a route. Dart's pattern matching makes this elegant:

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    // Empty path → home
    [] => HomeRoute(),
    
    // Single segment
    ['about'] => AboutRoute(),
    ['settings'] => SettingsRoute(),
    
    // Path with parameter
    ['profile', final userId] => ProfileRoute(userId: userId),
    ['post', final postId] => PostRoute(postId: postId),
    
    // Nested paths
    ['shop', 'product', final id] => ProductRoute(id: id),
    ['shop', 'cart'] => CartRoute(),
    
    // Catch-all with rest pattern
    ['docs', ...final slugs] => DocsRoute(slugs: slugs),
    
    // Fallback for unknown paths
    _ => NotFoundRoute(uri: uri),
  };
}
```

## toUri: The Reverse Journey

Every route that mixes in `RouteUnique` must implement `toUri()`. This method returns the URI that represents this route. It should be the inverse of `parseRouteFromUri`: if you parse the URI returned by `toUri()`, you should get an equal route back.

```dart
class ProfileRoute extends AppRoute {
  ProfileRoute({required this.userId});
  
  final String userId;
  
  @override
  Uri toUri() => Uri.parse('/profile/\$userId');
  
  @override
  List<Object?> get props => [userId];
}

// The round-trip should work:
final route = ProfileRoute(userId: '123');
final uri = route.toUri();  // /profile/123
final parsed = coordinator.parseRouteFromUri(uri);
assert(route == parsed);  // Should be true!
```

## Query Parameters

URIs can carry query parameters: `/search?q=flutter&page=2`. These are accessible via `uri.queryParameters` in your parsing logic:

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    ['search'] => SearchRoute(
      query: uri.queryParameters['q'] ?? '',
      page: int.tryParse(uri.queryParameters['page'] ?? '1') ?? 1,
    ),
    // ...
  };
}

class SearchRoute extends AppRoute {
  SearchRoute({required this.query, this.page = 1});
  
  final String query;
  final int page;
  
  @override
  Uri toUri() => Uri(
    path: '/search',
    queryParameters: {
      'q': query,
      if (page > 1) 'page': page.toString(),
    },
  );
  
  @override
  List<Object?> get props => [query, page];
}
```

> The beauty of Dart's pattern matching is that your routing logic reads like a specification. Each case is a rule: "this pattern means this route." There are no hidden conventions, no magic strings buried in annotations.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/concepts/uri-parsing.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'uri-parsing.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for UriParsingRoute.
///
/// URI: /docs/concepts/uri-parsing
/// Layout: DocsLayout
abstract class _$UriParsingRoute extends DocsRoute {
  _$UriParsingRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/concepts/uri-parsing');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/examples/_layout.dart
================================================
/// # Examples Section Layout
///
/// Pass-through layout - navigation is handled by the parent (docs) layout.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';

part '_layout.g.dart';

/// Pass-through layout for the Examples section.
@ZenLayout(type: LayoutType.stack)
class ExamplesLayout extends _$ExamplesLayout {
  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    return buildPath(coordinator);
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/examples/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for ExamplesLayout.
///
/// URI: /docs/examples
/// Path type: stack
/// Parent layout: DocsLayout
abstract class _$ExamplesLayout extends DocsRoute with RouteLayout<DocsRoute> {
  _$ExamplesLayout();

  @override
  Type? get layout => DocsLayout;

  @override
  NavigationPath<DocsRoute> resolvePath(
    covariant DocsCoordinator coordinator,
  ) => coordinator.examplesPath;

  @override
  Uri toUri() => Uri.parse('/docs/examples');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/examples/[slug]/index.dart
================================================
/// # Example Viewer
///
/// A dynamic route that displays live examples based on the slug parameter.
/// This demonstrates dynamic routing with [slug] in the file name.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_docs/widgets/mardown_section.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'index.g.dart';

/// The example viewer route at /examples/:slug
///
/// This file demonstrates the [slug] dynamic parameter pattern.
/// The slug is captured from the URL and passed to the route.
@ZenRoute()
class ExamplesSlugRoute extends _$ExamplesSlugRoute with RouteSeo, RouteToc {
  ExamplesSlugRoute({required super.slug});

  @override
  String get title {
    final example = examples[slug];
    return example?.title ?? 'Example Not Found';
  }

  @override
  String get description {
    final example = examples[slug];
    return example?.subtitle ?? 'The requested example does not exist';
  }

  @override
  String get keywords {
    final example = examples[slug];
    return example != null
        ? 'Example, ${example.title}, Code Sample, Flutter'
        : 'Example, Not Found';
  }

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    final example = examples[slug];
    if (example == null) {
      return _buildNotFound(context, coordinator, tocController);
    }

    return DocPage(
      title: example.title,
      subtitle: example.subtitle,
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown:
          '''
${example.description}

## Implementation

```dart
${example.code}
```

${example.notes != null ? '## Notes\n\n${example.notes}' : ''}
''',
    );
  }

  Widget _buildNotFound(
    BuildContext context,
    DocsCoordinator coordinator,
    TocController? tocController,
  ) {
    return DocPage(
      title: 'Example Not Found',
      subtitle: 'The requested example does not exist',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown:
          '''
The example "$slug" does not exist.

Available examples:
- [Basic Navigation](examples/basic-navigation) - Push, Pop, and Replace
- [Tab Bar Navigation](examples/tab-bar) - IndexedStackPath with Multiple Tabs
- [Deep Linking](examples/deep-linking) - Custom Navigation Stack Setup
- [Authentication Flow](examples/auth-flow) - Guards and Redirects
''',
    );
  }
}

/// Example data model
class _Example {
  const _Example({
    required this.title,
    required this.subtitle,
    required this.description,
    required this.codeTitle,
    required this.code,
    this.notes,
  });

  final String title;
  final String subtitle;
  final String description;
  final String codeTitle;
  final String code;
  final String? notes;
}

/// Available examples, indexed by slug
const examples = <String, _Example>{
  'basic-navigation': _Example(
    title: 'Basic Navigation',
    subtitle: 'Push, Pop, and Replace',
    description: '''
This example demonstrates the fundamental navigation operations: pushing a new route onto the stack, popping back, and replacing the current route.

These operations form the foundation of all navigation in ZenRouter, whether using the imperative, declarative, or coordinator paradigm.
''',
    codeTitle: 'Basic Navigation Example',
    code: '''
// Define your routes
class HomeRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            ElevatedButton(
              // Push adds a route to the stack
              onPressed: () => coordinator.push(ProfileRoute()),
              child: const Text('Go to Profile'),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              // Replace clears the stack
              onPressed: () => coordinator.replace(SettingsRoute()),
              child: const Text('Replace with Settings'),
            ),
          ],
        ),
      ),
    );
  }
}

class ProfileRoute extends AppRoute {
  @override
  Uri toUri() => Uri.parse('/profile');

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Profile')),
      body: Center(
        child: ElevatedButton(
          // Pop removes the top route
          onPressed: () => coordinator.pop(),
          child: const Text('Go Back'),
        ),
      ),
    );
  }
}''',
    notes: '''
Key points:
- `push` adds to the stack - user can go back
- `pop` removes from the stack - returns to previous route
- `replace` clears everything - no back navigation
- The URL bar (on web) updates automatically with each navigation
''',
  ),

  'tab-bar': _Example(
    title: 'Tab Bar Navigation',
    subtitle: 'IndexedStackPath with Multiple Tabs',
    description: '''
Tab bars require a different navigation model: you're not pushing and popping, you're switching between a fixed set of destinations. Each tab maintains its own navigation state.

This example shows how to implement a bottom tab bar using IndexedStackPath and RouteLayout.
''',
    codeTitle: 'Tab Bar Implementation',
    code: '''
// In your Coordinator, define the tab path:
class AppCoordinator extends Coordinator<AppRoute> {
  late final tabsPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'tabs',
    [HomeTabLayout(), SearchTabLayout(), ProfileTabLayout()],
  );

  @override
  List<StackPath> get paths => [...super.paths, tabsPath];
}

// The tabs layout wraps all tab content
class TabsLayout extends AppRoute with RouteLayout<AppRoute> {
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) {
    return coordinator.tabsPath;
  }

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);

    return Scaffold(
      body: buildPath(coordinator),  // Renders active tab
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: path.activePathIndex,
        onTap: (index) => coordinator.push(path.stack[index]),
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
          BottomNavigationBarItem(icon: Icon(Icons.search), label: 'Search'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
        ],
      ),
    );
  }
}''',
    notes: '''
Key points:
- IndexedStackPath holds a fixed set of tab routes
- Each tab can have its own NavigationPath for internal push/pop
- Tab state is preserved when switching - users return where they left off
- Deep links work: /profile opens directly to the profile tab
''',
  ),

  'deep-linking': _Example(
    title: 'Deep Linking',
    subtitle: 'Custom Navigation Stack Setup',
    description: '''
When your app is opened from a URL, you need to set up an appropriate navigation stack. The user should be able to tap "back" and reach sensible screens.

This example shows how to implement custom deep link handling for complex flows.
''',
    codeTitle: 'Custom Deep Link Handler',
    code: '''
class ProductRoute extends AppRoute with RouteDeepLink {
  ProductRoute({required this.productId});

  final String productId;

  @override
  Uri toUri() => Uri.parse('/product/\$productId');

  // Use custom handling instead of simple replace
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;

  @override
  Future<void> deeplinkHandler(
    AppCoordinator coordinator,
    Uri uri,
  ) async {
    // Build a sensible navigation stack

    // 1. Start at home
    coordinator.replace(HomeRoute());

    // 2. Go to shop tab
    coordinator.push(ShopTabLayout());

    // 3. Show product category
    final category = await loadProductCategory(productId);
    coordinator.push(CategoryRoute(category: category));

    // 4. Finally, show this product
    coordinator.push(this);

    // Now "back" goes: Product → Category → Shop → Home
    // Much better than orphaned product page!
  }
}''',
    notes: '''
Key points:
- DeeplinkStrategy.custom gives full control over navigation setup
- Build a stack that makes "back" navigation sensible
- You can async load data before completing navigation
- Consider auth state - redirect to login if needed
''',
  ),

  'auth-flow': _Example(
    title: 'Authentication Flow',
    subtitle: 'Guards and Redirects',
    description: '''
Many apps have protected routes that require authentication. ZenRouter's RouteRedirect mixin lets you check auth state before showing a route, redirecting to login if needed.

This example demonstrates a complete authentication flow.
''',
    codeTitle: 'Protected Route with Auth Redirect',
    code: '''
// A mixin for routes that require authentication
mixin AuthRequired<T extends RouteTarget> on RouteRedirect<T> {
  @override
  FutureOr<T?> redirect() async {
    final isLoggedIn = await authService.isAuthenticated();

    if (!isLoggedIn) {
      // Redirect to login, saving intended destination
      return LoginRoute(redirectTo: toUri().toString()) as T;
    }

    return null;  // Proceed to this route
  }
}

// Apply to protected routes
class DashboardRoute extends AppRoute
    with RouteRedirect<AppRoute>, AuthRequired<AppRoute> {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return DashboardScreen();
  }
}

// Login handles the redirect back
class LoginRoute extends AppRoute {
  LoginRoute({this.redirectTo});

  final String? redirectTo;

  void onLoginSuccess(AppCoordinator coordinator) {
    if (redirectTo != null) {
      // Return to intended destination
      coordinator.recoverRouteFromUri(Uri.parse(redirectTo!));
    } else {
      // Default to home
      coordinator.replace(HomeRoute());
    }
  }
}''',
    notes: '''
Key points:
- RouteRedirect runs before the route is shown
- Return null to proceed, or another route to redirect
- Store the intended destination to return after login
- Consider using a mixin for reusable auth checks
''',
  ),
};



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/examples/[slug]/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ExamplesSlugRoute.
///
/// URI: /docs/examples/:slug
/// Layout: ExamplesLayout
abstract class _$ExamplesSlugRoute extends DocsRoute {
  /// Dynamic parameter from path segment.
  final String slug;

  _$ExamplesSlugRoute({required this.slug});

  @override
  Type? get layout => ExamplesLayout;

  @override
  Uri toUri() => Uri.parse('/docs/examples/$slug');

  @override
  List<Object?> get props => [slug];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/conventions.dart
================================================
/// # File Naming Conventions
///
/// The rules that transform file paths into URL paths.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'conventions.g.dart';

/// The Naming Conventions documentation page.
@ZenRoute()
class ConventionsRoute extends _$ConventionsRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Naming Conventions';

  @override
  String get description => 'The Rules of the Road';

  @override
  String get keywords => 'File Naming, Conventions, Route Groups, Layouts';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Naming Conventions',
      subtitle: 'The Rules of the Road',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
File-based routing follows a set of conventions that map file paths to URL paths. Understanding these conventions lets you design your route structure with intention.

## Basic Routes

| Pattern | URL | Description |
|---------|-----|-------------|
| `index.dart` | `/path` | Route at directory level |
| `about.dart` | `/path/about` | Named route |
| `[id].dart` | `/path/:id` | Dynamic parameter |
| `[...slugs].dart` | `/path/*` | Catch-all parameter |
| `_layout.dart` | `-` | Layout wrapper |
| `_*.dart` | `-` | Private file (ignored) |
| `(group)/` | `-` | Route group (no URL segment) |

## The index.dart Pattern

A file named `index.dart` represents the route at its directory level. This lets you have both `/settings` (from `settings/index.dart`) and `/settings/account` (from `settings/account.dart`).

```json
routes/
├── settings/
│   ├── index.dart      # → /settings
│   ├── account.dart    # → /settings/account
│   └── privacy.dart    # → /settings/privacy
└── about.dart          # → /about
```

## Route Groups: (name)

Folders wrapped in parentheses create "route groups". They provide shared layouts without adding to the URL path. This documentation uses route groups extensively.

```json
routes/
├── (auth)/              # Route group - no URL segment
│   ├── _layout.dart     # Shared layout for auth pages
│   ├── login.dart       # → /login (NOT /(auth)/login)
│   └── register.dart    # → /register
├── (marketing)/
│   ├── _layout.dart     # Different layout
│   ├── pricing.dart     # → /pricing
│   └── features.dart    # → /features
└── dashboard.dart       # → /dashboard
```

## Layout Files: _layout.dart

A `_layout.dart` file defines a wrapper for all routes in its directory (and subdirectories). Use it for shared UI like navigation bars, sidebars, or common scaffolding.

```dart
// routes/tabs/_layout.dart
@ZenLayout(
  type: LayoutType.indexed,  // For tab-like navigation
  routes: [HomeRoute, SearchRoute, ProfileRoute],
)
class TabsLayout extends _\$TabsLayout {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);
    
    return Scaffold(
      body: buildPath(coordinator),  // Renders the current route
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: path.activePathIndex,
        onTap: (i) => coordinator.push(path.stack[i]),
        items: const [...],
      ),
    );
  }
}
```

## Private Files: _name.dart

Files starting with underscore are private - they don't become routes. Use them for:
- `_layout.dart` - Layout definitions
- `_coordinator.dart` - Coordinator configuration  
- `_route.dart` - Custom route base class
- Any shared utilities

The generator ignores these files when creating routes.

## Dot Notation

You can use dots in file names to represent nesting without creating directories. This flattens your file structure for deep paths.

```json
# These are equivalent:

# Directory approach
routes/shop/products/reviews.dart    # → /shop/products/reviews

# Dot notation approach
routes/shop.products.reviews.dart    # → /shop/products/reviews

# Useful for:
routes/settings.account.index.dart   # → /settings/account
routes/blog.[...slugs].dart          # → /blog/* (catch-all)
```
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/conventions.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'conventions.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ConventionsRoute.
///
/// URI: /docs/file-routing/conventions
/// Layout: DocsLayout
abstract class _$ConventionsRoute extends DocsRoute {
  _$ConventionsRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/file-routing/conventions');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/deferred-imports.dart
================================================
/// # Deferred Imports
///
/// Lazy loading routes for improved startup performance - load code
/// only when (and if) the user navigates there.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'deferred-imports.g.dart';

/// The Deferred Imports documentation page.
@ZenRoute()
class DeferredImportsRoute extends _$DeferredImportsRoute
    with RouteSeo, RouteToc {
  @override
  String get title => 'Deferred Imports';

  @override
  String get description => 'Lazy Loading for Performance';

  @override
  String get keywords =>
      'Deferred Imports, Lazy Loading, Code Splitting, Performance';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Deferred Imports',
      subtitle: 'Lazy Loading for Performance',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
Every route in your app contributes to its initial bundle size. For large applications with many routes, this can slow down startup - users wait longer before seeing anything, and on web, they download code they may never execute.

Deferred imports solve this: routes are loaded only when first navigated to. The initial bundle stays lean, and features load on demand.

## Enabling Deferred Imports

You can enable deferred imports per-route or globally.

```dart
// Per-Route Configuration
// Enable for a specific route
@ZenRoute(deferredImport: true)
class HeavyAdminPanelRoute extends _\$HeavyAdminPanelRoute {
  // This route and its dependencies load only when navigated to
}

// Disable for a critical route (when globally enabled)
@ZenRoute(deferredImport: false)
class HomeRoute extends _\$HomeRoute {
  // Always in initial bundle - no loading delay
}
```

```yaml
# build.yaml (Global Configuration)
# Enable deferred imports for all routes by default
targets:
  \$default:
    builders:
      zenrouter_file_generator|zen_coordinator:
        options:
          deferredImport: true
```

## Precedence Rules

When both per-route and global configuration exist:

1. **Route annotation wins**: Explicit `deferredImport: false` overrides global config
2. **IndexedStack routes are always non-deferred**: Tab routes need to be immediately available for smooth tab switching
3. **Global config applies otherwise**: Routes without explicit annotation use the global setting

## Generated Code

With deferred imports, the generator produces async navigation:

```dart
// Generated imports
import 'about.dart' deferred as about;
import 'admin.dart' deferred as admin;
import 'home.dart';  // Non-deferred (explicit or IndexedStack)

// Generated parseRouteFromUri (now async)
@override
Future<AppRoute> parseRouteFromUri(Uri uri) async {
  return switch (uri.pathSegments) {
    [] => HomeRoute(),  // Immediate
    ['about'] => await () async {
      await about.loadLibrary();
      return about.AboutRoute();
    }(),
    ['admin'] => await () async {
      await admin.loadLibrary();
      return admin.AdminPanelRoute();
    }(),
    _ => NotFoundRoute(uri: uri),
  };
}

// Generated navigation (also async)
Future<T?> pushAbout<T extends Object>() async => push(await () async {
  await about.loadLibrary();
  return about.AboutRoute();
}());
```

## Performance Benefits

Real-world benchmarks show significant improvements:

| Metric | Without Deferred | With Deferred | Change |
|--------|------------------|---------------|--------|
| Initial bundle | 2,414 KB | 2,155 KB | -10.7% |
| Total app size | 2,719 KB | 2,759 KB | +1.5% |
| Deferred chunks | 0 | 24 | - |

**Key Benefits:**
- Initial bundle reduced by ~10-15%
- Faster time-to-interactive for users
- Better caching - unchanged routes don't re-download
- Code splitting happens automatically

**Trade-offs:**
- Slight navigation delay on first visit to deferred routes
- Small increase in total code size (~1-2%)
- Async nature propagates through navigation methods

> This documentation app uses deferred imports. Most pages load on-demand, keeping the initial bundle lean. The home page and critical navigation are non-deferred for instant interaction.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/deferred-imports.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'deferred-imports.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for DeferredImportsRoute.
///
/// URI: /docs/file-routing/deferred-imports
/// Layout: DocsLayout
abstract class _$DeferredImportsRoute extends DocsRoute {
  _$DeferredImportsRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/file-routing/deferred-imports');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/dynamic-routes.dart
================================================
/// # Dynamic Routes
///
/// Parameters in URLs: single segments like `:id` and catch-all
/// segments like `*rest`.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'dynamic-routes.g.dart';

/// The Dynamic Routes documentation page.
@ZenRoute()
class DynamicRoutesRoute extends _$DynamicRoutesRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Dynamic Routes';

  @override
  String get description => 'Parameters and Catch-All Patterns';

  @override
  String get keywords => 'Dynamic Routes, Parameters, Catch-All, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Dynamic Routes',
      subtitle: 'Parameters and Catch-All Patterns',
      onTocItemsReady: (items) => tocItems.value = items,
      tocController: tocController,
      markdown: '''
Not every route is static. A user profile needs a user ID. A blog post needs a slug. Documentation might have arbitrary nested paths. Dynamic routes handle these cases with parameters.

## Single-Segment Parameters: [param]

A file named `[something].dart` creates a route that captures a single path segment. The captured value becomes a parameter on your route class.

```dart
// routes/profile/[userId].dart
@ZenRoute()
class ProfileUserIdRoute extends _\$ProfileUserIdRoute {
  // The parameter is passed via the constructor
  ProfileUserIdRoute({required super.userId});
  
  @override
  Widget build(DocsCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile: \$userId')),
      body: ProfileContent(userId: userId),
    );
  }
}

// Generated navigation:
coordinator.pushProfileUserId(userId: 'user-123');

// URL: /profile/user-123
```

## Catch-All Parameters: [...param]

A file or folder named `[...something]` captures *all remaining* path segments as a `List<String>`. This is perfect for:
- Documentation with arbitrary nesting: `/docs/getting-started/installation`
- File browsers: `/files/folder/subfolder/file.txt`
- Blog post paths: `/blog/2024/01/my-post-title`

```dart
// routes/docs/[...slugs]/index.dart
@ZenRoute()
class DocsRoute extends _\$DocsRoute {
  DocsRoute({required super.slugs});  // List<String>
  
  @override
  Widget build(DocsCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Docs: \${slugs.join('/')}'),
      ),
      body: DocumentationContent(path: slugs),
    );
  }
}

// Usage:
coordinator.pushDocs(slugs: ['getting-started', 'installation']);
// URL: /docs/getting-started/installation

coordinator.pushDocs(slugs: ['api', 'coordinator', 'methods']);
// URL: /docs/api/coordinator/methods
```

## Combining Parameters

You can have routes inside a catch-all folder, combining catch-all with additional fixed or dynamic segments:

```json
routes/docs/
└── [...slugs]/
    ├── index.dart      # /docs/a/b/c (catch-all)
    ├── edit.dart       # /docs/a/b/c/edit
    └── [version].dart  # /docs/a/b/c/v2

# Matched paths:
/docs/api/coordinator         → DocsRoute(slugs: ['api', 'coordinator'])
/docs/api/coordinator/edit    → DocsEditRoute(slugs: ['api', 'coordinator'])
/docs/api/coordinator/v2      → DocsVersionRoute(slugs: ['api', 'coordinator'], version: 'v2')
```

## Generated Pattern Matching

The generator creates Dart pattern matching code that handles all these cases. Here's what it produces:

```dart
@override
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    // Static routes first (more specific)
    [] => IndexRoute(),
    ['about'] => AboutRoute(),
    
    // Single-segment parameters
    ['profile', final userId] => ProfileUserIdRoute(userId: userId),
    
    // Catch-all with additional segments (more specific first)
    ['docs', ...final slugs, 'edit'] => DocsEditRoute(slugs: slugs),
    ['docs', ...final slugs, final version] => DocsVersionRoute(
      slugs: slugs,
      version: version,
    ),
    
    // Pure catch-all (least specific)
    ['docs', ...final slugs] => DocsRoute(slugs: slugs),
    
    // Fallback
    _ => NotFoundRoute(uri: uri),
  };
}
```

> Note the ordering: more specific patterns come before less specific ones. The generator handles this automatically, ensuring `/docs/api/edit` matches the edit route, not the catch-all.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/dynamic-routes.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'dynamic-routes.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for DynamicRoutesRoute.
///
/// URI: /docs/file-routing/dynamic-routes
/// Layout: DocsLayout
abstract class _$DynamicRoutesRoute extends DocsRoute {
  _$DynamicRoutesRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/file-routing/dynamic-routes');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/getting-started.dart
================================================
/// # Getting Started with File-Based Routing
///
/// Your file structure becomes your route structure. No more
/// maintaining route lists - just create files and run build_runner.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'getting-started.g.dart';

/// The Getting Started documentation page for file-based routing.
@ZenRoute()
class GettingStartedRoute extends _$GettingStartedRoute
    with RouteSeo, RouteToc {
  @override
  String get title => 'Getting Started';

  @override
  String get description => 'File = Route';

  @override
  String get keywords => 'File-Based Routing, Getting Started, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Getting Started',
      subtitle: 'File = Route',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
The zenrouter_file_generator package brings file-based routing to Flutter - a pattern popularized by Next.js, Nuxt, and Expo Router. Instead of maintaining route lists and parsing logic manually, you create files and let the generator do the rest.

This documentation app is itself built with file-based routing. The file you're reading exists at `lib/routes/docs/file-routing/getting-started.dart`, which automatically creates the `/docs/file-routing/getting-started` URL you see in your browser.

## Installation

```yaml
# pubspec.yaml
dependencies:
  zenrouter: ^0.4.10
  zenrouter_file_annotation: ^0.4.9

dev_dependencies:
  build_runner: ^2.10.4
  zenrouter_file_generator: ^0.4.9
```

## Project Structure

Create a `routes` directory inside `lib`. Each file becomes a route:

```json
lib/routes/
├── _coordinator.dart    # Optional: configure coordinator name
├── _route.dart          # Optional: custom route base class
├── index.dart           # → /
├── about.dart           # → /about
├── profile/
│   └── [id].dart        # → /profile/:id
└── settings/
    ├── index.dart       # → /settings
    └── account.dart     # → /settings/account
```

## Your First Route

A route file is simple: import the annotation, extend the generated base class, and implement `build`:

```dart
// lib/routes/about.dart
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'about.g.dart';

@ZenRoute()
class AboutRoute extends _\$AboutRoute {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('About')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('Welcome to our app!'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.pushIndex(),
              child: const Text('Go Home'),
            ),
          ],
        ),
      ),
    );
  }
}
```

## Generate the Code

```json
# One-time generation
dart run build_runner build

# Watch mode (regenerates on file changes)
dart run build_runner watch
```

This generates:
- `routes.zen.dart` - Your coordinator with all routes and navigation methods
- `*.g.dart` files - Base classes for each route

The generated coordinator provides type-safe navigation methods like `pushAbout()`, `pushProfileId(id: '123')`, etc.

## Wire Up Your App

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'routes/routes.zen.dart';

final coordinator = AppCoordinator();

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}
```

> That's it. Create files, run `build_runner`, and you have a fully-functional routing system with deep linking, type-safe navigation, and URL synchronization.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/file-routing/getting-started.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'getting-started.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for GettingStartedRoute.
///
/// URI: /docs/file-routing/getting-started
/// Layout: DocsLayout
abstract class _$GettingStartedRoute extends DocsRoute {
  _$GettingStartedRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/file-routing/getting-started');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/choosing.dart
================================================
/// # Choosing Your Paradigm
///
/// For the practical reader who seeks not philosophy but guidance:
/// a decision tree for selecting the right navigation approach.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'choosing.g.dart';

/// The Choosing Your Paradigm documentation page.
@ZenRoute()
class ChoosingRoute extends _$ChoosingRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Choosing Your Paradigm';

  @override
  String get description => 'A Practical Decision Guide';

  @override
  String get keywords => 'Paradigms, Navigation, Decision Guide, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Choosing Your Paradigm',
      subtitle: 'A Practical Decision Guide',
      onTocItemsReady: (items) => tocItems.value = items,
      tocController: tocController,
      markdown: '''
Philosophy has its place, but at some point you must ship. This guide will help you select the right paradigm for your specific needs.

## Decision Flowchart

**Do you need deep linking or web support?**

- **YES** → Use Coordinator
  - URLs, browser back button, shareable links

- **NO** → Is navigation driven by application state?
  - **YES** → Use Declarative
    - Tab bars, wizards, filtered lists
  - **NO** → Use Imperative
    - Simple, event-driven, direct control

## Comparison Table

| Feature | Imperative | Declarative | Coordinator |
|---------|------------|-------------|-------------|
| Complexity | Simple | Moderate | Advanced |
| Deep Linking | No | No | Yes |
| Web Support | No | No | Yes |
| URL Sync | No | No | Yes |
| State-Driven | Manual | Native | Supported |
| File-Based Routing | No | No | Yes |
| Nested Navigation | Manual | Manual | Built-in |
| Best For | Mobile apps | Tab bars | Web, large apps |

## Can I Mix Paradigms?

Yes, and this is often the right approach. Consider:

- Use Coordinator for your app's main navigation (to enable deep linking)
- Use Declarative within a specific screen (a wizard, a tab bar)
- Use Imperative for simple modal flows within a screen

The paradigms are not mutually exclusive. They solve different problems at different scales. A Coordinator can contain screens that internally use declarative navigation, and those screens might spawn imperative modal flows.

> When in doubt, start with Coordinator. It offers the most capability, and zenrouter_file_generator makes it nearly as simple as imperative navigation. You can always simplify later.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/choosing.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'choosing.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ChoosingRoute.
///
/// URI: /docs/paradigms/choosing
/// Layout: DocsLayout
abstract class _$ChoosingRoute extends DocsRoute {
  _$ChoosingRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/paradigms/choosing');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/coordinator.dart
================================================
/// # The Coordinator Pattern
///
/// At last we arrive at the heart of ZenRouter: the Coordinator.
/// Here, imperative simplicity meets declarative elegance, and both
/// gain the power to speak the language of URLs.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'coordinator.g.dart';

/// The Coordinator Pattern documentation page.
@ZenRoute()
class CoordinatorRoute extends _$CoordinatorRoute with RouteSeo, RouteToc {
  @override
  String get title => 'The Coordinator Pattern';

  @override
  String get description => 'URI-Aware Navigation for the Modern Age';

  @override
  String get keywords => 'Coordinator, Deep Linking, URLs, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'The Coordinator Pattern',
      subtitle: 'URI-Aware Navigation for the Modern Age',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
The web was built on URLs. Every resource has an address; every address can be shared, bookmarked, or deep-linked. Mobile apps, for the most part, abandoned this - and then slowly realized what they had lost.

Deep linking. Universal links. Web support. State restoration. All of these require that your app understand URLs - that it can translate a URI into a navigation state and vice versa.

The Coordinator pattern provides this capability. It sits at the center of your app's navigation, parsing incoming URIs, managing multiple navigation paths, and ensuring that the URL bar (on web) always reflects the current state.

## Anatomy of a Coordinator

A Coordinator is a class that extends `Coordinator<YourRouteType>`. At minimum, you must implement one method: `parseRouteFromUri`, which takes a URI and returns a route.

```dart
// First, define your route base class with RouteUnique
abstract class AppRoute extends RouteTarget with RouteUnique {}

// Then, create your coordinator
class AppCoordinator extends Coordinator<AppRoute> {
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    // Pattern matching on path segments
    return switch (uri.pathSegments) {
      [] => HomeRoute(),
      ['about'] => AboutRoute(),
      ['profile', final id] => ProfileRoute(id: id),
      ['settings'] => SettingsRoute(),
      _ => NotFoundRoute(uri: uri),
    };
  }
}
```

## Routes with RouteUnique

Unlike routes in the imperative paradigm, Coordinator routes must know their URI. The RouteUnique mixin requires you to implement `toUri()`, allowing the Coordinator to update the URL when navigation changes.

```dart
class ProfileRoute extends AppRoute {
  ProfileRoute({required this.id});
  
  final String id;
  
  // Required: How does this route look as a URI?
  @override
  Uri toUri() => Uri.parse('/profile/\$id');
  
  // Required for routes with parameters:
  // Define equality based on significant values
  @override
  List<Object?> get props => [id];
  
  @override
  Widget build(Coordinator coordinator, BuildContext context) {
    return ProfileScreen(userId: id);
  }
}
```

## Integration with MaterialApp

The Coordinator provides a `routerDelegate` and `routeInformationParser` that plug directly into Flutter's Router system via `MaterialApp.router`.

```dart
final coordinator = AppCoordinator();

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// Now you can navigate:
coordinator.push(ProfileRoute(id: 'user-123'));
coordinator.pop();
coordinator.replace(HomeRoute());

// And handle deep links:
// Opening myapp://profile/user-456 will automatically
// parse and navigate to ProfileRoute(id: 'user-456')
```

> This documentation app uses the Coordinator pattern. Right now, your browser's URL bar (if you're on web) shows the path to this page. You could share that URL, and anyone opening it would arrive exactly here.

## Multiple Navigation Paths

Real apps often have nested navigation: a bottom tab bar with independent stacks, a drawer with a separate navigation context, nested tabs within tabs. The Coordinator supports this through multiple StackPaths.

Each path is a separate navigation stack. Routes declare which path they belong to via the `layout` property, and the Coordinator routes pushes to the appropriate stack.

We explore this in depth in the Layouts documentation.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/coordinator.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'coordinator.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for CoordinatorRoute.
///
/// URI: /docs/paradigms/coordinator
/// Layout: DocsLayout
abstract class _$CoordinatorRoute extends DocsRoute {
  _$CoordinatorRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/paradigms/coordinator');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/declarative.dart
================================================
/// # Declarative Navigation
///
/// A shift in perspective: what if we did not *tell* the stack what to do,
/// but instead *described* what it should contain? The stack becomes a
/// function of state, not a sequence of commands.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'declarative.g.dart';

/// The Declarative Navigation documentation page.
@ZenRoute()
class DeclarativeRoute extends _$DeclarativeRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Declarative Navigation';

  @override
  String get description => 'State-Driven Routing';

  @override
  String get keywords => 'Declarative Navigation, State-Driven, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Declarative Navigation',
      subtitle: 'State-Driven Routing',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
Consider the philosophy that underlies Flutter itself: you do not tell widgets how to update - you describe what they should look like given the current state, and Flutter reconciles your description with reality.

What if navigation worked the same way?

In declarative navigation, you do not push and pop. Instead, you maintain state - a list of items, a selected tab, a series of form steps - and derive your navigation stack from that state. When state changes, the stack updates automatically.

## NavigationStack.declarative

ZenRouter provides a declarative variant of NavigationStack. Instead of binding to a NavigationPath that you mutate, you provide a list of routes directly - typically derived from your widget's state.

```dart
class MultiStepForm extends StatefulWidget {
  @override
  State<MultiStepForm> createState() => _MultiStepFormState();
}

class _MultiStepFormState extends State<MultiStepForm> {
  final List<FormStep> _completedSteps = [];
  FormStep _currentStep = FormStep.personal;

  @override
  Widget build(BuildContext context) {
    return NavigationStack.declarative(
      // The stack is derived from state
      routes: [
        for (final step in _completedSteps) StepRoute(step),
        StepRoute(_currentStep),
      ],
      resolver: (route) => StackTransition.material(
        route.build(context),
      ),
    );
  }
  
  void completeStep() {
    setState(() {
      _completedSteps.add(_currentStep);
      _currentStep = _currentStep.next;
    });
    // No push() call needed - the stack updates from state
  }
}
```

## The Myers Diff Algorithm

When your route list changes, ZenRouter must determine what actually changed. Did you add a route? Remove one? Replace one? The answer matters for animations - a push should animate differently than a pop.

ZenRouter uses the Myers diff algorithm (the same algorithm that powers `git diff`) to compute the minimal set of changes between the old and new route lists. Routes are compared using their `props` - the list of values that define their identity.

> This is why equality matters: if two routes have the same props, they are considered the same route. The diff algorithm can then determine that you added a new route rather than replaced everything.

## When to Use Declarative

The declarative paradigm excels when:

- Your navigation is state-driven - tab selection, wizard steps, filtered lists
- You want navigation to stay in sync with application state automatically
- You're building interfaces where the "current screen" is a function of data
- You prefer React-like patterns where UI is a pure function of state

It struggles when:

- You need URLs to reflect navigation state
- You need deep linking from external sources  
- Your navigation is primarily event-driven (user taps → push)

```dart
class TabExample extends StatefulWidget {
  @override
  State<TabExample> createState() => _TabExampleState();
}

class _TabExampleState extends State<TabExample> {
  int _selectedTab = 0;
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: NavigationStack.declarative(
        routes: [
          // Base route is always present
          HomeRoute(),
          // The visible tab depends on state
          switch (_selectedTab) {
            0 => FeedRoute(),
            1 => SearchRoute(),
            2 => ProfileRoute(),
            _ => FeedRoute(),
          },
        ],
        resolver: (route) => StackTransition.fade(
          route.build(context),
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _selectedTab,
        onTap: (i) => setState(() => _selectedTab = i),
        items: [...],
      ),
    );
  }
}
```
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/declarative.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'declarative.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for DeclarativeRoute.
///
/// URI: /docs/paradigms/declarative
/// Layout: DocsLayout
abstract class _$DeclarativeRoute extends DocsRoute {
  _$DeclarativeRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/paradigms/declarative');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/imperative.dart
================================================
/// # Imperative Navigation
///
/// We begin where Flutter's navigation story began: with direct,
/// imperative control over a stack of routes. Push, pop, replace -
/// commands as clear as placing cards on a deck.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'imperative.g.dart';

/// The Imperative Navigation documentation page.
@ZenRoute()
class ImperativeRoute extends _$ImperativeRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Imperative Navigation';

  @override
  String get description => 'Direct Control Over the Stack';

  @override
  String get keywords => 'Imperative Navigation, NavigationPath, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Imperative Navigation',
      subtitle: 'Direct Control Over the Stack',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
In the beginning, there was the stack.

Flutter's original navigation model - what we now call Navigator 1.0 - gave developers direct, imperative control over a stack of routes. When you wished to show a new screen, you pushed it onto the stack. When you wished to dismiss it, you popped it off. The mental model was immediate and intuitive: a deck of cards, with the topmost card visible to the user.

ZenRouter's imperative paradigm preserves this simplicity while adding the structure of typed routes. You define your routes as classes, then manipulate them through a NavigationPath.

## The NavigationPath

A NavigationPath is, conceptually, a typed list of routes with built-in notification when it changes. You create one, optionally give it a default route, and then push and pop to your heart's content.

```dart
// Define your route base class
sealed class AppRoute extends RouteTarget {
  Widget build(BuildContext context);
}

// Create a navigation path
final path = NavigationPath<AppRoute>.create();

// Now you can navigate
path.push(HomeRoute());
path.push(ProfileRoute(userId: '123'));
path.pop();
```

## Rendering with NavigationStack

A NavigationPath holds state; a NavigationStack renders it. The stack listens to the path and rebuilds when routes change, handling transitions between them.

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: NavigationStack(
        path: path,
        defaultRoute: HomeRoute(),
        resolver: (route) => StackTransition.material(
          route.build(context),
        ),
      ),
    );
  }
}
```

## When to Use Imperative

The imperative paradigm excels when:

- Your navigation is event-driven - the user taps a button, you respond with a push
- You're building a mobile-only app without deep linking requirements  
- You're migrating from Navigator 1.0 and want a gentle transition
- Your navigation flows are linear and predictable

It struggles when:

- You need deep linking or web URL support
- Your navigation state should be derived from application state
- You need to rebuild complex navigation stacks from a single URL

> The imperative paradigm is not inferior to the others - it is appropriate for different circumstances. Many excellent apps need nothing more.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/paradigms/imperative.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'imperative.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ImperativeRoute.
///
/// URI: /docs/paradigms/imperative
/// Layout: DocsLayout
abstract class _$ImperativeRoute extends DocsRoute {
  _$ImperativeRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/paradigms/imperative');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/deep-linking.dart
================================================
/// # Deep Linking
///
/// When your app is opened from a link - an email, a notification, a QR code -
/// you must reconstruct the appropriate navigation state. This is deep linking.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'deep-linking.g.dart';

/// The Deep Linking documentation page.
@ZenRoute()
class DeepLinkingRoute extends _$DeepLinkingRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Deep Linking';

  @override
  String get description => 'Universal Links and External Navigation';

  @override
  String get keywords =>
      'Deep Linking, Universal Links, External Navigation, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Deep Linking',
      subtitle: 'Universal Links and External Navigation',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
A deep link is a URL that opens your app at a specific location. When the user clicks a link like `myapp://product/abc123` or `https://myapp.com/product/abc123`, your app should open directly to that product - not to the home screen with no context.

The Coordinator handles deep links automatically through `parseRouteFromUri`. But sometimes you need more control over how the navigation stack is constructed.

## Default Behavior

By default, when a deep link arrives, the Coordinator:

1. Calls `parseRouteFromUri` to convert the URL to a route
2. Replaces the current navigation stack with the new route
3. The URL bar (on web) updates to reflect the new state

This works well for simple cases, but sometimes you need the deep link to set up a proper navigation hierarchy.

## Custom Deep Link Handling

The RouteDeepLink mixin lets you customize how a route handles being the target of a deep link. You can set up the navigation stack however you like - ensuring that "back" navigation makes sense.

```dart
class ProductRoute extends AppRoute with RouteDeepLink {
  ProductRoute({required this.productId});
  
  final String productId;
  
  // Use custom handling instead of default replace
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(
    AppCoordinator coordinator,
    Uri uri,
  ) async {
    // Build a sensible navigation stack:
    // Home → Shop Tab → Product
    
    // First, ensure we're on the shop tab
    coordinator.replace(TabsLayout());
    
    // Wait for layout to build
    await Future.delayed(Duration.zero);
    
    // Push to shop tab's stack
    coordinator.push(ShopTabLayout());
    
    // Finally, push this product
    coordinator.push(this);
    
    // Now "back" goes to shop list, then tabs, then home
    // Much better UX than orphaned product page!
  }
}
```

## Deep Link Strategies

The `DeeplinkStrategy` enum provides three options:

**replace** (default) - Clear the stack and push this route. Simple but may lose navigation context.

**push** - Push onto the existing stack. Good when the current context is relevant.

**custom** - Use the `deeplinkHandler` method for full control.

```dart
// Default: replaces stack
class ArticleRoute extends AppRoute {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.replace;
}

// Push onto existing stack
class NotificationDetailRoute extends AppRoute with RouteDeepLink {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.push;
  // Good for notifications - preserves user's current context
}

// Full control
class CheckoutRoute extends AppRoute with RouteDeepLink {
  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
  
  @override
  Future<void> deeplinkHandler(...) async {
    // Maybe check auth first, redirect if needed
    // Set up cart context
    // Then navigate to checkout
  }
}
```

## Platform Setup

Deep linking requires platform configuration beyond ZenRouter. You'll need to:

**iOS**: Configure Associated Domains in Xcode and host an `apple-app-site-association` file on your domain.

**Android**: Add intent filters in `AndroidManifest.xml` and host an `assetlinks.json` file.

**Web**: Deep linking works automatically via the browser's URL bar.

See the official Flutter documentation on deep linking for platform-specific setup instructions.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/deep-linking.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'deep-linking.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for DeepLinkingRoute.
///
/// URI: /docs/patterns/deep-linking
/// Layout: DocsLayout
abstract class _$DeepLinkingRoute extends DocsRoute {
  _$DeepLinkingRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/patterns/deep-linking');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/guards-redirects.dart
================================================
/// # Guards and Redirects
///
/// Not every navigation should succeed. Sometimes we must ask "are you
/// sure?" and sometimes we must redirect the user elsewhere entirely.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'guards-redirects.g.dart';

/// The Guards and Redirects documentation page.
@ZenRoute()
class GuardsRedirectsRoute extends _$GuardsRedirectsRoute
    with RouteSeo, RouteToc {
  @override
  String get title => 'Guards & Redirects';

  @override
  String get description => 'Controlling Navigation Flow';

  @override
  String get keywords => 'Guards, Redirects, Route Protection, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Guards & Redirects',
      subtitle: 'Controlling Navigation Flow',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
Sometimes navigation must be conditional. A checkout screen requires authentication. An editor should warn before discarding unsaved changes. A route might need to redirect to another based on application state.

ZenRouter provides two mixins for this: RouteGuard and RouteRedirect.

## RouteGuard: Controlling Exit

A guard controls whether navigation *away* from a route is allowed. When the user tries to pop (via back button, gesture, or programmatic pop), the guard's `popGuard` method is called. Return `true` to allow the pop, `false` to prevent it.

```dart
class EditPostRoute extends AppRoute with RouteGuard {
  bool hasUnsavedChanges = false;
  
  @override
  FutureOr<bool> popGuard() async {
    if (!hasUnsavedChanges) return true;
    
    // Show confirmation dialog
    final result = await showDialog<bool>(
      context: currentContext,
      builder: (context) => AlertDialog(
        title: const Text('Discard changes?'),
        content: const Text('You have unsaved changes.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Discard'),
          ),
        ],
      ),
    );
    
    return result ?? false;
  }
}
```

## RouteRedirect: Controlling Entry

A redirect controls whether navigation *to* a route is allowed - and where to go instead. The `redirect` method is called before the route is shown. Return `null` to proceed normally, or return a different route to redirect.

```dart
class CheckoutRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  FutureOr<AppRoute?> redirect() async {
    final isLoggedIn = await authService.isAuthenticated();
    
    if (!isLoggedIn) {
      // Redirect to login, preserving the intended destination
      return LoginRoute(redirectTo: toUri().toString());
    }
    
    // Proceed normally
    return null;
  }
}

// Multiple conditions
class AdminRoute extends AppRoute with RouteRedirect<AppRoute> {
  @override
  FutureOr<AppRoute?> redirect() async {
    final user = await authService.currentUser();
    
    if (user == null) {
      return LoginRoute();
    }
    
    if (!user.isAdmin) {
      return UnauthorizedRoute();
    }
    
    return null;  // Proceed to admin panel
  }
}
```

## File-Based Routing Integration

When using zenrouter_file_generator, you enable guards and redirects through the @ZenRoute annotation:

```dart
@ZenRoute(
  guard: true,     // Enable RouteGuard mixin
  redirect: true,  // Enable RouteRedirect mixin
)
class CheckoutRoute extends _\$CheckoutRoute {
  @override
  FutureOr<bool> popGuard() async {
    // Your guard logic
  }
  
  @override
  FutureOr<DocsRoute?> redirect() async {
    // Your redirect logic
  }
}
```

> Guards and redirects are checked before any transition animation begins. The user never sees a flash of the protected content - the redirect happens before rendering.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/guards-redirects.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'guards-redirects.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for GuardsRedirectsRoute.
///
/// URI: /docs/patterns/guards-redirects
/// Layout: DocsLayout
abstract class _$GuardsRedirectsRoute extends DocsRoute {
  _$GuardsRedirectsRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/patterns/guards-redirects');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/layouts.dart
================================================
/// # Layouts
///
/// Nested navigation through the RouteLayout mixin - tab bars within
/// tab bars, drawers with their own stacks, complex hierarchies made manageable.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'layouts.g.dart';

/// The Layouts documentation page.
@ZenRoute()
class LayoutsRoute extends _$LayoutsRoute with RouteSeo, RouteToc {
  @override
  String get title => 'Layouts';

  @override
  String get description => 'Nested Navigation Hierarchies';

  @override
  String get keywords => 'Layouts, Nested Navigation, RouteLayout, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Layouts',
      subtitle: 'Nested Navigation Hierarchies',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
Real applications rarely have flat navigation. Consider a typical mobile app: a bottom tab bar with three tabs, each tab having its own navigation stack. When you're deep in the Feed tab and switch to Profile, then back to Feed, you expect to return to where you were.

This is nested navigation, and ZenRouter handles it through the RouteLayout mixin.

## The RouteLayout Mixin

A layout is a route that contains other routes. It wraps child routes with shared UI (like a scaffold with a bottom nav bar) and manages its own navigation path.

```dart
class TabsLayout extends AppRoute with RouteLayout<AppRoute> {
  // Which path does this layout manage?
  @override
  IndexedStackPath<AppRoute> resolvePath(AppCoordinator coordinator) {
    return coordinator.tabsPath;
  }
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);
    
    return Scaffold(
      // buildPath renders the current child route
      body: buildPath(coordinator),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: path.activePathIndex,
        onTap: (index) {
          // Push the tab route - coordinator handles the rest
          coordinator.push(path.stack[index]);
        },
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Home'),
          BottomNavigationBarItem(icon: Icon(Icons.search), label: 'Search'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
        ],
      ),
    );
  }
}
```

## Declaring Path Ownership

Routes declare which layout they belong to via the `layout` getter. When you push such a route, the Coordinator automatically wraps it with its layout and routes it to the correct path.

```dart
// In your coordinator, define the paths:
class AppCoordinator extends Coordinator<AppRoute> {
  late final tabsPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'tabs',
    [HomeTabLayout(), SearchTabLayout(), ProfileTabLayout()],
  );
  
  late final homeStack = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'home',
  );
  
  @override
  List<StackPath> get paths => [...super.paths, tabsPath, homeStack];
}

// Routes declare their layout:
class FeedRoute extends AppRoute {
  @override
  Type? get layout => HomeTabLayout;  // Belongs to home tab
  
  // ...
}

class PostDetailRoute extends AppRoute {
  @override
  Type? get layout => HomeTabLayout;  // Also in home tab
  
  // Pushing this from FeedRoute adds it to homeStack,
  // not to the root navigation
}
```

## IndexedStackPath vs NavigationPath

**IndexedStackPath** is for fixed collections where you switch between predefined routes. Tab bars are the classic example: the tabs are known upfront, you just select which one is active.

**NavigationPath** is for dynamic stacks where routes are pushed and popped. A detail screen pushed from a list, a multi-step wizard, a modal flow.

Often, you'll nest these: an IndexedStackPath for your tabs, with each tab containing a NavigationPath for its own push/pop navigation.

> This documentation app uses exactly this pattern. The main navigation is a stack (you can go from home to paradigms to concepts), but within each section, a stack renders the current page while the sidebar shows all available pages.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/layouts.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'layouts.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for LayoutsRoute.
///
/// URI: /docs/patterns/layouts
/// Layout: DocsLayout
abstract class _$LayoutsRoute extends DocsRoute {
  _$LayoutsRoute();

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() => Uri.parse('/docs/patterns/layouts');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/query-parameters.dart
================================================
/// # Query Parameters
///
/// The question mark in your URL: `/search?q=flutter&page=2`.
/// How to read them, update them, and react to their changes.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/_coordinator.dart';
import 'package:zenrouter_docs/widgets/docs_layout.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'package:zenrouter_docs/routes/routes.zen.dart';
import 'package:zenrouter_docs/widgets/doc_page.dart';

part 'query-parameters.g.dart';

/// The Query Parameters documentation page.
///
/// Note: We enable queries here as a workaround - the generator expects it
/// based on the route name pattern. This demonstrates the feature in action.
@ZenRoute(queries: ['*'])
class QueryParametersRoute extends _$QueryParametersRoute
    with RouteSeo, RouteToc {
  QueryParametersRoute({super.queries = const {}});

  @override
  String get title => 'Query Parameters';

  @override
  String get description => 'Reactive URL State';

  @override
  String get keywords => 'Query Parameters, URL State, Reactive, Flutter';

  @override
  Widget build(covariant DocsCoordinator coordinator, BuildContext context) {
    super.build(coordinator, context);
    final tocController = DocsTocScope.of(context);

    return DocPage(
      title: 'Query Parameters',
      subtitle: 'Reactive URL State',
      tocController: tocController,
      onTocItemsReady: (items) => tocItems.value = items,
      markdown: '''
Query parameters are the key-value pairs after the question mark in a URL: `/search?q=flutter&sort=recent&page=2`. They're useful for state that should be shareable via URL but doesn't warrant a separate route.

ZenRouter provides first-class support for query parameters, including reactive updates that rebuild only the widgets that depend on changed parameters.

## Enabling Query Parameters

When using zenrouter_file_generator, you enable query parameter support through the `@ZenRoute` annotation. You can enable all parameters with `['*']` or specify which parameters your route cares about.

```dart
// Enable specific parameters
@ZenRoute(queries: ['q', 'sort', 'page'])
class SearchRoute extends _\$SearchRoute {
  // ...
}

// Enable all parameters
@ZenRoute(queries: ['*'])
class FlexibleRoute extends _\$FlexibleRoute {
  // ...
}
```

## Reading Query Parameters

Routes with query support receive a `queries` map that you can access directly. For reactive updates, use `selectorBuilder` which rebuilds only when the selected value changes.

```dart
@ZenRoute(queries: ['q', 'page', 'sort'])
class SearchRoute extends _\$SearchRoute {
  @override
  Widget build(DocsCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        // This rebuilds only when 'q' changes
        title: selectorBuilder<String>(
          selector: (queries) => queries['q'] ?? '',
          builder: (context, searchTerm) {
            return Text('Search: \$searchTerm');
          },
        ),
      ),
      body: Column(
        children: [
          // This rebuilds only when 'sort' changes
          selectorBuilder<String>(
            selector: (queries) => queries['sort'] ?? 'recent',
            builder: (context, sortOrder) {
              return SortDropdown(
                value: sortOrder,
                onChanged: (value) => updateQueries(
                  coordinator,
                  queries: {...queries, 'sort': value},
                ),
              );
            },
          ),
          
          // Search results - rebuilds when q or sort changes
          Expanded(
            child: selectorBuilder<(String, String)>(
              selector: (q) => (q['q'] ?? '', q['sort'] ?? 'recent'),
              builder: (context, params) {
                final (query, sort) = params;
                return SearchResults(query: query, sort: sort);
              },
            ),
          ),
        ],
      ),
    );
  }
}
```

## Updating Query Parameters

Use `updateQueries` to change query parameters without a full navigation. The URL updates, listeners are notified, and only the affected widgets rebuild.

```dart
// Update a single parameter
updateQueries(
  coordinator,
  queries: {...queries, 'page': '2'},
);

// Update multiple parameters
updateQueries(
  coordinator,
  queries: {
    ...queries,
    'q': 'new search',
    'page': '1',  // Reset to page 1 on new search
  },
);

// Remove a parameter
final newQueries = Map.of(queries)..remove('sort');
updateQueries(coordinator, queries: newQueries);

// Clear all parameters
updateQueries(coordinator, queries: {});
```

> Query parameters are ideal for filter/sort/search state - values that should be shareable and bookmarkable but that don't represent fundamentally different screens. When in doubt, ask: "Should this state be lost when the user navigates away?" If yes, use widget state. If no, consider query parameters.
''',
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/routes/docs/patterns/query-parameters.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'query-parameters.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for QueryParametersRoute.
///
/// URI: /docs/patterns/query-parameters
/// Layout: DocsLayout
abstract class _$QueryParametersRoute extends DocsRoute
    with RouteQueryParameters {
  @override
  late final ValueNotifier<Map<String, String>> queryNotifier;

  _$QueryParametersRoute({Map<String, String> queries = const {}})
    : queryNotifier = ValueNotifier(queries);

  @override
  Type? get layout => DocsLayout;

  @override
  Uri toUri() {
    final uri = Uri.parse('/docs/patterns/query-parameters');
    if (queries.isEmpty) return uri;
    return uri.replace(queryParameters: queries);
  }

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_docs/lib/theme/app_theme.dart
================================================
[Binary file]


================================================
FILE: packages/zenrouter_docs/lib/widgets/breadcrumb.dart
================================================
/// A breadcrumb navigation widget for displaying hierarchical navigation paths.
library;

import 'package:flutter/material.dart';
import 'package:zenrouter_docs/routes/routes.zen.dart';

/// Represents a single breadcrumb item in the navigation path.
class BreadcrumbItem {
  const BreadcrumbItem({required this.label, this.route});

  /// The display label for this breadcrumb segment
  final String label;

  /// Optional route to navigate to when clicked. If null, segment is not clickable.
  final DocsRoute? route;
}

/// A breadcrumb navigation widget that displays a hierarchical path.
///
/// Shows clickable segments separated by '/' characters. Non-clickable segments
/// (those without a route) are displayed in a muted color.
class Breadcrumb extends StatelessWidget {
  const Breadcrumb({super.key, required this.items});

  final List<BreadcrumbItem> items;

  @override
  Widget build(BuildContext context) {
    if (items.isEmpty) {
      return const SizedBox.shrink();
    }

    final theme = Theme.of(context);
    final coordinator = DocsCoordinatorProvider.of(context);

    return Wrap(
      crossAxisAlignment: WrapCrossAlignment.center,
      spacing: 8,
      children: [
        for (int i = 0; i < items.length; i++) ...[
          _BreadcrumbSegment(
            item: items[i],
            coordinator: coordinator,
            isLast: i == items.length - 1,
          ),
          if (i < items.length - 1)
            Text(
              '/',
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurface.withValues(alpha: 0.4),
              ),
            ),
        ],
      ],
    );
  }
}

/// A single segment in the breadcrumb navigation.
class _BreadcrumbSegment extends StatefulWidget {
  const _BreadcrumbSegment({
    required this.item,
    required this.coordinator,
    required this.isLast,
  });

  final BreadcrumbItem item;
  final DocsCoordinator coordinator;
  final bool isLast;

  @override
  State<_BreadcrumbSegment> createState() => _BreadcrumbSegmentState();
}

class _BreadcrumbSegmentState extends State<_BreadcrumbSegment> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isClickable = widget.item.route != null && !widget.isLast;

    final textStyle = theme.textTheme.bodySmall?.copyWith(
      color: widget.isLast
          ? theme.colorScheme.onSurface.withValues(alpha: 0.6)
          : _isHovered && isClickable
          ? theme.colorScheme.primary
          : theme.colorScheme.onSurface.withValues(alpha: 0.8),
      fontWeight: widget.isLast ? FontWeight.normal : FontWeight.w500,
    );

    if (!isClickable) {
      return Text(widget.item.label, style: textStyle);
    }

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        onTap: () {
          if (widget.item.route != null) {
            widget.coordinator.navigate(widget.item.route!);
          }
        },
        child: AnimatedDefaultTextStyle(
          duration: const Duration(milliseconds: 200),
          style: textStyle ?? const TextStyle(),
          child: Text(widget.item.label),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/widgets/code_block.dart
================================================
/// # Code Block Widget
///
/// Code examples are the bridge between theory and practice. They must
/// be readable, copyable, and visually distinct from prose. We use
/// syntax highlighting to aid comprehension and a monospace font to
/// preserve alignment.
library;

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:syntax_highlight/syntax_highlight.dart';

import 'package:zenrouter_docs/theme/app_theme.dart';

/// A syntax-highlighted code block with optional title and copy button.
class CodeBlock extends StatefulWidget {
  const CodeBlock({
    super.key,
    required this.code,
    this.language = 'dart',
    this.title,
    this.showLineNumbers = false,
    this.highlightedLines = const [],
  });

  /// The source code to display
  final String code;

  /// The programming language for syntax highlighting
  final String language;

  /// Optional title shown above the code block
  final String? title;

  /// Whether to show line numbers
  final bool showLineNumbers;

  /// Lines to highlight (1-indexed)
  final List<int> highlightedLines;

  @override
  State<CodeBlock> createState() => _CodeBlockState();
}

class _CodeBlockState extends State<CodeBlock> {
  bool? _isDark;
  Future<Highlighter>? highlighter;

  Future<Highlighter> _initHighlighter(BuildContext context) async {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    final highlighterTheme = isDark
        ? await HighlighterTheme.loadDarkTheme()
        : await HighlighterTheme.loadLightTheme();
    await Highlighter.initialize([widget.language]);
    return Highlighter(language: widget.language, theme: highlighterTheme);
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        highlighter = _initHighlighter(context);
        setState(() {});
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final docs = theme.docs;
    final isDark = theme.brightness == Brightness.dark;
    if (_isDark != isDark) {
      _isDark = isDark;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          highlighter = _initHighlighter(context);
          setState(() {});
        }
      });
    }

    if (highlighter == null) return const SizedBox();

    return FutureBuilder(
      key: ValueKey(highlighter),
      future: highlighter!,
      builder: (context, snapshot) {
        if (!snapshot.hasData) return const SizedBox();

        final highlighter = snapshot.data!;
        final highlightedCode = highlighter.highlight(widget.code);

        return ConstrainedBox(
          constraints: BoxConstraints(maxWidth: docs.proseMaxWidth + 100),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Header with title and copy button
              if (widget.title != null) _buildHeader(context, isDark),

              // Code content - LayoutBuilder ensures full width when code is short
              LayoutBuilder(
                builder: (context, constraints) => SingleChildScrollView(
                  scrollDirection: Axis.horizontal,
                  physics: const ClampingScrollPhysics(),
                  child: ConstrainedBox(
                    constraints: BoxConstraints(minWidth: constraints.maxWidth),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Text.rich(
                        highlightedCode,
                        style: GoogleFonts.jetBrainsMono(
                          fontSize: 14,
                          color: theme.colorScheme.onSurface,
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildHeader(BuildContext context, bool isDark) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        border: Border(bottom: BorderSide(color: theme.dividerColor)),
      ),
      child: Row(
        children: [
          Icon(_getLanguageIcon(), size: 16, color: theme.colorScheme.primary),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              widget.title!,
              style: GoogleFonts.jetBrainsMono(
                fontSize: 13,
                fontWeight: FontWeight.w500,
                color: theme.colorScheme.onSurface.withValues(alpha: 0.8),
                decoration: TextDecoration.none,
              ),
            ),
          ),
          _CopyButton(code: widget.code),
        ],
      ),
    );
  }

  IconData _getLanguageIcon() {
    return switch (widget.language) {
      'dart' => Icons.flutter_dash_rounded,
      'yaml' => Icons.settings,
      'shell' => Icons.terminal,
      'json' => Icons.data_object,
      _ => Icons.code,
    };
  }
}

/// A button to copy code to clipboard.
class _CopyButton extends StatefulWidget {
  const _CopyButton({required this.code});

  final String code;

  @override
  State<_CopyButton> createState() => _CopyButtonState();
}

class _CopyButtonState extends State<_CopyButton> {
  bool _copied = false;

  Future<void> _copyToClipboard() async {
    await Clipboard.setData(ClipboardData(text: widget.code.trim()));
    setState(() => _copied = true);
    await Future.delayed(const Duration(seconds: 2));
    if (mounted) setState(() => _copied = false);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return IconButton(
      icon: Icon(
        _copied ? Icons.check : Icons.copy,
        size: 18,
        color: _copied
            ? Colors.green
            : theme.colorScheme.onSurface.withValues(alpha: 0.5),
      ),
      onPressed: _copyToClipboard,
      tooltip: _copied ? 'Copied!' : 'Copy code',
      visualDensity: VisualDensity.compact,
    );
  }
}

/// An inline code span for use within prose.
class InlineCode extends StatelessWidget {
  const InlineCode(this.code, {super.key});

  final String code;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final docs = theme.docs;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: docs.codeBackground,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        code,
        style: GoogleFonts.jetBrainsMono(
          fontSize: 14,
          color: theme.colorScheme.primary,
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/widgets/doc_page.dart
================================================
/// # Documentation Page Widget
///
/// A comprehensive widget for rendering markdown documentation
/// with automatic Table of Contents extraction.
library;

import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:zenrouter_docs/theme/app_theme.dart';

import 'package:zenrouter_docs/widgets/mardown_section.dart';

/// A documentation page that renders markdown with TOC support
class DocPage extends StatefulWidget {
  const DocPage({
    super.key,
    required this.markdown,
    required this.title,
    this.subtitle,
    this.tocController,
    this.bottomWidget,
    required this.onTocItemsReady,
  });

  final ValueChanged<List<TocItem>> onTocItemsReady;
  final String markdown;
  final String title;
  final String? subtitle;
  final TocController? tocController;
  final Widget? bottomWidget;

  @override
  State<DocPage> createState() => _DocPageState();
}

class _DocPageState extends State<DocPage> {
  late TocController _tocController;
  late ScrollController _scrollController;

  void _resetTocController() {
    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
      _tocController.clearItems();
    });
  }

  void _updateActiveItemFromScroll() {
    if (!_scrollController.hasClients) return;
    if (_tocController.items.isEmpty) return;

    final scrollPosition = _scrollController.position.pixels;
    final viewportHeight = MediaQuery.of(context).size.height;

    _tocController.updateActiveItemFromScrollPosition(
      scrollPosition,
      viewportHeight,
    );
  }

  void _onScroll() {
    if (_tocController.items.isEmpty) return;

    // Check if scrolled to bottom - if so, activate the last item
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.position.pixels;
    final isAtBottom = currentScroll >= maxScroll - 50; // 50px threshold

    if (isAtBottom) {
      _tocController.setActiveItem(_tocController.items.last, fromScroll: true);
      return;
    }

    // Find the heading that's closest to the top of the viewport
    TocItem? activeItem;
    double minDistance = double.infinity;

    for (final item in _tocController.items) {
      final context = item.key.currentContext;
      if (context == null) continue;

      final renderBox = context.findRenderObject() as RenderBox?;
      if (renderBox == null) continue;

      // Get the position of the heading relative to the viewport
      final position = renderBox.localToGlobal(Offset.zero);

      // Calculate distance from top of viewport
      // We use a small offset (100px) to activate items slightly before they reach the top
      final distance = (position.dy - 100).abs();

      // Only consider headings that are above or near the top of the viewport
      if (position.dy <= 200 && distance < minDistance) {
        minDistance = distance;
        activeItem = item;
      }
    }

    // If no item is near the top, use the first visible item
    if (activeItem == null) {
      for (final item in _tocController.items) {
        final context = item.key.currentContext;
        if (context == null) continue;

        final renderBox = context.findRenderObject() as RenderBox?;
        if (renderBox == null) continue;

        final position = renderBox.localToGlobal(Offset.zero);

        // Check if heading is visible in viewport
        if (position.dy >= 0 &&
            position.dy <= MediaQuery.of(context).size.height) {
          activeItem = item;
          break;
        }
      }
    }

    if (activeItem != null) {
      _tocController.setActiveItem(activeItem, fromScroll: true);
    }
  }

  @override
  void initState() {
    super.initState();
    _tocController = widget.tocController ?? TocController();
    _scrollController = ScrollController();
    _scrollController.addListener(_onScroll);

    // Set up callback to update active item when all items are ready
    _tocController.onItemsReady = () {
      widget.onTocItemsReady.call(_tocController.items);
      // Wait for next frame to ensure scroll position is restored
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted && _scrollController.hasClients) {
          _updateActiveItemFromScroll();
        }
      });
    };

    // Also check after the first frame when scroll controller might be attached
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted &&
          _scrollController.hasClients &&
          _tocController.items.isNotEmpty) {
        // Wait a bit more for scroll restoration to complete
        Future.delayed(const Duration(milliseconds: 100), () {
          if (mounted && _scrollController.hasClients) {
            _updateActiveItemFromScroll();
          }
        });
      }
    });
  }

  @override
  void didUpdateWidget(DocPage oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.markdown != widget.markdown) {
      _resetTocController();
    }
    // Update active item when widget is updated (e.g., route restored)
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted && _scrollController.hasClients) {
        _updateActiveItemFromScroll();
      }
    });
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final docs = theme.docs;

    return SelectionArea(
      child: SingleChildScrollView(
        controller: _scrollController,
        padding: docs.contentPadding,
        child: Center(
          child: ConstrainedBox(
            constraints: BoxConstraints(maxWidth: docs.proseMaxWidth),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Page title
                Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            widget.title,
                            style: GoogleFonts.libreBaskerville(
                              fontSize: 36,
                              fontWeight: FontWeight.bold,
                              color: theme.colorScheme.onSurface,
                              height: 1.2,
                            ),
                          ),
                          if (widget.subtitle != null) ...[
                            const SizedBox(height: 8),
                            Text(
                              widget.subtitle!,
                              style: GoogleFonts.libreBaskerville(
                                fontSize: 18,
                                fontStyle: FontStyle.italic,
                                color: theme.colorScheme.primary,
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                    Builder(
                      builder: (context) {
                        final size = MediaQuery.sizeOf(context);
                        final isWide = size.width >= 1200;
                        final isMedium = size.width >= 800;

                        return Row(
                          children: [
                            if (!isMedium && !isWide)
                              IconButton(
                                onPressed: () =>
                                    Scaffold.of(context).openDrawer(),
                                tooltip: 'Show documentation sidebar',
                                icon: const Icon(Icons.article),
                              ),
                            if (!isWide)
                              IconButton(
                                onPressed: () =>
                                    Scaffold.of(context).openEndDrawer(),
                                tooltip: 'Show table of contents',
                                icon: const Icon(Icons.menu_book_rounded),
                              ),
                          ],
                        );
                      },
                    ),
                  ],
                ),

                const SizedBox(height: 32),

                // Markdown content
                MarkdownSection(
                  markdown: widget.markdown,
                  tocController: _tocController,
                ),

                if (widget.bottomWidget != null) widget.bottomWidget!,
                // Extra padding at bottom to allow last sections to scroll to top
                SizedBox(height: MediaQuery.of(context).size.height * 0.7),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/lib/widgets/docs_layout.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_docs/widgets/mardown_section.dart';
import 'package:sliver_tools/sliver_tools.dart';

/// Tree node for navigation
class NavTreeNode {
  const NavTreeNode({required this.label, this.path, this.children = const []});

  final String label;
  final String? path;
  final List<NavTreeNode> children;

  bool get isLeaf => children.isEmpty;
}

/// Stateful wrapper to manage TOC controller
class DocsLayoutBuilder extends StatefulWidget {
  const DocsLayoutBuilder({
    super.key,
    required this.navTree,
    required this.currentPath,
    required this.onNavigate,
    required this.child,
  });

  final List<NavTreeNode> navTree;
  final String currentPath;
  final ValueChanged<String> onNavigate;
  final Widget child;

  @override
  State<DocsLayoutBuilder> createState() => _DocsLayoutContentState();
}

class _DocsLayoutContentState extends State<DocsLayoutBuilder> {
  late TocController _tocController;

  @override
  void initState() {
    super.initState();
    _tocController = TocController();
  }

  @override
  void dispose() {
    _tocController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final child = widget.child;

    return DocsTocScope(
      controller: _tocController,
      child: Scaffold(
        body: LayoutBuilder(
          builder: (context, constraints) {
            final isWide = constraints.maxWidth >= 1200;
            final isMedium = constraints.maxWidth >= 800;

            if (isWide) {
              // Wide: Left nav + Content + Right TOC
              return Center(
                child: ConstrainedBox(
                  constraints: const BoxConstraints(maxWidth: 1300),
                  child: Row(
                    children: [
                      _DocsTreeView(
                        navTree: widget.navTree,
                        currentPath: widget.currentPath,
                        onNavigate: widget.onNavigate,
                      ),
                      Expanded(child: child),
                      _DocsTocSidebar(controller: _tocController),
                    ],
                  ),
                ),
              );
            } else if (isMedium) {
              // Medium: Left nav + Content (TOC in end drawer)
              return Scaffold(
                endDrawer: Drawer(
                  child: SafeArea(
                    child: _DocsTocSidebar(
                      controller: _tocController,
                      isInDrawer: true,
                    ),
                  ),
                ),

                body: Row(
                  children: [
                    _DocsTreeView(
                      navTree: widget.navTree,
                      currentPath: widget.currentPath,
                      onNavigate: widget.onNavigate,
                    ),
                    Expanded(child: child),
                  ],
                ),
              );
            } else {
              // Narrow: Drawer nav + Content (TOC in end drawer)
              return Scaffold(
                drawer: Drawer(
                  child: SafeArea(
                    child: _DocsTreeView(
                      navTree: widget.navTree,
                      currentPath: widget.currentPath,
                      onNavigate: widget.onNavigate,
                    ),
                  ),
                ),
                endDrawer: Drawer(
                  child: SafeArea(
                    child: _DocsTocSidebar(
                      controller: _tocController,
                      isInDrawer: true,
                    ),
                  ),
                ),
                body: child,
              );
            }
          },
        ),
      ),
    );
  }
}

/// Table of Contents sidebar
class _DocsTocSidebar extends StatefulWidget {
  const _DocsTocSidebar({required this.controller, this.isInDrawer = false});

  final TocController controller;
  final bool isInDrawer;

  @override
  State<_DocsTocSidebar> createState() => _DocsTocSidebarState();
}

class _DocsTocSidebarState extends State<_DocsTocSidebar> {
  @override
  void initState() {
    super.initState();
    widget.controller.addListener(_onTocControllerChanged);
  }

  void _onTocControllerChanged() {
    setState(() {});
  }

  @override
  void dispose() {
    widget.controller.removeListener(_onTocControllerChanged);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final items = widget.controller.items;

    return Container(
      width: widget.isInDrawer ? null : 260,
      color: theme.colorScheme.surfaceContainerLow,
      child: items.isEmpty
          ? const SizedBox.shrink()
          : CustomScrollView(
              slivers: [
                SliverPadding(
                  padding: const EdgeInsets.all(16),
                  sliver: MultiSliver(
                    children: [
                      Text(
                        'Table of Contents',
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                          color: theme.colorScheme.onSurface,
                        ),
                      ),
                      const SizedBox(height: 16),
                      // TOC items
                      SliverList.separated(
                        itemCount: widget.controller.items.length,
                        separatorBuilder: (context, index) =>
                            const SizedBox(height: 8),
                        itemBuilder: (context, index) {
                          final item = widget.controller.items[index];
                          final isActive = widget.controller.activeItem == item;

                          return _TocListItem(
                            item: item,
                            isActive: isActive,
                            onTap: () {
                              widget.controller.scrollToItem(item);
                              if (widget.isInDrawer) {
                                Navigator.of(context).pop();
                              }
                            },
                          );
                        },
                      ),
                    ],
                  ),
                ),
                // Header
              ],
            ),
    );
  }
}

/// Individual TOC list item
class _TocListItem extends StatelessWidget {
  const _TocListItem({
    required this.item,
    required this.isActive,
    required this.onTap,
  });

  final TocItem item;
  final bool isActive;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      child: Text(
        '| ${item.title}',
        style: theme.textTheme.bodySmall?.copyWith(
          fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
          color: isActive
              ? theme.colorScheme.primary
              : theme.colorScheme.onSurface.withValues(alpha: 0.7),
        ),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
    );
  }
}

/// Tree view navigation sidebar
class _DocsTreeView extends StatefulWidget {
  const _DocsTreeView({
    required this.navTree,
    required this.currentPath,
    required this.onNavigate,
  });

  final List<NavTreeNode> navTree;
  final String currentPath;
  final ValueChanged<String> onNavigate;

  @override
  State<_DocsTreeView> createState() => _DocsTreeViewState();
}

class _DocsTreeViewState extends State<_DocsTreeView> {
  late Set<int> _expandedSections;

  @override
  void initState() {
    super.initState();
    _expandedSections = _findExpandedSections();
  }

  @override
  void didUpdateWidget(_DocsTreeView oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.currentPath != widget.currentPath) {
      final newExpanded = _findExpandedSections();
      _expandedSections = {..._expandedSections, ...newExpanded};
    }
  }

  Set<int> _findExpandedSections() {
    final expanded = <int>{};
    for (var i = 0; i < widget.navTree.length; i++) {
      expanded.add(i);
    }
    return expanded;
  }

  void _toggleSection(int index) {
    setState(() {
      if (_expandedSections.contains(index)) {
        _expandedSections.remove(index);
      } else {
        _expandedSections.add(index);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      width: 260,
      color: theme.colorScheme.surfaceContainerLow,
      child: CustomScrollView(
        slivers: [
          SliverPadding(
            padding: const EdgeInsets.all(16),
            sliver: MultiSliver(
              children: [
                Text(
                  'Documentation',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.onSurface,
                  ),
                ),
                const SizedBox(height: 16),
                SliverList.separated(
                  itemCount: widget.navTree.length,
                  separatorBuilder: (context, index) =>
                      const SizedBox(height: 4),
                  itemBuilder: (context, index) {
                    final section = widget.navTree[index];
                    final isExpanded = _expandedSections.contains(index);

                    return _TreeSection(
                      section: section,
                      isExpanded: isExpanded,
                      currentPath: widget.currentPath,
                      onToggle: () => _toggleSection(index),
                      onNavigate: widget.onNavigate,
                    );
                  },
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

/// A collapsible section in the tree view
class _TreeSection extends StatelessWidget {
  const _TreeSection({
    required this.section,
    required this.isExpanded,
    required this.currentPath,
    required this.onToggle,
    required this.onNavigate,
  });

  final NavTreeNode section;
  final bool isExpanded;
  final String currentPath;
  final VoidCallback onToggle;
  final ValueChanged<String> onNavigate;

  bool get _hasSelectedChild {
    for (final child in section.children) {
      if (child.path == currentPath) return true;
      if (currentPath.startsWith('/examples') && section.label == 'Examples') {
        return true;
      }
    }
    return false;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final sectionColor = theme.colorScheme.primary;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      spacing: 4,
      children: [
        // Section header
        InkWell(
          onTap: onToggle,
          child: Text(
            section.label,
            style: theme.textTheme.titleSmall?.copyWith(
              fontWeight: _hasSelectedChild ? FontWeight.w600 : FontWeight.w500,
              color: _hasSelectedChild
                  ? sectionColor
                  : theme.colorScheme.onSurface.withValues(alpha: 0.5),
            ),
          ),
        ),

        // Children
        switch (isExpanded) {
          true => Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            spacing: 4,
            children: [
              for (final child in section.children)
                _TreeLeaf(
                  node: child,
                  isSelected:
                      child.path == currentPath ||
                      (child.path != null &&
                          currentPath.startsWith(child.path!)),
                  sectionColor: sectionColor,
                  onTap: () {
                    if (child.path != null) {
                      onNavigate(child.path!);
                    }
                  },
                ),
            ],
          ),
          false => const SizedBox.shrink(),
        },
      ],
    );
  }
}

/// A leaf node (actual page) in the tree view
class _TreeLeaf extends StatelessWidget {
  const _TreeLeaf({
    required this.node,
    required this.isSelected,
    required this.sectionColor,
    required this.onTap,
  });

  final NavTreeNode node;
  final bool isSelected;
  final Color sectionColor;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      child: Container(
        width: double.maxFinite,
        padding: const EdgeInsets.symmetric(horizontal: 16),
        child: Text(
          node.label,
          style: theme.textTheme.bodyMedium?.copyWith(
            fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
            color: isSelected
                ? sectionColor
                : theme.colorScheme.onSurface.withValues(alpha: 0.5),
            fontSize: 12,
          ),
        ),
      ),
    );
  }
}

/// InheritedWidget to provide TOC controller to child routes
class DocsTocScope extends InheritedWidget {
  const DocsTocScope({
    super.key,
    required this.controller,
    required super.child,
  });

  final TocController controller;

  static TocController? of(BuildContext context) {
    return context
        .dependOnInheritedWidgetOfExactType<DocsTocScope>()
        ?.controller;
  }

  @override
  bool updateShouldNotify(DocsTocScope oldWidget) {
    return controller != oldWidget.controller;
  }
}



================================================
FILE: packages/zenrouter_docs/lib/widgets/mardown_section.dart
================================================
/// # Markdown Section Widget
///
/// A reusable widget for rendering markdown content with custom styling
/// and Table of Contents support.
library;

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_markdown_plus/flutter_markdown_plus.dart';
import 'package:markdown/markdown.dart' as md;
import 'package:google_fonts/google_fonts.dart';
import 'package:zenrouter_docs/theme/app_theme.dart';
import 'package:zenrouter_docs/widgets/code_block.dart';

/// Controller for managing TOC state
class TocController extends ChangeNotifier {
  final List<TocItem> _items = [];
  TocItem? _activeItem;
  bool _isUserScrolling = false;
  DateTime? _lastManualScroll;
  DateTime? _lastItemAdded;
  Timer? _itemsReadyTimer;

  List<TocItem> get items => List.unmodifiable(_items);
  TocItem? get activeItem => _activeItem;

  void setActiveItem(TocItem? item, {bool fromScroll = false}) {
    if (_activeItem != item) {
      // If this is from scroll listener, check if we should ignore it
      if (fromScroll && _isUserScrolling) {
        // Ignore scroll updates for 500ms after manual scroll
        final timeSinceManual = _lastManualScroll != null
            ? DateTime.now().difference(_lastManualScroll!)
            : null;
        if (timeSinceManual != null && timeSinceManual.inMilliseconds < 500) {
          return;
        }
        _isUserScrolling = false;
      }

      _activeItem = item;
      notifyListeners();
    }
  }

  void scrollToItem(TocItem item) {
    final context = item.key.currentContext;
    if (context != null) {
      _isUserScrolling = true;
      _lastManualScroll = DateTime.now();

      Scrollable.ensureVisible(
        context,
        duration: const Duration(milliseconds: 300),
        curve: Curves.decelerate,
        alignment: 0.1,
      );
      setActiveItem(item);
    }
  }

  void addItem(TocItem tocItem) {
    _items.add(tocItem);
    _lastItemAdded = DateTime.now();
    if (_items.length == 1) {
      setActiveItem(tocItem);
    }
    notifyListeners();

    // Cancel existing timer and start a new one
    // This will trigger the callback after items stop being added
    _itemsReadyTimer?.cancel();
    _itemsReadyTimer = Timer(const Duration(milliseconds: 200), () {
      if (onItemsReady != null && _lastItemAdded != null) {
        final timeSinceLastAdd = DateTime.now().difference(_lastItemAdded!);
        if (timeSinceLastAdd.inMilliseconds >= 150) {
          onItemsReady?.call();
        }
      }
    });
  }

  /// Callback to notify when items should be checked for scroll position
  /// This is called after items stop being added for a short period
  void Function()? onItemsReady;

  void clearItems() {
    _itemsReadyTimer?.cancel();
    _itemsReadyTimer = null;
    _items.clear();
    _activeItem = null;
    _lastItemAdded = null;
    notifyListeners();
  }

  /// Updates the active item based on the current scroll position
  /// This is useful when the route is restored and scroll position is already set
  void updateActiveItemFromScrollPosition(
    double scrollPosition,
    double viewportHeight,
  ) {
    if (_items.isEmpty) return;

    // Check if scrolled to bottom
    // Note: maxScrollExtent would need to be passed separately if needed
    // For now, we'll just check based on item positions

    TocItem? activeItem;
    double minDistance = double.infinity;

    for (final item in _items) {
      final context = item.key.currentContext;
      if (context == null) continue;

      final renderBox = context.findRenderObject() as RenderBox?;
      if (renderBox == null) continue;

      // Get the position of the heading relative to the viewport
      final position = renderBox.localToGlobal(Offset.zero);

      // Calculate distance from top of viewport (with offset)
      final distance = (position.dy - 100).abs();

      // Only consider headings that are above or near the top of the viewport
      if (position.dy <= 200 && distance < minDistance) {
        minDistance = distance;
        activeItem = item;
      }
    }

    // If no item is near the top, use the first visible item
    if (activeItem == null) {
      for (final item in _items) {
        final context = item.key.currentContext;
        if (context == null) continue;

        final renderBox = context.findRenderObject() as RenderBox?;
        if (renderBox == null) continue;

        final position = renderBox.localToGlobal(Offset.zero);

        // Check if heading is visible in viewport
        if (position.dy >= 0 && position.dy <= viewportHeight) {
          activeItem = item;
          break;
        }
      }
    }

    // If still no item found and we're at the top, use first item
    if (activeItem == null && scrollPosition <= 50) {
      activeItem = _items.isNotEmpty ? _items.first : null;
    }

    // If still no item found, use last item (likely at bottom)
    if (activeItem == null && _items.isNotEmpty) {
      activeItem = _items.last;
    }

    if (activeItem != null) {
      setActiveItem(activeItem, fromScroll: true);
    }
  }
}

/// A heading item extracted from markdown for TOC
class TocItem {
  const TocItem({required this.title, required this.level, required this.key});

  final String title;
  final int level;
  final GlobalKey key;
}

/// A widget that renders markdown content with custom styling
class MarkdownSection extends StatelessWidget {
  const MarkdownSection({
    super.key,
    required this.markdown,
    this.tocController,
  });

  final String markdown;
  final TocController? tocController;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return MarkdownBody(
      data: markdown,
      styleSheet: _buildMarkdownStyleSheet(context, isDark),
      extensionSet: md.ExtensionSet(
        md.ExtensionSet.gitHubFlavored.blockSyntaxes,
        <md.InlineSyntax>[
          md.EmojiSyntax(),
          ...md.ExtensionSet.gitHubFlavored.inlineSyntaxes,
        ],
      ),
      builders: {
        'pre': CodeBlockBuilder(),
        'code': CodeTextBuilder(context: context),
        'h1': HeadingBuilder(
          type: HeadingType.h1,
          tocController: tocController,
        ),
        'h2': HeadingBuilder(
          type: HeadingType.h2,
          tocController: tocController,
        ),
        'h3': HeadingBuilder(
          type: HeadingType.h3,
          tocController: tocController,
        ),
        'h4': HeadingBuilder(
          type: HeadingType.h4,
          tocController: tocController,
        ),
        'h5': HeadingBuilder(
          type: HeadingType.h5,
          tocController: tocController,
        ),
        'h6': HeadingBuilder(
          type: HeadingType.h6,
          tocController: tocController,
        ),
      },
    );
  }

  MarkdownStyleSheet _buildMarkdownStyleSheet(
    BuildContext context,
    bool isDark,
  ) {
    final theme = Theme.of(context);
    final docs = theme.docs;

    return MarkdownStyleSheet(
      // Heading styles
      h1: GoogleFonts.libreBaskerville(
        fontSize: 32,
        fontWeight: FontWeight.bold,
        color: theme.colorScheme.onSurface,
        height: 1.4,
      ),
      h2: GoogleFonts.libreBaskerville(
        fontSize: 26,
        fontWeight: FontWeight.bold,
        color: theme.colorScheme.onSurface,
        height: 1.4,
      ),
      h3: GoogleFonts.libreBaskerville(
        fontSize: 22,
        fontWeight: FontWeight.w600,
        color: theme.colorScheme.onSurface,
        height: 1.4,
      ),
      h4: GoogleFonts.libreBaskerville(
        fontSize: 18,
        fontWeight: FontWeight.w600,
        color: theme.colorScheme.onSurface,
        height: 1.4,
      ),
      h5: GoogleFonts.libreBaskerville(
        fontSize: 16,
        fontWeight: FontWeight.w600,
        color: theme.colorScheme.onSurface,
        height: 1.4,
      ),
      h6: GoogleFonts.libreBaskerville(
        fontSize: 14,
        fontWeight: FontWeight.w600,
        color: theme.colorScheme.onSurface,
        height: 1.4,
      ),

      // Paragraph style
      p: GoogleFonts.libreBaskerville(
        fontSize: 16,
        color: theme.colorScheme.onSurface.withValues(alpha: 0.87),
        height: 1.7,
        letterSpacing: 0.15,
      ),

      codeblockDecoration: BoxDecoration(
        color: docs.codeBackground,
        borderRadius: BorderRadius.circular(16),
      ),

      // Blockquote style
      blockquote: GoogleFonts.libreBaskerville(
        fontSize: 16,
        color: theme.colorScheme.onSurface.withValues(alpha: 0.8),
        fontStyle: FontStyle.italic,
        height: 1.6,
      ),
      blockquoteDecoration: BoxDecoration(
        border: Border(
          left: BorderSide(color: theme.colorScheme.primary, width: 4),
        ),
      ),
      blockquotePadding: const EdgeInsets.symmetric(
        horizontal: 20,
        vertical: 10,
      ),

      // Link style
      a: TextStyle(
        color: theme.colorScheme.primary,
        decoration: TextDecoration.underline,
        decorationColor: theme.colorScheme.primary.withValues(alpha: 0.5),
      ),

      // List styles
      listBullet: GoogleFonts.libreBaskerville(
        fontSize: 16,
        color: theme.colorScheme.primary,
        fontWeight: FontWeight.bold,
      ),
      listIndent: 20,

      // Table styles
      tableHead: GoogleFonts.libreBaskerville(
        fontWeight: FontWeight.bold,
        color: theme.colorScheme.onSurface,
      ),
      tableBody: GoogleFonts.libreBaskerville(
        color: theme.colorScheme.onSurface.withValues(alpha: 0.87),
      ),
      tableBorder: TableBorder.all(
        color: theme.colorScheme.outlineVariant.withValues(alpha: 0.5),
        borderRadius: BorderRadius.circular(8),
      ),
      tableCellsPadding: const EdgeInsets.all(12),

      // Horizontal rule
      horizontalRuleDecoration: BoxDecoration(
        border: Border(
          top: BorderSide(
            color: theme.colorScheme.outlineVariant.withValues(alpha: 0.5),
            width: 0.5,
          ),
        ),
      ),

      // Text alignment
      textAlign: WrapAlignment.start,
      blockSpacing: 16,

      code: GoogleFonts.ptMono(fontSize: 16, color: theme.colorScheme.primary),
    );
  }
}

/// Custom builder for code blocks that uses the CodeBlock widget
class CodeBlockBuilder extends MarkdownElementBuilder {
  @override
  Widget? visitElementAfterWithContext(
    BuildContext context,
    md.Element element,
    TextStyle? preferredStyle,
    TextStyle? parentStyle,
  ) {
    // Code blocks are wrapped in <pre><code> elements
    // Find the code element inside the pre element
    md.Element? codeElement;
    final children = element.children;
    if (children != null) {
      for (final child in children) {
        if (child is md.Element && child.tag == 'code') {
          codeElement = child;
          break;
        }
      }
    }

    if (codeElement == null) {
      return null; // Let default builder handle it
    }

    // Extract language from class attribute (e.g., "language-dart" -> "dart")
    final classAttr = codeElement.attributes['class'] ?? '';
    final language = classAttr.replaceAll('language-', '').trim();
    final code = codeElement.textContent.trim();

    if (code.isEmpty) {
      return const SizedBox.shrink();
    }

    return CodeBlock(
      title: language.isEmpty ? 'Code' : language,
      code: code,
      language: language.isEmpty ? 'dart' : language,
    );
  }
}

class CodeTextBuilder extends MarkdownElementBuilder {
  CodeTextBuilder({required this.context});

  final BuildContext context;

  @override
  Widget? visitElementAfterWithContext(
    BuildContext context,
    md.Element element,
    TextStyle? preferredStyle,
    TextStyle? parentStyle,
  ) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    // The issue: Container is a block widget, causing line breaks.
    // Solution: Wrap the Container in a WidgetSpan inside Text.rich
    // This allows it to be placed inline with surrounding text
    return Text.rich(
      WidgetSpan(
        alignment: PlaceholderAlignment.middle,
        child: Container(
          decoration: BoxDecoration(
            color: isDark ? const Color(0xFF2D2D2D) : const Color(0xFFEFF1F3),
            borderRadius: BorderRadius.circular(8),
          ),
          margin: const EdgeInsets.only(top: 0.8),
          padding: const EdgeInsets.symmetric(horizontal: 4),
          child: Text(
            element.textContent.trim(),
            style: GoogleFonts.ptMono(
              fontSize: 16,
              color: theme.colorScheme.primary,
            ),
          ),
        ),
      ),
    );
  }
}

class HeadingBuilder extends MarkdownElementBuilder {
  HeadingBuilder({required this.type, required this.tocController});

  final HeadingType type;
  final TocController? tocController;

  @override
  Widget? visitElementAfterWithContext(
    BuildContext context,
    md.Element element,
    TextStyle? preferredStyle,
    TextStyle? parentStyle,
  ) {
    return _HeadingWidget(
      type: type,
      tocController: tocController,
      element: element,
    );
  }
}

class _HeadingWidget extends StatefulWidget {
  const _HeadingWidget({
    required this.type,
    required this.tocController,
    required this.element,
  });

  final HeadingType type;
  final TocController? tocController;
  final md.Element element;

  @override
  State<_HeadingWidget> createState() => _HeadingWidgetState();
}

class _HeadingWidgetState extends State<_HeadingWidget> {
  final GlobalKey _key = GlobalKey();
  late final TocItem? _item;
  bool _itemAdded = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {
      if (!_itemAdded && mounted) {
        widget.tocController?.addItem(
          _item = TocItem(
            title: widget.element.textContent,
            level: widget.type.index + 1,
            key: _key,
          ),
        );
        _itemAdded = true;
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final style = switch (widget.type) {
      HeadingType.h1 => theme.textTheme.headlineLarge,
      HeadingType.h2 => theme.textTheme.headlineMedium,
      HeadingType.h3 => theme.textTheme.headlineSmall,
      HeadingType.h4 => theme.textTheme.titleLarge,
      HeadingType.h5 => theme.textTheme.titleMedium,
      HeadingType.h6 => theme.textTheme.titleSmall,
    };
    final padTop = switch (widget.type) {
      HeadingType.h1 => 32,
      HeadingType.h2 => 24,
      HeadingType.h3 => 16,
      HeadingType.h4 => 12,
      HeadingType.h5 => 8,
      HeadingType.h6 => 4,
    }.toDouble();

    return Padding(
      padding: EdgeInsets.only(top: padTop),
      child: GestureDetector(
        onTap: () => widget.tocController?.scrollToItem(_item!),
        child: Text('# ${widget.element.textContent}', key: _key, style: style),
      ),
    );
  }
}

enum HeadingType { h1, h2, h3, h4, h5, h6 }



================================================
FILE: packages/zenrouter_docs/lib/widgets/section_layout.dart
================================================
/// # Section Layout Widget
///
/// Each major section of our documentation (Paradigms, Concepts, Patterns,
/// File Routing) shares a common layout: a navigation rail on the left
/// showing the pages within that section, and a content area on the right.
///
/// This widget provides that structure, while each section's `_layout.dart`
/// customizes it with the appropriate navigation items.
library;

import 'package:flutter/material.dart';

/// A navigation item within a documentation section.
class SectionNavItem {
  const SectionNavItem({
    required this.label,
    required this.icon,
    required this.path,
    this.selectedIcon,
  });

  final String label;
  final IconData icon;
  final IconData? selectedIcon;
  final String path;
}

/// The layout shell for a documentation section.
///
/// Provides a navigation rail and content area. The navigation rail
/// shows all pages within the section; the content area displays
/// the currently selected page.
class SectionLayout extends StatelessWidget {
  const SectionLayout({
    super.key,
    required this.sectionTitle,
    required this.items,
    required this.selectedPath,
    required this.onNavigate,
    required this.child,
    this.leading,
    this.trailing,
  });

  /// Title of this section, shown at the top of the nav rail
  final String sectionTitle;

  /// Navigation items within this section
  final List<SectionNavItem> items;

  /// Currently selected path
  final String selectedPath;

  /// Callback when a navigation item is tapped
  final ValueChanged<String> onNavigate;

  /// The content to display
  final Widget child;

  /// Optional widget above the navigation items
  final Widget? leading;

  /// Optional widget below the navigation items
  final Widget? trailing;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Find current selection index
    final selectedIndex = items.indexWhere((item) => item.path == selectedPath);

    return LayoutBuilder(
      builder: (context, constraints) {
        // Responsive: show rail on wide screens, drawer on narrow
        final isWide = constraints.maxWidth >= 800;

        if (isWide) {
          return Row(
            children: [
              // Navigation Rail
              _buildNavigationRail(context, theme, selectedIndex),

              // Vertical divider
              VerticalDivider(width: 1, color: theme.dividerColor),

              // Content area
              Expanded(child: child),
            ],
          );
        } else {
          // On narrow screens, use a drawer or bottom sheet
          return Scaffold(
            appBar: AppBar(title: Text(sectionTitle)),
            drawer: _buildDrawer(context, theme, selectedIndex),
            body: child,
          );
        }
      },
    );
  }

  Widget _buildNavigationRail(
    BuildContext context,
    ThemeData theme,
    int selectedIndex,
  ) {
    return SizedBox(
      width: 220,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Section header
          Padding(
            padding: const EdgeInsets.all(20),
            child: Text(
              sectionTitle,
              style: theme.textTheme.headlineSmall?.copyWith(
                color: theme.colorScheme.primary,
              ),
            ),
          ),

          ?leading,

          // Navigation items
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.symmetric(horizontal: 12),
              itemCount: items.length,
              itemBuilder: (context, index) {
                final item = items[index];
                final isSelected = index == selectedIndex;

                return _NavigationItem(
                  item: item,
                  isSelected: isSelected,
                  onTap: () => onNavigate(item.path),
                );
              },
            ),
          ),

          ?trailing,

          // Back to home link
          Padding(
            padding: const EdgeInsets.all(16),
            child: TextButton.icon(
              onPressed: () => onNavigate('/'),
              icon: const Icon(Icons.arrow_back, size: 18),
              label: const Text('Back to Home'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildDrawer(
    BuildContext context,
    ThemeData theme,
    int selectedIndex,
  ) {
    return Drawer(
      child: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.all(20),
              child: Text(
                sectionTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  color: theme.colorScheme.primary,
                ),
              ),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: items.length,
                itemBuilder: (context, index) {
                  final item = items[index];
                  final isSelected = index == selectedIndex;

                  return ListTile(
                    leading: Icon(
                      isSelected ? (item.selectedIcon ?? item.icon) : item.icon,
                      color: isSelected ? theme.colorScheme.primary : null,
                    ),
                    title: Text(item.label),
                    selected: isSelected,
                    onTap: () {
                      Navigator.pop(context);
                      onNavigate(item.path);
                    },
                  );
                },
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(16),
              child: TextButton.icon(
                onPressed: () {
                  Navigator.pop(context);
                  onNavigate('/');
                },
                icon: const Icon(Icons.arrow_back, size: 18),
                label: const Text('Back to Home'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// A single navigation item in the section rail.
class _NavigationItem extends StatelessWidget {
  const _NavigationItem({
    required this.item,
    required this.isSelected,
    required this.onTap,
  });

  final SectionNavItem item;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Material(
        color: isSelected
            ? theme.colorScheme.primary.withValues(alpha: 0.1)
            : Colors.transparent,
        borderRadius: BorderRadius.circular(8),
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(8),
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
            child: Row(
              children: [
                Icon(
                  isSelected ? (item.selectedIcon ?? item.icon) : item.icon,
                  size: 20,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurface.withValues(alpha: 0.7),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    item.label,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: isSelected ? FontWeight.w600 : null,
                      color: isSelected
                          ? theme.colorScheme.primary
                          : theme.colorScheme.onSurface.withValues(alpha: 0.87),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_docs/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "zenrouter_docs")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.example.zenrouter_docs")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
FILE: packages/zenrouter_docs/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
FILE: packages/zenrouter_docs/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <irondash_engine_context/irondash_engine_context_plugin.h>
#include <super_native_extensions/super_native_extensions_plugin.h>
#include <url_launcher_linux/url_launcher_plugin.h>

void fl_register_plugins(FlPluginRegistry* registry) {
  g_autoptr(FlPluginRegistrar) irondash_engine_context_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "IrondashEngineContextPlugin");
  irondash_engine_context_plugin_register_with_registrar(irondash_engine_context_registrar);
  g_autoptr(FlPluginRegistrar) super_native_extensions_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "SuperNativeExtensionsPlugin");
  super_native_extensions_plugin_register_with_registrar(super_native_extensions_registrar);
  g_autoptr(FlPluginRegistrar) url_launcher_linux_registrar =
      fl_plugin_registry_get_registrar_for_plugin(registry, "UrlLauncherPlugin");
  url_launcher_plugin_register_with_registrar(url_launcher_linux_registrar);
}



================================================
FILE: packages/zenrouter_docs/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter_docs/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  irondash_engine_context
  super_native_extensions
  url_launcher_linux
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter_docs/linux/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")



================================================
FILE: packages/zenrouter_docs/linux/runner/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
FILE: packages/zenrouter_docs/linux/runner/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView* view) {
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "zenrouter_docs");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "zenrouter_docs");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(
      project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000
  // for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb),
                           self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application,
                                                  gchar*** arguments,
                                                  int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
    g_warning("Failed to register: %s", error->message);
    *exit_status = 1;
    return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line =
      my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID, "flags",
                                     G_APPLICATION_NON_UNIQUE, nullptr));
}



================================================
FILE: packages/zenrouter_docs/linux/runner/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication,
                     my_application,
                     MY,
                     APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
FILE: packages/zenrouter_docs/macos/Podfile
================================================
platform :osx, '10.15'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'ephemeral', 'Flutter-Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure \"flutter pub get\" is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter-Generated.xcconfig, then run \"flutter pub get\""
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_macos_podfile_setup

target 'Runner' do
  use_frameworks!

  flutter_install_all_macos_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_macos_build_settings(target)
  end
end



================================================
FILE: packages/zenrouter_docs/macos/Podfile.lock
================================================
PODS:
  - FlutterMacOS (1.0.0)
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - url_launcher_macos (0.0.1):
    - FlutterMacOS

DEPENDENCIES:
  - FlutterMacOS (from `Flutter/ephemeral`)
  - path_provider_foundation (from `Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin`)
  - url_launcher_macos (from `Flutter/ephemeral/.symlinks/plugins/url_launcher_macos/macos`)

EXTERNAL SOURCES:
  FlutterMacOS:
    :path: Flutter/ephemeral
  path_provider_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin
  url_launcher_macos:
    :path: Flutter/ephemeral/.symlinks/plugins/url_launcher_macos/macos

SPEC CHECKSUMS:
  FlutterMacOS: d0db08ddef1a9af05a5ec4b724367152bb0500b1
  path_provider_foundation: 0b743cbb62d8e47eab856f09262bb8c1ddcfe6ba
  url_launcher_macos: 175a54c831f4375a6cf895875f716ee5af3888ce

PODFILE CHECKSUM: 54d867c82ac51cbd61b565781b9fada492027009

COCOAPODS: 1.16.2



================================================
FILE: packages/zenrouter_docs/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter_docs/macos/Flutter/Flutter-Release.xcconfig
================================================
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter_docs/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation

import device_info_plus
import irondash_engine_context
import super_native_extensions
import url_launcher_macos

func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
  DeviceInfoPlusMacosPlugin.register(with: registry.registrar(forPlugin: "DeviceInfoPlusMacosPlugin"))
  IrondashEngineContextPlugin.register(with: registry.registrar(forPlugin: "IrondashEngineContextPlugin"))
  SuperNativeExtensionsPlugin.register(with: registry.registrar(forPlugin: "SuperNativeExtensionsPlugin"))
  UrlLauncherPlugin.register(with: registry.registrar(forPlugin: "UrlLauncherPlugin"))
}



================================================
FILE: packages/zenrouter_docs/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}



================================================
FILE: packages/zenrouter_docs/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_docs/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter_docs/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
FILE: packages/zenrouter_docs/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_docs/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_docs/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
FILE: packages/zenrouter_docs/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = zenrouter_docs

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.example.zenrouterDocs

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2026 com.example. All rights reserved.



================================================
FILE: packages/zenrouter_docs/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter_docs/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter_docs/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
FILE: packages/zenrouter_docs/macos/RunnerTests/RunnerTests.swift
================================================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter_docs/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="Interactive documentation for ZenRouter - teaching the Coordinator pattern and file-based routing for Flutter applications.">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="ZenRouter">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>ZenRouter Documentation</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <!--
    You can customize the "flutter_bootstrap.js" script.
    This is useful to provide a custom configuration to the Flutter loader
    or to give the user feedback during the initialization process.

    For more details:
    * https://docs.flutter.dev/platform-integration/web/initialization
  -->
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>



================================================
FILE: packages/zenrouter_docs/web/manifest.json
================================================
{
    "name": "ZenRouter Documentation",
    "short_name": "ZenRouter",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "Interactive documentation for ZenRouter - teaching the Coordinator pattern and file-based routing.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}



================================================
FILE: packages/zenrouter_docs/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(zenrouter_docs LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "zenrouter_docs")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
FILE: packages/zenrouter_docs/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
FILE: packages/zenrouter_docs/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"

#include <irondash_engine_context/irondash_engine_context_plugin_c_api.h>
#include <super_native_extensions/super_native_extensions_plugin_c_api.h>
#include <url_launcher_windows/url_launcher_windows.h>

void RegisterPlugins(flutter::PluginRegistry* registry) {
  IrondashEngineContextPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("IrondashEngineContextPluginCApi"));
  SuperNativeExtensionsPluginCApiRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("SuperNativeExtensionsPluginCApi"));
  UrlLauncherWindowsRegisterWithRegistrar(
      registry->GetRegistrarForPlugin("UrlLauncherWindows"));
}



================================================
FILE: packages/zenrouter_docs/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter_docs/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
  irondash_engine_context
  super_native_extensions
  url_launcher_windows
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter_docs/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
FILE: packages/zenrouter_docs/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
FILE: packages/zenrouter_docs/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
FILE: packages/zenrouter_docs/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"zenrouter_docs", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
FILE: packages/zenrouter_docs/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
FILE: packages/zenrouter_docs/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>



================================================
FILE: packages/zenrouter_docs/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "zenrouter_docs" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "zenrouter_docs" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2026 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "zenrouter_docs.exe" "\0"
            VALUE "ProductName", "zenrouter_docs" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
FILE: packages/zenrouter_docs/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
FILE: packages/zenrouter_docs/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
FILE: packages/zenrouter_docs/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
FILE: packages/zenrouter_docs/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_



================================================
FILE: packages/zenrouter_file_annotation/README.md
================================================
<div align="center">

<img alt="ZenRouter Logo" src="https://raw.githubusercontent.com/definev/zenrouter/main/assets/zenrouter_light_solid.png">

# ZenRouter File Annotation

Shared annotations and structure for [zenrouter](https://pub.dev/packages/zenrouter) file-based routing.

This package contains the annotations (`@ZenRoute`, `@ZenLayout`, `@ZenCoordinator`) and helper classes used by the `zenrouter_file_generator` to generate type-safe routes.

[![pub package](https://img.shields.io/pub/v/zenrouter_file_annotation.svg)](https://pub.dev/packages/zenrouter_file_annotation)
[![Test](https://github.com/definev/zenrouter/actions/workflows/test.yml/badge.svg)](https://github.com/definev/zenrouter/actions/workflows/test.yml)
[![Codecov - zenrouter](https://codecov.io/gh/definev/zenrouter/branch/main/graph/badge.svg?flag=zenrouter)](https://app.codecov.io/gh/definev/zenrouter?branch=main&flags=zenrouter)

</div>

## Installation

This package is usually added automatically when using `zenrouter_file_generator`.

```yaml
dependencies:
  zenrouter_file_annotation: ^0.4.5

dev_dependencies:
  zenrouter_file_generator: ^0.4.5
```

## Usage

Use these annotations to define your routes and layouts:

```dart
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

@ZenRoute()
class MyRoute extends _$MyRoute { ... }

@ZenLayout(type: LayoutType.stack)
class MyLayout extends _$MyLayout { ... }

// With query parameters
@ZenRoute(queries: ['search', 'page'])
class SearchRoute extends _$SearchRoute { ... }
```

See [zenrouter_file_generator](https://pub.dev/packages/zenrouter_file_generator) for complete documentation and usage examples.



================================================
FILE: packages/zenrouter_file_annotation/CHANGELOG.md
================================================
## 1.0.0
- **Stable release**: Production-ready annotation package
- Compatible with `zenrouter: ^1.0.0` and `zenrouter_file_generator: ^1.0.0`

## 0.4.10

### New Features

- **deferredImport in `@ZenCoordinator`**: New optional `deferredImport` field to configure global deferred import behavior via annotation
  - Overrides the `deferredImport` option in `build.yaml` when specified
  - Example: `@ZenCoordinator(name: 'AppCoordinator', deferredImport: true)`
- **routeBasePath in `@ZenCoordinator`**: New optional `routeBasePath` field to import a custom base route class
  - When set, the generator imports the base class from the specified path instead of generating it
  - Example: `@ZenCoordinator(routeBase: 'MyAppRoute', routeBasePath: 'package:my_app/routes/base.dart')`

## 0.4.9
- **Refactor**: Extract shared code generation utilities (`LayoutCodeGenerator`, `RouteCodeGenerator`) for use by both `build_runner`

## 0.4.7
- **Docs**: Update README

## 0.4.6
- **Docs**: Update README and add screenshots

## 0.4.5
- Support new `RouteQueryParameters` and new dot notation flavor in naming convention.

## 0.4.0
- Update README.md

## 0.3.1
- Add support for lazy loading routes using the `deferredImport` option in the `@ZenCoordinator` annotation.

## 0.3.0
- Add support for catch-all parameters ([...slugs], [...ids], etc) in routes, including `List<String>` type handling and updated route specificity sorting.

## 0.2.1

- Initial extraction of annotations and structure from `zenrouter_file_generator`.



================================================
FILE: packages/zenrouter_file_annotation/LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Bui Dai Duong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: packages/zenrouter_file_annotation/pubspec.yaml
================================================
name: zenrouter_file_annotation
description: "Shared annotation and structure for zenrouter file-based routing."
version: 1.0.0
homepage: https://github.com/definev/zenrouter/tree/main/packages/zenrouter_file_annotation
repository: https://github.com/definev/zenrouter/tree/main/packages/zenrouter_file_annotation
resolution: workspace

environment:
  sdk: ^3.7.0



================================================
FILE: packages/zenrouter_file_annotation/example/README.md
================================================
## Example

This directory contains an example of how to use the `zenrouter_file_annotation` package.


================================================
FILE: packages/zenrouter_file_annotation/lib/zenrouter_file_annotation.dart
================================================
library;

export 'src/annotations.dart';
export 'src/analyzer/path_parser.dart';
export 'src/analyzer/route_element.dart';
export 'src/analyzer/layout_element.dart';
export 'src/codegen/layout_code_generator.dart';
export 'src/codegen/route_code_generator.dart';



================================================
FILE: packages/zenrouter_file_annotation/lib/src/annotations.dart
================================================
/// Annotations for file-based routing with ZenRouter.
///
/// These annotations are used by the code generator to create
/// type-safe routing infrastructure based on file structure.
///
/// The annotations in this file are used by the build system to generate
/// route classes, layouts, and coordinators from your file structure.
library;

/// Strategy for handling deep links.
///
/// This enum matches zenrouter's `DeeplinkStrategy` enum and is used
/// during code generation. The generator maps these values to zenrouter's
/// `DeeplinkStrategy` when generating code.
///
/// The values are:
/// - `replace` - Replace entire navigation stack with this route (default)
/// - `push` - Push this route onto the existing stack
/// - `custom` - Use custom `deeplinkHandler()` method
enum DeeplinkStrategyType {
  /// Replace entire navigation stack with this route (default).
  replace,

  /// Push this route onto the existing stack.
  push,

  /// Use custom deeplinkHandler() method.
  custom,
}

/// Type of navigation path for layouts.
enum LayoutType {
  /// Stack-based navigation with push/pop operations.
  /// Uses NavigationPath internally.
  stack,

  /// Index-based navigation for tabs/drawers.
  /// Uses IndexedStackPath internally.
  indexed,
}

/// Marks a class as a route in the file-based routing system.
///
/// The route's URI path is derived from its file location within
/// the `routes/` directory.
///
/// ## Basic Usage
///
/// ```dart
/// // lib/routes/about.dart -> /about
/// @ZenRoute()
/// class AboutRoute extends _$AboutRoute {
///   @override
///   Widget build(AppCoordinator coordinator, BuildContext context) {
///     return AboutScreen();
///   }
/// }
/// ```
///
/// ## Dynamic Parameters
///
/// For files named with brackets like `[id].dart`, the parameter
/// is automatically extracted:
///
/// ```dart
/// // lib/routes/profile/[id].dart -> /profile/:id
/// @ZenRoute()
/// class ProfileIdRoute extends _$ProfileIdRoute {
///   @override
///   Widget build(AppCoordinator coordinator, BuildContext context) {
///     return ProfileScreen(userId: id); // 'id' is auto-generated
///   }
/// }
/// ```
///
/// ## Route Mixins
///
/// Enable optional route behaviors:
///
/// ```dart
/// @ZenRoute(
///   guard: true,      // Enable RouteGuard mixin
///   redirect: true,   // Enable RouteRedirect mixin
///   deepLink: DeeplinkStrategyType.custom, // Enable RouteDeepLink mixin
/// )
/// class CheckoutRoute extends _$CheckoutRoute {
///   // Implement required mixin methods...
/// }
/// ```
///
/// ## Query Parameters
///
/// Declare expected query parameters:
///
/// ```dart
/// @ZenRoute(queries: ['search', 'page'])
/// class SearchRoute extends _$SearchRoute {
///   @override
///   Widget build(AppCoordinator coordinator, BuildContext context) {
///     final searchTerm = query('search');
///     final page = query('page');
///     return SearchScreen(search: searchTerm, page: page);
///   }
/// }
/// ```
class ZenRoute {
  /// Whether this route should have the RouteGuard mixin.
  ///
  /// When true, you must implement `popGuard()` to control
  /// whether navigation away from this route is allowed.
  final bool guard;

  /// Whether this route should have the RouteRedirect mixin.
  ///
  /// When true, you must implement `redirect()` to conditionally
  /// redirect to a different route (e.g., for auth checks).
  final bool redirect;

  /// Deep link handling strategy for this route.
  ///
  /// - `null` - No special deep link handling (default behavior)
  /// - `DeeplinkStrategyType.replace` - Replace stack when deep linking
  /// - `DeeplinkStrategyType.push` - Push onto existing stack
  /// - `DeeplinkStrategyType.custom` - Use custom `deeplinkHandler()`
  ///
  /// This maps to zenrouter's `DeeplinkStrategy` enum when generating code.
  final DeeplinkStrategyType? deepLink;

  /// Whether this route should have the RouteTransition mixin.
  ///
  /// When true, you must implement `transition()` to provide
  /// custom page transition animations.
  final bool transition;

  /// Whether this route can have the deferred import.
  ///
  /// When true, the generator will use this route as a `deferred as` import.
  /// It's useful to reduce the initial app size. One caveat is that the
  /// deferred import [Route] can't be used in [IndexedStackPath] since it fixed,
  /// loaded at runtime and can't be changed at runtime.
  final bool deferredImport;

  /// List of expected query parameter names.
  ///
  /// When provided, the route will have access to query parameters
  /// via the `queries` field and `query()` method.
  ///
  /// Example: `queries: ['search', 'page']` enables `query('search')` and `query('page')`.
  final List<String>? queries;

  /// Creates a route annotation.
  const ZenRoute({
    this.guard = false,
    this.redirect = false,
    this.deepLink,
    this.transition = false,
    this.deferredImport = false,
    this.queries,
  });
}

/// Marks a class as a layout in the file-based routing system.
///
/// Layouts manage nested navigation by wrapping child routes in a
/// common UI structure (like a tab bar or navigation shell).
///
/// ## Stack Layout (NavigationPath)
///
/// For stack-based push/pop navigation:
///
/// ```dart
/// // lib/routes/settings/_layout.dart
/// @ZenLayout(type: LayoutType.stack)
/// class SettingsLayout extends _$SettingsLayout {
///   @override
///   Widget build(AppCoordinator coordinator, BuildContext context) {
///     return Scaffold(
///       appBar: AppBar(title: Text('Settings')),
///       body: buildPath(coordinator),
///     );
///   }
/// }
/// ```
///
/// ## Indexed Layout (IndexedStackPath)
///
/// For tab-based or indexed navigation:
///
/// ```dart
/// // lib/routes/tabs/_layout.dart
/// @ZenLayout(
///   type: LayoutType.indexed,
///   routes: [FeedRoute, ProfileRoute, SettingsRoute],
/// )
/// class TabsLayout extends _$TabsLayout {
///   @override
///   Widget build(AppCoordinator coordinator, BuildContext context) {
///     final path = resolvePath(coordinator);
///     return Scaffold(
///       body: buildPath(coordinator),
///       bottomNavigationBar: BottomNavigationBar(
///         currentIndex: path.activePathIndex,
///         onTap: (i) => coordinator.push(path.stack[i]),
///         items: [...], // User defines UI
///       ),
///     );
///   }
/// }
/// ```
class ZenLayout {
  /// The type of navigation path this layout manages.
  final LayoutType type;

  /// For indexed layouts, the route types in order.
  ///
  /// The order determines the index of each tab.
  /// Only used when [type] is [LayoutType.indexed].
  final List<Type>? routes;

  /// Creates a layout annotation.
  const ZenLayout({required this.type, this.routes});
}

/// Configuration for the generated Coordinator.
///
/// Place this annotation on a class in `routes/_coordinator.dart`
/// to customize the generated coordinator.
///
/// ```dart
/// // lib/routes/_coordinator.dart
/// @ZenCoordinator(
///   name: 'AppCoordinator',
///   routeBase: 'AppRoute',
///   deferredImport: true,
/// )
/// class CoordinatorConfig {}
/// ```
class ZenCoordinator {
  /// The name of the generated Coordinator class.
  /// Defaults to 'AppCoordinator'.
  final String name;

  /// The name of the base route class.
  /// Defaults to 'AppRoute'.
  final String routeBase;

  /// Path to import the base route class from.
  ///
  /// When set, the generator will import and export the base class from
  /// this path instead of generating it. Use this when you have a custom
  /// base route class defined elsewhere.
  ///
  /// Example:
  /// ```dart
  /// @ZenCoordinator(
  ///   routeBase: 'MyAppRoute',
  ///   routeBasePath: 'package:my_app/routes/base_route.dart',
  /// )
  /// ```
  final String? routeBasePath;

  /// Global deferred import configuration.
  ///
  /// When true, all routes will use deferred imports unless explicitly
  /// disabled with `@ZenRoute(deferredImport: false)`.
  ///
  /// This setting overrides the `deferredImport` option in `build.yaml`.
  /// Defaults to null (uses `build.yaml` config or false if not specified).
  final bool? deferredImport;

  /// Creates a coordinator configuration annotation.
  const ZenCoordinator({
    this.name = 'AppCoordinator',
    this.routeBase = 'AppRoute',
    this.routeBasePath,
    this.deferredImport,
  });
}



================================================
FILE: packages/zenrouter_file_annotation/lib/src/analyzer/layout_element.dart
================================================
import '../annotations.dart';

/// Represents a parsed layout element from source code.
class LayoutElement {
  /// The class name (e.g., 'TabsLayout').
  final String className;

  /// The file path relative to routes directory.
  final String relativePath;

  /// The URI path for this layout.
  final List<String> pathSegments;

  /// The type of layout (stack or indexed).
  final LayoutType layoutType;

  /// For indexed layouts, the route types in order.
  final List<String> indexedRouteTypes;

  /// The parent layout type (if nested).
  final String? parentLayoutType;

  /// Creates a new layout element.
  ///
  /// The [className], [relativePath], [pathSegments], and [layoutType]
  /// are required. For indexed layouts, provide [indexedRouteTypes] to
  /// specify the route types in tab order. Set [parentLayoutType] if
  /// this layout is nested within another layout.
  LayoutElement({
    required this.className,
    required this.relativePath,
    required this.pathSegments,
    required this.layoutType,
    this.indexedRouteTypes = const [],
    this.parentLayoutType,
  });

  /// The URI path pattern for this layout.
  String get uriPattern {
    if (pathSegments.isEmpty) return '/';
    return '/${pathSegments.join('/')}';
  }

  /// The generated base class name (e.g., '_\$TabsLayout').
  String get generatedBaseClassName => '_\$$className';

  /// The generated path field name in Coordinator.
  String get pathFieldName {
    // Convert class name to camelCase path name
    // e.g., TabsLayout -> tabsPath, SettingsLayout -> settingsPath
    var name = className;
    if (name.endsWith('Layout')) {
      name = name.substring(0, name.length - 6);
    }
    // Convert to camelCase
    name = name[0].toLowerCase() + name.substring(1);
    return '${name}Path';
  }

  /// Create a copy with modified parentLayoutType.
  LayoutElement copyWith({String? parentLayoutType}) {
    return LayoutElement(
      className: className,
      relativePath: relativePath,
      pathSegments: pathSegments,
      layoutType: layoutType,
      indexedRouteTypes: indexedRouteTypes,
      parentLayoutType: parentLayoutType ?? this.parentLayoutType,
    );
  }
}



================================================
FILE: packages/zenrouter_file_annotation/lib/src/analyzer/path_parser.dart
================================================
/// Utility for parsing file paths into route segments and parameters.
///
/// This centralizes path parsing logic used by both route and coordinator generators.
class PathParser {
  /// Parse a relative file path into segments and parameters.
  ///
  /// Example:
  /// - `profile/[profileId]/collections/[collectionId]`
  ///   → segments: ['profile', ':profileId', 'collections', ':collectionId']
  ///   → params: [ParamInfo(name: 'profileId'), ParamInfo(name: 'collectionId')]
  /// - `posts/[...slug]`
  ///   → segments: ['posts', '...:slug']
  ///   → params: [ParamInfo(name: 'slug', isRest: true)]
  static (List<String>, List<ParamInfo>, bool, String) parsePath(
    String relativePath,
  ) {
    final segments = <String>[];
    final params = <ParamInfo>[];

    // Remove .dart extension and normalize dot-notation
    var path = relativePath;
    if (path.endsWith('.dart')) {
      path = path.substring(0, path.length - 5);
    }
    path = _normalizeFilePath(path);

    final parts = path.split('/').where((p) => p.isNotEmpty).toList();
    final fileName = parts.isNotEmpty ? parts.last : '';
    final isIndexFile = fileName == 'index';

    // Track if we've seen a rest parameter
    bool hasRestParam = false;

    // Process each path segment, extracting dynamic parameters
    // This correctly handles multiple parameters in nested routes
    for (final part in parts) {
      // Skip private files
      if (part.startsWith('_')) continue;

      // Skip route groups (name) - they don't add to URL path
      if (part.startsWith('(') && part.endsWith(')')) continue;

      // Check for rest parameter [...name] - captures remaining segments
      if (part.startsWith('[...') && part.endsWith(']')) {
        final paramName = part.substring(4, part.length - 1);
        if (paramName.isEmpty) {
          throw ArgumentError(
            'Rest parameter name cannot be empty in path: $relativePath',
          );
        }
        if (hasRestParam) {
          throw ArgumentError(
            'Only one rest parameter [...] is allowed per route: $relativePath',
          );
        }
        hasRestParam = true;
        segments.add('...:$paramName');
        params.add(ParamInfo(name: paramName, isRest: true));
      }
      // Check for dynamic parameter [name]
      // Supports multiple parameters like [profileId] and [collectionId]
      else if (part.startsWith('[') && part.endsWith(']')) {
        final paramName = part.substring(1, part.length - 1);
        if (paramName.isEmpty) {
          throw ArgumentError(
            'Dynamic parameter name cannot be empty in path: $relativePath',
          );
        }
        segments.add(':$paramName');
        params.add(ParamInfo(name: paramName));
      } else if (part == 'index') {
        // index.dart doesn't add a segment
        continue;
      } else {
        segments.add(part);
      }
    }

    return (segments, params, isIndexFile, fileName);
  }

  /// Parse layout path segments (excludes dynamic parameters).
  static List<String> parseLayoutPath(String relativePath) {
    final segments = <String>[];

    // Remove .dart extension and _layout, then normalize dot-notation
    var path = relativePath;
    if (path.endsWith('.dart')) {
      path = path.substring(0, path.length - 5);
    }
    path = _normalizeFilePath(path);
    if (path.endsWith('/_layout')) {
      path = path.substring(0, path.length - 8);
    }

    final parts = path.split('/').where((p) => p.isNotEmpty).toList();

    for (final part in parts) {
      if (part.startsWith('_')) continue;
      if (part.startsWith('(') && part.endsWith(')')) continue;
      segments.add(part);
    }

    return segments;
  }

  /// Normalize a file path that may contain dot-notation segments.
  ///
  /// Converts dot-notation to folder structure:
  /// - `docs.[id].detail` → `docs/[id]/detail`
  /// - `feed/tab/[id].detail` → `feed/tab/[id]/detail` (hybrid)
  ///
  /// Rules:
  /// - Dots inside brackets are preserved: `[...slugs]` stays as `[...slugs]`
  /// - Dots outside brackets become `/` separators
  /// - Works with hybrid paths mixing `/` and `.`
  static String _normalizeFilePath(String path) {
    final buffer = StringBuffer();
    int bracketDepth = 0;

    for (int i = 0; i < path.length; i++) {
      final char = path[i];

      if (char == '[') {
        bracketDepth++;
        buffer.write(char);
      } else if (char == ']') {
        bracketDepth--;
        buffer.write(char);
      } else if (char == '.' && bracketDepth == 0) {
        // Dot outside brackets becomes a path separator
        buffer.write('/');
      } else {
        buffer.write(char);
      }
    }

    return buffer.toString();
  }
}

/// Simplified parameter info for path parsing.
class ParamInfo {
  /// The name of the parameter extracted from the path segment.
  ///
  /// For a file path like `[userId]`, the name would be `userId`.
  final String name;

  /// Whether this is a rest parameter that captures multiple segments.
  ///
  /// Rest parameters use `[...name]` syntax and capture all remaining
  /// path segments as a `List<String>`.
  final bool isRest;

  /// Creates a new parameter info.
  ///
  /// The [name] is required and represents the parameter identifier.
  /// Set [isRest] to `true` for rest parameters (`[...name]` syntax).
  ParamInfo({required this.name, this.isRest = false});
}



================================================
FILE: packages/zenrouter_file_annotation/lib/src/analyzer/route_element.dart
================================================
import '../annotations.dart';

/// Represents a parsed route element from source code.
class RouteElement {
  /// The class name (e.g., 'AboutRoute').
  final String className;

  /// The file path relative to routes directory.
  final String relativePath;

  /// The URI path segments derived from file location.
  final List<String> pathSegments;

  /// Dynamic parameters extracted from [param] syntax.
  final List<RouteParameter> parameters;

  /// The layout type this route belongs to (if any).
  final String? parentLayoutType;

  /// Whether this route has RouteGuard mixin.
  final bool hasGuard;

  /// Whether this route has RouteRedirect mixin.
  final bool hasRedirect;

  /// The deep link strategy (if any).
  final DeeplinkStrategyType? deepLinkStrategy;

  /// Whether this route has RouteTransition mixin.
  final bool hasTransition;

  /// Whether this route has deferred import.
  final bool hasDeferredImport;

  /// Expected query parameter names (if any).
  final List<String>? queries;

  RouteElement({
    required this.className,
    required this.relativePath,
    required this.pathSegments,
    required this.parameters,
    this.parentLayoutType,
    this.hasGuard = false,
    this.hasRedirect = false,
    this.deepLinkStrategy,
    this.hasTransition = false,
    this.hasDeferredImport = false,
    this.queries,
  });

  /// The URI path pattern for this route.
  String get uriPattern {
    if (pathSegments.isEmpty) return '/';
    return '/${pathSegments.join('/')}';
  }

  /// The generated base class name (e.g., '_\$AboutRoute').
  String get generatedBaseClassName => '_\$$className';

  /// Whether this route has any dynamic parameters.
  bool get hasDynamicParameters => parameters.isNotEmpty;

  /// Whether this route expects query parameters.
  bool get hasQueries => queries != null && queries!.isNotEmpty;

  /// Create a copy with modified parentLayoutType.
  RouteElement copyWith({String? parentLayoutType}) {
    return RouteElement(
      className: className,
      relativePath: relativePath,
      pathSegments: pathSegments,
      parameters: parameters,
      parentLayoutType: parentLayoutType ?? this.parentLayoutType,
      hasGuard: hasGuard,
      hasRedirect: hasRedirect,
      deepLinkStrategy: deepLinkStrategy,
      hasTransition: hasTransition,
      hasDeferredImport: hasDeferredImport,
      queries: queries,
    );
  }
}

/// Represents a dynamic route parameter.
class RouteParameter {
  /// The parameter name (from [name] or [...name] syntax).
  final String name;

  /// The Dart type for this parameter.
  final String type;

  /// Whether this parameter is optional.
  final bool isOptional;

  /// Default value if optional.
  final String? defaultValue;

  /// Whether this is a rest parameter that captures multiple segments.
  final bool isRest;

  RouteParameter({
    required this.name,
    this.type = 'String',
    this.isOptional = false,
    this.defaultValue,
    this.isRest = false,
  });
}



================================================
FILE: packages/zenrouter_file_annotation/lib/src/codegen/layout_code_generator.dart
================================================
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

/// Configuration for layout code generation.
class LayoutCodeConfig {
  /// The base route class name (e.g., 'AppRoute').
  final String routeBase;

  /// The coordinator class name (e.g., 'AppCoordinator').
  final String coordinatorName;

  /// Creates a new layout code generation configuration.
  ///
  /// The [routeBase] and [coordinatorName] default to `'AppRoute'` and
  /// `'AppCoordinator'` respectively if not specified.
  const LayoutCodeConfig({
    this.routeBase = 'AppRoute',
    this.coordinatorName = 'AppCoordinator',
  });
}

/// Shared utility for generating layout base class code.
///
/// This class is used by both `LayoutGenerator` (build_runner) and
/// `ZenLayoutMacro` (macro_kit) to ensure consistent code generation.
class LayoutCodeGenerator {
  const LayoutCodeGenerator._();

  /// Generate the layout base class code.
  ///
  /// Returns the generated Dart code as a String.
  static String generate(LayoutElement layout, LayoutCodeConfig config) {
    final buffer = StringBuffer();
    final routeBase = config.routeBase;
    final coordinatorName = config.coordinatorName;

    final pathType =
        layout.layoutType == LayoutType.indexed
            ? 'IndexedStackPath<$routeBase>'
            : 'NavigationPath<$routeBase>';

    // Generate class declaration
    buffer.writeln('/// Generated base class for ${layout.className}.');
    buffer.writeln('///');
    buffer.writeln('/// URI: ${layout.uriPattern}');
    buffer.writeln('/// Path type: ${layout.layoutType.name}');
    if (layout.parentLayoutType != null) {
      buffer.writeln('/// Parent layout: ${layout.parentLayoutType}');
    }
    buffer.writeln(
      'abstract class ${layout.generatedBaseClassName} extends $routeBase with RouteLayout<$routeBase> {',
    );
    buffer.writeln();

    // Generate constructor
    buffer.writeln('  ${layout.generatedBaseClassName}();');
    buffer.writeln();

    // Generate parent layout getter if nested
    if (layout.parentLayoutType != null) {
      buffer.writeln('  @override');
      buffer.writeln('  Type? get layout => ${layout.parentLayoutType};');
      buffer.writeln();
    }

    // Generate resolvePath method
    buffer.writeln('  @override');
    buffer.writeln(
      '  $pathType resolvePath(covariant $coordinatorName coordinator) =>',
    );
    buffer.writeln('      coordinator.${layout.pathFieldName};');
    buffer.writeln();

    // Generate toUri method
    buffer.writeln('  @override');
    buffer.writeln('  Uri toUri() => Uri.parse(\'${layout.uriPattern}\');');
    buffer.writeln();

    // Generate props for equality
    buffer.writeln('  @override');
    buffer.writeln('  List<Object?> get props => [];');

    buffer.writeln('}');

    return buffer.toString();
  }
}



================================================
FILE: packages/zenrouter_file_annotation/lib/src/codegen/route_code_generator.dart
================================================
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

/// Configuration for route code generation.
class RouteCodeConfig {
  /// The base route class name (e.g., 'AppRoute').
  final String routeBase;

  const RouteCodeConfig({this.routeBase = 'AppRoute'});
}

/// Shared utility for generating route base class code.
///
/// This class is used by both `RouteGenerator` (build_runner) and
/// `ZenRouteMacro` (macro_kit) to ensure consistent code generation.
class RouteCodeGenerator {
  const RouteCodeGenerator._();

  /// Generate the route base class code.
  ///
  /// Returns the generated Dart code as a String.
  static String generate(RouteElement route, RouteCodeConfig config) {
    final buffer = StringBuffer();
    final routeBase = config.routeBase;

    // Build mixin list
    final mixins = <String>[];
    if (route.hasGuard) mixins.add('RouteGuard');
    if (route.hasRedirect) mixins.add('RouteRedirect<$routeBase>');
    if (route.deepLinkStrategy != null) mixins.add('RouteDeepLink');
    if (route.hasTransition) mixins.add('RouteTransition');
    if (route.hasQueries) mixins.add('RouteQueryParameters');

    final mixinStr = mixins.isNotEmpty ? ' with ${mixins.join(', ')}' : '';

    // Generate class declaration
    buffer.writeln('/// Generated base class for ${route.className}.');
    buffer.writeln('///');
    buffer.writeln('/// URI: ${route.uriPattern}');
    if (route.parentLayoutType != null) {
      buffer.writeln('/// Layout: ${route.parentLayoutType}');
    }
    buffer.writeln(
      'abstract class ${route.generatedBaseClassName} extends $routeBase$mixinStr {',
    );

    // Generate constructor parameters for dynamic segments
    if (route.hasDynamicParameters) {
      for (final param in route.parameters) {
        buffer.writeln('  /// Dynamic parameter from path segment.');
        buffer.writeln('  final ${param.type} ${param.name};');
        buffer.writeln();
      }
    }

    // Generate queryNotifier field for query parameters (overrides mixin)
    if (route.hasQueries) {
      buffer.writeln('  @override');
      buffer.writeln(
        '  late final ValueNotifier<Map<String, String>> queryNotifier;',
      );
      buffer.writeln();
    }

    // Generate constructor
    if (route.hasDynamicParameters) {
      final paramsList = route.parameters
          .map((p) => 'required this.${p.name}')
          .join(', ');
      if (route.hasQueries) {
        buffer.writeln(
          '  ${route.generatedBaseClassName}({$paramsList, Map<String, String> queries = const {}}) : queryNotifier = ValueNotifier(queries);',
        );
      } else {
        buffer.writeln('  ${route.generatedBaseClassName}({$paramsList});');
      }
    } else {
      if (route.hasQueries) {
        buffer.writeln(
          '  ${route.generatedBaseClassName}({Map<String, String> queries = const {}}) : queryNotifier = ValueNotifier(queries);',
        );
      } else {
        buffer.writeln('  ${route.generatedBaseClassName}();');
      }
    }
    buffer.writeln();

    // query() method is inherited from RouteQueryParameter mixin

    // Generate layout getter if route has a parent layout
    if (route.parentLayoutType != null) {
      buffer.writeln('  @override');
      buffer.writeln('  Type? get layout => ${route.parentLayoutType};');
      buffer.writeln();
    }

    // Generate toUri method with query parameters (only if declared)
    buffer.writeln('  @override');
    if (route.hasQueries) {
      buffer.writeln('  Uri toUri() {');
      buffer.writeln(
        '    final uri = Uri.parse(\'${_generateUriTemplate(route)}\');',
      );
      buffer.writeln('    if (queries.isEmpty) return uri;');
      buffer.writeln('    return uri.replace(queryParameters: queries);');
      buffer.writeln('  }');
    } else {
      buffer.writeln(
        '  Uri toUri() => Uri.parse(\'${_generateUriTemplate(route)}\');',
      );
    }
    buffer.writeln();

    // Generate props for equality (path params only, NOT queries)
    // Queries are intentionally excluded so that updating query params
    // doesn't trigger route changes - same path = same route identity
    buffer.writeln('  @override');
    if (route.hasDynamicParameters) {
      final propsItems = route.parameters.map((p) => p.name).join(', ');
      buffer.writeln('  List<Object?> get props => [$propsItems];');
    } else {
      buffer.writeln('  List<Object?> get props => [];');
    }

    // Generate deep link strategy getter if needed
    if (route.deepLinkStrategy != null) {
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln(
        '  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.${route.deepLinkStrategy!.name};',
      );
    }

    // Generate query selector helpers
    if (route.hasQueries && route.queries != null) {
      for (final query in route.queries!) {
        // Skip invalid query names or wildcards
        if (query == '*' || !_isValidQueryParam(query)) continue;

        final camelCaseName = _toCamelCase(query);
        buffer.writeln();
        buffer.writeln('  Widget ${camelCaseName}Builder<T>({');
        buffer.writeln(
          '    required T Function(String? $camelCaseName) selector,',
        );
        buffer.writeln(
          '    required Widget Function(BuildContext, T $camelCaseName) builder,',
        );
        buffer.writeln('  }) => selectorBuilder<T>(');
        buffer.writeln(
          '    selector: (queries) => selector(queries[\'$query\']),',
        );
        buffer.writeln(
          '    builder: (context, $camelCaseName) => builder(context, $camelCaseName),',
        );
        buffer.writeln('  );');
      }
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  static bool _isValidQueryParam(String name) {
    if (name.isEmpty) return false;
    if (name == '*') return false;

    for (var i = 0; i < name.length; i++) {
      final char = name.codeUnitAt(i);
      // Allow A-Z, a-z, 0-9, _, -
      if (!((char >= 65 && char <= 90) || // A-Z
          (char >= 97 && char <= 122) || // a-z
          (char >= 48 && char <= 57) || // 0-9
          char == 95 || // _
          char == 45)) {
        // -
        return false;
      }
    }
    return true;
  }

  static String _toCamelCase(String str) {
    if (str.isEmpty) return str;

    // First, split on underscores and hyphens
    final delimiterParts = str.split(RegExp(r'[_\-]+'));

    // Then, for each part, also split on uppercase letters (PascalCase/camelCase)
    final allParts = <String>[];
    for (final part in delimiterParts) {
      if (part.isEmpty) continue;
      // Split on uppercase letters using lookahead to preserve the uppercase letter
      // e.g., "SortOrder" -> ["Sort", "Order"], "sortOrder" -> ["sort", "Order"]
      final camelParts = part.split(RegExp(r'(?=[A-Z])'));
      for (final camelPart in camelParts) {
        if (camelPart.isNotEmpty) {
          allParts.add(camelPart);
        }
      }
    }

    if (allParts.isEmpty) return str;

    final buffer = StringBuffer();
    // First part is lower case
    buffer.write(allParts.first.toLowerCase());

    // Subsequent parts are capitalized
    for (var i = 1; i < allParts.length; i++) {
      final part = allParts[i];
      if (part.isNotEmpty) {
        buffer.write(part[0].toUpperCase());
        if (part.length > 1) {
          buffer.write(part.substring(1).toLowerCase());
        }
      }
    }
    return buffer.toString();
  }

  static String _generateUriTemplate(RouteElement route) {
    if (route.pathSegments.isEmpty) return '/';

    final segments = route.pathSegments
        .map((segment) {
          if (segment.startsWith('...:')) {
            // Rest parameter - interpolate
            final paramName = segment.substring(4);
            return '\${$paramName.join(\'/\')}';
          }
          if (segment.startsWith(':')) {
            // Dynamic parameter - interpolate
            final paramName = segment.substring(1);
            return '\$$paramName';
          }
          return segment;
        })
        .join('/');

    return '/$segments';
  }
}



================================================
FILE: packages/zenrouter_file_generator/README.md
================================================
<div align="center">

<img alt="ZenRouter Logo" src="https://raw.githubusercontent.com/definev/zenrouter/main/assets/zenrouter_light_solid.png">

# ZenRouter File Generator

[![pub package](https://img.shields.io/pub/v/zenrouter_file_generator.svg)](https://pub.dev/packages/zenrouter_file_generator)
[![Test](https://github.com/definev/zenrouter/actions/workflows/test.yml/badge.svg)](https://github.com/definev/zenrouter/actions/workflows/test.yml)
[![Codecov - zenrouter](https://codecov.io/gh/definev/zenrouter/branch/main/graph/badge.svg?flag=zenrouter)](https://app.codecov.io/gh/definev/zenrouter?branch=main&flags=zenrouter)

</div>

A code generator for **file-based routing** in Flutter using [zenrouter](https://pub.dev/packages/zenrouter). Generate type-safe routes from your file/directory structure, similar to Next.js, Nuxt.js or expo-router.

This package is part of the [ZenRouter](https://github.com/definev/zenrouter/blob/main/packages/zenrouter/README.md) ecosystem and builds on the Coordinator paradigm for deep linking and web support.

## Features

- 🗂️ **File = Route** - Each file in `routes/` becomes a route automatically
- 📁 **Nested layouts** - `_layout.dart` files define layout wrappers for nested routes
- 🔗 **Dynamic routes** - `[param].dart` files create typed path parameters
- 🌟 **Catch-all routes** - `[...params].dart` files capture multiple path segments
- 📦 **Route groups** - `(name)/` folders wrap routes in layouts without affecting URLs
- 🎯 **Type-safe navigation** - Generated extension methods for type-safe navigation
- 📱 **Full ZenRouter support** - Deep linking, guards, redirects, transitions, and more
- 🚀 **Zero boilerplate** - Routes are generated from your file structure
- 🕸️ **Lazy loading** - Routes can be lazy loaded using the `deferredImport` option in the `@ZenCoordinator` annotation. Improves app startup time and reduces initial bundle size.

## Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [File Naming Conventions](#file-naming-conventions)
- [Route Groups `(name)`](#route-groups-name)
- [Deferred Imports](#deferred-imports)
- [Route Mixins](#route-mixins)
- [Route Query Parameters](#route-query-parameters)
- [Layout Types](#layout-types)
- [Generated Code Structure](#generated-code-structure)
- [Custom Coordinator Configuration](#custom-coordinator-configuration)
- [Customizing the Coordinator](#customizing-the-coordinator)
- [Integration with ZenRouter](#integration-with-zenrouter)
- [Example](#example)

## Installation

Add `zenrouter_file_generator`, `zenrouter_file_annotation` and `zenrouter` to your `pubspec.yaml`:

```yaml
dependencies:
  zenrouter: ^0.4.10
  zenrouter_file_annotation: ^0.4.9

dev_dependencies:
  build_runner: ^2.10.4
  zenrouter_file_generator: ^0.4.9
```

## Quick Start

### 1. Create your routes directory structure

Organize your routes in `lib/routes/` following these conventions:

```
lib/routes/
├── index.dart            → /
├── about.dart            → /about
├── (auth)/               → Route group (no URL segment)
│   ├── _layout.dart      → AuthLayout wrapper
│   ├── login.dart        → /login
│   └── register.dart     → /register
├── profile/
│   └── [id].dart         → /profile/:id
├── docs/
│   └── [...slugs]/       → Catch-all: /docs/a/b/c
│       └── index.dart    → /docs/any/path
└── tabs/
    ├── _layout.dart      → Layout for tabs
    ├── feed/
    │   ├── index.dart    → /tabs/feed
    │   └── [postId].dart → /tabs/feed/:postId
    ├── profile.dart      → /tabs/profile
    └── settings.dart     → /tabs/settings
```

### 2. Define routes with `@ZenRoute`

```dart
// lib/routes/about.dart
import 'package:flutter/material.dart';
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_file_generator/zenrouter_file_generator.dart';
import 'routes.zen.dart';

part 'about.g.dart';

@ZenRoute()
class AboutRoute extends _$AboutRoute {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('About')),
      body: const Center(child: Text('About Page')),
    );
  }
}
```

### 3. Dynamic parameters with `[param].dart`

Files named with brackets create dynamic route parameters:

```dart
// lib/routes/profile/[id].dart
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'routes.zen.dart';

part '[id].g.dart';

@ZenRoute()
class ProfileIdRoute extends _$ProfileIdRoute {
  ProfileIdRoute({required super.id});

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile: $id')),
      body: Center(child: Text('User ID: $id')),
    );
  }
}
```

### 3.1 Catch-all parameters with `[...params].dart`

Folders or files named with `[...name]` capture **all remaining path segments** as a `List<String>`. This is useful for:

- Documentation pages: `/docs/getting-started/installation`
- File paths: `/files/folder/subfolder/file.txt`
- Arbitrary nested routing: `/blog/2024/01/my-post-title`

```dart
// lib/routes/docs/[...slugs]/index.dart
// Matches: /docs/any/number/of/segments
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'routes.zen.dart';

part 'index.g.dart';

@ZenRoute()
class DocsRoute extends _$DocsRoute {
  DocsRoute({required super.slugs}); // slugs is List<String>

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Docs: ${slugs.join('/')}'),
      body: Center(
        child: Column(
          children: [
            Text('Path segments: ${slugs.length}'),
            for (final slug in slugs) Text('- $slug'),
          ],
        ),
      ),
    );
  }
}
```

#### Combining with other parameters

You can have additional routes inside a catch-all folder:

```
lib/routes/
└── docs/
    └── [...slugs]/
        ├── index.dart      → /docs/a/b/c (catch-all)
        ├── about.dart      → /docs/a/b/c/about
        └── [id].dart       → /docs/a/b/c/:id
```

```dart
// lib/routes/docs/[...slugs]/[id].dart
// Matches: /docs/any/path/user-123
@ZenRoute()
class DocsItemRoute extends _$DocsItemRoute {
  DocsItemRoute({required super.slugs, required super.id});

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Item: $id')),
      body: Text('In path: ${slugs.join('/')}'),
    );
  }
}
```

#### Generated pattern matching

The generator uses Dart's rest patterns for URL parsing:

```dart
// Generated parseRouteFromUri
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    ['docs', ...final slugs] => DocsRoute(slugs: slugs),
    ['docs', ...final slugs, final id] => DocsItemRoute(slugs: slugs, id: id),
    _ => NotFoundRoute(uri: uri),
  };
}

// Generated navigation methods
extension AppCoordinatorNav on AppCoordinator {
  Future<dynamic> pushDocs(List<String> slugs) => 
    push(DocsRoute(slugs: slugs));
  Future<dynamic> pushDocsItem(List<String> slugs, String id) => 
    push(DocsItemRoute(slugs: slugs, id: id));
}
```

> **Note:** Only one catch-all parameter is allowed per route. Routes with static segments are prioritized over catch-all routes during matching.

### 4. Layouts with `_layout.dart`

Layouts wrap child routes in a common UI structure:

```dart
// lib/routes/tabs/_layout.dart
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'routes.zen.dart';

part '_layout.g.dart';

@ZenLayout(
  type: LayoutType.indexed,
  routes: [FeedRoute, ProfileRoute, SettingsRoute],
)
class TabsLayout extends _$TabsLayout {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);
    
    return Scaffold(
      body: buildPath(coordinator),
      // You control the UI completely
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: path.activePathIndex,
        onTap: (i) => coordinator.push(path.stack[i]),
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Feed'),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: 'Profile'),
          BottomNavigationBarItem(icon: Icon(Icons.settings), label: 'Settings'),
        ],
      ),
    );
  }
}
```

### 5. Run build_runner

Generate the routing code:

```bash
dart run build_runner build
```

Or watch for changes:

```bash
dart run build_runner watch
```

### 6. Use in your app

```dart
import 'package:flutter/material.dart';
import 'routes/routes.zen.dart';

final coordinator = AppCoordinator();

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}

// Type-safe navigation with generated methods
coordinator.pushAbout();              // Push to /about
coordinator.pushProfileId('user-123'); // Push to /profile/user-123
coordinator.replaceIndex();            // Replace with home
coordinator.recoverTabProfile();       // Deep link to /tabs/profile
```

## File Naming Conventions

| Pattern | URL | Description |
|---------|-----|-------------|
| `index.dart` | `/path` | Route at directory level |
| `about.dart` | `/path/about` | Named route |
| `[id].dart` | `/path/:id` | Dynamic parameter (single segment) |
| `[...slugs]/` | `/path/*` | Catch-all parameter (multiple segments, `List<String>`) |
| `_layout.dart` | - | Layout wrapper (not a route) |
| `_*.dart` | - | Private files (ignored) |
| `(group)/` | - | Route group (layout without URL segment) |

### Dot Notation

You can also use dot notation in file names to represent directory nesting. This helps flatten your file structure while keeping deep URL paths.

`parent.child.dart` is equivalent to `parent/child.dart`.

**Examples:**
- `shop.products.[id].dart` → `/shop/products/:id`
- `settings.account.dart` → `/settings/account`
- `docs.[version].index.dart` → `/docs/:version`

This is especially useful for grouping related deep routes without creating many nested folders.

## Route Groups `(name)`

Route groups allow you to wrap routes with a layout **without adding the folder name to the URL path**. This is useful for:

- Grouping related routes under a shared layout (e.g., auth flows)
- Organizing routes without affecting URL structure
- Applying different styling/themes to route groups

### Example

```
lib/routes/
├── (auth)/                 # Route group - wraps routes without URL segment
│   ├── _layout.dart        # AuthLayout - shared auth styling
│   ├── login.dart          → /login (NOT /(auth)/login)
│   └── register.dart       → /register (NOT /(auth)/register)
├── (marketing)/
│   ├── _layout.dart        # MarketingLayout
│   ├── landing.dart        → /landing
│   └── pricing.dart        → /pricing
└── dashboard/
    └── index.dart          → /dashboard
```

### Creating a Route Group Layout

```dart
// lib/routes/(auth)/_layout.dart
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter/zenrouter.dart';

import '../routes.zen.dart';

part '_layout.g.dart';

@ZenLayout(type: LayoutType.stack)
class AuthLayout extends _$AuthLayout {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Container(
        // Auth-specific styling (gradient, logo, etc.)
        decoration: const BoxDecoration(
          gradient: LinearGradient(colors: [Colors.purple, Colors.blue]),
        ),
        child: buildPath(coordinator),
      ),
    );
  }
}
```

### Routes Inside Route Groups

```dart
// lib/routes/(auth)/login.dart
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part 'login.g.dart';

// URL: /login (not /(auth)/login)
// Layout: AuthLayout
@ZenRoute()
class LoginRoute extends _$LoginRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Center(
      child: Column(
        children: [
          TextField(decoration: InputDecoration(labelText: 'Email')),
          TextField(decoration: InputDecoration(labelText: 'Password')),
          ElevatedButton(
            onPressed: () => coordinator.replaceIndex(),
            child: const Text('Sign In'),
          ),
        ],
      ),
    );
  }
}
```

### Generated Code

The generator correctly handles route groups:

```dart
// Generated parseRouteFromUri
AppRoute parseRouteFromUri(Uri uri) {
  return switch (uri.pathSegments) {
    ['login'] => LoginRoute(),      // /login - wrapped by AuthLayout
    ['register'] => RegisterRoute(), // /register - wrapped by AuthLayout
    ['dashboard'] => DashboardRoute(),
    _ => NotFoundRoute(uri: uri),
  };
}

// Generated navigation methods
extension AppCoordinatorNav on AppCoordinator {
  Future<dynamic> pushLogin() => push(LoginRoute());
  Future<dynamic> pushRegister() => push(RegisterRoute());
}
```

## Deferred Imports

Improve your app's startup time by lazy-loading routes using deferred imports. When enabled, routes are only loaded when first navigated to, reducing initial bundle size.

### Per-Route Configuration

Enable deferred imports for individual routes:

```dart
@ZenRoute(deferredImport: true)
class HeavyRoute extends _$HeavyRoute {
  // Route implementation
}
```

### Global Configuration

Enable deferred imports for all routes via `build.yaml`:

```yaml
# In your project's build.yaml (not the package's build.yaml)
targets:
  $default:
    builders:
      zenrouter_file_generator|zen_coordinator:
        options:
          deferredImport: true
```

### Precedence Rules

1. **Route annotation takes precedence**: `deferredImport: false` in annotation overrides global config
2. **IndexedStack routes are always non-deferred**: Routes in `LayoutType.indexed` cannot use deferred imports
3. **Otherwise, global config applies**: Routes without explicit annotation use the global setting

### Example with Global Config

```yaml
# build.yaml
targets:
  $default:
    builders:
      zenrouter_file_generator|zen_coordinator:
        options:
          deferredImport: true  # All routes deferred by default
```

```dart
// Most routes use deferred imports automatically
@ZenRoute()  // Uses global config (deferred)
class AboutRoute extends _$AboutRoute { }

// Explicitly disable for critical routes
@ZenRoute(deferredImport: false)  // Override global config
class HomeRoute extends _$HomeRoute { }

// IndexedStack routes are always non-deferred
@ZenLayout(
  type: LayoutType.indexed,
  routes: [Tab1Route, Tab2Route],  // Always non-deferred
)
class TabsLayout extends _$TabsLayout { }
```

### Generated Code

With deferred imports enabled:

```dart
// Generated imports
import 'about.dart' deferred as about;
import 'home.dart';  // Non-deferred (explicit or IndexedStack)

// Generated navigation
Future<void> pushAbout() async => push(await () async {
  await about.loadLibrary();
  return about.AboutRoute();
}());

Future<void> pushHome() => push(HomeRoute());  // No deferred loading
```

### Performance Benchmarks

Real-world benchmarks demonstrate significant initial bundle size reductions with deferred imports:

| Metric | Without Deferred | With Deferred | Improvement |
|--------|-----------------|---------------|-------------|
| **Initial bundle** | 2,414 KB | 2,155 KB | **-259 KB (-10.7%)** ✅ |
| **Total app size** | 2,719 KB | 2,759 KB | +40 KB (+1.5%) |
| **Deferred chunks** | 0 | 24 chunks | - |

**Key Benefits:**
- ✅ **10.7% faster initial load** - Users see the app faster
- ✅ **On-demand loading** - Routes load only when navigated to
- ✅ **Better caching** - Unchanged routes won't re-download
- ⚠️ **Minimal overhead** - Only 1.5% total size increase

**Recommendation:** For most applications, enabling deferred imports provides substantial initial load improvements with minimal trade-offs. The feature is especially effective for apps with many routes or large route components.

See the example's [BENCHMARK_ANALYSIS.md](example/BENCHMARK_ANALYSIS.md) for detailed measurements.

## Route Mixins

Enable advanced behaviors with annotation parameters:

```dart
import 'package:zenrouter/zenrouter.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

@ZenRoute(
  guard: true,      // RouteGuard - control pop behavior
  redirect: true,   // RouteRedirect - conditional routing
  deepLink: DeeplinkStrategyType.custom, // Custom deep link handling
  transition: true, // RouteTransition - custom animations
  queries: ['search', 'page'], // Query parameters
)
class CheckoutRoute extends _$CheckoutRoute {
  @override
  FutureOr<bool> popGuard() async {
    return await confirmExit();
  }
  
  @override
  FutureOr<AppRoute?> redirect() async {
    if (!auth.isLoggedIn) return LoginRoute();
    return null; // null means proceed with this route
  }
  
  @override
  FutureOr<void> deeplinkHandler(AppCoordinator c, Uri uri) async {
    c.replace(HomeRoute());
    c.push(CartRoute());
    c.push(this);
  }
  
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final searchTerm = query('search');
    final page = query('page');
    return CheckoutScreen(search: searchTerm, page: page);
  }
}
```

## Route Query Parameters

You can easily handle query parameters with reactive updates using the `queries` parameter in `@ZenRoute`.

### 1. Enable Query Support

```dart
// Enable all query parameters
@ZenRoute(queries: ['*'])
class SearchRoute extends _$SearchRoute { ... }

// OR enable specific parameters
@ZenRoute(queries: ['q', 'page', 'sort'])
class SearchRoute extends _$SearchRoute { ... }
```

### 2. Access and Watch Queries

Use `selectorBuilder` to rebuild *only* when specific query parameters change, avoiding unnecessary rebuilds.

```dart
@override
Widget build(AppCoordinator coordinator, BuildContext context) {
  return Scaffold(
    appBar: AppBar(title: Text('Search Results')),
    body: Column(
      children: [
        // Rebuilds ONLY when 'q' query param changes
        selectorBuilder<String>(
          selector: (queries) => queries['q'] ?? '',
          builder: (context, searchTerm) {
            return Text('Searching for: $searchTerm');
          },
        ),
        // ... rest of UI
      ],
    ),
  );
}
```

### 3. Update Queries

You can update queries without full navigation (preserving widget state where possible). The URL will be updated automatically.

```dart
// Update specific query param
updateQueries(
  coordinator, 
  queries: {...queries, 'page': '2'},
);

// Clear all queries
updateQueries(coordinator, queries: {});
```

## Layout Types

### Stack Layout (NavigationPath)

For push/pop navigation:

```dart
@ZenLayout(type: LayoutType.stack)
class SettingsLayout extends _$SettingsLayout {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: buildPath(coordinator),
    );
  }
}
```

### Indexed Layout (IndexedStackPath)

For tabs/drawers:

```dart
@ZenLayout(
  type: LayoutType.indexed,
  routes: [Tab1Route, Tab2Route, Tab3Route], // Order = index
)
class TabsLayout extends _$TabsLayout {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);
    
    return Scaffold(
      body: buildPath(coordinator),
      // Full control over navigation UI
      bottomNavigationBar: YourNavigationWidget(
        index: path.activePathIndex,
        onTap: (i) => coordinator.push(path.stack[i]),
      ),
    );
  }
}
```

## Generated Code Structure

After running `build_runner`, your routes directory will look like:

```
lib/routes/
├── index.dart          # Your route class
├── index.g.dart        # Generated base class
├── about.dart
├── about.g.dart
└── routes.zen.dart     # Generated coordinator
```

### Generated Coordinator

The generator creates `routes.zen.dart` with:

- `AppRoute` base class (or custom name via `@ZenCoordinator`)
- `AppCoordinator` class with `parseRouteFromUri` implementation
- Navigation path definitions for layouts
- Type-safe navigation extension methods (push/replace/recover)

```dart
// routes.zen.dart (generated)
abstract class AppRoute extends RouteTarget with RouteUnique {}

class AppCoordinator extends Coordinator<AppRoute> {
  final IndexedStackPath<AppRoute> tabsPath = IndexedStackPath([...]);
  
  @override
  List<StackPath> get paths => [root, tabsPath];
  
  @override
  AppRoute parseRouteFromUri(Uri uri) {
    return switch (uri.pathSegments) {
      [] => IndexRoute(),
      ['about'] => AboutRoute(),
      ['profile', final id] => ProfileIdRoute(id: id),
      _ => NotFoundRoute(uri: uri),
    };
  }
}

// Type-safe navigation extensions
extension AppCoordinatorNav on AppCoordinator {
  // Push, Replace, Recover methods for each route
  Future<dynamic> pushAbout() => push(AboutRoute());
  void replaceAbout() => replace(AboutRoute());
  void recoverAbout() => recoverRouteFromUri(AboutRoute().toUri());
  
  // Routes with parameters
  Future<dynamic> pushProfileId(String id) => push(ProfileIdRoute(id: id));
  void replaceProfileId(String id) => replace(ProfileIdRoute(id: id));
  void recoverProfileId(String id) => recoverRouteFromUri(ProfileIdRoute(id: id).toUri());
}
```

### Navigation Methods: Push / Replace / Recover

For each route, the generator creates **three type-safe navigation methods**:

| Method | Return Type | Description |
|--------|-------------|-------------|
| `push{Route}()` | `Future<dynamic>` | Push route onto stack. Returns result when popped. |
| `replace{Route}()` | `void` | Replace current route. No navigation history. |
| `recover{Route}()` | `void` | Restore full navigation state from URI. For deep links. |

#### When to Use Each Method

**`push` - Standard Navigation**
```dart
// Navigate forward, user can go back
coordinator.pushAbout();
coordinator.pushProfileId('user-123');

// Wait for result when route pops
final result = await coordinator.pushCheckout();
if (result == 'success') { /* ... */ }
```

**`replace` - Replace Current Route**
```dart
// After login, replace login screen with home (no back button to login)
coordinator.replaceIndex();

// Switch tabs without adding to history
coordinator.replaceTabProfile();
```

**`recover` - Deep Link / State Restoration**
```dart
// Restore complete navigation state from a URI
// This rebuilds the entire navigation stack to reach the target route
coordinator.recoverProfileId('user-123');
// Equivalent to: coordinator.recoverRouteFromUri(Uri.parse('/profile/user-123'));

// Use for:
// - Deep links from external sources
// - App state restoration
// - Sharing URLs that should restore full navigation context
```

#### Example: Auth Flow

```dart
// On app start - check auth and recover appropriate state
if (isLoggedIn) {
  coordinator.recoverIndex();  // Restore to home with full stack
} else {
  coordinator.replaceLogin();  // Show login, no back navigation
}

// After successful login
coordinator.replaceIndex();  // Replace login with home

// User taps profile
coordinator.pushProfileId('current-user');  // Can go back to home
```

#### Example: Deep Link Handling

```dart
// When app receives deep link: myapp://profile/user-123
void handleDeepLink(Uri uri) {
  // recover rebuilds navigation stack: [Home] -> [Profile]
  coordinator.recoverProfileId('user-123');
}
```

## Custom Coordinator Configuration

Customize the generated coordinator by creating `lib/routes/_coordinator.dart`:

```dart
// lib/routes/_coordinator.dart
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

@ZenCoordinator(
  name: 'MyAppCoordinator',
  routeBase: 'MyAppRoute',
)
class CoordinatorConfig {}
```

## Integration with ZenRouter

This package generates routes compatible with zenrouter's coordinator pattern:

- Routes extend `RouteTarget with RouteUnique`
- Layouts use `RouteLayout` mixin
- Dynamic routes have typed parameters
- Full deep linking and URL synchronization support
- Route guards, redirects, and transitions

See the [zenrouter documentation](https://pub.dev/packages/zenrouter) for more details on advanced features.

## Example

Check out the `/example` directory for a complete working example:

```bash
cd example
flutter pub get
dart run build_runner build
flutter run
```

## Customizing the Coordinator

You can extend the generated coordinator to add custom capabilities, such as the debugging tools provided by `zenrouter_devtools`.

### Usage with `zenrouter_devtools`

To use the `CoordinatorDebug` mixin from `zenrouter_devtools` with your generated coordinator:

1. Add `zenrouter_devtools` to your dependencies.
2. Create a new class that extends the generated `AppCoordinator`.
3. Mixin `CoordinatorDebug`.

```dart
// lib/routes/_coordinator_debug.dart
import 'package:flutter/foundation.dart';
import 'package:zenrouter_devtools/zenrouter_devtools.dart';
import 'routes.zen.dart';

class DebugAppCoordinator extends AppCoordinator with CoordinatorDebug<AppRoute> {
  @override
  bool get debugEnabled => kDebugMode; // Only enable in debug mode

  @override
  List<AppRoute> get debugRoutes => [
    // Pre-populate specific routes for quick testing
    const LoginRoute(),
    ProfileIdRoute(id: 'test-user'),
    const SettingsRoute(),
  ];

  @override
  String debugLabel(StackPath path) {
    // Optional: Customize how paths appear in the debugger
    if (path == root) return 'Root Stack';
    return super.debugLabel(path);
  }
}
```

Then use `DebugAppCoordinator` in your app entry point:

```dart
void main() {
  final coordinator = DebugAppCoordinator();
  
  runApp(MaterialApp.router(
    routerDelegate: coordinator.routerDelegate,
    routeInformationParser: coordinator.routeInformationParser,
  ));
}
```

### Why isn't this built-in?

We chose not to generate this boilerplate automatically for several reasons:

1.  **Custom Data Requirements**: `debugRoutes` requires specific instantiation of your routes (e.g., providing dummy IDs), which the generator cannot guess using `const` constructors alone.
2.  **Environment Logic**: You may want complex logic for `debugEnabled` (e.g., checking flavors or environment variables) that exceeds simple boolean flags.
3.  **Dependency Management**: Keeping `zenrouter_devtools` optional ensures your production app stays lightweight if you choose not to use the devtools.

## License

Apache License 2.0 - see LICENSE file for details.



================================================
FILE: packages/zenrouter_file_generator/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options



================================================
FILE: packages/zenrouter_file_generator/build.yaml
================================================
builders:
  # File-based routing generators - generates _$RouteName base classes
  zen_route:
    import: "package:zenrouter_file_generator/builder.dart"
    builder_factories: ["zenRouteBuilder"]
    build_extensions: {".dart": [".g.part"]}
    auto_apply: dependents
    build_to: cache
    applies_builders: ["source_gen|combining_builder"]

  # Coordinator generator - aggregates all routes into routes.zen.dart
  # 
  # Configuration options:
  #   deferredImport: bool (default: false)
  #     When true, all routes will use deferred imports unless explicitly 
  #     disabled in the route annotation. This can improve app startup time
  #     by lazy-loading route implementations.
  #     
  #     Precedence rules:
  #     - Route-level explicit deferredImport annotation takes precedence
  #     - Routes in IndexedStack layouts are always non-deferred
  #     - Otherwise, uses this global config value
  zen_coordinator:
    import: "package:zenrouter_file_generator/builder.dart"
    builder_factories: ["zenCoordinatorBuilder"]
    build_extensions:
      "$lib$": ["routes/routes.zen.dart"]
    auto_apply: dependents
    build_to: source




================================================
FILE: packages/zenrouter_file_generator/CHANGELOG.md
================================================
## 1.0.0
- **BREAKING**: Requires `zenrouter: ^1.0.0` and `zenrouter_file_annotation: ^1.0.0`
- **Stable release**: Production-ready file-based routing generator
- Generates code compatible with zenrouter 1.0.0 features

## 0.4.14
- **Fix**: Upgrade to `analyzer` to `^9.0.0`

## 0.4.13
- **Docs**: Add "Customizing the Coordinator" section to README
- **Docs**: Add Table of Contents to README

## 0.4.12
- **Feat**: Add `super.paths` to ensure `root` always added in the `paths` getter (Thanks @mrgnhnt96)

## 0.4.11

### New Features

- **NavContext extension**: Auto-generated extension on route base class (e.g., `AppRoute`) providing convenient navigation methods directly from route instances:
  - `route.navigate(context)` - Navigate to the route
  - `route.push<T>(context)` - Push the route and optionally return a result
  - `route.replace(context)` - Replace the current route
  - `route.recover(context)` - Recover to the route

## 0.4.10

### New Features

- **CoordinatorProvider**: Auto-generated `InheritedWidget` provider for accessing the coordinator from the widget tree via `context.appCoordinator`
- **layoutBuilder override**: The generated Coordinator now includes a `layoutBuilder` override that wraps layouts with the provider
- **deferredImport in `@ZenCoordinator`**: Configure global deferred import via annotation, overriding `build.yaml`
- **routeBasePath in `@ZenCoordinator`**: Import a custom base route class from a specified path instead of generating it
- **outputFile config**: New `build.yaml` option to customize the output filename (default: `routes.zen.dart`)

### Bug Fixes

- **Fixed file processing order**: Read `_coordinator.dart` directly first before processing routes to ensure correct configuration

## 0.4.9
- **Refactor**: Use shared code generation utilities (`LayoutCodeGenerator`, `RouteCodeGenerator`) from `zenrouter_file_annotation`

## 0.4.8
- **Docs**: Update README

## 0.4.7
- **Docs**: Update README and add screenshots

## 0.4.6
- Downgrade `analyzer` to `^8.0.0` for compatibility.

## 0.4.5
- Support new `RouteQueryParameters` and new dot notation flavor in naming convention.

## 0.4.1
- **Docs**: Improve documentation and update outdated examples
- Bump zenrouter_file_annotation to 0.4.0

## 0.4.0
- **BREAKING CHANGE**: Upgraded generated code to use `zenrouter` 0.4.0+ constructor syntax (`NavigationPath.createWith`/`IndexedStackPath.createWith`). Requires `zenrouter: ^0.4.0`.

## 0.3.1

- **NEW FEATURE**: Add ability to lazy load routes using the `deferredImport` option in the `@ZenCoordinator` annotation
- **PERFORMANCE IMPROVEMENTS**: Performance improvements (30-40% faster generation, 25-35% lower memory) and automatic code formatting with `dart_style`

## 0.3.0
- Bump version to 0.3.0 
- Add support for catch-all parameters ([...slugs], [...ids], etc) in routes, including `List<String>` type handling and updated route specificity sorting.

## 0.2.3

- Format files

## 0.2.2

### Bug Fixes

- Update the debug label correctly for the generated Path in the Coordinator
- Update README.md

## 0.2.1

### New Features

- **Extract annotations and analyzer elements into a new `zenrouter_file_annotation` package**

### Breaking Changes

- **Remove `zenrouter_file_generator` from `pubspec.yaml` and move it to `dev_dependencies`**

## 0.2.0

### New Features

- **Route Groups `(name)`**: Wrap routes in a layout without adding the folder name to the URL path
  - Folders named with parentheses like `(auth)` create route groups
  - Routes inside `(auth)/login.dart` generate URL `/login` (not `/(auth)/login`)
  - Routes are still wrapped by the `_layout.dart` in that folder
  - Useful for grouping auth flows, marketing pages, or applying shared styling

## 0.1.0

- Initial release of zenrouter_file_generator with file-based routing support for Flutter.


================================================
FILE: packages/zenrouter_file_generator/devtools_options.yaml
================================================
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:



================================================
FILE: packages/zenrouter_file_generator/LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 Bui Dai Duong

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: packages/zenrouter_file_generator/pubspec.yaml
================================================
name: zenrouter_file_generator
description: "A code generator for file-based routing in Flutter using zenrouter. Generate type-safe routes from your file/directory structure, similar to Next.js or Nuxt.js."
version: 1.0.0
homepage: https://github.com/definev/zenrouter/tree/main/packages/zenrouter_file_generator
repository: https://github.com/definev/zenrouter/tree/main/packages/zenrouter_file_generator
resolution: workspace

environment:
  sdk: ^3.7.0
  flutter: ">=1.17.0"

dependencies:
  flutter:
    sdk: flutter

  # Build runner dependencies
  build: ^4.0.2
  source_gen: ^4.1.1
  analyzer: ^9.0.0
  glob: ^2.1.3
  zenrouter_file_annotation: ^1.0.0
  dart_style: ^3.1.3

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0
  build_runner: ^2.10.4



================================================
FILE: packages/zenrouter_file_generator/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: package



================================================
FILE: packages/zenrouter_file_generator/.pubignore
================================================
doc/api
doc/paradigms
doc/guides
build
zenrouter_docs



================================================
FILE: packages/zenrouter_file_generator/example/analysis_options.yaml
================================================
include: package:flutter_lints/flutter.yaml

linter:
  rules:
    file_names: false


================================================
FILE: packages/zenrouter_file_generator/example/benchmark.sh
================================================
#!/bin/bash

# Comprehensive Deferred Import Benchmark Script
# Tests application-level deferred imports (main_deferred.dart vs main_no_deferred.dart)

set -e

echo "======================================================"
echo "ZenRouter Deferred Import Benchmark"
echo "======================================================"
echo ""

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Directory setup
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_DIR="$SCRIPT_DIR/build/web"
RESULTS_FILE="$SCRIPT_DIR/benchmark_results.txt"
BUILD_YAML="$SCRIPT_DIR/build.yaml"

# Function to update deferredImport setting in build.yaml
update_deferred_import() {
    local value=$1
    echo -e "${BLUE}Setting deferredImport to $value in build.yaml...${NC}"
    
    # Update the deferredImport value in build.yaml
    sed -i.bak "s/deferredImport: .*/deferredImport: $value/" "$BUILD_YAML"
    
    # Show the updated setting
    grep "deferredImport:" "$BUILD_YAML"
}

# Function to clean build directory
clean_build() {
    echo -e "${YELLOW}Cleaning build directory...${NC}"
    if [ -d "$BUILD_DIR" ]; then
        rm -rf "$BUILD_DIR"
    fi
}

# Function to run flutter build with specific target
run_build() {
    local target=$1
    local label=$2
    
    echo -e "${BLUE}Building with target: $target${NC}"
    echo -e "${BLUE}Running flutter clean...${NC}"
    flutter clean
    
    echo -e "${BLUE}Running flutter pub get...${NC}"
    flutter pub get
    
    echo -e "${BLUE}Running build_runner clean...${NC}"
    flutter packages pub run build_runner clean
    
    echo -e "${BLUE}Running build_runner build...${NC}"
    flutter packages pub run build_runner build --delete-conflicting-outputs
    
    echo -e "${BLUE}Building web app (target: $target)...${NC}"
    flutter build web --release -t "$target"
}

# Function to measure JS files
measure_js_files() {
    local label=$1
    local total_size=0
    
    echo -e "${GREEN}Measuring JS files for: $label${NC}"
    echo "----------------------------------------"
    
    if [ ! -d "$BUILD_DIR" ]; then
        echo "Error: Build directory not found!"
        return 1
    fi
    
    # Find all .js files and calculate sizes
    while IFS= read -r -d '' file; do
        local size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
        local size_kb=$((size / 1024))
        local filename=$(basename "$file")
        echo "  $filename: ${size_kb} KB"
        total_size=$((total_size + size))
    done < <(find "$BUILD_DIR" -name "*.js" -type f -print0 | sort -z)
    
    local total_kb=$((total_size / 1024))
    local total_mb=$(python3 -c "print(f'{$total_size / 1024 / 1024:.2f}')")
    
    echo "----------------------------------------"
    echo -e "${GREEN}Total JS size: ${total_kb} KB (${total_mb} MB)${NC}"
    
    # Count files
    local file_count=$(find "$BUILD_DIR" -name "*.js" -type f | wc -l | tr -d ' ')
    echo -e "${GREEN}Total JS files: ${file_count}${NC}"
    echo ""
    
    # Return total size
    echo "$total_size"
}

# Initialize results file
echo "ZenRouter Deferred Import Benchmark Results" > "$RESULTS_FILE"
echo "Generated: $(date)" >> "$RESULTS_FILE"
echo "======================================================" >> "$RESULTS_FILE"
echo "" >> "$RESULTS_FILE"

# Benchmark 1: main_no_deferred.dart (baseline)
echo -e "${YELLOW}========================================${NC}"
echo -e "${YELLOW}Test 1: main_no_deferred.dart${NC}"
echo -e "${YELLOW}(Normal import - Baseline)${NC}"
echo -e "${YELLOW}========================================${NC}"
update_deferred_import "false"
clean_build
run_build "lib/main_no_deferred.dart" "No Deferred"
size_no_deferred=$(measure_js_files "main_no_deferred.dart")

echo "Test 1: main_no_deferred.dart (Normal Import - Baseline)" >> "$RESULTS_FILE"
echo "----------------------------------------" >> "$RESULTS_FILE"
find "$BUILD_DIR" -name "*.js" -type f | sort | while read file; do
    echo "  $(basename "$file"): $(($(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null) / 1024)) KB" >> "$RESULTS_FILE"
done
file_count_no_deferred=$(find "$BUILD_DIR" -name "*.js" -type f | wc -l | tr -d ' ')
echo "Total: $((size_no_deferred / 1024)) KB" >> "$RESULTS_FILE"
echo "File count: $file_count_no_deferred" >> "$RESULTS_FILE"
echo "" >> "$RESULTS_FILE"

# Benchmark 2: main_deferred.dart
echo -e "${YELLOW}========================================${NC}"
echo -e "${YELLOW}Test 2: main_deferred.dart${NC}"
echo -e "${YELLOW}(Deferred import with loadLibrary)${NC}"
echo -e "${YELLOW}========================================${NC}"
update_deferred_import "true"
clean_build
run_build "lib/main_deferred.dart" "Deferred"
size_deferred=$(measure_js_files "main_deferred.dart")

echo "Test 2: main_deferred.dart (Deferred Import)" >> "$RESULTS_FILE"
echo "----------------------------------------" >> "$RESULTS_FILE"
find "$BUILD_DIR" -name "*.js" -type f | sort | while read file; do
    echo "  $(basename "$file"): $(($(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null) / 1024)) KB" >> "$RESULTS_FILE"
done
file_count_deferred=$(find "$BUILD_DIR" -name "*.js" -type f | wc -l | tr -d ' ')
echo "Total: $((size_deferred / 1024)) KB" >> "$RESULTS_FILE"
echo "File count: $file_count_deferred" >> "$RESULTS_FILE"
echo "" >> "$RESULTS_FILE"

# Calculate difference
echo "======================================================" >> "$RESULTS_FILE"
echo "Comparison" >> "$RESULTS_FILE"
echo "======================================================" >> "$RESULTS_FILE"
difference=$((size_deferred - size_no_deferred))
difference_kb=$((difference / 1024))
percentage=$(python3 -c "print(f'{($difference * 100) / $size_no_deferred:.2f}')")
file_diff=$((file_count_deferred - file_count_no_deferred))

# Calculate main bundle sizes (main.dart.js)
main_no_deferred=$(find "$BUILD_DIR" -name "main.dart.js" 2>/dev/null | head -1)
if [ -n "$main_no_deferred" ]; then
    # Need to rebuild to get accurate main bundle comparison
    echo "Note: For main bundle comparison, check the individual test outputs above" >> "$RESULTS_FILE"
fi

echo "Size without deferred: $((size_no_deferred / 1024)) KB ($file_count_no_deferred files)" >> "$RESULTS_FILE"
echo "Size with deferred: $((size_deferred / 1024)) KB ($file_count_deferred files)" >> "$RESULTS_FILE"
echo "Bundle size difference: ${difference_kb} KB (${percentage}%)" >> "$RESULTS_FILE"
echo "File count difference: ${file_diff} files" >> "$RESULTS_FILE"

# Display summary
echo ""
echo -e "${GREEN}=====================================================${NC}"
echo -e "${GREEN}BENCHMARK SUMMARY${NC}"
echo -e "${GREEN}=====================================================${NC}"
echo -e "main_no_deferred.dart:  $((size_no_deferred / 1024)) KB ($file_count_no_deferred files)"
echo -e "main_deferred.dart:     $((size_deferred / 1024)) KB ($file_count_deferred files)"
echo -e "Bundle difference:      ${difference_kb} KB (${percentage}%)"
echo -e "File difference:        ${file_diff} files"
echo ""
echo -e "${BLUE}Full results saved to: $RESULTS_FILE${NC}"
echo ""



================================================
FILE: packages/zenrouter_file_generator/example/BENCHMARK_ANALYSIS.md
================================================
# Deferred Import Benchmark Results

**Generated:** Sat Dec 13 21:23:47 +07 2025

---

## ✅ Accurate Baseline Comparison

This benchmark properly compares **non-deferred** vs **deferred** import strategies by programmatically switching the `deferredImport` setting in `build.yaml` between tests.

---

## 📊 Results Summary

### Without Deferred Imports (`deferredImport: false`)
- **Main bundle:** `main.dart.js` = 2,414 KB
- **Total application JS:** 2,414 KB
- **Framework/Engine JS:** 308 KB
- **Grand Total:** 2,722 KB
- **File count:** 8 JS files

### With Deferred Imports (`deferredImport: true`)
- **Main bundle:** `main.dart.js` = 1,941 KB
- **Deferred chunks:** 49 part files = 539 KB
- **Total application JS:** 2,480 KB
- **Framework/Engine JS:** 305 KB  
- **Grand Total:** 2,785 KB
- **File count:** 57 JS files

---

## 📈 Analysis

### Bundle Size Comparison

| Metric | Without Deferred | With Deferred | Difference |
|--------|-----------------|---------------|------------|
| **Main bundle** | 2,414 KB | 1,941 KB | **-473 KB (-19.6%)** ✅ |
| **Deferred chunks** | 0 KB | 539 KB | +539 KB |
| **Total app JS** | 2,414 KB | 2,480 KB | +66 KB (+2.7%) |
| **Grand total** | 2,722 KB | 2,785 KB | +63 KB (+2.3%) |

### 🎯 Key Findings

✅ **Massive Initial Load Reduction:** The main bundle is **473 KB smaller** (19.6% reduction) with deferred imports
- Main `main.dart.js`: 2,414 KB → 1,941 KB
- This is a **game-changing improvement** for initial page load performance

📦 **Code Split into 49 Chunks:** Routes are intelligently split into separate files:
- **Largest deferred chunk:** `main.dart.js_57.part.js` (250 KB) - major route/layout
- **Large chunks:** `main.dart.js_67.part.js` (83 KB), `main.dart.js_34.part.js` (54 KB)
- **Medium chunks:** `main.dart.js_4.part.js` (21 KB), `main.dart.js_36.part.js` (17 KB), `main.dart.js_12.part.js` (16 KB)
- **Many small chunks:** 43 files ≤ 12 KB each for granular lazy loading

⚖️ **Excellent Trade-off:** Total bundle size increases by only **63 KB** (2.3%), which is minimal considering:
- Additional module loading infrastructure
- Small amount of duplicate framework code across chunks
- Module boundary overhead

### Performance Impact

**Pros:**
- ✅ **Dramatically faster initial page load** (473 KB / 19.6% less to download/parse upfront)
- ✅ **Massive time-to-interactive improvement** - large route (250 KB) loads on-demand
- ✅ **Better caching** - unchanged routes won't re-download on updates
- ✅ **Improved perceived performance** - essential code loads first
- ✅ **Progressive loading** - users only download what they navigate to

**Cons:**
- ⚠️ Slightly larger total download size (+63 KB, ~2.3%)
- ⚠️ Additional HTTP requests for deferred chunks (49 extra requests)
- ⚠️ Small delay when navigating to deferred routes (mitigated by predictive loading)

---

## 📁 Detailed File Breakdown

### Without Deferred Imports
```
Framework/Engine:
  flutter_bootstrap.js:      9 KB
  flutter.js:                9 KB
  flutter_service_worker.js: 0 KB
  skwasm.js:                59 KB
  skwasm_heavy.js:          59 KB
  canvaskit.js (2x):       168 KB
  
Application:
  main.dart.js:          2,414 KB  ⭐ All code in one bundle
  
Total: 2,722 KB (8 files)
```

### With Deferred Imports
```
Framework/Engine:
  flutter_bootstrap.js:      9 KB
  flutter.js:                9 KB
  flutter_service_worker.js: 0 KB
  skwasm.js:                59 KB
  skwasm_heavy.js:          59 KB
  canvaskit.js (2x):       168 KB

Application (Main):
  main.dart.js:          1,941 KB  ⭐ 19.6% smaller!

Application (Deferred - 49 chunks):
  main.dart.js_57.part.js: 250 KB  ⭐ Largest chunk
  main.dart.js_67.part.js:  83 KB
  main.dart.js_34.part.js:  54 KB
  main.dart.js_4.part.js:   21 KB
  main.dart.js_36.part.js:  17 KB
  main.dart.js_12.part.js:  16 KB
  main.dart.js_39.part.js:  12 KB
  main.dart.js_10.part.js:  12 KB
  main.dart.js_49/54.part.js: 6 KB each
  main.dart.js_37.part.js:   5 KB
  main.dart.js_56.part.js:   4 KB
  main.dart.js_2/14.part.js: 3 KB each
  main.dart.js_25/33/50/55/9.part.js: 2 KB each
  (+ 38 more chunks ≤ 1 KB each)
  
Total: 2,785 KB (57 files)
```

---

## 📊 Chunk Distribution Analysis

### Size Distribution (49 deferred chunks)
- **Very Large (>100 KB):** 1 chunk (250 KB)
- **Large (50-100 KB):** 2 chunks (83 KB, 54 KB)
- **Medium (10-50 KB):** 5 chunks (21 KB, 17 KB, 16 KB, 12 KB, 12 KB)
- **Small (5-10 KB):** 3 chunks (6 KB, 6 KB, 5 KB)
- **Tiny (<5 KB):** 38 chunks

**Observation:** The distribution shows excellent code splitting with several substantial chunks (250 KB, 83 KB, 54 KB) that provide major benefits when loaded on-demand, plus many small chunks for granular lazy loading.

---

## 💡 Recommendation

### ✅ **STRONGLY RECOMMENDED to use `deferredImport: true`**

The benefits are overwhelmingly clear:

#### 🚀 **Primary Benefits:**
- **19.6% reduction in initial bundle** (473 KB) = significantly faster first load
- **Only 2.3% increase in total size** (63 KB) = minimal bandwidth penalty
- **One massive chunk (250 KB)** + two large chunks (83 KB, 54 KB) that load only when needed = major performance win

#### 📈 **Real-World Impact:**
- **Initial page load:** ~19.6% faster download/parse time
- **Time-to-interactive:** Dramatically improved - 473 KB less code to parse before app becomes interactive
- **Network efficiency:** Users who don't visit all routes save significant bandwidth
- **Cache efficiency:** Granular chunks mean app updates don't invalidate entire bundle

### When to use deferred imports:
✅ **This application** - Clear, massive win with 19.6% main bundle reduction  
✅ **Production apps** where initial load time is critical  
✅ **Large applications** with many routes (especially heavy ones)  
✅ **Modern deployment** with HTTP/2 or HTTP/3 (parallel chunk loading)  
✅ **Progressive Web Apps** (PWAs) targeting Core Web Vitals  

### When to skip:
❌ **Very simple apps** with only 1-2 small routes  
❌ **Poor network conditions** where many HTTP requests are extremely costly  
❌ **Apps where 100% of users visit all routes** in every session  

---

## 🚀 Impact Summary

The deferred import feature delivers **exceptional performance improvements**:

- ✅ Initial page loads **19.6% faster** (473 KB reduction)
- ✅ Users who don't navigate to certain routes save **up to 539 KB** of downloads
- ✅ Total bandwidth cost is minimal (+63 KB / +2.3% for full app usage)
- ✅ Progressive loading dramatically improves perceived performance
- ✅ Better cache efficiency with granular chunks

### � Performance Metrics Comparison

| Metric | Without Deferred | With Deferred | Improvement |
|--------|------------------|---------------|-------------|
| **Initial Load Size** | 2,722 KB | 2,248 KB* | -17.4% |
| **Main Bundle Parse Time** | 100% | 80.4% | -19.6% |
| **Routes Loaded Upfront** | All | Essential only | Lazy loading |

*Assuming user doesn't immediately navigate to all deferred routes

---

## � Technical Notes

- **Build date:** December 13, 2025, 21:23:47 +07
- **Flutter SDK:** Web release build
- **Configuration method:** Programmatic `build.yaml` switching via benchmark script
- **Compression:** Sizes shown are uncompressed (gzip would reduce by ~70%)
- **HTTP/2:** Modern browsers can download chunks in parallel, minimizing request overhead
- **Route splitting:** 49 chunks provide excellent balance between granularity and HTTP overhead

---

## 🎉 Conclusion

With a **19.6% reduction in initial bundle size** and only **2.3% increase in total size**, deferred imports provide an outstanding performance improvement for ZenRouter applications. This feature should be considered **essential** for production deployments.



================================================
FILE: packages/zenrouter_file_generator/example/benchmark_results.txt
================================================
ZenRouter Deferred Import Benchmark Results
Generated: Sat Dec 13 21:23:47 +07 2025
======================================================

Test 1: main_no_deferred.dart (Normal Import - Baseline)
----------------------------------------
  canvaskit.js: 84 KB
  canvaskit.js: 84 KB
  skwasm.js: 59 KB
  skwasm_heavy.js: 59 KB
  flutter.js: 9 KB
  flutter_bootstrap.js: 9 KB
  flutter_service_worker.js: 0 KB
  main.dart.js: 2414 KB
File count: 8

Test 2: main_deferred.dart (Deferred Import)
----------------------------------------
  canvaskit.js: 84 KB
  canvaskit.js: 84 KB
  skwasm.js: 59 KB
  skwasm_heavy.js: 59 KB
  flutter.js: 9 KB
  flutter_bootstrap.js: 9 KB
  flutter_service_worker.js: 0 KB
  main.dart.js: 1941 KB
  main.dart.js_1.part.js: 1 KB
  main.dart.js_10.part.js: 12 KB
  main.dart.js_11.part.js: 0 KB
  main.dart.js_12.part.js: 16 KB
  main.dart.js_13.part.js: 1 KB
  main.dart.js_14.part.js: 3 KB
  main.dart.js_15.part.js: 0 KB
  main.dart.js_16.part.js: 0 KB
  main.dart.js_17.part.js: 0 KB
  main.dart.js_18.part.js: 0 KB
  main.dart.js_19.part.js: 0 KB
  main.dart.js_2.part.js: 3 KB
  main.dart.js_21.part.js: 1 KB
  main.dart.js_23.part.js: 0 KB
  main.dart.js_25.part.js: 2 KB
  main.dart.js_27.part.js: 0 KB
  main.dart.js_29.part.js: 1 KB
  main.dart.js_30.part.js: 0 KB
  main.dart.js_33.part.js: 2 KB
  main.dart.js_34.part.js: 54 KB
  main.dart.js_35.part.js: 1 KB
  main.dart.js_36.part.js: 17 KB
  main.dart.js_37.part.js: 5 KB
  main.dart.js_39.part.js: 12 KB
  main.dart.js_4.part.js: 21 KB
  main.dart.js_40.part.js: 0 KB
  main.dart.js_41.part.js: 0 KB
  main.dart.js_43.part.js: 1 KB
  main.dart.js_44.part.js: 0 KB
  main.dart.js_45.part.js: 0 KB
  main.dart.js_47.part.js: 1 KB
  main.dart.js_49.part.js: 6 KB
  main.dart.js_5.part.js: 1 KB
  main.dart.js_50.part.js: 2 KB
  main.dart.js_52.part.js: 0 KB
  main.dart.js_54.part.js: 6 KB
  main.dart.js_55.part.js: 2 KB
  main.dart.js_56.part.js: 4 KB
  main.dart.js_57.part.js: 250 KB
  main.dart.js_58.part.js: 1 KB
  main.dart.js_59.part.js: 0 KB
  main.dart.js_6.part.js: 0 KB
  main.dart.js_61.part.js: 1 KB
  main.dart.js_63.part.js: 1 KB
  main.dart.js_65.part.js: 1 KB
  main.dart.js_67.part.js: 83 KB
  main.dart.js_7.part.js: 0 KB
  main.dart.js_8.part.js: 1 KB
  main.dart.js_9.part.js: 2 KB
File count: 57

======================================================
Comparison
======================================================



================================================
FILE: packages/zenrouter_file_generator/example/build.yaml
================================================
targets:
  $default:
    builders:
      zenrouter_file_generator|zen_coordinator:
        options:
          deferredImport: true
          outputFile: 'routes.zen.dart'



================================================
FILE: packages/zenrouter_file_generator/example/devtools_options.yaml
================================================
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:



================================================
FILE: packages/zenrouter_file_generator/example/pubspec.yaml
================================================
name: zenrouter_file_generator_example
description: "An example project for zenrouter_file_generator."
publish_to: 'none'
version: 0.1.0+1

resolution: workspace

environment:
  sdk: ^3.8.0

dependencies:
  flutter:
    sdk: flutter
  
  zenrouter: 
  zenrouter_devtools:
  zenrouter_file_annotation:

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^6.0.0

  build_runner: ^2.10.4
  zenrouter_file_generator:

flutter:
  uses-material-design: true



================================================
FILE: packages/zenrouter_file_generator/example/.metadata
================================================
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "e74c5954502f51a5cb2089320767dfab8f611168"
  channel: "master"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: android
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: ios
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: linux
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: macos
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: web
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168
    - platform: windows
      create_revision: e74c5954502f51a5cb2089320767dfab8f611168
      base_revision: e74c5954502f51a5cb2089320767dfab8f611168

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'



================================================
FILE: packages/zenrouter_file_generator/example/android/build.gradle.kts
================================================
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}



================================================
FILE: packages/zenrouter_file_generator/example/android/gradle.properties
================================================
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true



================================================
FILE: packages/zenrouter_file_generator/example/android/settings.gradle.kts
================================================
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.11.1" apply false
    id("org.jetbrains.kotlin.android") version "2.2.20" apply false
}

include(":app")



================================================
FILE: packages/zenrouter_file_generator/example/android/app/build.gradle.kts
================================================
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.example"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_17.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.example"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/debug/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/main/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="example"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/main/kotlin/com/example/example/MainActivity.kt
================================================
package com.example.example

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/main/res/drawable/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/main/res/drawable-v21/launch_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/main/res/values/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/main/res/values-night/styles.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>



================================================
FILE: packages/zenrouter_file_generator/example/android/app/src/profile/AndroidManifest.xml
================================================
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>



================================================
FILE: packages/zenrouter_file_generator/example/android/gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14-all.zip



================================================
FILE: packages/zenrouter_file_generator/example/ios/Flutter/AppFrameworkInfo.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter_file_generator/example/ios/Flutter/Debug.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter_file_generator/example/ios/Flutter/Release.xcconfig
================================================
#include "Generated.xcconfig"



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/AppDelegate.swift
================================================
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Example</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>example</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Runner-Bridging-Header.h
================================================
#import "GeneratedPluginRegistrant.h"



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/README.md
================================================
# Launch Screen Assets

You can customize the launch screen with your own desired assets by replacing the image files in this directory.

You can also do it by opening your Flutter project's Xcode project with `open ios/Runner.xcworkspace`, selecting `Runner/Assets.xcassets` in the Project Navigator and dropping in the desired images.


================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json
================================================
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Base.lproj/LaunchScreen.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>



================================================
FILE: packages/zenrouter_file_generator/example/ios/Runner/Base.lproj/Main.storyboard
================================================
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>



================================================
FILE: packages/zenrouter_file_generator/example/ios/RunnerTests/RunnerTests.swift
================================================
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter_file_generator/example/lib/flutter_scan.dart
================================================
import 'dart:collection';
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

/// A widget that visualizes widget rebuilds by drawing a flashing rectangle
/// over widgets that have just rebuilt.
///
/// Usage:
/// ```dart
/// void main() {
///   runApp(
///     FlutterScan(
///       enabled: true,
///       child: MyApp(),
///     ),
///   );
/// }
/// ```
class FlutterScan extends StatefulWidget {
  final Widget child;
  final bool enabled;

  const FlutterScan({super.key, required this.child, this.enabled = true});

  @override
  State<FlutterScan> createState() => _FlutterScanState();
}

class _FlutterScanState extends State<FlutterScan>
    with SingleTickerProviderStateMixin {
  final ListQueue<_RebuildInfo> _rebuilds = ListQueue();
  late final Ticker _ticker;
  final ValueNotifier<int> _tickNotifier = ValueNotifier(0);
  final List<Element> _dirtyElements = [];
  bool _frameCallbackScheduled = false;

  @override
  void initState() {
    super.initState();
    _ticker = createTicker(_onTick);
    if (widget.enabled) {
      _enableScanning();
    }
  }

  @override
  void didUpdateWidget(FlutterScan oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.enabled != oldWidget.enabled) {
      if (widget.enabled) {
        _enableScanning();
      } else {
        _disableScanning();
      }
    }
  }

  @override
  void dispose() {
    _ticker.dispose();
    _disableScanning();
    super.dispose();
  }

  void _onTick(Duration elapsed) {
    _tickNotifier.value++;

    // Cleanup old rebuilds
    final now = DateTime.now();
    while (_rebuilds.isNotEmpty) {
      final info = _rebuilds.first;
      if (now.difference(info.timestamp).inMilliseconds > 500) {
        _rebuilds.removeFirst();
      } else {
        break;
      }
    }

    if (_rebuilds.isEmpty) {
      _ticker.stop();
    }
  }

  void _enableScanning() {
    debugOnRebuildDirtyWidget = _onRebuildDirtyWidget;
  }

  void _disableScanning() {
    if (debugOnRebuildDirtyWidget == _onRebuildDirtyWidget) {
      debugOnRebuildDirtyWidget = null;
    }
    _rebuilds.clear();
    _ticker.stop();
  }

  void _onRebuildDirtyWidget(Element element, bool builtOnce) {
    // Avoid scanning our own internal widgets to prevent infinite loops
    if (element.widget is FlutterScan) {
      if (element.widget.runtimeType.toString() == '_RebuildPainter' ||
          element.widget is FlutterScan) {
        return;
      }
    }

    // We only care about elements that have a render object attached directly
    // or indirectly that we can measure.
    if (element.renderObject == null || !element.renderObject!.attached) {
      return;
    }

    _dirtyElements.add(element);
    if (!_frameCallbackScheduled) {
      _frameCallbackScheduled = true;
      SchedulerBinding.instance.addPostFrameCallback(_onPostFrame);
    }
  }

  void _onPostFrame(Duration timeStamp) {
    _frameCallbackScheduled = false;
    if (!mounted) {
      _dirtyElements.clear();
      return;
    }

    final now = DateTime.now();
    bool addedAny = false;

    for (final element in _dirtyElements) {
      // The logic from _processElement is now inlined here.
      if (!element.mounted || element.renderObject == null) continue;

      final renderObject = element.renderObject!;
      if (!renderObject.attached) continue;

      // We don't calculate rect here anymore, we just store the renderObject.
      // But we do check if it's visible/valid to avoid adding junk.
      try {
        // Quick check if it has size (optional, but good for perf)
        if (!renderObject.paintBounds.isEmpty) {
          _rebuilds.add(
            _RebuildInfo(renderObject: renderObject, timestamp: now),
          );
          addedAny = true;
        }
      } catch (e) {
        // Ignore
      }
    }
    _dirtyElements.clear();

    if (addedAny && !_ticker.isActive) {
      _ticker.start();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      textDirection: TextDirection.ltr,
      children: [
        widget.child,
        // Overlay for rebuilds
        IgnorePointer(
          child: CustomPaint(
            size: Size.infinite,
            painter: _RebuildPainter(
              rebuilds: _rebuilds,
              repaint: _tickNotifier,
            ),
          ),
        ),
      ],
    );
  }
}

class _RebuildInfo {
  final WeakReference<RenderObject> renderObjectRef;
  final DateTime timestamp;

  _RebuildInfo({required RenderObject renderObject, required this.timestamp})
    : renderObjectRef = WeakReference(renderObject);
}

class _RebuildPainter extends CustomPainter {
  final ListQueue<_RebuildInfo> rebuilds;

  _RebuildPainter({required this.rebuilds, required super.repaint});

  @override
  void paint(Canvas canvas, Size size) {
    final now = DateTime.now();

    for (final info in rebuilds) {
      final renderObject = info.renderObjectRef.target;
      if (renderObject == null || !renderObject.attached) continue;

      final age = now.difference(info.timestamp).inMilliseconds;
      if (age > 500) continue;

      try {
        final transform = renderObject.getTransformTo(null);
        final paintBounds = renderObject.paintBounds;
        final rect = MatrixUtils.transformRect(transform, paintBounds);

        if (rect.isEmpty) continue;

        final opacity = 1.0 - (age / 500.0);

        const strokeWidth = 2.0;
        final insideRect = rect.deflate(strokeWidth / 2);

        final borderPaint = Paint()
          ..color = const Color.fromARGB(
            255,
            104,
            167,
            159,
          ).withValues(alpha: opacity)
          ..style = PaintingStyle.stroke
          ..strokeWidth = strokeWidth;

        canvas.drawRect(insideRect, borderPaint);
      } catch (e) {
        // RenderObject might be detached during paint
      }
    }
  }

  @override
  bool shouldRepaint(_RebuildPainter oldDelegate) => true;
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/main_deferred.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_generator_example/flutter_scan.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

void main() {
  runApp(FlutterScan(child: const MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  static final coordinator = AppCoordinator();

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter File-Based Routing Example',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.indigo),
        useMaterial3: true,
      ),
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/main_no_deferred.dart
================================================
import 'package:flutter/material.dart';
import 'routes/routes.zen.dart';

void main() {
  runApp(const MyApp());
}

final coordinator = AppCoordinator();

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'ZenRouter File-Based Routing Example',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.indigo),
        useMaterial3: true,
      ),
      routerDelegate: coordinator.routerDelegate,
      routeInformationParser: coordinator.routeInformationParser,
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth).forgot-password.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part '(auth).forgot-password.g.dart';

/// Example of route group using dot notation.
///
/// URL: /forgot-password (not /(auth)/forgot-password)
///
/// This route is wrapped by the (auth)/_layout.dart layout
/// but the (auth) segment is not part of the URL.
///
/// Equivalent to: (auth)/forgot-password.dart
@ZenRoute()
class ForgotPasswordRoute extends _$ForgotPasswordRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Forgot Password')),
      body: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.lock_reset, size: 64, color: Colors.blue),
            const SizedBox(height: 24),
            const Text(
              'Enter your email to reset password',
              style: TextStyle(fontSize: 18),
            ),
            const SizedBox(height: 16),
            const TextField(
              decoration: InputDecoration(
                labelText: 'Email',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () => coordinator.pushLogin(),
              child: const Text('Send Reset Link'),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth).forgot-password.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '(auth).forgot-password.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ForgotPasswordRoute.
///
/// URI: /forgot-password
abstract class _$ForgotPasswordRoute extends AppRoute {
  _$ForgotPasswordRoute();

  @override
  Uri toUri() => Uri.parse('/forgot-password');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/_coordinator.dart
================================================
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

@ZenCoordinator(
  name: 'AppCoordinator',
  routeBase: 'AppRoute',
  routeBasePath: '_route.dart',
  deferredImport: true,
)
class CoordinatorConfig {}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/_route.dart
================================================
import 'package:zenrouter/zenrouter.dart';

abstract class AppRoute extends RouteTarget with RouteUnique {}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/about.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'about.g.dart';

/// About route at /about
@ZenRoute()
class AboutRoute extends _$AboutRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('About')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Text('About Page'),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Go Back'),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/about.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'about.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for AboutRoute.
///
/// URI: /about
abstract class _$AboutRoute extends AppRoute {
  _$AboutRoute();

  @override
  Uri toUri() => Uri.parse('/about');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/blog.[...slugs].dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'blog.[...slugs].g.dart';

/// Example of catch-all route using dot notation.
///
/// Matches paths like:
/// - /blog/2024/01/my-post
/// - /blog/tutorials/flutter/basics
///
/// Equivalent to: blog/[...slugs]/index.dart
@ZenRoute()
class BlogSlugsRoute extends _$BlogSlugsRoute {
  BlogSlugsRoute({required super.slugs});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Blog Post')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Path: /blog/${slugs.join("/")}'),
            const SizedBox(height: 16),
            Text('Segments: ${slugs.length}'),
            const SizedBox(height: 8),
            ...slugs.map((s) => Text('- $s')),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/blog.[...slugs].g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'blog.[...slugs].dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for BlogSlugsRoute.
///
/// URI: /blog/...:slugs
abstract class _$BlogSlugsRoute extends AppRoute {
  /// Dynamic parameter from path segment.
  final List<String> slugs;

  _$BlogSlugsRoute({required this.slugs});

  @override
  Uri toUri() => Uri.parse('/blog/${slugs.join('/')}');

  @override
  List<Object?> get props => [slugs];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/collection.list.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'collection.list.g.dart';

/// Demonstrates advanced routing capabilities including dot-notation file naming
/// and reactive query parameter handling.
///
/// This route uses the [RouteQueryParameters] mixin to enable granular rebuilds
/// when specific query parameters change, optimizing performance for complex
/// filter/sort/pagination scenarios.
///
/// File naming convention:
/// `collection.list.dart` automatically maps to the route path `/collection/list`.
@ZenRoute(queries: ['page', 'sortOrder', 'filter'])
class CollectionListRoute extends _$CollectionListRoute {
  CollectionListRoute({super.queries = const {}});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          spacing: 16,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Current URL display
            selectorBuilder(
              selector: (value) => value,
              builder: (context, value) => Card(
                child: Padding(
                  padding: const EdgeInsets.all(12),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Current URL:',
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        toUri().toString(),
                        style: const TextStyle(fontFamily: 'monospace'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
            // Pagination controls
            const Text(
              'Pagination',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            pageBuilder(
              selector: (page) => int.tryParse(query('page') ?? '1') ?? 1,
              builder: (context, currentPage) => Row(
                children: [
                  ElevatedButton(
                    onPressed: currentPage > 1
                        ? () => updateQueries(
                            coordinator,
                            queries: {...queries, 'page': '${currentPage - 1}'},
                          )
                        : null,
                    child: const Text('← Prev'),
                  ),
                  Padding(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    child: Text('Page $currentPage'),
                  ),
                  ElevatedButton(
                    onPressed: () => updateQueries(
                      coordinator,
                      queries: {...queries, 'page': '${currentPage + 1}'},
                    ),
                    child: const Text('Next →'),
                  ),
                ],
              ),
            ),
          ],
        ),
      ), // End of ListenableBuilder
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/collection.list.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'collection.list.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for CollectionListRoute.
///
/// URI: /collection/list
abstract class _$CollectionListRoute extends AppRoute
    with RouteQueryParameters {
  @override
  late final ValueNotifier<Map<String, String>> queryNotifier;

  _$CollectionListRoute({Map<String, String> queries = const {}})
    : queryNotifier = ValueNotifier(queries);

  @override
  Uri toUri() {
    final uri = Uri.parse('/collection/list');
    if (queries.isEmpty) return uri;
    return uri.replace(queryParameters: queries);
  }

  @override
  List<Object?> get props => [];

  Widget pageBuilder<T>({
    required T Function(String? page) selector,
    required Widget Function(BuildContext, T page) builder,
  }) => selectorBuilder<T>(
    selector: (queries) => selector(queries['page']),
    builder: (context, page) => builder(context, page),
  );

  Widget sortOrderBuilder<T>({
    required T Function(String? sortOrder) selector,
    required Widget Function(BuildContext, T sortOrder) builder,
  }) => selectorBuilder<T>(
    selector: (queries) => selector(queries['sortOrder']),
    builder: (context, sortOrder) => builder(context, sortOrder),
  );

  Widget filterBuilder<T>({
    required T Function(String? filter) selector,
    required Widget Function(BuildContext, T filter) builder,
  }) => selectorBuilder<T>(
    selector: (queries) => selector(queries['filter']),
    builder: (context, filter) => builder(context, filter),
  );
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/index.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'index.g.dart';

/// Home route at /
@ZenRoute()
class IndexRoute extends _$IndexRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home')),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text('Welcome to ZenRouter File-based Routing!'),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: () => coordinator.pushAbout(),
                child: const Text('Go to About'),
              ),
              const SizedBox(height: 12),
              ElevatedButton(
                onPressed: () =>
                    coordinator.pushProfileId(profileId: 'user-123'),
                child: const Text('Go to Profile'),
              ),
              const SizedBox(height: 12),
              ElevatedButton(
                onPressed: () => coordinator.pushFollowing(),
                child: const Text('Go to Tabs'),
              ),
              const SizedBox(height: 12),
              ElevatedButton(
                onPressed: () => coordinator.recoverForYouSheet(),
                child: const Text('Go to For you sheets'),
              ),
              const SizedBox(height: 24),
              // Dot Notation Demo
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.teal.shade50,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.teal.shade200),
                ),
                child: Column(
                  children: [
                    const Text(
                      'Dot Notation Demo',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Colors.teal,
                      ),
                    ),
                    const SizedBox(height: 8),
                    const Text(
                      'Routes defined using dots instead of folders\n'
                      'e.g., blog.[...slugs].dart → /blog/*',
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 12, color: Colors.grey),
                    ),
                    const SizedBox(height: 12),
                    ElevatedButton.icon(
                      onPressed: () => coordinator.pushBlogSlugs(
                        slugs: ['2024', '12', 'hello-world'],
                      ),
                      icon: const Icon(Icons.article),
                      label: const Text('Blog Post (catch-all)'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.teal,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: () =>
                          coordinator.pushShopProductsProductIdReviews(
                            productId: 'prod-456',
                          ),
                      icon: const Icon(Icons.reviews),
                      label: const Text('Product Reviews'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.teal,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: () => coordinator.pushSettingsAccountIndex(),
                      icon: const Icon(Icons.settings),
                      label: const Text('Account Settings'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.teal,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: () => coordinator.pushForgotPassword(),
                      icon: const Icon(Icons.lock_reset),
                      label: const Text('Forgot Password'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.teal,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: () => coordinator.pushCollectionList(),
                      icon: const Icon(Icons.collections),
                      label: const Text('Collections (hybrid)'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.teal,
                        foregroundColor: Colors.white,
                      ),
                    ),
                  ],
                ),
              ),
              Container(
                margin: EdgeInsets.only(top: 16),
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: Colors.purple.shade50,
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(color: Colors.purple.shade200),
                ),
                child: Column(
                  children: [
                    const Text(
                      'Route Groups Demo',
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: Colors.purple,
                      ),
                    ),
                    const SizedBox(height: 8),
                    const Text(
                      'Routes in (auth) folder are wrapped by AuthLayout\n'
                      'but the URL does NOT include "(auth)"',
                      textAlign: TextAlign.center,
                      style: TextStyle(fontSize: 12, color: Colors.grey),
                    ),
                    const SizedBox(height: 12),
                    ElevatedButton.icon(
                      onPressed: () => coordinator.pushLogin(),
                      icon: const Icon(Icons.login),
                      label: const Text('Go to Login (/login)'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.purple,
                        foregroundColor: Colors.white,
                      ),
                    ),
                    const SizedBox(height: 8),
                    ElevatedButton.icon(
                      onPressed: () => coordinator.pushRegister(),
                      icon: const Icon(Icons.person_add),
                      label: const Text('Go to Register (/register)'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.purple,
                        foregroundColor: Colors.white,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for IndexRoute.
///
/// URI: /
abstract class _$IndexRoute extends AppRoute {
  _$IndexRoute();

  @override
  Uri toUri() => Uri.parse('/');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/not_found.dart
================================================
import 'package:flutter/material.dart';

import 'routes.zen.dart';

/// Custom NotFoundRoute example.
///
/// To use a custom NotFoundRoute:
/// 1. Create a file named `not_found.dart` in your `lib/routes/` directory
/// 2. Create a class named `NotFoundRoute` that extends `AppRoute`
/// 3. Implement the required constructor: `NotFoundRoute({required this.uri, this.queries = const {}})`
/// 4. Implement the required methods: `toUri()`, `props`, and `build()`
///
/// The generator will automatically detect and use your custom NotFoundRoute
/// instead of generating the default one.
class NotFoundRoute extends AppRoute {
  final Uri uri;
  final Map<String, String> queries;

  NotFoundRoute({required this.uri, this.queries = const {}});

  /// Get a query parameter by name.
  /// Returns null if the parameter is not present.
  String? query(String name) => queries[name];

  @override
  Uri toUri() => Uri.parse('/not-found');

  @override
  List<Object?> get props => [uri, queries];

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('404 - Page Not Found'),
        backgroundColor: Colors.red,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 80, color: Colors.red),
            const SizedBox(height: 24),
            const Text(
              'Oops! Page not found',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              'The route "${uri.path}" does not exist.',
              style: const TextStyle(fontSize: 16),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              onPressed: () => coordinator.recoverRouteFromUri(Uri.parse('/')),
              icon: const Icon(Icons.arrow_back),
              label: const Text('Go Home'),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/routes.zen.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint

import 'package:flutter/widgets.dart';
import 'package:zenrouter/zenrouter.dart';
import '_route.dart';

import '(auth).forgot-password.dart' deferred as _auth_forgotpassword;
import '(auth)/_layout.dart';
import '(auth)/login.dart' deferred as _auth_login;
import '(auth)/register.dart' deferred as _auth_register;
import 'about.dart' deferred as about;
import 'blog.[...slugs].dart' deferred as blog___slugs;
import 'collection.list.dart' deferred as collection_list;
import 'index.dart' deferred as index;
import 'not_found.dart';
import 'profile/[profileId]/index.dart' deferred as profile__profileId_index;
import 'profile/general.dart' deferred as profile_general;
import 'settings.account.index.dart' deferred as settings_account_index;
import 'shop.products.[productId].reviews.dart'
    deferred as shop_products__productId_reviews;
import 'tabs/_layout.dart';
import 'tabs/feed/_layout.dart';
import 'tabs/feed/following/[...slugs]/[id].dart'
    deferred as tabs_feed_following___slugs__id;
import 'tabs/feed/following/[...slugs]/about.dart'
    deferred as tabs_feed_following___slugs_about;
import 'tabs/feed/following/[...slugs]/index.dart'
    deferred as tabs_feed_following___slugs_index;
import 'tabs/feed/following/[postId].dart'
    deferred as tabs_feed_following__postId;
import 'tabs/feed/following/_layout.dart';
import 'tabs/feed/following/index.dart' deferred as tabs_feed_following_index;
import 'tabs/feed/for-you/_layout.dart';
import 'tabs/feed/for-you/index.dart' deferred as tabs_feed_foryou_index;
import 'tabs/feed/for-you/sheet.dart' deferred as tabs_feed_foryou_sheet;
import 'tabs/profile.dart';
import 'tabs/settings.dart';

export 'package:zenrouter/zenrouter.dart';
export '(auth)/_layout.dart';
export 'not_found.dart';
export 'tabs/_layout.dart';
export 'tabs/feed/_layout.dart';
export 'tabs/feed/following/_layout.dart';
export 'tabs/feed/for-you/_layout.dart';
export 'tabs/profile.dart';
export 'tabs/settings.dart';
export '_route.dart';

/// Generated coordinator managing all routes.
class AppCoordinator extends Coordinator<AppRoute> {
  late final authPath = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'Auth',
  )..bindLayout(AuthLayout.new);
  late final tabsPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'Tabs',
    [FeedTabLayout(), TabProfileRoute(), TabSettingsRoute()],
  )..bindLayout(TabsLayout.new);
  late final feedTabPath = IndexedStackPath<AppRoute>.createWith(
    coordinator: this,
    label: 'FeedTab',
    [FollowingLayout(), ForYouLayout()],
  )..bindLayout(FeedTabLayout.new);
  late final followingPath = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'Following',
  )..bindLayout(FollowingLayout.new);
  late final forYouPath = NavigationPath<AppRoute>.createWith(
    coordinator: this,
    label: 'ForYou',
  )..bindLayout(ForYouLayout.new);

  @override
  List<StackPath> get paths => [
    ...super.paths,
    authPath,
    tabsPath,
    feedTabPath,
    followingPath,
    forYouPath,
  ];

  @override
  Future<AppRoute> parseRouteFromUri(Uri uri) async {
    return switch (uri.pathSegments) {
      [] => await () async {
        await index.loadLibrary();
        return index.IndexRoute();
      }(),
      ['tabs', 'feed', 'for-you', 'sheet'] => await () async {
        await tabs_feed_foryou_sheet.loadLibrary();
        return tabs_feed_foryou_sheet.ForYouSheetRoute();
      }(),
      ['shop', 'products', final productId, 'reviews'] => await () async {
        await shop_products__productId_reviews.loadLibrary();
        return shop_products__productId_reviews.ShopProductsProductIdReviewsRoute(
          productId: productId,
        );
      }(),
      ['tabs', 'feed', 'following', final postId] => await () async {
        await tabs_feed_following__postId.loadLibrary();
        return tabs_feed_following__postId.FeedPostRoute(postId: postId);
      }(),
      ['tabs', 'feed', 'following'] => await () async {
        await tabs_feed_following_index.loadLibrary();
        return tabs_feed_following_index.FollowingRoute();
      }(),
      ['tabs', 'feed', 'for-you'] => await () async {
        await tabs_feed_foryou_index.loadLibrary();
        return tabs_feed_foryou_index.ForYouRoute(queries: uri.queryParameters);
      }(),
      ['collection', 'list'] => await () async {
        await collection_list.loadLibrary();
        return collection_list.CollectionListRoute(
          queries: uri.queryParameters,
        );
      }(),
      ['profile', 'general'] => await () async {
        await profile_general.loadLibrary();
        return profile_general.ProfileGeneralRoute();
      }(),
      ['settings', 'account'] => await () async {
        await settings_account_index.loadLibrary();
        return settings_account_index.SettingsAccountIndexRoute();
      }(),
      ['tabs', 'profile'] => TabProfileRoute(),
      ['tabs', 'settings'] => TabSettingsRoute(),
      ['profile', final profileId] => await () async {
        await profile__profileId_index.loadLibrary();
        return profile__profileId_index.ProfileIdRoute(profileId: profileId);
      }(),
      ['forgot-password'] => await () async {
        await _auth_forgotpassword.loadLibrary();
        return _auth_forgotpassword.ForgotPasswordRoute();
      }(),
      ['login'] => await () async {
        await _auth_login.loadLibrary();
        return _auth_login.LoginRoute();
      }(),
      ['register'] => await () async {
        await _auth_register.loadLibrary();
        return _auth_register.RegisterRoute();
      }(),
      ['about'] => await () async {
        await about.loadLibrary();
        return about.AboutRoute();
      }(),
      ['tabs', 'feed', 'following', ...final slugs, 'about'] => await () async {
        await tabs_feed_following___slugs_about.loadLibrary();
        return tabs_feed_following___slugs_about.FeedDynamicAboutRoute(
          slugs: slugs,
        );
      }(),
      ['tabs', 'feed', 'following', ...final slugs, final id] =>
        await () async {
          await tabs_feed_following___slugs__id.loadLibrary();
          return tabs_feed_following___slugs__id.FeedDynamicIdRoute(
            slugs: slugs,
            id: id,
          );
        }(),
      ['tabs', 'feed', 'following', ...final slugs] => await () async {
        await tabs_feed_following___slugs_index.loadLibrary();
        return tabs_feed_following___slugs_index.FeedDynamicRoute(slugs: slugs);
      }(),
      ['blog', ...final slugs] => await () async {
        await blog___slugs.loadLibrary();
        return blog___slugs.BlogSlugsRoute(slugs: slugs);
      }(),
      _ => NotFoundRoute(uri: uri, queries: uri.queryParameters),
    };
  }

  @override
  Widget layoutBuilder(BuildContext context) {
    return AppCoordinatorProvider(
      coordinator: this,
      child: super.layoutBuilder(context),
    );
  }
}

/// Type-safe navigation extension methods.
extension AppCoordinatorNav on AppCoordinator {
  Future<T?> pushForgotPassword<T extends Object>() async =>
      push(await () async {
        await _auth_forgotpassword.loadLibrary();
        return _auth_forgotpassword.ForgotPasswordRoute();
      }());
  Future<void> replaceForgotPassword() async => replace(await () async {
    await _auth_forgotpassword.loadLibrary();
    return _auth_forgotpassword.ForgotPasswordRoute();
  }());
  Future<void> recoverForgotPassword() async => recover(await () async {
    await _auth_forgotpassword.loadLibrary();
    return _auth_forgotpassword.ForgotPasswordRoute();
  }());
  Future<T?> pushLogin<T extends Object>() async => push(await () async {
    await _auth_login.loadLibrary();
    return _auth_login.LoginRoute();
  }());
  Future<void> replaceLogin() async => replace(await () async {
    await _auth_login.loadLibrary();
    return _auth_login.LoginRoute();
  }());
  Future<void> recoverLogin() async => recover(await () async {
    await _auth_login.loadLibrary();
    return _auth_login.LoginRoute();
  }());
  Future<T?> pushRegister<T extends Object>() async => push(await () async {
    await _auth_register.loadLibrary();
    return _auth_register.RegisterRoute();
  }());
  Future<void> replaceRegister() async => replace(await () async {
    await _auth_register.loadLibrary();
    return _auth_register.RegisterRoute();
  }());
  Future<void> recoverRegister() async => recover(await () async {
    await _auth_register.loadLibrary();
    return _auth_register.RegisterRoute();
  }());
  Future<T?> pushAbout<T extends Object>() async => push(await () async {
    await about.loadLibrary();
    return about.AboutRoute();
  }());
  Future<void> replaceAbout() async => replace(await () async {
    await about.loadLibrary();
    return about.AboutRoute();
  }());
  Future<void> recoverAbout() async => recover(await () async {
    await about.loadLibrary();
    return about.AboutRoute();
  }());
  Future<T?> pushBlogSlugs<T extends Object>({
    required List<String> slugs,
  }) async => push(await () async {
    await blog___slugs.loadLibrary();
    return blog___slugs.BlogSlugsRoute(slugs: slugs);
  }());
  Future<void> replaceBlogSlugs({required List<String> slugs}) async =>
      replace(await () async {
        await blog___slugs.loadLibrary();
        return blog___slugs.BlogSlugsRoute(slugs: slugs);
      }());
  Future<void> recoverBlogSlugs({required List<String> slugs}) async =>
      recover(await () async {
        await blog___slugs.loadLibrary();
        return blog___slugs.BlogSlugsRoute(slugs: slugs);
      }());
  Future<T?> pushCollectionList<T extends Object>({
    Map<String, String> queries = const {},
  }) async => push(await () async {
    await collection_list.loadLibrary();
    return collection_list.CollectionListRoute(queries: queries);
  }());
  Future<void> replaceCollectionList({
    Map<String, String> queries = const {},
  }) async => replace(await () async {
    await collection_list.loadLibrary();
    return collection_list.CollectionListRoute(queries: queries);
  }());
  Future<void> recoverCollectionList({
    Map<String, String> queries = const {},
  }) async => recover(await () async {
    await collection_list.loadLibrary();
    return collection_list.CollectionListRoute(queries: queries);
  }());
  Future<T?> pushIndex<T extends Object>() async => push(await () async {
    await index.loadLibrary();
    return index.IndexRoute();
  }());
  Future<void> replaceIndex() async => replace(await () async {
    await index.loadLibrary();
    return index.IndexRoute();
  }());
  Future<void> recoverIndex() async => recover(await () async {
    await index.loadLibrary();
    return index.IndexRoute();
  }());
  Future<T?> pushProfileId<T extends Object>({
    required String profileId,
  }) async => push(await () async {
    await profile__profileId_index.loadLibrary();
    return profile__profileId_index.ProfileIdRoute(profileId: profileId);
  }());
  Future<void> replaceProfileId({required String profileId}) async =>
      replace(await () async {
        await profile__profileId_index.loadLibrary();
        return profile__profileId_index.ProfileIdRoute(profileId: profileId);
      }());
  Future<void> recoverProfileId({required String profileId}) async =>
      recover(await () async {
        await profile__profileId_index.loadLibrary();
        return profile__profileId_index.ProfileIdRoute(profileId: profileId);
      }());
  Future<T?> pushProfileGeneral<T extends Object>() async =>
      push(await () async {
        await profile_general.loadLibrary();
        return profile_general.ProfileGeneralRoute();
      }());
  Future<void> replaceProfileGeneral() async => replace(await () async {
    await profile_general.loadLibrary();
    return profile_general.ProfileGeneralRoute();
  }());
  Future<void> recoverProfileGeneral() async => recover(await () async {
    await profile_general.loadLibrary();
    return profile_general.ProfileGeneralRoute();
  }());
  Future<T?> pushSettingsAccountIndex<T extends Object>() async =>
      push(await () async {
        await settings_account_index.loadLibrary();
        return settings_account_index.SettingsAccountIndexRoute();
      }());
  Future<void> replaceSettingsAccountIndex() async => replace(await () async {
    await settings_account_index.loadLibrary();
    return settings_account_index.SettingsAccountIndexRoute();
  }());
  Future<void> recoverSettingsAccountIndex() async => recover(await () async {
    await settings_account_index.loadLibrary();
    return settings_account_index.SettingsAccountIndexRoute();
  }());
  Future<T?> pushShopProductsProductIdReviews<T extends Object>({
    required String productId,
  }) async => push(await () async {
    await shop_products__productId_reviews.loadLibrary();
    return shop_products__productId_reviews.ShopProductsProductIdReviewsRoute(
      productId: productId,
    );
  }());
  Future<void> replaceShopProductsProductIdReviews({
    required String productId,
  }) async => replace(await () async {
    await shop_products__productId_reviews.loadLibrary();
    return shop_products__productId_reviews.ShopProductsProductIdReviewsRoute(
      productId: productId,
    );
  }());
  Future<void> recoverShopProductsProductIdReviews({
    required String productId,
  }) async => recover(await () async {
    await shop_products__productId_reviews.loadLibrary();
    return shop_products__productId_reviews.ShopProductsProductIdReviewsRoute(
      productId: productId,
    );
  }());
  Future<T?> pushFeedDynamicId<T extends Object>({
    required List<String> slugs,
    required String id,
  }) async => push(await () async {
    await tabs_feed_following___slugs__id.loadLibrary();
    return tabs_feed_following___slugs__id.FeedDynamicIdRoute(
      slugs: slugs,
      id: id,
    );
  }());
  Future<void> replaceFeedDynamicId({
    required List<String> slugs,
    required String id,
  }) async => replace(await () async {
    await tabs_feed_following___slugs__id.loadLibrary();
    return tabs_feed_following___slugs__id.FeedDynamicIdRoute(
      slugs: slugs,
      id: id,
    );
  }());
  Future<void> recoverFeedDynamicId({
    required List<String> slugs,
    required String id,
  }) async => recover(await () async {
    await tabs_feed_following___slugs__id.loadLibrary();
    return tabs_feed_following___slugs__id.FeedDynamicIdRoute(
      slugs: slugs,
      id: id,
    );
  }());
  Future<T?> pushFeedDynamicAbout<T extends Object>({
    required List<String> slugs,
  }) async => push(await () async {
    await tabs_feed_following___slugs_about.loadLibrary();
    return tabs_feed_following___slugs_about.FeedDynamicAboutRoute(
      slugs: slugs,
    );
  }());
  Future<void> replaceFeedDynamicAbout({required List<String> slugs}) async =>
      replace(await () async {
        await tabs_feed_following___slugs_about.loadLibrary();
        return tabs_feed_following___slugs_about.FeedDynamicAboutRoute(
          slugs: slugs,
        );
      }());
  Future<void> recoverFeedDynamicAbout({required List<String> slugs}) async =>
      recover(await () async {
        await tabs_feed_following___slugs_about.loadLibrary();
        return tabs_feed_following___slugs_about.FeedDynamicAboutRoute(
          slugs: slugs,
        );
      }());
  Future<T?> pushFeedDynamic<T extends Object>({
    required List<String> slugs,
  }) async => push(await () async {
    await tabs_feed_following___slugs_index.loadLibrary();
    return tabs_feed_following___slugs_index.FeedDynamicRoute(slugs: slugs);
  }());
  Future<void> replaceFeedDynamic({required List<String> slugs}) async =>
      replace(await () async {
        await tabs_feed_following___slugs_index.loadLibrary();
        return tabs_feed_following___slugs_index.FeedDynamicRoute(slugs: slugs);
      }());
  Future<void> recoverFeedDynamic({required List<String> slugs}) async =>
      recover(await () async {
        await tabs_feed_following___slugs_index.loadLibrary();
        return tabs_feed_following___slugs_index.FeedDynamicRoute(slugs: slugs);
      }());
  Future<T?> pushFeedPost<T extends Object>({required String postId}) async =>
      push(await () async {
        await tabs_feed_following__postId.loadLibrary();
        return tabs_feed_following__postId.FeedPostRoute(postId: postId);
      }());
  Future<void> replaceFeedPost({required String postId}) async =>
      replace(await () async {
        await tabs_feed_following__postId.loadLibrary();
        return tabs_feed_following__postId.FeedPostRoute(postId: postId);
      }());
  Future<void> recoverFeedPost({required String postId}) async =>
      recover(await () async {
        await tabs_feed_following__postId.loadLibrary();
        return tabs_feed_following__postId.FeedPostRoute(postId: postId);
      }());
  Future<T?> pushFollowing<T extends Object>() async => push(await () async {
    await tabs_feed_following_index.loadLibrary();
    return tabs_feed_following_index.FollowingRoute();
  }());
  Future<void> replaceFollowing() async => replace(await () async {
    await tabs_feed_following_index.loadLibrary();
    return tabs_feed_following_index.FollowingRoute();
  }());
  Future<void> recoverFollowing() async => recover(await () async {
    await tabs_feed_following_index.loadLibrary();
    return tabs_feed_following_index.FollowingRoute();
  }());
  Future<T?> pushForYou<T extends Object>({
    Map<String, String> queries = const {},
  }) async => push(await () async {
    await tabs_feed_foryou_index.loadLibrary();
    return tabs_feed_foryou_index.ForYouRoute(queries: queries);
  }());
  Future<void> replaceForYou({Map<String, String> queries = const {}}) async =>
      replace(await () async {
        await tabs_feed_foryou_index.loadLibrary();
        return tabs_feed_foryou_index.ForYouRoute(queries: queries);
      }());
  Future<void> recoverForYou({Map<String, String> queries = const {}}) async =>
      recover(await () async {
        await tabs_feed_foryou_index.loadLibrary();
        return tabs_feed_foryou_index.ForYouRoute(queries: queries);
      }());
  Future<T?> pushForYouSheet<T extends Object>() async => push(await () async {
    await tabs_feed_foryou_sheet.loadLibrary();
    return tabs_feed_foryou_sheet.ForYouSheetRoute();
  }());
  Future<void> replaceForYouSheet() async => replace(await () async {
    await tabs_feed_foryou_sheet.loadLibrary();
    return tabs_feed_foryou_sheet.ForYouSheetRoute();
  }());
  Future<void> recoverForYouSheet() async => recover(await () async {
    await tabs_feed_foryou_sheet.loadLibrary();
    return tabs_feed_foryou_sheet.ForYouSheetRoute();
  }());
  Future<T?> pushTabProfile<T extends Object>() => push(TabProfileRoute());
  Future<void> replaceTabProfile() => replace(TabProfileRoute());
  Future<void> recoverTabProfile() => recover(TabProfileRoute());
  Future<T?> pushTabSettings<T extends Object>() => push(TabSettingsRoute());
  Future<void> replaceTabSettings() => replace(TabSettingsRoute());
  Future<void> recoverTabSettings() => recover(TabSettingsRoute());
}

/// InheritedWidget provider for accessing the coordinator from the widget tree.
class AppCoordinatorProvider extends InheritedWidget {
  const AppCoordinatorProvider({
    required this.coordinator,
    required super.child,
    super.key,
  });

  /// Retrieves the [AppCoordinator] from the widget tree.
  static AppCoordinator of(BuildContext context) => context
      .dependOnInheritedWidgetOfExactType<AppCoordinatorProvider>()!
      .coordinator;

  final AppCoordinator coordinator;

  @override
  bool updateShouldNotify(AppCoordinatorProvider oldWidget) =>
      coordinator != oldWidget.coordinator;
}

/// Extension on [BuildContext] for convenient coordinator access.
extension AppCoordinatorGetter on BuildContext {
  /// Access the [AppCoordinator] from the widget tree.
  AppCoordinator get appCoordinator => AppCoordinatorProvider.of(this);
}

/// Extension on [AppRoute] for navigation methods.
extension AppCoordinatorNavContext on AppRoute {
  Future<void> navigate(BuildContext context) =>
      context.appCoordinator.navigate(this);
  Future<T?> push<T extends Object>(BuildContext context) =>
      context.appCoordinator.push<T>(this);
  Future<void> replace(BuildContext context) =>
      context.appCoordinator.replace(this);
  Future<void> recover(BuildContext context) =>
      context.appCoordinator.recover(this);
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/settings.account.index.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'settings.account.index.g.dart';

/// Example of index route using dot notation.
///
/// URL: /settings/account (index route at /settings/account level)
///
/// Equivalent to: settings/account/index.dart
@ZenRoute()
class SettingsAccountIndexRoute extends _$SettingsAccountIndexRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Account Settings')),
      body: ListView(
        children: [
          ListTile(
            leading: const Icon(Icons.person),
            title: const Text('Profile Information'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.email),
            title: const Text('Email Preferences'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.security),
            title: const Text('Security'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {},
          ),
          ListTile(
            leading: const Icon(Icons.delete, color: Colors.red),
            title: const Text(
              'Delete Account',
              style: TextStyle(color: Colors.red),
            ),
            onTap: () {},
          ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/settings.account.index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'settings.account.index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for SettingsAccountIndexRoute.
///
/// URI: /settings/account
abstract class _$SettingsAccountIndexRoute extends AppRoute {
  _$SettingsAccountIndexRoute();

  @override
  Uri toUri() => Uri.parse('/settings/account');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/shop.products.[productId].reviews.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import 'routes.zen.dart';

part 'shop.products.[productId].reviews.g.dart';

/// Example of nested route using dot notation.
///
/// URL: /shop/products/:productId/reviews
///
/// Equivalent to: shop/products/[productId]/reviews.dart
@ZenRoute()
class ShopProductsProductIdReviewsRoute
    extends _$ShopProductsProductIdReviewsRoute {
  ShopProductsProductIdReviewsRoute({required super.productId});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Reviews for Product $productId')),
      body: ListView(
        children: [
          ListTile(
            leading: const Icon(Icons.star, color: Colors.amber),
            title: const Text('Great product!'),
            subtitle: Text('Product ID: $productId'),
          ),
          const ListTile(
            leading: Icon(Icons.star, color: Colors.amber),
            title: Text('Highly recommended'),
            subtitle: Text('5 stars'),
          ),
          const ListTile(
            leading: Icon(Icons.star_half, color: Colors.amber),
            title: Text('Good but could be better'),
            subtitle: Text('3.5 stars'),
          ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/shop.products.[productId].reviews.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'shop.products.[productId].reviews.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ShopProductsProductIdReviewsRoute.
///
/// URI: /shop/products/:productId/reviews
abstract class _$ShopProductsProductIdReviewsRoute extends AppRoute {
  /// Dynamic parameter from path segment.
  final String productId;

  _$ShopProductsProductIdReviewsRoute({required this.productId});

  @override
  Uri toUri() => Uri.parse('/shop/products/$productId/reviews');

  @override
  List<Object?> get props => [productId];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth)/_layout.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part '_layout.g.dart';

/// Auth layout - wraps login and register routes.
///
/// This layout is in a route group folder `(auth)`, which means:
/// - Routes inside are wrapped by this layout
/// - The URL path does NOT include `(auth)` segment
///
/// Example:
/// - `(auth)/login.dart` → URL: `/login`
/// - `(auth)/register.dart` → URL: `/register`
@ZenLayout(type: LayoutType.stack)
class AuthLayout extends _$AuthLayout {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: Container(
        decoration: const BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [Color(0xFF6B5CE7), Color(0xFF9B8DFF)],
          ),
        ),
        child: SafeArea(
          child: Column(
            children: [
              // Auth header
              const Padding(
                padding: EdgeInsets.all(24.0),
                child: Column(
                  children: [
                    Icon(Icons.lock_outline, size: 64, color: Colors.white),
                    SizedBox(height: 16),
                    Text(
                      'Welcome',
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    SizedBox(height: 8),
                    Text(
                      'Sign in or create an account',
                      style: TextStyle(fontSize: 16, color: Colors.white70),
                    ),
                  ],
                ),
              ),
              // Auth content (nested routes)
              Expanded(
                child: Container(
                  decoration: const BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.vertical(
                      top: Radius.circular(32),
                    ),
                  ),
                  child: ClipRRect(
                    borderRadius: const BorderRadius.vertical(
                      top: Radius.circular(32),
                    ),
                    child: buildPath(coordinator),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth)/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for AuthLayout.
///
/// URI: /
/// Path type: stack
abstract class _$AuthLayout extends AppRoute with RouteLayout<AppRoute> {
  _$AuthLayout();

  @override
  NavigationPath<AppRoute> resolvePath(covariant AppCoordinator coordinator) =>
      coordinator.authPath;

  @override
  Uri toUri() => Uri.parse('/');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth)/login.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part 'login.g.dart';

/// Login route at /login
///
/// This route is inside the `(auth)` route group folder, so:
/// - It's wrapped by AuthLayout
/// - But the URL is `/login` (not `/(auth)/login`)
@ZenRoute()
class LoginRoute extends _$LoginRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          const Text(
            'Sign In',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 32),
          TextField(
            decoration: InputDecoration(
              labelText: 'Email',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              prefixIcon: const Icon(Icons.email_outlined),
            ),
          ),
          const SizedBox(height: 16),
          TextField(
            obscureText: true,
            decoration: InputDecoration(
              labelText: 'Password',
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
              ),
              prefixIcon: const Icon(Icons.lock_outlined),
            ),
          ),
          const SizedBox(height: 24),
          FilledButton(
            onPressed: () => coordinator.replaceIndex(),
            style: FilledButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 16),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
            child: const Text('Sign In', style: TextStyle(fontSize: 16)),
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text("Don't have an account?"),
              TextButton(
                onPressed: () => coordinator.pushRegister(),
                child: const Text('Sign Up'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth)/login.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'login.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for LoginRoute.
///
/// URI: /login
/// Layout: AuthLayout
abstract class _$LoginRoute extends AppRoute {
  _$LoginRoute();

  @override
  Type? get layout => AuthLayout;

  @override
  Uri toUri() => Uri.parse('/login');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth)/register.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part 'register.g.dart';

/// Register route at /register
///
/// This route is inside the `(auth)` route group folder, so:
/// - It's wrapped by AuthLayout
/// - But the URL is `/register` (not `/(auth)/register`)
@ZenRoute()
class RegisterRoute extends _$RegisterRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: SingleChildScrollView(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const Text(
              'Create Account',
              style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            TextField(
              decoration: InputDecoration(
                labelText: 'Full Name',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                prefixIcon: const Icon(Icons.person_outlined),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              decoration: InputDecoration(
                labelText: 'Email',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              obscureText: true,
              decoration: InputDecoration(
                labelText: 'Password',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                prefixIcon: const Icon(Icons.lock_outlined),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              obscureText: true,
              decoration: InputDecoration(
                labelText: 'Confirm Password',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
                prefixIcon: const Icon(Icons.lock_outlined),
              ),
            ),
            const SizedBox(height: 24),
            FilledButton(
              onPressed: () => coordinator.replaceIndex(),
              style: FilledButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: const Text(
                'Create Account',
                style: TextStyle(fontSize: 16),
              ),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text('Already have an account?'),
                TextButton(
                  onPressed: () => coordinator.pop(),
                  child: const Text('Sign In'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/(auth)/register.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'register.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for RegisterRoute.
///
/// URI: /register
/// Layout: AuthLayout
abstract class _$RegisterRoute extends AppRoute {
  _$RegisterRoute();

  @override
  Type? get layout => AuthLayout;

  @override
  Uri toUri() => Uri.parse('/register');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/profile/general.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

part 'general.g.dart';

@ZenRoute()
class ProfileGeneralRoute extends _$ProfileGeneralRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(appBar: AppBar(title: Text('Profile General')));
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/profile/general.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'general.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ProfileGeneralRoute.
///
/// URI: /profile/general
abstract class _$ProfileGeneralRoute extends AppRoute {
  _$ProfileGeneralRoute();

  @override
  Uri toUri() => Uri.parse('/profile/general');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/profile/[profileId]/index.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../../routes.zen.dart';

part 'index.g.dart';

/// Profile route at /profile/:id
@ZenRoute()
class ProfileIdRoute extends _$ProfileIdRoute {
  ProfileIdRoute({required super.profileId});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Profile: $profileId')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          spacing: 8,
          children: [
            Text('User ID: $profileId', style: const TextStyle(fontSize: 24)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Go Back'),
            ),
            ElevatedButton(
              onPressed: () {},
              child: const Text('Go to Collections'),
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/profile/[profileId]/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ProfileIdRoute.
///
/// URI: /profile/:profileId
abstract class _$ProfileIdRoute extends AppRoute {
  /// Dynamic parameter from path segment.
  final String profileId;

  _$ProfileIdRoute({required this.profileId});

  @override
  Uri toUri() => Uri.parse('/profile/$profileId');

  @override
  List<Object?> get props => [profileId];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/_layout.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part '_layout.g.dart';

/// Tab layout at /tabs
///
/// The annotation only specifies which routes belong to this layout.
/// All UI decisions are left to you in the build() method.
@ZenLayout(
  type: LayoutType.indexed,
  routes: [FeedTabLayout, TabProfileRoute, TabSettingsRoute],
)
class TabsLayout extends _$TabsLayout {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);

    return Scaffold(
      body: buildPath(coordinator),
      // User has full control over the navigation UI
      bottomNavigationBar: ListenableBuilder(
        listenable: path,
        builder: (context, _) => NavigationBar(
          selectedIndex: path.activeIndex,
          onDestinationSelected: (index) => coordinator.push(path.stack[index]),
          destinations: const [
            NavigationDestination(
              icon: Icon(Icons.feed_outlined),
              selectedIcon: Icon(Icons.feed),
              label: 'Feed',
            ),
            NavigationDestination(
              icon: Icon(Icons.person_outline),
              selectedIcon: Icon(Icons.person),
              label: 'Profile',
            ),
            NavigationDestination(
              icon: Icon(Icons.settings_outlined),
              selectedIcon: Icon(Icons.settings),
              label: 'Settings',
            ),
          ],
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for TabsLayout.
///
/// URI: /tabs
/// Path type: indexed
abstract class _$TabsLayout extends AppRoute with RouteLayout<AppRoute> {
  _$TabsLayout();

  @override
  IndexedStackPath<AppRoute> resolvePath(
    covariant AppCoordinator coordinator,
  ) => coordinator.tabsPath;

  @override
  Uri toUri() => Uri.parse('/tabs');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/profile.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part 'profile.g.dart';

/// Profile tab at /tabs/profile
@ZenRoute()
class TabProfileRoute extends _$TabProfileRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const CircleAvatar(radius: 50, child: Icon(Icons.person, size: 50)),
          const SizedBox(height: 16),
          const Text('Profile Tab', style: TextStyle(fontSize: 24)),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () =>
                coordinator.pushProfileId(profileId: 'current-user'),
            child: const Text('View Full Profile'),
          ),
        ],
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/profile.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'profile.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for TabProfileRoute.
///
/// URI: /tabs/profile
/// Layout: TabsLayout
abstract class _$TabProfileRoute extends AppRoute {
  _$TabProfileRoute();

  @override
  Type? get layout => TabsLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/profile');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/settings.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../routes.zen.dart';

part 'settings.g.dart';

/// Settings tab at /tabs/settings
@ZenRoute()
class TabSettingsRoute extends _$TabSettingsRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return ListView(
      children: [
        ListTile(
          leading: const Icon(Icons.dark_mode),
          title: const Text('Dark Mode'),
          trailing: const Switch(value: false, onChanged: null),
        ),
        ListTile(
          leading: const Icon(Icons.notifications),
          title: const Text('Notifications'),
          trailing: const Switch(value: true, onChanged: null),
        ),
        ListTile(
          leading: const Icon(Icons.language),
          title: const Text('Language'),
          subtitle: const Text('English'),
          onTap: () {},
        ),
        ListTile(
          leading: const Icon(Icons.info),
          title: const Text('About'),
          onTap: () => coordinator.pushAbout(),
        ),
      ],
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/settings.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'settings.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for TabSettingsRoute.
///
/// URI: /tabs/settings
/// Layout: TabsLayout
abstract class _$TabSettingsRoute extends AppRoute {
  _$TabSettingsRoute();

  @override
  Type? get layout => TabsLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/settings');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/_layout.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

part '_layout.g.dart';

@ZenLayout(type: LayoutType.indexed, routes: [FollowingLayout, ForYouLayout])
class FeedTabLayout extends _$FeedTabLayout {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    final path = resolvePath(coordinator);
    final size = MediaQuery.sizeOf(context);
    if (size.width < 600) {
      return Column(
        children: [
          Expanded(child: path.stack[0].build(coordinator, context)),
          Divider(height: 1),
          Expanded(child: path.stack[1].build(coordinator, context)),
        ],
      );
    }
    return Row(
      children: [
        Expanded(child: path.stack[0].build(coordinator, context)),
        VerticalDivider(width: 1),
        Expanded(child: path.stack[1].build(coordinator, context)),
      ],
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for FeedTabLayout.
///
/// URI: /tabs/feed
/// Path type: indexed
/// Parent layout: TabsLayout
abstract class _$FeedTabLayout extends AppRoute with RouteLayout<AppRoute> {
  _$FeedTabLayout();

  @override
  Type? get layout => TabsLayout;

  @override
  IndexedStackPath<AppRoute> resolvePath(
    covariant AppCoordinator coordinator,
  ) => coordinator.feedTabPath;

  @override
  Uri toUri() => Uri.parse('/tabs/feed');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[postId].dart
================================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/tabs/feed/following/index.dart';

import '../../../routes.zen.dart';

part '[postId].g.dart';

/// Feed post detail at /tabs/feed/:postId
@ZenRoute(guard: true, deepLink: DeeplinkStrategyType.custom)
class FeedPostRoute extends _$FeedPostRoute {
  FeedPostRoute({required super.postId});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Post: $postId')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text('Post ID: $postId', style: const TextStyle(fontSize: 24)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Go Back'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Future<bool> popGuard() async {
    // Example: Always allow pop for this demo
    return true;
  }

  @override
  FutureOr<void> deeplinkHandler(AppCoordinator coordinator, Uri uri) {
    coordinator.recover(FollowingRoute());
    coordinator.push(this);
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[postId].g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '[postId].dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for FeedPostRoute.
///
/// URI: /tabs/feed/following/:postId
/// Layout: FollowingLayout
abstract class _$FeedPostRoute extends AppRoute with RouteGuard, RouteDeepLink {
  /// Dynamic parameter from path segment.
  final String postId;

  _$FeedPostRoute({required this.postId});

  @override
  Type? get layout => FollowingLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/following/$postId');

  @override
  List<Object?> get props => [postId];

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/_layout.dart
================================================
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

part '_layout.g.dart';

@ZenLayout(type: LayoutType.stack)
class FollowingLayout extends _$FollowingLayout {}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for FollowingLayout.
///
/// URI: /tabs/feed/following
/// Path type: stack
/// Parent layout: FeedTabLayout
abstract class _$FollowingLayout extends AppRoute with RouteLayout<AppRoute> {
  _$FollowingLayout();

  @override
  Type? get layout => FeedTabLayout;

  @override
  NavigationPath<AppRoute> resolvePath(covariant AppCoordinator coordinator) =>
      coordinator.followingPath;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/following');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/index.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

import '../../../routes.zen.dart';

part 'index.g.dart';

/// Feed tab at /tabs/feed
@ZenRoute()
class FollowingRoute extends _$FollowingRoute {
  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      body: ListView.builder(
        itemCount: 10,
        itemBuilder: (context, index) {
          return ListTile(
            title: Text('Post ${index + 1}'),
            subtitle: const Text('Tap to view details'),
            onTap: () => coordinator.pushFeedPost(postId: 'post-$index'),
          );
        },
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for FollowingRoute.
///
/// URI: /tabs/feed/following
/// Layout: FollowingLayout
abstract class _$FollowingRoute extends AppRoute {
  _$FollowingRoute();

  @override
  Type? get layout => FollowingLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/following');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[...slugs]/[id].dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

part '[id].g.dart';

@ZenRoute()
class FeedDynamicIdRoute extends _$FeedDynamicIdRoute {
  FeedDynamicIdRoute({required super.slugs, required super.id});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Feed Dynamic Id')),
      body: Center(child: Text('Feed Dynamic Id: ${slugs.join('/')}')),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[...slugs]/[id].g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '[id].dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for FeedDynamicIdRoute.
///
/// URI: /tabs/feed/following/...:slugs/:id
/// Layout: FollowingLayout
abstract class _$FeedDynamicIdRoute extends AppRoute {
  /// Dynamic parameter from path segment.
  final List<String> slugs;

  /// Dynamic parameter from path segment.
  final String id;

  _$FeedDynamicIdRoute({required this.slugs, required this.id});

  @override
  Type? get layout => FollowingLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/following/${slugs.join('/')}/$id');

  @override
  List<Object?> get props => [slugs, id];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[...slugs]/about.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

part 'about.g.dart';

@ZenRoute()
class FeedDynamicAboutRoute extends _$FeedDynamicAboutRoute {
  FeedDynamicAboutRoute({required super.slugs});

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Feed Dynamic About')),
      body: Center(child: Text('Feed Dynamic About: ${slugs.join('/')}')),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[...slugs]/about.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'about.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for FeedDynamicAboutRoute.
///
/// URI: /tabs/feed/following/...:slugs/about
/// Layout: FollowingLayout
abstract class _$FeedDynamicAboutRoute extends AppRoute {
  /// Dynamic parameter from path segment.
  final List<String> slugs;

  _$FeedDynamicAboutRoute({required this.slugs});

  @override
  Type? get layout => FollowingLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/following/${slugs.join('/')}/about');

  @override
  List<Object?> get props => [slugs];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[...slugs]/index.dart
================================================
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';

part 'index.g.dart';

@ZenRoute()
class FeedDynamicRoute extends _$FeedDynamicRoute {
  FeedDynamicRoute({required super.slugs});

  @override
  Widget build(covariant AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Feed Dynamic')),
      body: Center(child: Text('Feed Dynamic: ${slugs.join('/')}')),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/following/[...slugs]/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for FeedDynamicRoute.
///
/// URI: /tabs/feed/following/...:slugs
/// Layout: FollowingLayout
abstract class _$FeedDynamicRoute extends AppRoute {
  /// Dynamic parameter from path segment.
  final List<String> slugs;

  _$FeedDynamicRoute({required this.slugs});

  @override
  Type? get layout => FollowingLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/following/${slugs.join('/')}');

  @override
  List<Object?> get props => [slugs];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/for-you/_layout.dart
================================================
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

part '_layout.g.dart';

@ZenLayout(type: LayoutType.stack)
class ForYouLayout extends _$ForYouLayout {}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/for-you/_layout.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of '_layout.dart';

// **************************************************************************
// LayoutGenerator
// **************************************************************************

/// Generated base class for ForYouLayout.
///
/// URI: /tabs/feed/for-you
/// Path type: stack
/// Parent layout: FeedTabLayout
abstract class _$ForYouLayout extends AppRoute with RouteLayout<AppRoute> {
  _$ForYouLayout();

  @override
  Type? get layout => FeedTabLayout;

  @override
  NavigationPath<AppRoute> resolvePath(covariant AppCoordinator coordinator) =>
      coordinator.forYouPath;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/for-you');

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/for-you/index.dart
================================================
import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';
import 'package:flutter/material.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

part 'index.g.dart';

/// Demonstrates query parameter manipulation using [RouteQueryParameters] mixin.
///
/// This route shows how to:
/// - Use [QuerySelector.select] for fine-grained rebuilds on specific query changes
/// - Update query parameters without triggering navigation
/// - Sync URL with [updateQueries]
@ZenRoute(queries: ['*'])
class ForYouRoute extends _$ForYouRoute {
  ForYouRoute({super.queries = const {}});

  // Helper getters for query parameters
  String get category => query('category') ?? 'all';
  int get page => int.tryParse(query('page') ?? '1') ?? 1;

  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('For You - Query Demo')),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Current URL display - rebuilds only when queries map changes
              selectorBuilder<String>(
                selector: (q) => toUri().toString(),
                builder: (context, url) => Card(
                  child: Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Current URL:',
                          style: TextStyle(fontWeight: FontWeight.bold),
                        ),
                        const SizedBox(height: 4),
                        Text(
                          url,
                          style: const TextStyle(
                            fontFamily: 'monospace',
                            fontSize: 12,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Category selector - rebuilds only when 'category' changes
              const Text(
                'Category',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              selectorBuilder<String>(
                selector: (q) => q['category'] ?? 'all',
                builder: (context, selectedCategory) => Wrap(
                  spacing: 8,
                  children: ['all', 'trending', 'new', 'popular'].map((cat) {
                    return ChoiceChip(
                      label: Text(cat),
                      selected: selectedCategory == cat,
                      onSelected: (_) => updateQueries(
                        coordinator,
                        queries: {...queries, 'category': cat, 'page': '1'},
                      ),
                    );
                  }).toList(),
                ),
              ),
              const SizedBox(height: 16),

              // Pagination - rebuilds only when 'page' changes
              const Text('Page', style: TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              selectorBuilder<int>(
                selector: (q) => int.tryParse(q['page'] ?? '1') ?? 1,
                builder: (context, currentPage) => Row(
                  children: [
                    IconButton.filled(
                      onPressed: currentPage > 1
                          ? () => updateQueries(
                              coordinator,
                              queries: {
                                ...queries,
                                'page': '${currentPage - 1}',
                              },
                            )
                          : null,
                      icon: const Icon(Icons.arrow_back),
                    ),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: Text(
                        'Page $currentPage',
                        style: const TextStyle(fontSize: 18),
                      ),
                    ),
                    IconButton.filled(
                      onPressed: () => updateQueries(
                        coordinator,
                        queries: {...queries, 'page': '${currentPage + 1}'},
                      ),
                      icon: const Icon(Icons.arrow_forward),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 24),

              // Clear queries button - static, no listener needed
              OutlinedButton.icon(
                onPressed: () => updateQueries(coordinator, queries: {}),
                icon: const Icon(Icons.clear),
                label: const Text('Clear All Queries'),
              ),
              const SizedBox(height: 24),

              // Show sheet button - static, no listener needed
              ElevatedButton(
                onPressed: () => coordinator.pushForYouSheet(),
                child: const Text('Show Sheet'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/for-you/index.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'index.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ForYouRoute.
///
/// URI: /tabs/feed/for-you
/// Layout: ForYouLayout
abstract class _$ForYouRoute extends AppRoute with RouteQueryParameters {
  @override
  late final ValueNotifier<Map<String, String>> queryNotifier;

  _$ForYouRoute({Map<String, String> queries = const {}})
    : queryNotifier = ValueNotifier(queries);

  @override
  Type? get layout => ForYouLayout;

  @override
  Uri toUri() {
    final uri = Uri.parse('/tabs/feed/for-you');
    if (queries.isEmpty) return uri;
    return uri.replace(queryParameters: queries);
  }

  @override
  List<Object?> get props => [];
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/for-you/sheet.dart
================================================
import 'dart:async';

import 'package:zenrouter_file_generator_example/routes/routes.zen.dart';
import 'package:flutter/cupertino.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

part 'sheet.g.dart';

@ZenRoute(transition: true, deepLink: DeeplinkStrategyType.custom)
class ForYouSheetRoute extends _$ForYouSheetRoute {
  @override
  Widget build(AppCoordinator coordinator, BuildContext context) {
    return CupertinoPageScaffold(child: Center(child: Text('For You Sheet')));
  }

  @override
  FutureOr<void> deeplinkHandler(AppCoordinator coordinator, Uri uri) async {
    await coordinator.replaceFollowing();
    coordinator.pushForYou();
    coordinator.push(this);
  }

  @override
  StackTransition<T> transition<T extends RouteUnique>(
    AppCoordinator coordinator,
  ) => StackTransition.sheet(build(coordinator, coordinator.navigator.context));
}



================================================
FILE: packages/zenrouter_file_generator/example/lib/routes/tabs/feed/for-you/sheet.g.dart
================================================
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sheet.dart';

// **************************************************************************
// RouteGenerator
// **************************************************************************

/// Generated base class for ForYouSheetRoute.
///
/// URI: /tabs/feed/for-you/sheet
/// Layout: ForYouLayout
abstract class _$ForYouSheetRoute extends AppRoute
    with RouteDeepLink, RouteTransition {
  _$ForYouSheetRoute();

  @override
  Type? get layout => ForYouLayout;

  @override
  Uri toUri() => Uri.parse('/tabs/feed/for-you/sheet');

  @override
  List<Object?> get props => [];

  @override
  DeeplinkStrategy get deeplinkStrategy => DeeplinkStrategy.custom;
}



================================================
FILE: packages/zenrouter_file_generator/example/linux/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.example.example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()



================================================
FILE: packages/zenrouter_file_generator/example/linux/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)



================================================
FILE: packages/zenrouter_file_generator/example/linux/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void fl_register_plugins(FlPluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter_file_generator/example/linux/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter_linux/flutter_linux.h>

// Registers Flutter plugins.
void fl_register_plugins(FlPluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter_file_generator/example/linux/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/linux plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/linux plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter_file_generator/example/linux/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")



================================================
FILE: packages/zenrouter_file_generator/example/linux/runner/main.cc
================================================
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}



================================================
FILE: packages/zenrouter_file_generator/example/linux/runner/my_application.cc
================================================
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView* view) {
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "example");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "example");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(
      project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000
  // for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb),
                           self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application,
                                                  gchar*** arguments,
                                                  int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
    g_warning("Failed to register: %s", error->message);
    *exit_status = 1;
    return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  // MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line =
      my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID, "flags",
                                     G_APPLICATION_NON_UNIQUE, nullptr));
}



================================================
FILE: packages/zenrouter_file_generator/example/linux/runner/my_application.h
================================================
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication,
                     my_application,
                     MY,
                     APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_



================================================
FILE: packages/zenrouter_file_generator/example/macos/Flutter/Flutter-Debug.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter_file_generator/example/macos/Flutter/Flutter-Release.xcconfig
================================================
#include "ephemeral/Flutter-Generated.xcconfig"



================================================
FILE: packages/zenrouter_file_generator/example/macos/Flutter/GeneratedPluginRegistrant.swift
================================================
//
//  Generated file. Do not edit.
//

import FlutterMacOS
import Foundation


func RegisterGeneratedPlugins(registry: FlutterPluginRegistry) {
}



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/AppDelegate.swift
================================================
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/DebugProfile.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/MainFlutterWindow.swift
================================================
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Release.entitlements
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json
================================================
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Base.lproj/MainMenu.xib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Configs/AppInfo.xcconfig
================================================
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = example

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.example.example

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2025 com.example. All rights reserved.



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Configs/Debug.xcconfig
================================================
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Configs/Release.xcconfig
================================================
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"



================================================
FILE: packages/zenrouter_file_generator/example/macos/Runner/Configs/Warnings.xcconfig
================================================
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES



================================================
FILE: packages/zenrouter_file_generator/example/macos/RunnerTests/RunnerTests.swift
================================================
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



================================================
FILE: packages/zenrouter_file_generator/example/web/index.html
================================================
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="example">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>example</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <!--
    You can customize the "flutter_bootstrap.js" script.
    This is useful to provide a custom configuration to the Flutter loader
    or to give the user feedback during the initialization process.

    For more details:
    * https://docs.flutter.dev/platform-integration/web/initialization
  -->
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>



================================================
FILE: packages/zenrouter_file_generator/example/web/manifest.json
================================================
{
    "name": "example",
    "short_name": "example",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}



================================================
FILE: packages/zenrouter_file_generator/example/windows/CMakeLists.txt
================================================
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(example LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "example")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)



================================================
FILE: packages/zenrouter_file_generator/example/windows/flutter/CMakeLists.txt
================================================
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)



================================================
FILE: packages/zenrouter_file_generator/example/windows/flutter/generated_plugin_registrant.cc
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#include "generated_plugin_registrant.h"


void RegisterPlugins(flutter::PluginRegistry* registry) {
}



================================================
FILE: packages/zenrouter_file_generator/example/windows/flutter/generated_plugin_registrant.h
================================================
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GENERATED_PLUGIN_REGISTRANT_
#define GENERATED_PLUGIN_REGISTRANT_

#include <flutter/plugin_registry.h>

// Registers Flutter plugins.
void RegisterPlugins(flutter::PluginRegistry* registry);

#endif  // GENERATED_PLUGIN_REGISTRANT_



================================================
FILE: packages/zenrouter_file_generator/example/windows/flutter/generated_plugins.cmake
================================================
#
# Generated file, do not edit.
#

list(APPEND FLUTTER_PLUGIN_LIST
)

list(APPEND FLUTTER_FFI_PLUGIN_LIST
)

set(PLUGIN_BUNDLED_LIBRARIES)

foreach(plugin ${FLUTTER_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${plugin}/windows plugins/${plugin})
  target_link_libraries(${BINARY_NAME} PRIVATE ${plugin}_plugin)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES $<TARGET_FILE:${plugin}_plugin>)
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${plugin}_bundled_libraries})
endforeach(plugin)

foreach(ffi_plugin ${FLUTTER_FFI_PLUGIN_LIST})
  add_subdirectory(flutter/ephemeral/.plugin_symlinks/${ffi_plugin}/windows plugins/${ffi_plugin})
  list(APPEND PLUGIN_BUNDLED_LIBRARIES ${${ffi_plugin}_bundled_libraries})
endforeach(ffi_plugin)



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/CMakeLists.txt
================================================
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/flutter_window.cpp
================================================
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/flutter_window.h
================================================
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/main.cpp
================================================
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"example", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/resource.h
================================================
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/runner.exe.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/Runner.rc
================================================
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.example" "\0"
            VALUE "FileDescription", "example" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "example" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.example. All rights reserved." "\0"
            VALUE "OriginalFilename", "example.exe" "\0"
            VALUE "ProductName", "example" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/utils.cpp
================================================
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/utils.h
================================================
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/win32_window.cpp
================================================
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}



================================================
FILE: packages/zenrouter_file_generator/example/windows/runner/win32_window.h
================================================
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_



================================================
FILE: packages/zenrouter_file_generator/lib/builder.dart
================================================
/// Build runner builders for ZenRouter file-based routing.
///
/// This library provides two builders:
/// - `zenRouteBuilder`: Generates _$RouteName base classes for individual routes
/// - `zenCoordinatorBuilder`: Generates the AppCoordinator from all routes
library;

export 'src/builder.dart';



================================================
FILE: packages/zenrouter_file_generator/lib/zenrouter_file_generator.dart
================================================
/// File-based routing generator for ZenRouter.
///
/// This package provides annotations and code generation for file-based routing
/// with the Coordinator paradigm from zenrouter.
///
/// ## Usage
///
/// 1. Create a `routes/` directory in your `lib/` folder
/// 2. Add route files following the naming conventions:
///    - `index.dart` - Route at current path level
///    - `[param].dart` - Dynamic route parameter
///    - `_layout.dart` - RouteLayout definition
///
/// 3. Annotate your route classes:
/// ```dart
/// @ZenRoute()
/// class AboutRoute extends _$AboutRoute {
///   @override
///   Widget build(AppCoordinator coordinator, BuildContext context) {
///     return AboutScreen();
///   }
/// }
/// ```
///
/// 4. Run build_runner to generate the routing code.
library;

export 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';



================================================
FILE: packages/zenrouter_file_generator/lib/src/builder.dart
================================================
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';

import 'generators/route_generator.dart';
import 'generators/layout_generator.dart';
import 'generators/coordinator_generator.dart';

/// Builder for generating individual route base classes.
///
/// Processes @ZenRoute and @ZenLayout annotations to generate
/// _$RouteName and _$LayoutName base classes.
Builder zenRouteBuilder(BuilderOptions options) {
  return SharedPartBuilder([RouteGenerator(), LayoutGenerator()], 'zen_route');
}

/// Builder for generating the aggregated Coordinator.
///
/// Scans all routes in lib/routes/ and generates:
/// - AppRoute base class
/// - AppCoordinator class
/// - Navigation paths
/// - Type-safe navigation extensions
///
/// Configurable options in `build.yaml`:
/// - `deferredImport`: Global deferred import setting (default: false)
/// - `outputFile`: Output filename (default: 'routes.zen.dart')
Builder zenCoordinatorBuilder(BuilderOptions options) {
  final globalDeferredImport =
      options.config['deferredImport'] as bool? ?? false;
  final outputFile =
      options.config['outputFile'] as String? ?? 'routes.zen.dart';
  return CoordinatorGenerator(
    globalDeferredImport: globalDeferredImport,
    outputFile: outputFile,
  );
}



================================================
FILE: packages/zenrouter_file_generator/lib/src/analyzers/layout_element.dart
================================================
import 'package:source_gen/source_gen.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

/// Parse a LayoutElement from an annotated class.
LayoutElement? layoutElementFromAnnotatedElement(
  String className,
  ConstantReader annotation,
  String filePath,
  String routesDir, {
  String? parentLayoutType,
}) {
  // Extract relative path from routes directory
  final relativePath = _extractRelativePath(filePath, routesDir);
  if (relativePath == null) return null;

  // Parse path segments using shared parser (removes _layout from path)
  final segments = PathParser.parseLayoutPath(relativePath);

  // Read layout type
  final typeReader = annotation.read('type');
  final typeIndex = typeReader.read('index').intValue;
  final layoutType = LayoutType.values[typeIndex];

  // Read indexed routes if present
  final indexedRoutes = <String>[];
  final routesReader = annotation.read('routes');
  if (!routesReader.isNull) {
    for (final routeReader in routesReader.listValue) {
      final typeValue = routeReader.toTypeValue();
      if (typeValue != null) {
        indexedRoutes.add(typeValue.getDisplayString());
      }
    }
  }

  return LayoutElement(
    className: className,
    relativePath: relativePath,
    pathSegments: segments,
    layoutType: layoutType,
    indexedRouteTypes: indexedRoutes,
    parentLayoutType: parentLayoutType,
  );
}

String? _extractRelativePath(String filePath, String routesDir) {
  // Normalize paths
  final normalizedFile = filePath.replaceAll('\\', '/');
  final normalizedRoutes = routesDir.replaceAll('\\', '/');

  // Find the routes directory in the path
  final routesIndex = normalizedFile.indexOf(normalizedRoutes);
  if (routesIndex == -1) return null;

  // Get path after routes directory
  var relative = normalizedFile.substring(
    routesIndex + normalizedRoutes.length,
  );
  if (relative.startsWith('/')) {
    relative = relative.substring(1);
  }

  // Remove .dart extension
  if (relative.endsWith('.dart')) {
    relative = relative.substring(0, relative.length - 5);
  }

  return relative;
}



================================================
FILE: packages/zenrouter_file_generator/lib/src/analyzers/route_element.dart
================================================
import 'package:source_gen/source_gen.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

/// Parse a RouteElement from an annotated class.
RouteElement? routeElementFromAnnotatedElement(
  String className,
  ConstantReader annotation,
  String filePath,
  String routesDir, {
  String? parentLayoutType,
}) {
  // Extract relative path from routes directory
  final relativePath = _extractRelativePath(filePath, routesDir);
  if (relativePath == null) return null;

  // Parse path segments and parameters using shared parser
  final (segments, paramInfos, _, _) = PathParser.parsePath(relativePath);
  // Convert ParamInfo to RouteParameter
  final params =
      paramInfos
          .map(
            (p) => switch (p.isRest) {
              true => RouteParameter(
                name: p.name,
                type: 'List<String>',
                isRest: true,
              ),
              false => RouteParameter(
                name: p.name,
                type: 'String',
                isRest: false,
              ),
            },
          )
          .toList();

  // Read annotation values
  final guard = annotation.read('guard').boolValue;
  final redirect = annotation.read('redirect').boolValue;
  final transition = annotation.read('transition').boolValue;
  final deferredImport = annotation.read('deferredImport').boolValue;

  DeeplinkStrategyType? deepLink;
  final deepLinkReader = annotation.read('deepLink');
  if (!deepLinkReader.isNull) {
    final enumIndex = deepLinkReader.read('index').intValue;
    deepLink = DeeplinkStrategyType.values[enumIndex];
  }

  // Read query parameter names
  List<String>? queries;
  final queriesReader = annotation.read('queries');
  if (!queriesReader.isNull) {
    final queriesList = queriesReader.listValue;
    queries = queriesList.map((e) => e.toStringValue()!).toList();
  }

  return RouteElement(
    className: className,
    relativePath: relativePath,
    pathSegments: segments,
    parameters: params,
    parentLayoutType: parentLayoutType,
    hasGuard: guard,
    hasRedirect: redirect,
    deepLinkStrategy: deepLink,
    hasTransition: transition,
    hasDeferredImport: deferredImport,
    queries: queries,
  );
}

String? _extractRelativePath(String filePath, String routesDir) {
  // Normalize paths
  final normalizedFile = filePath.replaceAll('\\', '/');
  final normalizedRoutes = routesDir.replaceAll('\\', '/');

  // Find the routes directory in the path
  final routesIndex = normalizedFile.indexOf(normalizedRoutes);
  if (routesIndex == -1) return null;

  // Get path after routes directory
  var relative = normalizedFile.substring(
    routesIndex + normalizedRoutes.length,
  );
  if (relative.startsWith('/')) {
    relative = relative.substring(1);
  }

  // Remove .dart extension
  if (relative.endsWith('.dart')) {
    relative = relative.substring(0, relative.length - 5);
  }

  return relative;
}



================================================
FILE: packages/zenrouter_file_generator/lib/src/generators/coordinator_generator.dart
================================================
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:dart_style/dart_style.dart';
import 'package:glob/glob.dart';

import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

typedef FileImportPath = (String path, bool isDeferred);

/// Generator that produces the aggregated Coordinator and route infrastructure.
///
/// This generator runs after all individual route generators and produces:
/// - The AppRoute base class
/// - The AppCoordinator class with parseRouteFromUri
/// - Navigation path definitions
/// - Layout registrations
/// - Type-safe navigation extensions
class CoordinatorGenerator implements Builder {
  /// Global deferred import configuration.
  /// When true, all routes will use deferred imports unless explicitly disabled.
  final bool globalDeferredImport;

  /// Output filename for the generated coordinator file.
  /// Defaults to 'routes.zen.dart'.
  final String outputFile;

  CoordinatorGenerator({
    this.globalDeferredImport = false,
    this.outputFile = 'routes.zen.dart',
  });

  // Cached regex patterns for performance
  static final _annotationRegex = RegExp(r'@ZenCoordinator\s*\(([^)]+)\)');
  static final _nameMatchSingleQuote = RegExp(r"name:\s*'([^']+)'");
  static final _nameMatchDoubleQuote = RegExp(r'name:\s*"([^"]+)"');
  static final _routeBaseMatchSingleQuote = RegExp(r"routeBase:\s*'([^']+)'");
  static final _routeBaseMatchDoubleQuote = RegExp(r'routeBase:\s*"([^"]+)"');
  static final _classMatchRoute = RegExp(r'class\s+(\w+Route)\s+extends');
  static final _classMatchLayout = RegExp(r'class\s+(\w+Layout)\s+extends');
  static final _queriesMatch = RegExp(r'queries:\s*\[([^\]]+)\]');
  static final _queriesContentMatch = RegExp(r"'([^']+)'");

  @override
  Map<String, List<String>> get buildExtensions => {
    r'$lib$': ['routes/$outputFile'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Collect all route and layout information from generated files
    final routes = <RouteInfo>[];
    final layouts = <LayoutInfo>[];
    String? customNotFoundRoutePath;
    // Map to track which routes come from which files
    final routeFileMap = <String, String>{};

    // Default coordinator configuration
    String coordinatorName = 'AppCoordinator';
    String routeBaseName = 'AppRoute';
    String? routeBasePath;
    // Effective deferred import (can be overridden by annotation)
    bool effectiveDeferredImport = globalDeferredImport;

    // Get language version for formatting from _coordinator.dart
    LibraryElement? lib;
    final coordinatorId = AssetId(
      buildStep.inputId.package,
      'lib/routes/_coordinator.dart',
    );

    // Read _coordinator.dart first to get configuration
    if (await buildStep.canRead(coordinatorId)) {
      try {
        lib = await buildStep.resolver.libraryFor(
          coordinatorId,
          allowSyntaxErrors: true,
        );
      } catch (_) {
        // Ignore errors, will use latest language version
      }

      final content = await buildStep.readAsString(coordinatorId);
      if (content.contains('@ZenCoordinator')) {
        final config = _parseCoordinatorConfig(content);
        if (config != null) {
          coordinatorName = config['name'] as String? ?? coordinatorName;
          routeBaseName = config['routeBase'] as String? ?? routeBaseName;
          routeBasePath = config['routeBasePath'] as String?;
          // Annotation deferredImport overrides build.yaml config
          if (config['deferredImport'] != null) {
            effectiveDeferredImport = config['deferredImport'] as bool;
          }
        }
      }
    }

    // Collect all route files
    final routeFiles = Glob('lib/routes/**.dart');
    final allInputs = <AssetId>[];
    await for (final input in buildStep.findAssets(routeFiles)) {
      if (input.path.contains('.g.dart')) continue;
      if (input.path.contains('.zen.dart')) continue;
      allInputs.add(input);
    }

    // Process all route and layout files
    for (final input in allInputs) {
      final relativePath = input.path.replaceFirst('lib/routes/', '');
      final fileName = relativePath.split('/').last;

      // Skip _coordinator.dart (already processed)
      if (fileName == '_coordinator.dart') {
        continue;
      }

      final content = await buildStep.readAsString(input);

      // Check for custom NotFoundRoute
      if (content.contains('class NotFoundRoute') &&
          content.contains('extends $routeBaseName')) {
        customNotFoundRoutePath = input.path;
        // Don't add NotFoundRoute to routes list - it's handled specially
        continue;
      }

      // Parse route info from file content and path
      final info = _parseRouteInfo(
        input.path,
        content,
        effectiveDeferredImport,
      );
      if (info != null) {
        if (info is RouteInfo) {
          // Store file path for error reporting
          info.filePath = input.path;
          routes.add(info);
          // Track which file this route comes from
          routeFileMap[info.className] = relativePath;
        } else if (info is LayoutInfo) {
          layouts.add(info);
          // Track layout files too
          routeFileMap[info.className] = relativePath;
        }
      }
    }

    // Only generate if we found routes
    if (routes.isEmpty && layouts.isEmpty) {
      return;
    }

    // Build the route tree
    final tree = _buildRouteTree(routes, layouts);

    // Validate and enforce IndexedStack routes to be non-deferred
    // This must happen BEFORE we build allFilePaths
    _validateRouteConflicts(tree.routes);
    _validateIndexedStackDeferredImports(tree.routes, tree.layouts);

    // Now build allFilePaths with correct deferred import flags
    final allFilePaths = <FileImportPath>[];
    for (final route in routes) {
      final relativePath = routeFileMap[route.className];
      if (relativePath != null) {
        final fileName = relativePath.split('/').last;
        // Skip private files except _layout
        if (!fileName.startsWith('_')) {
          allFilePaths.add((relativePath, route.hasDeferredImport));
        }
      }
    }
    for (final layout in layouts) {
      final relativePath = routeFileMap[layout.className];
      if (relativePath != null) {
        final fileName = relativePath.split('/').last;
        // Include _layout files
        if (fileName == '_layout.dart') {
          allFilePaths.add((relativePath, false));
        }
      }
    }

    // Generate coordinator code
    final output = _generateCoordinatorCode(
      tree,
      customNotFoundRoutePath,
      allFilePaths,
      coordinatorName,
      routeBaseName,
      routeBasePath,
      routeFileMap,
    );

    // Format the generated code
    final formattedOutput = _formatOutput(lib, output);

    // Write output - path is relative to lib/ since we use $lib$ trigger
    final outputId = AssetId(
      buildStep.inputId.package,
      'lib/routes/$outputFile',
    );
    await buildStep.writeAsString(outputId, formattedOutput);
  }

  /// Format the generated Dart code using dart_style.
  String _formatOutput(LibraryElement? library, String code) {
    try {
      final languageVersion =
          library?.languageVersion.effective ??
          DartFormatter.latestLanguageVersion;
      final formatter = DartFormatter(languageVersion: languageVersion);
      return formatter.format(code);
    } catch (e) {
      // If formatting fails, return the unformatted code
      // This ensures generation doesn't fail due to formatting issues
      return code;
    }
  }

  /// Parse @ZenCoordinator annotation from _coordinator.dart file.
  ///
  /// Returns a map with 'name', 'routeBase', and 'deferredImport' keys,
  /// or null if not found.
  Map<String, Object?>? _parseCoordinatorConfig(String content) {
    if (!content.contains('@ZenCoordinator')) {
      return null;
    }

    // Extract annotation parameters
    final annotationMatch = _annotationRegex.firstMatch(content);

    if (annotationMatch == null) {
      // Use defaults if annotation exists but has no parameters
      return {'name': 'AppCoordinator', 'routeBase': 'AppRoute'};
    }

    final params = annotationMatch.group(1)!;
    final config = <String, Object?>{};

    // Parse name parameter - supports both single and double quotes
    final nameMatchSingle = _nameMatchSingleQuote.firstMatch(params);
    final nameMatchDouble = _nameMatchDoubleQuote.firstMatch(params);
    if (nameMatchSingle != null) {
      config['name'] = nameMatchSingle.group(1)!;
    } else if (nameMatchDouble != null) {
      config['name'] = nameMatchDouble.group(1)!;
    }

    // Parse routeBase parameter - supports both single and double quotes
    final routeBaseMatchSingle = _routeBaseMatchSingleQuote.firstMatch(params);
    final routeBaseMatchDouble = _routeBaseMatchDoubleQuote.firstMatch(params);
    if (routeBaseMatchSingle != null) {
      config['routeBase'] = routeBaseMatchSingle.group(1)!;
    } else if (routeBaseMatchDouble != null) {
      config['routeBase'] = routeBaseMatchDouble.group(1)!;
    }

    // Parse deferredImport parameter
    if (params.contains('deferredImport: true')) {
      config['deferredImport'] = true;
    } else if (params.contains('deferredImport: false')) {
      config['deferredImport'] = false;
    }

    // Parse routeBasePath parameter - supports both single and double quotes
    final routeBasePathSingle = RegExp(
      r"routeBasePath:\s*'([^']+)'",
    ).firstMatch(params);
    final routeBasePathDouble = RegExp(
      r'routeBasePath:\s*"([^"]+)"',
    ).firstMatch(params);
    if (routeBasePathSingle != null) {
      config['routeBasePath'] = routeBasePathSingle.group(1)!;
    } else if (routeBasePathDouble != null) {
      config['routeBasePath'] = routeBasePathDouble.group(1)!;
    }

    return config.isEmpty ? null : config;
  }

  Object? _parseRouteInfo(
    String path,
    String content,
    bool effectiveDeferredImport,
  ) {
    // Extract relative path from routes directory
    final relativePath = path.replaceFirst('lib/routes/', '');

    // Skip private files except _layout
    final fileName = relativePath.split('/').last;
    if (fileName.startsWith('_') && !fileName.startsWith('_layout')) {
      return null;
    }

    // Check if it's a layout file
    if (fileName == '_layout.dart') {
      return _parseLayoutFromContent(relativePath, content);
    }

    // Check for @ZenRoute annotation
    if (content.contains('@ZenRoute')) {
      return _parseRouteFromContent(
        relativePath,
        content,
        effectiveDeferredImport,
      );
    }

    return null;
  }

  RouteInfo? _parseRouteFromContent(
    String relativePath,
    String content,
    bool effectiveDeferredImport,
  ) {
    // Extract class name
    final classMatch = _classMatchRoute.firstMatch(content);
    if (classMatch == null) return null;

    final className = classMatch.group(1)!;

    // Parse path segments using shared parser
    final (segments, params, isIndex, fileName) = PathParser.parsePath(
      relativePath,
    );

    // Check for mixins
    final hasGuard = content.contains('guard: true');
    final hasRedirect = content.contains('redirect: true');
    final hasTransition = content.contains('transition: true');

    // Check for explicit deferredImport annotation
    bool hasDeferredImport;
    if (content.contains('deferredImport: false')) {
      // Explicitly disabled - respect annotation
      hasDeferredImport = false;
    } else if (content.contains('deferredImport: true')) {
      // Explicitly enabled - respect annotation
      hasDeferredImport = true;
    } else {
      // No explicit annotation - use global config
      hasDeferredImport = effectiveDeferredImport;
    }

    DeeplinkStrategyType? deepLink;
    if (content.contains('.replace')) {
      deepLink = DeeplinkStrategyType.replace;
    } else if (content.contains('.push')) {
      deepLink = DeeplinkStrategyType.push;
    } else if (content.contains('.custom')) {
      deepLink = DeeplinkStrategyType.custom;
    }

    // Parse query parameter names from annotation
    List<String>? queries;
    final queriesMatch = _queriesMatch.firstMatch(content);
    if (queriesMatch != null) {
      final queriesList = queriesMatch.group(1)!;
      queries =
          _queriesContentMatch
              .allMatches(queriesList)
              .map((m) => m.group(1)!)
              .toList();
    }

    return RouteInfo(
      className: className,
      pathSegments: segments,
      parameters: params,
      hasGuard: hasGuard,
      hasRedirect: hasRedirect,
      deepLinkStrategy: deepLink,
      hasTransition: hasTransition,
      hasDeferredImport: hasDeferredImport,
      isIndexFile: isIndex,
      originalFileName: fileName,
      queries: queries,
    );
  }

  LayoutInfo? _parseLayoutFromContent(String relativePath, String content) {
    // Extract class name
    final classMatch = _classMatchLayout.firstMatch(content);
    if (classMatch == null) return null;

    final className = classMatch.group(1)!;

    // Parse path segments using shared parser
    final segments = PathParser.parseLayoutPath(relativePath);

    // Determine layout type
    final isIndexed = content.contains('LayoutType.indexed');
    final layoutType = isIndexed ? LayoutType.indexed : LayoutType.stack;

    // Extract indexed routes if present (can be Route or Layout types)
    final indexedRoutes = <String>[];
    if (isIndexed) {
      final routesMatch = RegExp(r'routes:\s*\[([^\]]+)\]').firstMatch(content);
      if (routesMatch != null) {
        final routesList = routesMatch.group(1)!;
        // Match both Route and Layout types
        final routeTypes = RegExp(
          r'(\w+(?:Route|Layout))',
        ).allMatches(routesList);
        for (final match in routeTypes) {
          indexedRoutes.add(match.group(1)!);
        }
      }
    }

    return LayoutInfo(
      className: className,
      pathSegments: segments,
      layoutType: layoutType,
      indexedRouteTypes: indexedRoutes,
    );
  }

  RouteTreeInfo _buildRouteTree(
    List<RouteInfo> routes,
    List<LayoutInfo> layouts,
  ) {
    // Resolve parent layouts for routes
    for (final route in routes) {
      String? parentLayout;
      int maxMatchLength = 0;

      for (final layout in layouts) {
        if (_isPathPrefix(layout.pathSegments, route.pathSegments) &&
            layout.pathSegments.length > maxMatchLength) {
          parentLayout = layout.className;
          maxMatchLength = layout.pathSegments.length;
        }
      }

      route.parentLayoutType = parentLayout;
    }

    // Resolve parent layouts for layouts
    for (final layout in layouts) {
      String? parentLayout;
      int maxMatchLength = 0;

      for (final other in layouts) {
        if (other.className == layout.className) continue;
        if (_isPathPrefix(other.pathSegments, layout.pathSegments) &&
            other.pathSegments.length > maxMatchLength) {
          parentLayout = other.className;
          maxMatchLength = other.pathSegments.length;
        }
      }

      layout.parentLayoutType = parentLayout;
    }

    return RouteTreeInfo(routes: routes, layouts: layouts);
  }

  bool _isPathPrefix(List<String> prefix, List<String> path) {
    if (prefix.length >= path.length) return false;
    for (var i = 0; i < prefix.length; i++) {
      if (prefix[i].startsWith(':') || path[i].startsWith(':')) continue;
      if (prefix[i] != path[i]) return false;
    }
    return true;
  }

  /// Validate routes for duplicates and throw descriptive errors.
  ///
  /// Checks for duplicate routes (same path pattern).
  /// Note: Static routes can coexist with dynamic routes - they will be
  /// automatically ordered correctly (static before dynamic) by the sorting logic.
  void _validateRouteConflicts(List<RouteInfo> routes) {
    final pathPatterns = <String, List<RouteInfo>>{};

    // Group routes by path pattern
    for (final route in routes) {
      final pattern = route.pathSegments.join('/');
      pathPatterns.putIfAbsent(pattern, () => []).add(route);
    }

    // Check for duplicate routes (same path pattern)
    for (final entry in pathPatterns.entries) {
      if (entry.value.length > 1) {
        final duplicates = entry.value;
        final filePaths = duplicates
            .map((r) => r.filePath ?? 'unknown')
            .join(', ');
        final classNames = duplicates.map((r) => r.className).join(', ');
        throw ArgumentError(
          'Duplicate route pattern detected: /${entry.key}\n'
          'Found ${duplicates.length} routes with the same path:\n'
          '  Classes: $classNames\n'
          '  Files: $filePaths\n'
          'Please ensure each route has a unique path pattern.',
        );
      }
    }
  }

  /// Validate that routes in IndexedStack layouts cannot be deferred imports.
  ///
  /// IndexedStack displays one child at a time but keeps all children in the
  /// widget tree, so they must be available immediately and cannot use
  /// deferred imports.
  ///
  /// This method also enforces hasDeferredImport = false for these routes,
  /// overriding both annotation and global config.
  void _validateIndexedStackDeferredImports(
    List<RouteInfo> routes,
    List<LayoutInfo> layouts,
  ) {
    // Check each IndexedStack layout
    for (final layout in layouts) {
      if (layout.layoutType == LayoutType.indexed) {
        // Check each route type listed in the IndexedStack
        for (final routeType in layout.indexedRouteTypes) {
          RouteInfo? route;
          for (final r in routes) {
            if (r.className == routeType) {
              route = r;
              break;
            }
          }
          if (route == null) {
            continue;
          }

          // Force deferred import to false for IndexedStack routes
          // This overrides both annotation and global config
          if (route.hasDeferredImport) {
            route.hasDeferredImport = false;
          }
        }
      }
    }
  }

  String _getAliasImport(String path) {
    // Performance optimization: single-pass character iteration
    // Track bracket depth to preserve dots inside brackets (e.g., [...slugs])
    final buffer = StringBuffer();
    int bracketDepth = 0;

    for (var i = 0; i < path.length; i++) {
      final char = path[i];
      switch (char) {
        case '[':
          bracketDepth++;
          buffer.write('_');
        case ']':
          bracketDepth--;
          // Skip closing bracket
          break;
        case '.':
          if (bracketDepth > 0) {
            // Inside brackets: check for rest parameter ...
            if (i + 2 < path.length && path.substring(i, i + 3) == '...') {
              buffer.write('_');
              i += 2; // Skip the next two dots
            }
            // Otherwise skip single dots inside brackets
          } else {
            // Outside brackets: check for .dart extension
            if (i + 4 < path.length && path.substring(i, i + 5) == '.dart') {
              // Skip .dart extension
              i += 4;
            } else {
              // Dot outside brackets becomes underscore (path separator)
              buffer.write('_');
            }
          }
        case '/':
        case '(':
          buffer.write('_');
        case ')':
        case '-':
          // Skip these characters
          break;
        default:
          buffer.write(char);
      }
    }
    return buffer.toString();
  }

  String _wrapDeferredImportLoad(String importPath, String instance) {
    final aliasImport = _getAliasImport(importPath);
    return 'await () async { await $aliasImport.loadLibrary(); return $aliasImport.$instance; }()';
  }

  String _generateCoordinatorCode(
    RouteTreeInfo tree,
    String? customNotFoundRoutePath,
    List<FileImportPath> allFilePaths,
    String coordinatorName,
    String routeBaseName,
    String? routeBasePath,
    Map<String, String> routeFileMap,
  ) {
    final deferredImports = allFilePaths.where((f) => f.$2);

    final buffer = StringBuffer();

    // Header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// ignore_for_file: type=lint');
    buffer.writeln();
    // Always import Material for CoordinatorProvider (InheritedWidget)
    buffer.writeln("import 'package:flutter/widgets.dart';");
    buffer.writeln("import 'package:zenrouter/zenrouter.dart';");
    // Import custom route base class if path is specified
    if (routeBasePath != null) {
      buffer.writeln("import '$routeBasePath';");
    }
    buffer.writeln();

    // Import all route and layout files using relative paths
    final imports = <(String path, bool isDeferred)>{};
    for (final filePath in allFilePaths) {
      imports.add(filePath);
    }
    // Import custom NotFoundRoute if it exists (may already be in allFilePaths)
    if (customNotFoundRoutePath != null) {
      final relativePath = customNotFoundRoutePath.replaceFirst(
        'lib/routes/',
        '',
      );
      imports.add((relativePath, false));
    }
    final sortedImports =
        imports.toList()..sort((a, b) => a.$1.compareTo(b.$1));
    for (final import in sortedImports) {
      if (import.$2 == true) {
        final aliasImport = _getAliasImport(import.$1);
        buffer.writeln("import '${import.$1}' deferred as $aliasImport;");
      } else {
        buffer.writeln("import '${import.$1}';");
      }
    }
    buffer.writeln();

    buffer.writeln("export 'package:zenrouter/zenrouter.dart';");
    // Export all route and layout files using relative paths
    for (final export in sortedImports.where((i) => i.$2 == false)) {
      buffer.writeln("export '${export.$1}';");
    }
    // Export custom route base class if path is specified
    if (routeBasePath != null) {
      buffer.writeln("export '$routeBasePath';");
    }
    buffer.writeln();

    // Generate route base class (only if routeBasePath is not specified)
    if (routeBasePath == null) {
      buffer.writeln('/// Base class for all routes in this application.');
      buffer.writeln(
        'abstract class $routeBaseName extends RouteTarget with RouteUnique {}',
      );
      buffer.writeln();
    }

    // Generate Coordinator
    buffer.writeln('/// Generated coordinator managing all routes.');
    buffer.writeln(
      'class $coordinatorName extends Coordinator<$routeBaseName> {',
    );

    // Generate navigation paths for layouts
    for (final layout in tree.layouts) {
      final pathFieldName = _getPathFieldName(layout.className);
      final pathName = layout.className.replaceAll('Layout', '');
      if (layout.layoutType == LayoutType.indexed) {
        final routeInstances = layout.indexedRouteTypes
            .map((r) => '$r()')
            .join(', ');
        buffer.writeln(
          '  late final $pathFieldName = IndexedStackPath<$routeBaseName>.createWith('
          'coordinator: this, '
          "label: '$pathName', "
          '[',
        );
        buffer.writeln('    $routeInstances,');
        buffer.writeln("  ],)..bindLayout(${layout.className}.new);");
      } else {
        buffer.writeln(
          "  late final $pathFieldName = NavigationPath<$routeBaseName>.createWith(coordinator: this, label: '$pathName')..bindLayout(${layout.className}.new);",
        );
      }
    }
    buffer.writeln();

    // Generate paths getter
    buffer.writeln('  @override');
    buffer.write('  List<StackPath> get paths => [...super.paths');
    for (final layout in tree.layouts) {
      buffer.write(', ${_getPathFieldName(layout.className)}');
    }
    buffer.writeln('];');
    buffer.writeln();

    // Generate parseRouteFromUri
    buffer.writeln('  @override');
    if (deferredImports.isNotEmpty) {
      buffer.writeln(
        '  Future<$routeBaseName> parseRouteFromUri(Uri uri) async {',
      );
    } else {
      buffer.writeln('  $routeBaseName parseRouteFromUri(Uri uri) {');
    }
    buffer.writeln('    return switch (uri.pathSegments) {');

    // Validate routes for conflicts before sorting
    // Validate routes for duplicates (static/dynamic conflicts are allowed)
    _validateRouteConflicts(tree.routes);
    // Validate that routes in IndexedStack layouts cannot be deferred imports
    _validateIndexedStackDeferredImports(tree.routes, tree.layouts);

    // Sort routes by specificity (more segments first, static before dynamic)
    // This ensures static routes come before dynamic routes, allowing both to coexist
    // Performance optimization: use pre-computed route characteristics
    final sortedRoutes = List<RouteInfo>.from(tree.routes)..sort((a, b) {
      // 1. Routes with rest params go last
      if (a.hasRestParams && !b.hasRestParams) return 1; // a goes after b
      if (!a.hasRestParams && b.hasRestParams) return -1; // a goes before b

      // 2. More static segments first (cached)
      if (a.staticSegmentCount != b.staticSegmentCount) {
        return b.staticSegmentCount - a.staticSegmentCount;
      }

      // 3. More total segments first
      final segmentDiff = b.pathSegments.length - a.pathSegments.length;
      if (segmentDiff != 0) return segmentDiff;

      // 4. Static segments before dynamic (cached)
      return a.dynamicSegmentCount - b.dynamicSegmentCount;
    });

    // Root route
    final rootRoute =
        sortedRoutes.where((r) => r.pathSegments.isEmpty).firstOrNull;
    if (rootRoute != null) {
      final routeInstance =
          rootRoute.hasQueries
              ? '${rootRoute.className}(queries: uri.queryParameters)'
              : '${rootRoute.className}()';
      if (rootRoute.hasDeferredImport) {
        final relativePath = routeFileMap[rootRoute.className] ?? 'index.dart';
        buffer.writeln(
          '      [] => ${_wrapDeferredImportLoad(relativePath, routeInstance)},',
        );
      } else {
        buffer.writeln('      [] => $routeInstance,');
      }
    }

    // Other routes
    for (final route in sortedRoutes) {
      if (route.pathSegments.isEmpty) continue;

      final pattern = _generateSwitchPattern(route);
      final constructor = _generateConstructor(route);
      buffer.writeln('      $pattern => $constructor,');
    }

    // Default not found
    buffer.writeln(
      '      _ => NotFoundRoute(uri: uri, queries: uri.queryParameters),',
    );
    buffer.writeln('    };');
    buffer.writeln('  }');
    buffer.writeln();

    // Generate layoutBuilder override for CoordinatorProvider
    final providerName = '${coordinatorName}Provider';
    buffer.writeln('  @override');
    buffer.writeln('  Widget layoutBuilder(BuildContext context) {');
    buffer.writeln('    return $providerName(');
    buffer.writeln('      coordinator: this,');
    buffer.writeln('      child: super.layoutBuilder(context),');
    buffer.writeln('    );');
    buffer.writeln('  }');

    buffer.writeln('}');
    buffer.writeln();

    // Generate NotFoundRoute only if custom one doesn't exist
    if (customNotFoundRoutePath == null) {
      buffer.writeln('/// Default not found route.');
      buffer.writeln(
        '/// You can customize this by creating your own NotFoundRoute class.',
      );
      buffer.writeln('class NotFoundRoute extends $routeBaseName {');
      buffer.writeln('  final Uri uri;');
      buffer.writeln('  final Map<String, String> queries;');
      buffer.writeln();
      buffer.writeln(
        '  NotFoundRoute({required this.uri, this.queries = const {}});',
      );
      buffer.writeln();
      buffer.writeln('  /// Get a query parameter by name.');
      buffer.writeln('  /// Returns null if the parameter is not present.');
      buffer.writeln('  String? query(String name) => queries[name];');
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln("  Uri toUri() => Uri.parse('/not-found');");
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln('  List<Object?> get props => [uri, queries];');
      buffer.writeln();
      buffer.writeln('  @override');
      buffer.writeln(
        '  Widget build(covariant $coordinatorName coordinator, BuildContext context) {',
      );
      buffer.writeln('    return Scaffold(');
      buffer.writeln("      appBar: AppBar(title: const Text('Not Found')),");
      buffer.writeln('      body: Center(');
      buffer.writeln('        child: Column(');
      buffer.writeln('          mainAxisAlignment: MainAxisAlignment.center,');
      buffer.writeln('          children: [');
      buffer.writeln(
        '            const Icon(Icons.error_outline, size: 64, color: Colors.red),',
      );
      buffer.writeln('            const SizedBox(height: 16),');
      buffer.writeln("            Text('Route not found: \${uri.path}'),");
      buffer.writeln('          ],');
      buffer.writeln('        ),');
      buffer.writeln('      ),');
      buffer.writeln('    );');
      buffer.writeln('  }');
      buffer.writeln('}');
      buffer.writeln();
    }

    // Generate type-safe navigation extension
    buffer.writeln('/// Type-safe navigation extension methods.');
    buffer.writeln('extension ${coordinatorName}Nav on $coordinatorName {');
    for (final route in tree.routes) {
      final baseMethodName = _getBaseMethodName(route.className);
      final (params, args) = _buildMethodParams(route);
      final deferredImportPath =
          route.hasDeferredImport
              ? route.filePath!.replaceFirst('lib/routes/', '')
              : null;

      // Generate push method
      _writeNavMethod(
        buffer,
        baseMethodName,
        'push',
        route.className,
        params,
        args,
        deferredImportPath: deferredImportPath,
        generic: 'T extends Object',
        returnType: 'Future<T?>',
      );

      // Generate replace method
      _writeNavMethod(
        buffer,
        baseMethodName,
        'replace',
        route.className,
        params,
        args,
        deferredImportPath: deferredImportPath,
        returnType: 'Future<void>',
      );

      // Generate recoverFromUri method
      _writeRecoverMethod(
        buffer,
        baseMethodName,
        route.className,
        params,
        args,
        deferredImportPath: deferredImportPath,
      );
    }
    buffer.writeln('}');
    buffer.writeln();

    // Generate CoordinatorProvider (InheritedWidget)
    final contextGetterName =
        coordinatorName[0].toLowerCase() + coordinatorName.substring(1);

    buffer.writeln(
      '/// InheritedWidget provider for accessing the coordinator from the widget tree.',
    );
    buffer.writeln('class $providerName extends InheritedWidget {');
    buffer.writeln('  const $providerName({');
    buffer.writeln('    required this.coordinator,');
    buffer.writeln('    required super.child,');
    buffer.writeln('    super.key,');
    buffer.writeln('  });');
    buffer.writeln();
    buffer.writeln(
      '  /// Retrieves the [$coordinatorName] from the widget tree.',
    );
    buffer.writeln(
      '  static $coordinatorName of(BuildContext context) => context.dependOnInheritedWidgetOfExactType<$providerName>()!.coordinator;',
    );
    buffer.writeln();
    buffer.writeln('  final $coordinatorName coordinator;');
    buffer.writeln();
    buffer.writeln('  @override');
    buffer.writeln('  bool updateShouldNotify($providerName oldWidget) =>');
    buffer.writeln('      coordinator != oldWidget.coordinator;');
    buffer.writeln('}');
    buffer.writeln();

    buffer.writeln(
      '/// Extension on [BuildContext] for convenient coordinator access.',
    );
    buffer.writeln('extension ${coordinatorName}Getter on BuildContext {');
    buffer.writeln('  /// Access the [$coordinatorName] from the widget tree.');
    buffer.writeln(
      '  $coordinatorName get $contextGetterName => $providerName.of(this);',
    );
    buffer.writeln('}');

    /// Extension for pushing [routeBase] routes.
    buffer.writeln('/// Extension on [$routeBaseName] for navigation methods.');
    buffer.writeln(
      'extension ${coordinatorName}NavContext on $routeBaseName {',
    );
    // Navigate
    buffer.writeln(
      '  Future<void> navigate(BuildContext context) => context.$contextGetterName.navigate(this);',
    );
    // Push
    buffer.writeln(
      '  Future<T?> push<T extends Object>(BuildContext context) => context.$contextGetterName.push<T>(this);',
    );
    // Replace
    buffer.writeln(
      '  Future<void> replace(BuildContext context) => context.$contextGetterName.replace(this);',
    );
    // Recover
    buffer.writeln(
      '  Future<void> recover(BuildContext context) => context.$contextGetterName.recover(this);',
    );
    buffer.writeln('}');

    return buffer.toString();
  }

  String _getPathFieldName(String className) {
    var name = className;
    if (name.endsWith('Layout')) {
      name = name.substring(0, name.length - 6);
    }
    name = name[0].toLowerCase() + name.substring(1);
    return '${name}Path';
  }

  String _generateSwitchPattern(RouteInfo route) {
    final parts = route.pathSegments
        .map((segment) {
          if (segment.startsWith('...:')) {
            final paramName = segment.substring(4);
            return '...final $paramName';
          }
          if (segment.startsWith(':')) {
            final paramName = segment.substring(1);
            return 'final $paramName';
          }
          return "'$segment'";
        })
        .join(', ');

    return '[$parts]';
  }

  String _generateConstructor(RouteInfo route) {
    final args = <String>[];
    String routeInstance = '';

    // Add path parameters
    for (final param in route.parameters) {
      args.add('${param.name}: ${param.name}');
    }

    // Add query parameters only if route expects them
    if (route.hasQueries) {
      args.add('queries: uri.queryParameters');
    }

    if (args.isEmpty) {
      routeInstance = '${route.className}()';
    } else {
      routeInstance = '${route.className}(${args.join(', ')})';
    }

    final relativePath = route.filePath!.replaceFirst('lib/routes/', '');

    if (route.hasDeferredImport) {
      return _wrapDeferredImportLoad(relativePath, routeInstance);
    }
    return routeInstance;
  }

  String _getBaseMethodName(String className) {
    // Convert HomeRoute -> Home
    var name = className;
    if (name.endsWith('Route')) {
      name = name.substring(0, name.length - 5);
    }
    return name;
  }

  (List<String> params, List<String> args) _buildMethodParams(RouteInfo route) {
    final params = <String>[];
    final args = <String>[];

    // Add path parameters as named parameters
    for (final param in route.parameters) {
      switch (param.isRest) {
        case true:
          params.add('required List<String> ${param.name}');
        case false:
          params.add('required String ${param.name}');
      }
      args.add('${param.name}: ${param.name}');
    }

    // Add optional query parameters only if route expects them
    if (route.hasQueries) {
      params.add('Map<String, String> queries = const {}');
      args.add('queries: queries');
    }

    return (params, args);
  }

  void _writeNavMethod(
    StringBuffer buffer,
    String baseMethodName,
    String navMethod,
    String routeClassName,
    List<String> params,
    List<String> args, {
    String? generic,
    String returnType = 'Future<dynamic>',
    String? deferredImportPath,
  }) {
    final methodName = '$navMethod$baseMethodName';
    final paramsStr = params.isEmpty ? '' : '{${params.join(', ')}}';
    final argsStr = args.join(', ');

    final genericStr = generic != null ? '<$generic>' : '';

    String routeInstance = '';
    String arrowFunction = '';
    if (args.isNotEmpty) {
      routeInstance = '$routeClassName($argsStr)';
    } else {
      routeInstance = '$routeClassName()';
    }
    if (deferredImportPath != null) {
      arrowFunction = 'async =>';
      routeInstance = _wrapDeferredImportLoad(
        deferredImportPath,
        routeInstance,
      );
    } else {
      arrowFunction = '=>';
    }

    if (paramsStr.isEmpty) {
      buffer.writeln(
        '  $returnType $methodName$genericStr() $arrowFunction $navMethod($routeInstance);',
      );
    } else {
      buffer.writeln(
        '  $returnType $methodName$genericStr($paramsStr) $arrowFunction $navMethod($routeInstance);',
      );
    }
  }

  void _writeRecoverMethod(
    StringBuffer buffer,
    String baseMethodName,
    String routeClassName,
    List<String> params,
    List<String> args, {
    String? deferredImportPath,
  }) {
    final methodName = 'recover$baseMethodName';
    final paramsStr = params.isEmpty ? '' : '{${params.join(', ')}}';
    final argsStr = args.join(', ');
    String routeInstance = '';
    if (args.isEmpty) {
      routeInstance = '$routeClassName()';
    } else {
      routeInstance = '$routeClassName($argsStr)';
    }

    if (deferredImportPath != null) {
      routeInstance = _wrapDeferredImportLoad(
        deferredImportPath,
        routeInstance,
      );
    }

    String arrowFunction = '';
    if (deferredImportPath != null) {
      arrowFunction = 'async =>';
    } else {
      arrowFunction = '=>';
    }

    if (paramsStr.isEmpty) {
      buffer.writeln(
        '  Future<void> $methodName() $arrowFunction recover($routeInstance);',
      );
    } else {
      buffer.writeln(
        '  Future<void> $methodName($paramsStr) $arrowFunction recover($routeInstance);',
      );
    }
  }
}

/// Simplified route info for coordinator generation.
class RouteInfo {
  final String className;
  final List<String> pathSegments;
  final List<ParamInfo> parameters;
  final bool hasGuard;
  final bool hasRedirect;
  final DeeplinkStrategyType? deepLinkStrategy;
  final bool hasTransition;
  bool hasDeferredImport;
  final bool isIndexFile;
  final String originalFileName;
  final List<String>? queries;
  String? parentLayoutType;
  String? filePath; // File path for error reporting

  // Cached path characteristics for performance (computed once during construction)
  late final bool _hasRestParams;
  late final int _staticSegmentCount;
  late final int _dynamicSegmentCount;

  RouteInfo({
    required this.className,
    required this.pathSegments,
    required this.parameters,
    this.hasGuard = false,
    this.hasRedirect = false,
    this.deepLinkStrategy,
    this.hasTransition = false,
    this.hasDeferredImport = false,
    this.isIndexFile = false,
    this.originalFileName = '',
    this.queries,
    this.parentLayoutType,
    this.filePath,
  }) {
    // Pre-compute path characteristics for faster sorting
    _hasRestParams = pathSegments.any((s) => s.startsWith('...:'));
    _staticSegmentCount =
        pathSegments
            .where((s) => !s.startsWith(':') && !s.startsWith('...'))
            .length;
    _dynamicSegmentCount =
        pathSegments
            .where((s) => s.startsWith(':') && !s.startsWith('...'))
            .length;
  }

  /// Whether this route expects query parameters.
  bool get hasQueries => queries != null && queries!.isNotEmpty;

  /// Cached: whether this route has rest parameters
  bool get hasRestParams => _hasRestParams;

  /// Cached: number of static segments
  int get staticSegmentCount => _staticSegmentCount;

  /// Cached: number of dynamic segments (excluding rest params)
  int get dynamicSegmentCount => _dynamicSegmentCount;
}

/// Simplified layout info for coordinator generation.
class LayoutInfo {
  final String className;
  final List<String> pathSegments;
  final LayoutType layoutType;
  final List<String> indexedRouteTypes;
  String? parentLayoutType;

  LayoutInfo({
    required this.className,
    required this.pathSegments,
    required this.layoutType,
    this.indexedRouteTypes = const [],
    this.parentLayoutType,
  });
}

/// Container for route tree info.
class RouteTreeInfo {
  final List<RouteInfo> routes;
  final List<LayoutInfo> layouts;

  RouteTreeInfo({required this.routes, required this.layouts});
}



================================================
FILE: packages/zenrouter_file_generator/lib/src/generators/layout_generator.dart
================================================
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:source_gen/source_gen.dart';
import 'package:zenrouter_file_generator/src/analyzers/layout_element.dart';

import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

/// Generator for layout files.
///
/// Generates the `_$LayoutName` base class for each @ZenLayout annotated class.
class LayoutGenerator extends GeneratorForAnnotation<ZenLayout> {
  // Cached regex patterns for performance
  static final _routeBaseMatchSingleQuote = RegExp(r"routeBase:\s*'([^']+)'");
  static final _routeBaseMatchDoubleQuote = RegExp(r'routeBase:\s*"([^"]+)"');
  static final _nameMatchSingleQuote = RegExp(r"name:\s*'([^']+)'");
  static final _nameMatchDoubleQuote = RegExp(r'name:\s*"([^"]+)"');
  static final _classMatchLayout = RegExp(r'class\s+(\w+Layout)\s+extends');

  // Cache coordinator config to avoid re-reading the file for every layout
  static ({String routeBase, String coordinatorName})? _cachedConfig;
  static bool _configLoaded = false;
  @override
  Future<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '@ZenLayout can only be applied to classes.',
        element: element,
      );
    }

    final filePath = buildStep.inputId.path;
    final routesDir = 'lib/routes';

    // Use element.name for the class name
    final className = element.name!;

    // Get coordinator config for route base and coordinator names
    final config = await _getCoordinatorConfig(buildStep, routesDir);

    // Find parent layout by scanning for _layout.dart files in parent directories
    final parentLayout = await _findParentLayout(
      buildStep,
      filePath,
      routesDir,
    );

    final layoutElement = layoutElementFromAnnotatedElement(
      className,
      annotation,
      filePath,
      routesDir,
      parentLayoutType: parentLayout,
    );

    if (layoutElement == null) {
      throw InvalidGenerationSourceError(
        'Layout file must be inside lib/routes directory.',
        element: element,
      );
    }

    return _generateLayoutBaseClass(layoutElement, config);
  }

  /// Get coordinator configuration from _coordinator.dart.
  Future<({String routeBase, String coordinatorName})> _getCoordinatorConfig(
    BuildStep buildStep,
    String routesDir,
  ) async {
    // Performance optimization: cache the coordinator config
    if (_configLoaded) {
      return _cachedConfig ??
          (routeBase: 'AppRoute', coordinatorName: 'AppCoordinator');
    }

    String routeBase = 'AppRoute';
    String coordinatorName = 'AppCoordinator';

    final coordinatorGlob = Glob('$routesDir/_coordinator.dart');
    await for (final asset in buildStep.findAssets(coordinatorGlob)) {
      final content = await buildStep.readAsString(asset);

      // Parse routeBase
      final routeBaseMatchSingle = _routeBaseMatchSingleQuote.firstMatch(
        content,
      );
      final routeBaseMatchDouble = _routeBaseMatchDoubleQuote.firstMatch(
        content,
      );
      if (routeBaseMatchSingle != null) {
        routeBase = routeBaseMatchSingle.group(1)!;
      } else if (routeBaseMatchDouble != null) {
        routeBase = routeBaseMatchDouble.group(1)!;
      }

      // Parse coordinator name
      final nameMatchSingle = _nameMatchSingleQuote.firstMatch(content);
      final nameMatchDouble = _nameMatchDoubleQuote.firstMatch(content);
      if (nameMatchSingle != null) {
        coordinatorName = nameMatchSingle.group(1)!;
      } else if (nameMatchDouble != null) {
        coordinatorName = nameMatchDouble.group(1)!;
      }
    }

    _cachedConfig = (routeBase: routeBase, coordinatorName: coordinatorName);
    _configLoaded = true;
    return _cachedConfig!;
  }

  /// Find the closest parent _layout.dart file (in PARENT directories only).
  /// Unlike routes, layouts should only look at parent directories, not same directory.
  Future<String?> _findParentLayout(
    BuildStep buildStep,
    String filePath,
    String routesDir,
  ) async {
    // Get the directory path of the current file
    final normalizedPath = filePath.replaceAll('\\', '/');
    final routesIndex = normalizedPath.indexOf(routesDir);
    if (routesIndex == -1) return null;

    // Get the relative path within routes directory
    var relativePath = normalizedPath.substring(routesIndex + routesDir.length);
    if (relativePath.startsWith('/')) {
      relativePath = relativePath.substring(1);
    }

    // Split into directory parts
    final parts = relativePath.split('/');
    if (parts.isEmpty) return null;

    // Remove the file name (_layout.dart) to get directory parts
    parts.removeLast();

    // For layouts, we skip the current directory and only look at parents
    if (parts.isNotEmpty) {
      parts.removeLast(); // Skip current directory
    }

    // Search from innermost parent to outermost for _layout.dart
    while (parts.isNotEmpty) {
      final layoutPath = '$routesDir/${parts.join('/')}/_layout.dart';
      // Escape parentheses in glob patterns - they are special characters
      final escapedPath = _escapeGlobPattern(layoutPath);
      final layoutGlob = Glob(escapedPath);

      await for (final asset in buildStep.findAssets(layoutGlob)) {
        // Found a layout file, extract the class name
        final content = await buildStep.readAsString(asset);
        final classMatch = _classMatchLayout.firstMatch(content);
        if (classMatch != null) {
          return classMatch.group(1);
        }
      }

      // Move to parent directory
      parts.removeLast();
    }

    // Check root _layout.dart
    final rootLayoutGlob = Glob('$routesDir/_layout.dart');
    await for (final asset in buildStep.findAssets(rootLayoutGlob)) {
      final content = await buildStep.readAsString(asset);
      final classMatch = _classMatchLayout.firstMatch(content);
      if (classMatch != null) {
        return classMatch.group(1);
      }
    }

    return null;
  }

  /// Escape special glob characters in a path.
  String _escapeGlobPattern(String path) {
    return path.replaceAll('(', '[(]').replaceAll(')', '[)]');
  }

  String _generateLayoutBaseClass(
    LayoutElement layout,
    ({String routeBase, String coordinatorName}) config,
  ) {
    return LayoutCodeGenerator.generate(
      layout,
      LayoutCodeConfig(
        routeBase: config.routeBase,
        coordinatorName: config.coordinatorName,
      ),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/lib/src/generators/route_generator.dart
================================================
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:source_gen/source_gen.dart';
import 'package:zenrouter_file_generator/src/analyzers/route_element.dart';

import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

/// Generator for individual route files.
///
/// Generates the `_$RouteName` base class for each @ZenRoute annotated class.
class RouteGenerator extends GeneratorForAnnotation<ZenRoute> {
  // Cached regex patterns for performance
  static final _routeBaseMatchSingleQuote = RegExp(r"routeBase:\s*'([^']+)'");
  static final _routeBaseMatchDoubleQuote = RegExp(r'routeBase:\s*"([^"]+)"');
  static final _classMatchLayout = RegExp(r'class\s+(\w+Layout)\s+extends');

  // Cache coordinator config to avoid re-reading the file for every route
  static String? _cachedRouteBase;
  static bool _configLoaded = false;
  @override
  Future<String> generateForAnnotatedElement(
    Element element,
    ConstantReader annotation,
    BuildStep buildStep,
  ) async {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
        '@ZenRoute can only be applied to classes.',
        element: element,
      );
    }

    final filePath = buildStep.inputId.path;
    final routesDir = 'lib/routes';

    // Use element.name for the class name
    final className = element.name!;

    // Get coordinator config for route base name
    final routeBase = await _getRouteBaseName(buildStep, routesDir);

    // Find parent layout by scanning for _layout.dart files
    final parentLayout = await _findParentLayout(
      buildStep,
      filePath,
      routesDir,
    );

    final routeElement = routeElementFromAnnotatedElement(
      className,
      annotation,
      filePath,
      routesDir,
      parentLayoutType: parentLayout,
    );

    if (routeElement == null) {
      throw InvalidGenerationSourceError(
        'Route file must be inside lib/routes directory.',
        element: element,
      );
    }

    return _generateRouteBaseClass(routeElement, annotation, routeBase);
  }

  /// Get the route base name from _coordinator.dart or use default.
  Future<String> _getRouteBaseName(
    BuildStep buildStep,
    String routesDir,
  ) async {
    // Performance optimization: cache the coordinator config
    if (_configLoaded) {
      return _cachedRouteBase ?? 'AppRoute';
    }

    final coordinatorGlob = Glob('$routesDir/_coordinator.dart');
    await for (final asset in buildStep.findAssets(coordinatorGlob)) {
      final content = await buildStep.readAsString(asset);
      // Parse routeBase from @ZenCoordinator annotation
      final routeBaseMatchSingle = _routeBaseMatchSingleQuote.firstMatch(
        content,
      );
      final routeBaseMatchDouble = _routeBaseMatchDoubleQuote.firstMatch(
        content,
      );
      if (routeBaseMatchSingle != null) {
        _cachedRouteBase = routeBaseMatchSingle.group(1)!;
        _configLoaded = true;
        return _cachedRouteBase!;
      } else if (routeBaseMatchDouble != null) {
        _cachedRouteBase = routeBaseMatchDouble.group(1)!;
        _configLoaded = true;
        return _cachedRouteBase!;
      }
    }
    _configLoaded = true;
    _cachedRouteBase = 'AppRoute'; // Default
    return _cachedRouteBase!;
  }

  /// Find the closest parent _layout.dart file and extract the layout class name.
  Future<String?> _findParentLayout(
    BuildStep buildStep,
    String filePath,
    String routesDir,
  ) async {
    // Get the directory path of the current file
    final normalizedPath = filePath.replaceAll('\\', '/');
    final routesIndex = normalizedPath.indexOf(routesDir);
    if (routesIndex == -1) return null;

    // Get the relative path within routes directory
    var relativePath = normalizedPath.substring(routesIndex + routesDir.length);
    if (relativePath.startsWith('/')) {
      relativePath = relativePath.substring(1);
    }

    // Split into directory parts
    final parts = relativePath.split('/');
    if (parts.isEmpty) return null;

    // Remove the file name to get directory parts
    parts.removeLast();

    // Search from innermost to outermost directory for _layout.dart
    while (parts.isNotEmpty) {
      final layoutPath = '$routesDir/${parts.join('/')}/_layout.dart';
      // Escape parentheses in glob patterns - they are special characters
      final escapedPath = _escapeGlobPattern(layoutPath);
      final layoutGlob = Glob(escapedPath);

      await for (final asset in buildStep.findAssets(layoutGlob)) {
        // Found a layout file, extract the class name
        final content = await buildStep.readAsString(asset);
        final classMatch = _classMatchLayout.firstMatch(content);
        if (classMatch != null) {
          return classMatch.group(1);
        }
      }

      // Move to parent directory
      parts.removeLast();
    }

    // Check root _layout.dart
    final rootLayoutGlob = Glob('$routesDir/_layout.dart');
    await for (final asset in buildStep.findAssets(rootLayoutGlob)) {
      final content = await buildStep.readAsString(asset);
      final classMatch = _classMatchLayout.firstMatch(content);
      if (classMatch != null) {
        return classMatch.group(1);
      }
    }

    return null;
  }

  /// Escape special glob characters in a path.
  String _escapeGlobPattern(String path) {
    return path.replaceAll('(', '[(]').replaceAll(')', '[)]');
  }

  String _generateRouteBaseClass(
    RouteElement route,
    ConstantReader annotation,
    String routeBase,
  ) {
    return RouteCodeGenerator.generate(
      route,
      RouteCodeConfig(routeBase: routeBase),
    );
  }
}



================================================
FILE: packages/zenrouter_file_generator/test/annotations_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

void main() {
  group('DeeplinkStrategyType', () {
    test('has replace value', () {
      expect(DeeplinkStrategyType.replace.name, 'replace');
      expect(DeeplinkStrategyType.replace.index, 0);
    });

    test('has push value', () {
      expect(DeeplinkStrategyType.push.name, 'push');
      expect(DeeplinkStrategyType.push.index, 1);
    });

    test('has custom value', () {
      expect(DeeplinkStrategyType.custom.name, 'custom');
      expect(DeeplinkStrategyType.custom.index, 2);
    });

    test('has all three values', () {
      expect(DeeplinkStrategyType.values.length, 3);
    });
  });

  group('LayoutType', () {
    test('has stack value', () {
      expect(LayoutType.stack.name, 'stack');
      expect(LayoutType.stack.index, 0);
    });

    test('has indexed value', () {
      expect(LayoutType.indexed.name, 'indexed');
      expect(LayoutType.indexed.index, 1);
    });

    test('has both values', () {
      expect(LayoutType.values.length, 2);
    });
  });

  group('ZenRoute', () {
    test('has default values', () {
      const route = ZenRoute();

      expect(route.guard, false);
      expect(route.redirect, false);
      expect(route.deepLink, null);
      expect(route.transition, false);
      expect(route.queries, null);
    });

    test('accepts guard parameter', () {
      const route = ZenRoute(guard: true);

      expect(route.guard, true);
    });

    test('accepts redirect parameter', () {
      const route = ZenRoute(redirect: true);

      expect(route.redirect, true);
    });

    test('accepts deepLink parameter', () {
      const route = ZenRoute(deepLink: DeeplinkStrategyType.push);

      expect(route.deepLink, DeeplinkStrategyType.push);
    });

    test('accepts transition parameter', () {
      const route = ZenRoute(transition: true);

      expect(route.transition, true);
    });

    test('accepts queries parameter', () {
      const route = ZenRoute(queries: ['search', 'page', 'sort']);

      expect(route.queries, ['search', 'page', 'sort']);
    });

    test('accepts all parameters together', () {
      const route = ZenRoute(
        guard: true,
        redirect: true,
        deepLink: DeeplinkStrategyType.custom,
        transition: true,
        queries: ['q'],
      );

      expect(route.guard, true);
      expect(route.redirect, true);
      expect(route.deepLink, DeeplinkStrategyType.custom);
      expect(route.transition, true);
      expect(route.queries, ['q']);
    });
  });

  group('ZenLayout', () {
    test('requires type parameter', () {
      const layout = ZenLayout(type: LayoutType.stack);

      expect(layout.type, LayoutType.stack);
      expect(layout.routes, null);
    });

    test('accepts stack type', () {
      const layout = ZenLayout(type: LayoutType.stack);

      expect(layout.type, LayoutType.stack);
    });

    test('accepts indexed type', () {
      const layout = ZenLayout(type: LayoutType.indexed);

      expect(layout.type, LayoutType.indexed);
    });

    test('accepts routes parameter for indexed layout', () {
      const layout = ZenLayout(
        type: LayoutType.indexed,
        routes: [String, int], // Using built-in types as example
      );

      expect(layout.type, LayoutType.indexed);
      expect(layout.routes, [String, int]);
    });

    test('routes can be null for stack layout', () {
      const layout = ZenLayout(type: LayoutType.stack, routes: null);

      expect(layout.routes, null);
    });
  });

  group('ZenCoordinator', () {
    test('has default values', () {
      const coordinator = ZenCoordinator();

      expect(coordinator.name, 'AppCoordinator');
      expect(coordinator.routeBase, 'AppRoute');
    });

    test('accepts custom name', () {
      const coordinator = ZenCoordinator(name: 'MyCoordinator');

      expect(coordinator.name, 'MyCoordinator');
      expect(coordinator.routeBase, 'AppRoute');
    });

    test('accepts custom routeBase', () {
      const coordinator = ZenCoordinator(routeBase: 'MyRoute');

      expect(coordinator.name, 'AppCoordinator');
      expect(coordinator.routeBase, 'MyRoute');
    });

    test('accepts both custom values', () {
      const coordinator = ZenCoordinator(
        name: 'CustomCoordinator',
        routeBase: 'CustomRoute',
      );

      expect(coordinator.name, 'CustomCoordinator');
      expect(coordinator.routeBase, 'CustomRoute');
    });
  });
}



================================================
FILE: packages/zenrouter_file_generator/test/coordinator_generator_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';
import 'package:zenrouter_file_generator/src/generators/coordinator_generator.dart';

void main() {
  group('CoordinatorGenerator', () {
    late CoordinatorGenerator generator;

    setUp(() {
      generator = CoordinatorGenerator();
    });

    group('buildExtensions', () {
      test('outputs to routes/routes.zen.dart', () {
        expect(generator.buildExtensions, {
          r'$lib$': ['routes/routes.zen.dart'],
        });
      });
    });
  });

  group('RouteInfo', () {
    group('hasQueries', () {
      test('returns false when queries is null', () {
        final route = RouteInfo(
          className: 'HomeRoute',
          pathSegments: [],
          parameters: [],
          queries: null,
        );

        expect(route.hasQueries, false);
      });

      test('returns false when queries is empty', () {
        final route = RouteInfo(
          className: 'HomeRoute',
          pathSegments: [],
          parameters: [],
          queries: [],
        );

        expect(route.hasQueries, false);
      });

      test('returns true when queries has values', () {
        final route = RouteInfo(
          className: 'SearchRoute',
          pathSegments: ['search'],
          parameters: [],
          queries: ['q', 'page'],
        );

        expect(route.hasQueries, true);
      });
    });

    test('stores all route properties', () {
      final params = [ParamInfo(name: 'userId')];
      final route = RouteInfo(
        className: 'UserRoute',
        pathSegments: ['users', ':userId'],
        parameters: params,
        hasGuard: true,
        hasRedirect: true,
        deepLinkStrategy: DeeplinkStrategyType.push,
        hasTransition: true,
        isIndexFile: false,
        originalFileName: '[userId]',
        queries: ['tab'],
        parentLayoutType: 'UsersLayout',
        filePath: 'lib/routes/users/[userId].dart',
      );

      expect(route.className, 'UserRoute');
      expect(route.pathSegments, ['users', ':userId']);
      expect(route.parameters, params);
      expect(route.hasGuard, true);
      expect(route.hasRedirect, true);
      expect(route.deepLinkStrategy, DeeplinkStrategyType.push);
      expect(route.hasTransition, true);
      expect(route.isIndexFile, false);
      expect(route.originalFileName, '[userId]');
      expect(route.queries, ['tab']);
      expect(route.parentLayoutType, 'UsersLayout');
      expect(route.filePath, 'lib/routes/users/[userId].dart');
    });

    test('allows mutable parentLayoutType', () {
      final route = RouteInfo(
        className: 'HomeRoute',
        pathSegments: [],
        parameters: [],
      );

      expect(route.parentLayoutType, null);
      route.parentLayoutType = 'MainLayout';
      expect(route.parentLayoutType, 'MainLayout');
    });
  });

  group('LayoutInfo', () {
    test('stores all layout properties', () {
      final layout = LayoutInfo(
        className: 'TabsLayout',
        pathSegments: ['tabs'],
        layoutType: LayoutType.indexed,
        indexedRouteTypes: ['HomeRoute', 'ProfileRoute', 'SettingsRoute'],
        parentLayoutType: 'RootLayout',
      );

      expect(layout.className, 'TabsLayout');
      expect(layout.pathSegments, ['tabs']);
      expect(layout.layoutType, LayoutType.indexed);
      expect(layout.indexedRouteTypes, [
        'HomeRoute',
        'ProfileRoute',
        'SettingsRoute',
      ]);
      expect(layout.parentLayoutType, 'RootLayout');
    });

    test('defaults indexedRouteTypes to empty', () {
      final layout = LayoutInfo(
        className: 'StackLayout',
        pathSegments: ['stack'],
        layoutType: LayoutType.stack,
      );

      expect(layout.indexedRouteTypes, isEmpty);
    });

    test('allows mutable parentLayoutType', () {
      final layout = LayoutInfo(
        className: 'ChildLayout',
        pathSegments: ['child'],
        layoutType: LayoutType.stack,
      );

      expect(layout.parentLayoutType, null);
      layout.parentLayoutType = 'ParentLayout';
      expect(layout.parentLayoutType, 'ParentLayout');
    });
  });

  group('RouteTreeInfo', () {
    test('stores routes and layouts', () {
      final routes = [
        RouteInfo(className: 'HomeRoute', pathSegments: [], parameters: []),
      ];

      final layouts = [
        LayoutInfo(
          className: 'MainLayout',
          pathSegments: [],
          layoutType: LayoutType.stack,
        ),
      ];

      final tree = RouteTreeInfo(routes: routes, layouts: layouts);

      expect(tree.routes, routes);
      expect(tree.layouts, layouts);
    });
  });

  group('ParamInfo', () {
    test('stores parameter name', () {
      final param = ParamInfo(name: 'userId');

      expect(param.name, 'userId');
    });
  });
}



================================================
FILE: packages/zenrouter_file_generator/test/layout_element_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

void main() {
  group('LayoutElement', () {
    group('uriPattern', () {
      test('returns / for empty path segments (root layout)', () {
        final layout = LayoutElement(
          className: 'RootLayout',
          relativePath: '_layout',
          pathSegments: [],
          layoutType: LayoutType.stack,
        );

        expect(layout.uriPattern, '/');
      });

      test('returns correct pattern for nested layout', () {
        final layout = LayoutElement(
          className: 'SettingsLayout',
          relativePath: 'settings/_layout',
          pathSegments: ['settings'],
          layoutType: LayoutType.stack,
        );

        expect(layout.uriPattern, '/settings');
      });

      test('returns correct pattern for deeply nested layout', () {
        final layout = LayoutElement(
          className: 'ProfileSettingsLayout',
          relativePath: 'profile/settings/_layout',
          pathSegments: ['profile', 'settings'],
          layoutType: LayoutType.indexed,
        );

        expect(layout.uriPattern, '/profile/settings');
      });
    });

    group('generatedBaseClassName', () {
      test('returns prefixed class name', () {
        final layout = LayoutElement(
          className: 'TabsLayout',
          relativePath: 'tabs/_layout',
          pathSegments: ['tabs'],
          layoutType: LayoutType.indexed,
        );

        expect(layout.generatedBaseClassName, r'_$TabsLayout');
      });
    });

    group('pathFieldName', () {
      test('converts layout name to path field name', () {
        final layout = LayoutElement(
          className: 'TabsLayout',
          relativePath: 'tabs/_layout',
          pathSegments: ['tabs'],
          layoutType: LayoutType.indexed,
        );

        expect(layout.pathFieldName, 'tabsPath');
      });

      test('handles multi-word layout names', () {
        final layout = LayoutElement(
          className: 'MainNavigationLayout',
          relativePath: 'main/_layout',
          pathSegments: ['main'],
          layoutType: LayoutType.stack,
        );

        expect(layout.pathFieldName, 'mainNavigationPath');
      });

      test('handles layout without Layout suffix', () {
        // This is an edge case - class names should end with Layout
        // but the method handles it gracefully
        final layout = LayoutElement(
          className: 'Dashboard',
          relativePath: 'dashboard/_layout',
          pathSegments: ['dashboard'],
          layoutType: LayoutType.stack,
        );

        expect(layout.pathFieldName, 'dashboardPath');
      });
    });

    group('layoutType', () {
      test('stores stack layout type', () {
        final layout = LayoutElement(
          className: 'SettingsLayout',
          relativePath: 'settings/_layout',
          pathSegments: ['settings'],
          layoutType: LayoutType.stack,
        );

        expect(layout.layoutType, LayoutType.stack);
      });

      test('stores indexed layout type', () {
        final layout = LayoutElement(
          className: 'TabsLayout',
          relativePath: 'tabs/_layout',
          pathSegments: ['tabs'],
          layoutType: LayoutType.indexed,
        );

        expect(layout.layoutType, LayoutType.indexed);
      });
    });

    group('indexedRouteTypes', () {
      test('stores indexed route types for indexed layout', () {
        final layout = LayoutElement(
          className: 'TabsLayout',
          relativePath: 'tabs/_layout',
          pathSegments: ['tabs'],
          layoutType: LayoutType.indexed,
          indexedRouteTypes: ['HomeRoute', 'ProfileRoute', 'SettingsRoute'],
        );

        expect(layout.indexedRouteTypes, [
          'HomeRoute',
          'ProfileRoute',
          'SettingsRoute',
        ]);
      });

      test('defaults to empty list', () {
        final layout = LayoutElement(
          className: 'StackLayout',
          relativePath: 'stack/_layout',
          pathSegments: ['stack'],
          layoutType: LayoutType.stack,
        );

        expect(layout.indexedRouteTypes, isEmpty);
      });
    });

    group('parentLayoutType', () {
      test('stores parent layout type for nested layouts', () {
        final layout = LayoutElement(
          className: 'NestedLayout',
          relativePath: 'parent/nested/_layout',
          pathSegments: ['parent', 'nested'],
          layoutType: LayoutType.stack,
          parentLayoutType: 'ParentLayout',
        );

        expect(layout.parentLayoutType, 'ParentLayout');
      });

      test('defaults to null for root layouts', () {
        final layout = LayoutElement(
          className: 'RootLayout',
          relativePath: '_layout',
          pathSegments: [],
          layoutType: LayoutType.stack,
        );

        expect(layout.parentLayoutType, null);
      });
    });

    group('copyWith', () {
      test('copies with new parentLayoutType', () {
        final layout = LayoutElement(
          className: 'ChildLayout',
          relativePath: 'child/_layout',
          pathSegments: ['child'],
          layoutType: LayoutType.stack,
          parentLayoutType: null,
        );

        final copied = layout.copyWith(parentLayoutType: 'ParentLayout');

        expect(copied.className, 'ChildLayout');
        expect(copied.relativePath, 'child/_layout');
        expect(copied.parentLayoutType, 'ParentLayout');
      });

      test('preserves other properties when copying', () {
        final layout = LayoutElement(
          className: 'TabsLayout',
          relativePath: 'tabs/_layout',
          pathSegments: ['tabs'],
          layoutType: LayoutType.indexed,
          indexedRouteTypes: ['HomeRoute', 'ProfileRoute'],
          parentLayoutType: 'RootLayout',
        );

        final copied = layout.copyWith(parentLayoutType: 'NewParent');

        expect(copied.layoutType, LayoutType.indexed);
        expect(copied.indexedRouteTypes, ['HomeRoute', 'ProfileRoute']);
        expect(copied.pathSegments, ['tabs']);
        expect(copied.parentLayoutType, 'NewParent');
      });

      test('keeps existing parentLayoutType if null passed', () {
        final layout = LayoutElement(
          className: 'ChildLayout',
          relativePath: 'child/_layout',
          pathSegments: ['child'],
          layoutType: LayoutType.stack,
          parentLayoutType: 'ExistingParent',
        );

        final copied = layout.copyWith();

        expect(copied.parentLayoutType, 'ExistingParent');
      });
    });
  });
}



================================================
FILE: packages/zenrouter_file_generator/test/path_parser_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

void main() {
  group('PathParser', () {
    group('parsePath', () {
      test('parses simple static path', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'about.dart',
        );

        expect(segments, ['about']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, 'about');
      });

      test('parses nested static path', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'settings/profile.dart',
        );

        expect(segments, ['settings', 'profile']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, 'profile');
      });

      test('parses single dynamic parameter', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'profile/[id].dart',
        );

        expect(segments, ['profile', ':id']);
        expect(params.length, 1);
        expect(params[0].name, 'id');
        expect(isIndex, false);
        expect(fileName, '[id]');
      });

      test('parses multiple dynamic parameters', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'profile/[profileId]/collections/[collectionId].dart',
        );

        expect(segments, [
          'profile',
          ':profileId',
          'collections',
          ':collectionId',
        ]);
        expect(params.length, 2);
        expect(params[0].name, 'profileId');
        expect(params[1].name, 'collectionId');
        expect(isIndex, false);
        expect(fileName, '[collectionId]');
      });

      test('handles index file', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'settings/index.dart',
        );

        expect(segments, ['settings']);
        expect(params, isEmpty);
        expect(isIndex, true);
        expect(fileName, 'index');
      });

      test('handles root index file', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'index.dart',
        );

        expect(segments, isEmpty);
        expect(params, isEmpty);
        expect(isIndex, true);
        expect(fileName, 'index');
      });

      test('skips private files (underscore prefix)', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'settings/_helper.dart',
        );

        expect(segments, ['settings']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, '_helper');
      });

      test('skips route groups (parentheses)', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          '(auth)/login.dart',
        );

        expect(segments, ['login']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, 'login');
      });

      test('handles nested route groups', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          '(marketing)/(campaigns)/landing.dart',
        );

        expect(segments, ['landing']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, 'landing');
      });

      test('handles complex path with groups and dynamic params', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          '(auth)/profile/[userId]/settings.dart',
        );

        expect(segments, ['profile', ':userId', 'settings']);
        expect(params.length, 1);
        expect(params[0].name, 'userId');
        expect(isIndex, false);
        expect(fileName, 'settings');
      });

      test('handles path without .dart extension', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'about',
        );

        expect(segments, ['about']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, 'about');
      });

      test('handles hyphenated path segments', () {
        final (segments, params, isIndex, fileName) = PathParser.parsePath(
          'user-profile/my-settings.dart',
        );

        expect(segments, ['user-profile', 'my-settings']);
        expect(params, isEmpty);
        expect(isIndex, false);
        expect(fileName, 'my-settings');
      });

      test('throws on empty dynamic parameter', () {
        expect(
          () => PathParser.parsePath('profile/[].dart'),
          throwsA(isA<ArgumentError>()),
        );
      });

      group('dot-notation file naming', () {
        test('parses simple dot notation', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            'docs.[id].detail.dart',
          );

          expect(segments, ['docs', ':id', 'detail']);
          expect(params.length, 1);
          expect(params[0].name, 'id');
          expect(isIndex, false);
          expect(fileName, 'detail');
        });

        test('parses rest param with dot notation', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            'docs.[...slugs].dart',
          );

          expect(segments, ['docs', '...:slugs']);
          expect(params.length, 1);
          expect(params[0].name, 'slugs');
          expect(params[0].isRest, true);
          expect(isIndex, false);
          expect(fileName, '[...slugs]');
        });

        test('parses hybrid path with trailing dot segments', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            'feed/tab/[id].detail.dart',
          );

          expect(segments, ['feed', 'tab', ':id', 'detail']);
          expect(params.length, 1);
          expect(params[0].name, 'id');
          expect(isIndex, false);
          expect(fileName, 'detail');
        });

        test('parses route group with dot notation', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            '(auth).login.dart',
          );

          expect(segments, ['login']);
          expect(params, isEmpty);
          expect(isIndex, false);
          expect(fileName, 'login');
        });

        test('parses complex hybrid with groups and params', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            '(auth)/settings.[userId].profile.dart',
          );

          expect(segments, ['settings', ':userId', 'profile']);
          expect(params.length, 1);
          expect(params[0].name, 'userId');
          expect(isIndex, false);
          expect(fileName, 'profile');
        });

        test('parses index with dot notation', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            'settings.index.dart',
          );

          expect(segments, ['settings']);
          expect(params, isEmpty);
          expect(isIndex, true);
          expect(fileName, 'index');
        });

        test('parses multiple params with dot notation', () {
          final (segments, params, isIndex, fileName) = PathParser.parsePath(
            'users.[userId].posts.[postId].dart',
          );

          expect(segments, ['users', ':userId', 'posts', ':postId']);
          expect(params.length, 2);
          expect(params[0].name, 'userId');
          expect(params[1].name, 'postId');
          expect(isIndex, false);
          expect(fileName, '[postId]');
        });
      });
    });

    group('parseLayoutPath', () {
      test('parses simple layout path', () {
        final segments = PathParser.parseLayoutPath('settings/_layout.dart');

        expect(segments, ['settings']);
      });

      test('parses nested layout path', () {
        final segments = PathParser.parseLayoutPath(
          'dashboard/analytics/_layout.dart',
        );

        expect(segments, ['dashboard', 'analytics']);
      });

      test('parses root layout path', () {
        final segments = PathParser.parseLayoutPath('_layout.dart');

        expect(segments, isEmpty);
      });

      test('skips route groups in layout path', () {
        final segments = PathParser.parseLayoutPath(
          '(auth)/login/_layout.dart',
        );

        expect(segments, ['login']);
      });

      test('skips private directories in layout path', () {
        final segments = PathParser.parseLayoutPath(
          'settings/_private/_layout.dart',
        );

        expect(segments, ['settings']);
      });

      test('handles path without .dart extension', () {
        final segments = PathParser.parseLayoutPath('settings/_layout');

        expect(segments, ['settings']);
      });

      test('handles complex nested layout with groups', () {
        final segments = PathParser.parseLayoutPath(
          '(admin)/dashboard/(reports)/weekly/_layout.dart',
        );

        expect(segments, ['dashboard', 'weekly']);
      });

      test('parses layout path with dot notation', () {
        final segments = PathParser.parseLayoutPath(
          'settings.profile._layout.dart',
        );

        expect(segments, ['settings', 'profile']);
      });
    });
  });
}



================================================
FILE: packages/zenrouter_file_generator/test/route_element_test.dart
================================================
import 'package:flutter_test/flutter_test.dart';
import 'package:zenrouter_file_annotation/zenrouter_file_annotation.dart';

void main() {
  group('RouteElement', () {
    group('uriPattern', () {
      test('returns / for empty path segments', () {
        final route = RouteElement(
          className: 'HomeRoute',
          relativePath: 'index',
          pathSegments: [],
          parameters: [],
        );

        expect(route.uriPattern, '/');
      });

      test('returns correct pattern for static segments', () {
        final route = RouteElement(
          className: 'AboutRoute',
          relativePath: 'about',
          pathSegments: ['about'],
          parameters: [],
        );

        expect(route.uriPattern, '/about');
      });

      test('returns correct pattern for nested static segments', () {
        final route = RouteElement(
          className: 'ProfileSettingsRoute',
          relativePath: 'profile/settings',
          pathSegments: ['profile', 'settings'],
          parameters: [],
        );

        expect(route.uriPattern, '/profile/settings');
      });

      test('returns correct pattern with dynamic segments', () {
        final route = RouteElement(
          className: 'ProfileIdRoute',
          relativePath: 'profile/[id]',
          pathSegments: ['profile', ':id'],
          parameters: [RouteParameter(name: 'id')],
        );

        expect(route.uriPattern, '/profile/:id');
      });

      test('returns correct pattern with multiple dynamic segments', () {
        final route = RouteElement(
          className: 'CollectionItemRoute',
          relativePath: 'profile/[profileId]/collections/[collectionId]',
          pathSegments: [
            'profile',
            ':profileId',
            'collections',
            ':collectionId',
          ],
          parameters: [
            RouteParameter(name: 'profileId'),
            RouteParameter(name: 'collectionId'),
          ],
        );

        expect(
          route.uriPattern,
          '/profile/:profileId/collections/:collectionId',
        );
      });
    });

    group('generatedBaseClassName', () {
      test('returns prefixed class name', () {
        final route = RouteElement(
          className: 'AboutRoute',
          relativePath: 'about',
          pathSegments: ['about'],
          parameters: [],
        );

        expect(route.generatedBaseClassName, r'_$AboutRoute');
      });
    });

    group('hasDynamicParameters', () {
      test('returns false when no parameters', () {
        final route = RouteElement(
          className: 'AboutRoute',
          relativePath: 'about',
          pathSegments: ['about'],
          parameters: [],
        );

        expect(route.hasDynamicParameters, false);
      });

      test('returns true when has parameters', () {
        final route = RouteElement(
          className: 'ProfileIdRoute',
          relativePath: 'profile/[id]',
          pathSegments: ['profile', ':id'],
          parameters: [RouteParameter(name: 'id')],
        );

        expect(route.hasDynamicParameters, true);
      });
    });

    group('hasQueries', () {
      test('returns false when queries is null', () {
        final route = RouteElement(
          className: 'AboutRoute',
          relativePath: 'about',
          pathSegments: ['about'],
          parameters: [],
          queries: null,
        );

        expect(route.hasQueries, false);
      });

      test('returns false when queries is empty', () {
        final route = RouteElement(
          className: 'AboutRoute',
          relativePath: 'about',
          pathSegments: ['about'],
          parameters: [],
          queries: [],
        );

        expect(route.hasQueries, false);
      });

      test('returns true when queries has values', () {
        final route = RouteElement(
          className: 'SearchRoute',
          relativePath: 'search',
          pathSegments: ['search'],
          parameters: [],
          queries: ['query', 'page'],
        );

        expect(route.hasQueries, true);
      });
    });

    group('copyWith', () {
      test('copies with new parentLayoutType', () {
        final route = RouteElement(
          className: 'AboutRoute',
          relativePath: 'about',
          pathSegments: ['about'],
          parameters: [],
          parentLayoutType: null,
        );

        final copied = route.copyWith(parentLayoutType: 'MainLayout');

        expect(copied.className, 'AboutRoute');
        expect(copied.relativePath, 'about');
        expect(copied.parentLayoutType, 'MainLayout');
      });

      test('preserves other properties when copying', () {
        final route = RouteElement(
          className: 'SearchRoute',
          relativePath: 'search',
          pathSegments: ['search'],
          parameters: [RouteParameter(name: 'id')],
          hasGuard: true,
          hasRedirect: true,
          deepLinkStrategy: DeeplinkStrategyType.push,
          hasTransition: true,
          queries: ['q'],
        );

        final copied = route.copyWith(parentLayoutType: 'MainLayout');

        expect(copied.hasGuard, true);
        expect(copied.hasRedirect, true);
        expect(copied.deepLinkStrategy, DeeplinkStrategyType.push);
        expect(copied.hasTransition, true);
        expect(copied.queries, ['q']);
        expect(copied.parameters.length, 1);
      });
    });

    group('mixins and features', () {
      test('stores guard configuration', () {
        final route = RouteElement(
          className: 'CheckoutRoute',
          relativePath: 'checkout',
          pathSegments: ['checkout'],
          parameters: [],
          hasGuard: true,
        );

        expect(route.hasGuard, true);
      });

      test('stores redirect configuration', () {
        final route = RouteElement(
          className: 'DashboardRoute',
          relativePath: 'dashboard',
          pathSegments: ['dashboard'],
          parameters: [],
          hasRedirect: true,
        );

        expect(route.hasRedirect, true);
      });

      test('stores deepLink strategy', () {
        final route = RouteElement(
          className: 'ProductRoute',
          relativePath: 'product/[id]',
          pathSegments: ['product', ':id'],
          parameters: [RouteParameter(name: 'id')],
          deepLinkStrategy: DeeplinkStrategyType.custom,
        );

        expect(route.deepLinkStrategy, DeeplinkStrategyType.custom);
      });

      test('stores transition configuration', () {
        final route = RouteElement(
          className: 'ModalRoute',
          relativePath: 'modal',
          pathSegments: ['modal'],
          parameters: [],
          hasTransition: true,
        );

        expect(route.hasTransition, true);
      });
    });
  });

  group('RouteParameter', () {
    test('creates with required name', () {
      final param = RouteParameter(name: 'userId');

      expect(param.name, 'userId');
      expect(param.type, 'String');
      expect(param.isOptional, false);
      expect(param.defaultValue, null);
    });

    test('creates with custom type', () {
      final param = RouteParameter(name: 'count', type: 'int');

      expect(param.name, 'count');
      expect(param.type, 'int');
    });

    test('creates optional parameter with default', () {
      final param = RouteParameter(
        name: 'page',
        isOptional: true,
        defaultValue: '1',
      );

      expect(param.name, 'page');
      expect(param.isOptional, true);
      expect(param.defaultValue, '1');
    });
  });
}



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: ''
assignees: ''

---

**Describe the bug**
A clear and concise description of what the bug is.

**To Reproduce**
Steps to reproduce the behavior:
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

**Expected behavior**
A clear and concise description of what you expected to happen.

**Screenshots**
If applicable, add screenshots to help explain your problem.

**Desktop (please complete the following information):**
 - OS: [e.g. iOS]
 - Browser [e.g. chrome, safari]
 - Version [e.g. 22]

**Smartphone (please complete the following information):**
 - Device: [e.g. iPhone6]
 - OS: [e.g. iOS8.1]
 - Browser [e.g. stock browser, safari]
 - Version [e.g. 22]

**Additional context**
Add any other context about the problem here.



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: ''
assignees: ''

---

**Is your feature request related to a problem? Please describe.**
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

**Describe the solution you'd like**
A clear and concise description of what you want to happen.

**Describe alternatives you've considered**
A clear and concise description of any alternative solutions or features you've considered.

**Additional context**
Add any other context or screenshots about the feature request here.



================================================
FILE: .github/workflows/test.yml
================================================
name: Test

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for coverage-badge-action to update gh-pages
      pull-requests: write  # Required for commenting on PRs
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Required for coverage-badge-action

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: true

      - name: Install dependencies
        run: flutter pub get
        working-directory: .

      - name: Verify formatting
        run: dart format --set-exit-if-changed .
        continue-on-error: false

      - name: Analyze code
        run: flutter analyze
        continue-on-error: false

      - name: Run tests with coverage (zenrouter)
        run: flutter test --coverage
        working-directory: packages/zenrouter
        continue-on-error: false

      - name: Run tests with coverage (zenrouter_file_generator)
        run: flutter test --coverage
        working-directory: packages/zenrouter_file_generator
        continue-on-error: false

      - name: Upload coverage to Codecov (zenrouter)
        uses: codecov/codecov-action@v4
        with:
            token: ${{ secrets.CODECOV_TOKEN }}  
            files: packages/zenrouter/coverage/lcov.info
            flags: zenrouter
            disable_search: true
            fail_ci_if_error: true


